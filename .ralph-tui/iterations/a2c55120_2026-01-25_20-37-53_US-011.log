# Iteration 11 Log

## Metadata

- **Task ID**: US-011
- **Task Title**: Create Artifact Browser for Session Data
- **Description**: As a user, I want to browse all data generated in my session so that I can access any intermediate result.
- **Status**: completed
- **Task Completed**: Yes
- **Promise Detected**: Yes
- **Started At**: 2026-01-25T19:37:53.286Z
- **Ended At**: 2026-01-25T19:46:16.159Z
- **Duration**: 8m 22s
- **Agent**: claude
- **Sandbox Mode**: auto
- **Sandbox Network**: Enabled
--- RAW OUTPUT ---
{"type":"system","subtype":"init","cwd":"/Users/martin/Gattaca-Secuenciador-de-Prompts","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","KillShell","AskUserQuestion","Skill","EnterPlanMode","MCPSearch","mcp__notion__API-get-user","mcp__notion__API-get-users","mcp__notion__API-get-self","mcp__notion__API-post-search","mcp__notion__API-get-block-children","mcp__notion__API-patch-block-children","mcp__notion__API-retrieve-a-block","mcp__notion__API-update-a-block","mcp__notion__API-delete-a-block","mcp__notion__API-retrieve-a-page","mcp__notion__API-patch-page","mcp__notion__API-post-page","mcp__notion__API-retrieve-a-page-property","mcp__notion__API-retrieve-a-comment","mcp__notion__API-create-a-comment","mcp__notion__API-query-data-source","mcp__notion__API-retrieve-a-data-source","mcp__notion__API-update-a-data-source","mcp__notion__API-create-a-data-source","mcp__notion__API-list-data-source-templates","mcp__notion__API-move-page","mcp__supabase__search_docs","mcp__supabase__list_tables","mcp__supabase__list_extensions","mcp__supabase__list_migrations","mcp__supabase__apply_migration","mcp__supabase__execute_sql","mcp__supabase__get_logs","mcp__supabase__get_advisors","mcp__supabase__get_project_url","mcp__supabase__get_publishable_keys","mcp__supabase__generate_typescript_types","mcp__supabase__list_edge_functions","mcp__supabase__get_edge_function","mcp__supabase__deploy_edge_function","mcp__supabase__create_branch","mcp__supabase__list_branches","mcp__supabase__delete_branch","mcp__supabase__merge_branch","mcp__supabase__reset_branch","mcp__supabase__rebase_branch","mcp__n8n-mcp__tools_documentation","mcp__n8n-mcp__search_nodes","mcp__n8n-mcp__get_node","mcp__n8n-mcp__validate_node","mcp__n8n-mcp__get_template","mcp__n8n-mcp__search_templates","mcp__n8n-mcp__validate_workflow","mcp__n8n-mcp__n8n_create_workflow","mcp__n8n-mcp__n8n_get_workflow","mcp__n8n-mcp__n8n_update_full_workflow","mcp__n8n-mcp__n8n_update_partial_workflow","mcp__n8n-mcp__n8n_delete_workflow","mcp__n8n-mcp__n8n_list_workflows","mcp__n8n-mcp__n8n_validate_workflow","mcp__n8n-mcp__n8n_autofix_workflow","mcp__n8n-mcp__n8n_test_workflow","mcp__n8n-mcp__n8n_executions","mcp__n8n-mcp__n8n_health_check","mcp__n8n-mcp__n8n_workflow_versions","mcp__n8n-mcp__n8n_deploy_template"],"mcp_servers":[{"name":"notion","status":"connected"},{"name":"supabase","status":"connected"},{"name":"n8n-mcp","status":"connected"}],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["pptx","ralph-tui-create-beads","ralph-tui-create-beads-rust","ralph-tui-create-json","ralph-tui-prd","remotion-best-practices","vercel-react-best-practices","web-design-guidelines","agent-browser","ralph-tui-prd","reactcomponents","supabase-postgres-best-practices","vercel-react-best-practices","plan","review-docs","merge-and-deploy","deploy","check-db","test-upload","analyze-tokens","setup-env","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.3","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","frontend-developer","prompt-engineer"],"skills":["pptx","ralph-tui-create-beads","ralph-tui-create-beads-rust","ralph-tui-create-json","ralph-tui-prd","remotion-best-practices","vercel-react-best-practices","web-design-guidelines","agent-browser","ralph-tui-prd","reactcomponents","supabase-postgres-best-practices","vercel-react-best-practices"],"plugins":[],"uuid":"4ccebe1b-1c75-4129-861c-e89b0dfe6c24"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FDuQ5Gat2Vnp614Mmaz8vS","type":"message","role":"assistant","content":[{"type":"text","text":"I'll implement US-011 - Create Artifact Browser for Session Data. Let me start by exploring the existing codebase to understand the patterns and structure."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":36282,"cache_read_input_tokens":13308,"cache_creation":{"ephemeral_5m_input_tokens":36282,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"a5375507-7392-45dc-9f84-dcb3babc0eac"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FDuQ5Gat2Vnp614Mmaz8vS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NeTViCLxxDiXQemcH8frdz","name":"Task","input":{"subagent_type":"Explore","prompt":"Explore the codebase to understand:\n1. The structure of the src/components directory, especially any existing session-related components\n2. How artifacts/data are stored and managed in the session (look for session state, context, or stores)\n3. The existing modal patterns used in the app\n4. How the \"Save to Context Lake\" functionality is implemented\n5. Any existing export functionality (CSV/JSON)\n6. The UI patterns used for tabs/panels and expandable sections\n\nFocus on finding patterns I should follow for the Artifact Browser implementation.","description":"Explore codebase structure"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":36282,"cache_read_input_tokens":13308,"cache_creation":{"ephemeral_5m_input_tokens":36282,"ephemeral_1h_input_tokens":0},"output_tokens":247,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"dafa1842-4001-4e9e-a7e9-c9a7465d9d21"}
{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Explore the codebase to understand:\n1. The structure of the src/components directory, especially any existing session-related components\n2. How artifacts/data are stored and managed in the session (look for session state, context, or stores)\n3. The existing modal patterns used in the app\n4. How the \"Save to Context Lake\" functionality is implemented\n5. Any existing export functionality (CSV/JSON)\n6. The UI patterns used for tabs/panels and expandable sections\n\nFocus on finding patterns I should follow for the Artifact Browser implementation."}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"6c55de0e-a294-4099-96e5-1712782ec348"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01RZPq4YrcB8oxiDjRESDzNP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01J4qyLYMC9YehSNWkimZ4wF","name":"Bash","input":{"command":"find /Users/martin/Gattaca-Secuenciador-de-Prompts/src -type f -name \"*.tsx\" -o -name \"*.ts\" | head -30"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":41568,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":41568,"ephemeral_1h_input_tokens":0},"output_tokens":127,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"f39df329-e12b-4515-aec7-82988041ce67"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01J4qyLYMC9YehSNWkimZ4wF","type":"tool_result","content":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/middleware.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/types/scraper.types.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/types/database.types.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/types/flow.types.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/guide/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/clients/[clientId]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/clients/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/apple-icon.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/icon.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/auth/logout/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/auth/callback/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/auth/login/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/projects/join/[token]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/projects/[projectId]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/projects/new/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/playbooks/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/playbooks/[slug]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/trash/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/layout.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/test-upload/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/scraper/webhook/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/scraper/start/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/scraper/status/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/scraper/preview/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/scraper/poll/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/import-data/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/generate-audio/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/publish/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/compose-video/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/generate-clips/route.ts","is_error":false}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"30ef49c1-1a49-455c-9f55-73d0c86d8b96","tool_use_result":{"stdout":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/middleware.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/types/scraper.types.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/types/database.types.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/types/flow.types.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/guide/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/clients/[clientId]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/clients/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/apple-icon.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/icon.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/auth/logout/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/auth/callback/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/auth/login/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/projects/join/[token]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/projects/[projectId]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/projects/new/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/playbooks/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/playbooks/[slug]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/trash/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/layout.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/test-upload/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/scraper/webhook/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/scraper/start/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/scraper/status/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/scraper/preview/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/scraper/poll/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/import-data/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/generate-audio/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/publish/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/compose-video/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/generate-clips/route.ts","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01TMNd3SFhQMSWUdokfnMwzs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014WBpa5SY7TYY2sDQon2mfS","name":"Bash","input":{"command":"find /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components -type f -name \"*.tsx\" | sort"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1227,"cache_read_input_tokens":41568,"cache_creation":{"ephemeral_5m_input_tokens":1227,"ephemeral_1h_input_tokens":0},"output_tokens":101,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"3d4582d4-64e6-4eba-9879-940db77299fb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014WBpa5SY7TYY2sDQon2mfS","type":"tool_result","content":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/CampaignBulkUpload.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/CampaignComparison.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/CampaignFlowEditor.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/CampaignRunner.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/DeepResearchProgress.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/StatusManager.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/StepOutputEditor.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/common/MarkdownRenderer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/context-lake/ContextLakeDashboard.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/credits/CreditsBalance.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/CSVTableViewer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentBulkUpload.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentFolderView.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentList.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentSelector.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentUpload.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/JSONViewer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/SaveToContextLakeModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/flow/ExecutionCostModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/flow/FlowSetup.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/flow/PromptValidationPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/flow/ScraperStepConfig.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/flow/StepEditor.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/Header.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/layout/ClientSidebar.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/layout/ProjectSidebar.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/NicheDetail.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/NicheFinderPlaybook.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/NicheFinderPlaybookV2.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/NicheResultsDashboard.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/NicheTable.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/ScrapedContentViewer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/ScraperStepOutput.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/notifications/NotificationBell.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/openrouter/OpenRouterAuthModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/openrouter/OpenRouterModelSelector.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/openrouter/OpenRouterStatusBadge.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/openrouter/UsageDashboard.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/AllSessionsPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/CampaignSettings.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/CampaignWizard.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ConfigurationMode.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/FailedStepActions.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/ErrorAnalyzer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/ExecutionSection.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/InputContextSection.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/OutputSection.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/JobControlPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/KeywordConfigPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/NavigationPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/NavigationWarningDialog.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookStepContainer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookWizardNav.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/QueryPreviewPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ReviewAndScrapePanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SavedIndicator.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ScrapeResultsPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SearchWithPreviewPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SerpResultsPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SessionHistoryPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StartSessionDialog.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepExecutionProgress.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepInspectionPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepRetryDialog.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/steps/DeepResearchManualStep.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/UnifiedSearchExtractPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/WorkArea.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbooks/PlaybooksDashboard.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/ExportDataTab.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/ProjectVariables.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/ResearchPromptsEditor.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/SetupTab.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/ShareProjectModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/reports/CampaignSelector.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/reports/InconsistencyAnalyzer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/reports/ReportGenerator.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/reports/ReportPreview.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/scraper/ScraperLauncher.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/settings/ApiKeysConfig.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/settings/ApiKeySetupModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/signal-outreach/SignalBasedOutreachPlaybook.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/TokenMonitor.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Growth4ULogo.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Modal/ConfirmModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Modal/ModalContext.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Providers.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Toast/ToastContainer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Toast/ToastContext.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Toast/ToastItem.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/video-viral-ia/VideoViralIAPlaybook.tsx","is_error":false}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"ad3d076d-f4c5-47c4-8b98-f56913c491b3","tool_use_result":{"stdout":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/CampaignBulkUpload.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/CampaignComparison.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/CampaignFlowEditor.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/CampaignRunner.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/DeepResearchProgress.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/StatusManager.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/StepOutputEditor.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/common/MarkdownRenderer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/context-lake/ContextLakeDashboard.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/credits/CreditsBalance.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/CSVTableViewer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentBulkUpload.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentFolderView.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentList.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentSelector.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentUpload.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/JSONViewer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/SaveToContextLakeModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/flow/ExecutionCostModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/flow/FlowSetup.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/flow/PromptValidationPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/flow/ScraperStepConfig.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/flow/StepEditor.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/Header.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/layout/ClientSidebar.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/layout/ProjectSidebar.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/NicheDetail.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/NicheFinderPlaybook.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/NicheFinderPlaybookV2.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/NicheResultsDashboard.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/NicheTable.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/ScrapedContentViewer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/ScraperStepOutput.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/notifications/NotificationBell.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/openrouter/OpenRouterAuthModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/openrouter/OpenRouterModelSelector.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/openrouter/OpenRouterStatusBadge.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/openrouter/UsageDashboard.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/AllSessionsPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/CampaignSettings.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/CampaignWizard.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ConfigurationMode.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/FailedStepActions.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/ErrorAnalyzer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/ExecutionSection.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/InputContextSection.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/OutputSection.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/JobControlPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/KeywordConfigPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/NavigationPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/NavigationWarningDialog.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookStepContainer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookWizardNav.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/QueryPreviewPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ReviewAndScrapePanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SavedIndicator.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ScrapeResultsPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SearchWithPreviewPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SerpResultsPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SessionHistoryPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StartSessionDialog.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepExecutionProgress.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepInspectionPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepRetryDialog.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/steps/DeepResearchManualStep.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/UnifiedSearchExtractPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/WorkArea.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbooks/PlaybooksDashboard.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/ExportDataTab.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/ProjectVariables.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/ResearchPromptsEditor.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/SetupTab.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/ShareProjectModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/reports/CampaignSelector.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/reports/InconsistencyAnalyzer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/reports/ReportGenerator.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/reports/ReportPreview.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/scraper/ScraperLauncher.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/settings/ApiKeysConfig.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/settings/ApiKeySetupModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/signal-outreach/SignalBasedOutreachPlaybook.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/TokenMonitor.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Growth4ULogo.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Modal/ConfirmModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Modal/ModalContext.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Providers.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Toast/ToastContainer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Toast/ToastContext.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Toast/ToastItem.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/video-viral-ia/VideoViralIAPlaybook.tsx","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012YuH4LjDFaN5GJBd29Lipx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KmoBCTyhM1DWK3UaiYS6mo","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/SaveToContextLakeModal.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":3483,"cache_read_input_tokens":42795,"cache_creation":{"ephemeral_5m_input_tokens":3483,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"0cecea63-aaf7-44b1-8962-422810370e7c"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012YuH4LjDFaN5GJBd29Lipx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JAHyicE4UGSUreSLrtFuN8","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/AllSessionsPanel.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":3483,"cache_read_input_tokens":42795,"cache_creation":{"ephemeral_5m_input_tokens":3483,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"dcc053e7-1053-4bb3-9fad-d87db88a9d70"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012YuH4LjDFaN5GJBd29Lipx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Dq7pyutyiF5UHJDSiWxH4h","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/ExportDataTab.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":3483,"cache_read_input_tokens":42795,"cache_creation":{"ephemeral_5m_input_tokens":3483,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"7e922833-3920-4547-b5af-bbf1056c822e"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012YuH4LjDFaN5GJBd29Lipx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EMG3efWcmvzphVYA4YywK2","name":"Bash","input":{"command":"find /Users/martin/Gattaca-Secuenciador-de-Prompts/src -type f -name \"*session*\" -o -name \"*context*\" | grep -E \"\\.(ts|tsx)$\""}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":3483,"cache_read_input_tokens":42795,"cache_creation":{"ephemeral_5m_input_tokens":3483,"ephemeral_1h_input_tokens":0},"output_tokens":335,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"aef20c9a-4c28-40aa-b11a-8bc3d31ab0ba"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KmoBCTyhM1DWK3UaiYS6mo","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useEffect, useRef } from 'react'\n     4→import { createPortal } from 'react-dom'\n     5→import { X, Save, FileText, Tag, Folder, Building2, FolderKanban, User, Clock, Cpu, Sparkles, Loader2, Info } from 'lucide-react'\n     6→import { PlaybookStepSourceMetadata } from '@/hooks/useDocuments'\n     7→\n     8→// ============================================\n     9→// TYPES\n    10→// ============================================\n    11→\n    12→export interface StepOutputContext {\n    13→  // Step info\n    14→  stepId: string\n    15→  stepName: string\n    16→  stepOrder: number\n    17→  // Campaign info\n    18→  campaignId: string\n    19→  campaignName: string\n    20→  campaignVariables?: Record<string, string>\n    21→  // Playbook info\n    22→  playbookId: string\n    23→  playbookName: string\n    24→  // Execution info\n    25→  executedAt?: string\n    26→  modelUsed?: string\n    27→  modelProvider?: string\n    28→  inputTokens?: number\n    29→  outputTokens?: number\n    30→  // Input references\n    31→  inputDocumentIds?: string[]\n    32→  inputPreviousStepIds?: string[]\n    33→  // Was the content edited before saving?\n    34→  wasEditedBeforeConversion: boolean\n    35→}\n    36→\n    37→export interface SaveToContextLakeModalProps {\n    38→  isOpen: boolean\n    39→  content: string\n    40→  projectId: string\n    41→  clientId: string\n    42→  userId: string\n    43→  stepContext: StepOutputContext\n    44→  onSave: (savedDocId: string) => void\n    45→  onClose: () => void\n    46→}\n    47→\n    48→// Document categories\n    49→const DOCUMENT_CATEGORIES = [\n    50→  { value: 'research', label: 'Investigación' },\n    51→  { value: 'strategy', label: 'Estrategia' },\n    52→  { value: 'content', label: 'Contenido' },\n    53→  { value: 'analysis', label: 'Análisis' },\n    54→  { value: 'persona', label: 'Persona/Avatar' },\n    55→  { value: 'brief', label: 'Brief' },\n    56→  { value: 'guidelines', label: 'Guías/Guidelines' },\n    57→  { value: 'other', label: 'Otro' },\n    58→]\n    59→\n    60→// ============================================\n    61→// MODAL COMPONENT\n    62→// ============================================\n    63→\n    64→export default function SaveToContextLakeModal({\n    65→  isOpen,\n    66→  content,\n    67→  projectId,\n    68→  clientId,\n    69→  userId,\n    70→  stepContext,\n    71→  onSave,\n    72→  onClose,\n    73→}: SaveToContextLakeModalProps) {\n    74→  const [mounted, setMounted] = useState(false)\n    75→  const [isVisible, setIsVisible] = useState(false)\n    76→  const [saving, setSaving] = useState(false)\n    77→  const [error, setError] = useState<string | null>(null)\n    78→  const modalRef = useRef<HTMLDivElement>(null)\n    79→\n    80→  // Form state\n    81→  const defaultFilename = `${stepContext.stepName} - ${stepContext.campaignName} - ${new Date().toLocaleDateString('es-ES', { day: 'numeric', month: 'short', year: 'numeric' })}`\n    82→  const [filename, setFilename] = useState(defaultFilename)\n    83→  const [category, setCategory] = useState('content')\n    84→  const [description, setDescription] = useState(`Output del paso \"${stepContext.stepName}\" del playbook ${stepContext.playbookName}.`)\n    85→  const [tags, setTags] = useState<string[]>([stepContext.campaignName.toLowerCase().replace(/\\s+/g, '-')])\n    86→  const [newTag, setNewTag] = useState('')\n    87→  const [destination, setDestination] = useState<'project' | 'client'>('project')\n    88→\n    89→  useEffect(() => {\n    90→    setMounted(true)\n    91→  }, [])\n    92→\n    93→  useEffect(() => {\n    94→    if (isOpen) {\n    95→      requestAnimationFrame(() => setIsVisible(true))\n    96→      // Reset form when opening\n    97→      setFilename(defaultFilename)\n    98→      setError(null)\n    99→    } else {\n   100→      setIsVisible(false)\n   101→    }\n   102→  }, [isOpen, defaultFilename])\n   103→\n   104→  // Handle escape key\n   105→  useEffect(() => {\n   106→    if (!isOpen) return\n   107→\n   108→    const handleKeyDown = (e: KeyboardEvent) => {\n   109→      if (e.key === 'Escape') onClose()\n   110→    }\n   111→\n   112→    document.addEventListener('keydown', handleKeyDown)\n   113→    return () => document.removeEventListener('keydown', handleKeyDown)\n   114→  }, [isOpen, onClose])\n   115→\n   116→  // Prevent body scroll\n   117→  useEffect(() => {\n   118→    if (isOpen) {\n   119→      document.body.style.overflow = 'hidden'\n   120→    } else {\n   121→      document.body.style.overflow = ''\n   122→    }\n   123→    return () => {\n   124→      document.body.style.overflow = ''\n   125→    }\n   126→  }, [isOpen])\n   127→\n   128→  const handleAddTag = () => {\n   129→    const trimmedTag = newTag.trim().toLowerCase().replace(/\\s+/g, '-')\n   130→    if (trimmedTag && !tags.includes(trimmedTag)) {\n   131→      setTags([...tags, trimmedTag])\n   132→      setNewTag('')\n   133→    }\n   134→  }\n   135→\n   136→  const handleRemoveTag = (tagToRemove: string) => {\n   137→    setTags(tags.filter(t => t !== tagToRemove))\n   138→  }\n   139→\n   140→  const handleSave = async () => {\n   141→    if (!filename.trim()) {\n   142→      setError('El nombre del documento es requerido')\n   143→      return\n   144→    }\n   145→\n   146→    setSaving(true)\n   147→    setError(null)\n   148→\n   149→    try {\n   150→      // Build source metadata\n   151→      const sourceMetadata: PlaybookStepSourceMetadata = {\n   152→        origin_type: 'flow_step_output',\n   153→        playbook_id: stepContext.playbookId,\n   154→        playbook_name: stepContext.playbookName,\n   155→        campaign_id: stepContext.campaignId,\n   156→        campaign_name: stepContext.campaignName,\n   157→        campaign_variables: stepContext.campaignVariables || {},\n   158→        step_id: stepContext.stepId,\n   159→        step_name: stepContext.stepName,\n   160→        step_order: stepContext.stepOrder,\n   161→        executed_at: stepContext.executedAt || new Date().toISOString(),\n   162→        model_used: stepContext.modelUsed || 'unknown',\n   163→        model_provider: stepContext.modelProvider || 'unknown',\n   164→        input_tokens: stepContext.inputTokens || 0,\n   165→        output_tokens: stepContext.outputTokens || 0,\n   166→        input_document_ids: stepContext.inputDocumentIds || [],\n   167→        input_previous_step_ids: stepContext.inputPreviousStepIds || [],\n   168→        converted_at: new Date().toISOString(),\n   169→        converted_by: userId,\n   170→        was_edited_before_conversion: stepContext.wasEditedBeforeConversion,\n   171→      }\n   172→\n   173→      const response = await fetch('/api/documents/from-step-output', {\n   174→        method: 'POST',\n   175→        headers: { 'Content-Type': 'application/json' },\n   176→        body: JSON.stringify({\n   177→          projectId: destination === 'project' ? projectId : null,\n   178→          clientId,\n   179→          filename: filename.trim(),\n   180→          category,\n   181→          content,\n   182→          description: description.trim() || null,\n   183→          tags: tags.length > 0 ? tags : null,\n   184→          userId,\n   185→          sourceMetadata,\n   186→          sourceCampaignId: stepContext.campaignId,\n   187→          sourceStepId: stepContext.stepId,\n   188→          sourceStepName: stepContext.stepName,\n   189→          sourcePlaybookId: stepContext.playbookId,\n   190→        }),\n   191→      })\n   192→\n   193→      const data = await response.json()\n   194→\n   195→      if (!response.ok) {\n   196→        throw new Error(data.error || 'Error al guardar el documento')\n   197→      }\n   198→\n   199→      onSave(data.document.id)\n   200→    } catch (err) {\n   201→      setError(err instanceof Error ? err.message : 'Error desconocido')\n   202→    } finally {\n   203→      setSaving(false)\n   204→    }\n   205→  }\n   206→\n   207→  if (!mounted || !isOpen) return null\n   208→\n   209→  return createPortal(\n   210→    <div\n   211→      className={`fixed inset-0 z-[10000] flex items-center justify-center p-4 transition-all duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n   212→      role=\"dialog\"\n   213→      aria-modal=\"true\"\n   214→      aria-labelledby=\"modal-title\"\n   215→    >\n   216→      {/* Backdrop */}\n   217→      <div\n   218→        className={`absolute inset-0 bg-gray-900/60 backdrop-blur-sm transition-opacity duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n   219→        onClick={onClose}\n   220→        aria-hidden=\"true\"\n   221→      />\n   222→\n   223→      {/* Modal */}\n   224→      <div\n   225→        ref={modalRef}\n   226→        className={`relative w-full max-w-2xl max-h-[90vh] overflow-y-auto bg-white dark:bg-gray-900 rounded-2xl shadow-2xl transform transition-all duration-200 ${isVisible ? 'scale-100 opacity-100' : 'scale-95 opacity-0'}`}\n   227→      >\n   228→        {/* Header */}\n   229→        <div className=\"sticky top-0 bg-gradient-to-r from-indigo-600 to-purple-600 px-6 py-5 rounded-t-2xl z-10\">\n   230→          <div className=\"flex items-center justify-between\">\n   231→            <div className=\"flex items-center gap-3\">\n   232→              <div className=\"p-3 bg-white/20 rounded-xl backdrop-blur-sm\">\n   233→                <Save className=\"w-6 h-6 text-white\" />\n   234→              </div>\n   235→              <div>\n   236→                <h2 id=\"modal-title\" className=\"text-xl font-bold text-white\">\n   237→                  Guardar en Context Lake\n   238→                </h2>\n   239→                <p className=\"text-indigo-100 text-sm mt-0.5\">\n   240→                  Crear documento permanente desde este output\n   241→                </p>\n   242→              </div>\n   243→            </div>\n   244→            <button\n   245→              onClick={onClose}\n   246→              className=\"p-2 text-white/70 hover:text-white hover:bg-white/10 rounded-lg transition-colors\"\n   247→            >\n   248→              <X size={20} />\n   249→            </button>\n   250→          </div>\n   251→        </div>\n   252→\n   253→        {/* Content */}\n   254→        <div className=\"p-6 space-y-6\">\n   255→          {/* Error message */}\n   256→          {error && (\n   257→            <div className=\"p-4 bg-red-50 border border-red-200 text-red-700 rounded-xl text-sm\">\n   258→              {error}\n   259→            </div>\n   260→          )}\n   261→\n   262→          {/* Filename */}\n   263→          <div>\n   264→            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   265→              <FileText size={14} className=\"inline mr-1.5\" />\n   266→              Nombre del documento\n   267→            </label>\n   268→            <input\n   269→              type=\"text\"\n   270→              value={filename}\n   271→              onChange={(e) => setFilename(e.target.value)}\n   272→              className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n   273→              placeholder=\"Nombre del documento...\"\n   274→            />\n   275→          </div>\n   276→\n   277→          {/* Category and Destination */}\n   278→          <div className=\"grid grid-cols-2 gap-4\">\n   279→            <div>\n   280→              <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   281→                <Folder size={14} className=\"inline mr-1.5\" />\n   282→                Categoría\n   283→              </label>\n   284→              <select\n   285→                value={category}\n   286→                onChange={(e) => setCategory(e.target.value)}\n   287→                className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n   288→              >\n   289→                {DOCUMENT_CATEGORIES.map((cat) => (\n   290→                  <option key={cat.value} value={cat.value}>\n   291→                    {cat.label}\n   292→                  </option>\n   293→                ))}\n   294→              </select>\n   295→            </div>\n   296→\n   297→            <div>\n   298→              <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   299→                Guardar en\n   300→              </label>\n   301→              <div className=\"flex gap-2\">\n   302→                <button\n   303→                  type=\"button\"\n   304→                  onClick={() => setDestination('project')}\n   305→                  className={`flex-1 px-4 py-3 text-sm rounded-xl border transition-all flex items-center justify-center gap-2 ${\n   306→                    destination === 'project'\n   307→                      ? 'bg-indigo-50 border-indigo-300 text-indigo-700 dark:bg-indigo-900/30 dark:border-indigo-600 dark:text-indigo-300'\n   308→                      : 'border-gray-200 text-gray-600 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800'\n   309→                  }`}\n   310→                >\n   311→                  <FolderKanban size={16} />\n   312→                  Proyecto\n   313→                </button>\n   314→                <button\n   315→                  type=\"button\"\n   316→                  onClick={() => setDestination('client')}\n   317→                  className={`flex-1 px-4 py-3 text-sm rounded-xl border transition-all flex items-center justify-center gap-2 ${\n   318→                    destination === 'client'\n   319→                      ? 'bg-indigo-50 border-indigo-300 text-indigo-700 dark:bg-indigo-900/30 dark:border-indigo-600 dark:text-indigo-300'\n   320→                      : 'border-gray-200 text-gray-600 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800'\n   321→                  }`}\n   322→                >\n   323→                  <Building2 size={16} />\n   324→                  Cliente\n   325→                </button>\n   326→              </div>\n   327→              <p className=\"text-xs text-gray-500 mt-1.5\">\n   328→                {destination === 'project'\n   329→                  ? 'Visible solo en este proyecto'\n   330→                  : 'Compartido con todos los proyectos del cliente'}\n   331→              </p>\n   332→            </div>\n   333→          </div>\n   334→\n   335→          {/* Description */}\n   336→          <div>\n   337→            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   338→              Descripción (opcional)\n   339→            </label>\n   340→            <textarea\n   341→              value={description}\n   342→              onChange={(e) => setDescription(e.target.value)}\n   343→              rows={2}\n   344→              className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 resize-none\"\n   345→              placeholder=\"Descripción del documento...\"\n   346→            />\n   347→          </div>\n   348→\n   349→          {/* Tags */}\n   350→          <div>\n   351→            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   352→              <Tag size={14} className=\"inline mr-1.5\" />\n   353→              Tags\n   354→            </label>\n   355→            <div className=\"flex flex-wrap gap-2 mb-2\">\n   356→              {tags.map((tag) => (\n   357→                <span\n   358→                  key={tag}\n   359→                  className=\"inline-flex items-center gap-1 px-3 py-1.5 bg-indigo-50 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300 rounded-lg text-sm\"\n   360→                >\n   361→                  {tag}\n   362→                  <button\n   363→                    type=\"button\"\n   364→                    onClick={() => handleRemoveTag(tag)}\n   365→                    className=\"ml-1 text-indigo-400 hover:text-indigo-600\"\n   366→                  >\n   367→                    <X size={12} />\n   368→                  </button>\n   369→                </span>\n   370→              ))}\n   371→            </div>\n   372→            <div className=\"flex gap-2\">\n   373→              <input\n   374→                type=\"text\"\n   375→                value={newTag}\n   376→                onChange={(e) => setNewTag(e.target.value)}\n   377→                onKeyDown={(e) => {\n   378→                  if (e.key === 'Enter') {\n   379→                    e.preventDefault()\n   380→                    handleAddTag()\n   381→                  }\n   382→                }}\n   383→                className=\"flex-1 px-4 py-2 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n   384→                placeholder=\"Agregar tag...\"\n   385→              />\n   386→              <button\n   387→                type=\"button\"\n   388→                onClick={handleAddTag}\n   389→                className=\"px-4 py-2 text-sm bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 rounded-xl hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors\"\n   390→              >\n   391→                Agregar\n   392→              </button>\n   393→            </div>\n   394→          </div>\n   395→\n   396→          {/* Traceability Info */}\n   397→          <div className=\"p-4 bg-gray-50 dark:bg-gray-800/50 rounded-xl border border-gray-200 dark:border-gray-700\">\n   398→            <div className=\"flex items-center gap-2 text-gray-700 dark:text-gray-300 font-medium text-sm mb-3\">\n   399→              <Info size={16} />\n   400→              Trazabilidad que se guardará\n   401→            </div>\n   402→            <div className=\"grid grid-cols-2 gap-3 text-sm\">\n   403→              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n   404→                <FolderKanban size={14} />\n   405→                <span className=\"font-medium\">Campaña:</span>\n   406→                <span className=\"truncate\">{stepContext.campaignName}</span>\n   407→              </div>\n   408→              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n   409→                <Sparkles size={14} />\n   410→                <span className=\"font-medium\">Paso:</span>\n   411→                <span className=\"truncate\">{stepContext.stepName} (#{stepContext.stepOrder})</span>\n   412→              </div>\n   413→              {stepContext.modelUsed && (\n   414→                <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n   415→                  <Cpu size={14} />\n   416→                  <span className=\"font-medium\">Modelo:</span>\n   417→                  <span className=\"truncate\">{stepContext.modelUsed}</span>\n   418→                </div>\n   419→              )}\n   420→              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n   421→                <User size={14} />\n   422→                <span className=\"font-medium\">Creado por:</span>\n   423→                <span className=\"truncate\">Usuario actual</span>\n   424→              </div>\n   425→              {stepContext.wasEditedBeforeConversion && (\n   426→                <div className=\"col-span-2 flex items-center gap-2 text-amber-600 dark:text-amber-400\">\n   427→                  <Clock size={14} />\n   428→                  <span>El output fue editado antes de guardarse</span>\n   429→                </div>\n   430→              )}\n   431→            </div>\n   432→          </div>\n   433→\n   434→          {/* Content Preview */}\n   435→          <div>\n   436→            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   437→              Vista previa del contenido ({content.length.toLocaleString()} caracteres)\n   438→            </label>\n   439→            <div className=\"max-h-40 overflow-y-auto p-4 bg-gray-50 dark:bg-gray-800/50 rounded-xl border border-gray-200 dark:border-gray-700 text-sm text-gray-600 dark:text-gray-400 font-mono whitespace-pre-wrap\">\n   440→              {content.substring(0, 1000)}\n   441→              {content.length > 1000 && (\n   442→                <span className=\"text-gray-400\">... [{(content.length - 1000).toLocaleString()} caracteres más]</span>\n   443→              )}\n   444→            </div>\n   445→          </div>\n   446→        </div>\n   447→\n   448→        {/* Footer */}\n   449→        <div className=\"sticky bottom-0 flex items-center justify-end gap-3 px-6 py-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/50 rounded-b-2xl\">\n   450→          <button\n   451→            type=\"button\"\n   452→            onClick={onClose}\n   453→            className=\"px-5 py-2.5 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-xl hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors\"\n   454→          >\n   455→            Cancelar\n   456→          </button>\n   457→          <button\n   458→            type=\"button\"\n   459→            onClick={handleSave}\n   460→            disabled={saving || !filename.trim()}\n   461→            className=\"px-6 py-2.5 text-sm font-medium text-white bg-gradient-to-r from-indigo-600 to-purple-600 rounded-xl hover:from-indigo-700 hover:to-purple-700 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed transition-all shadow-md hover:shadow-lg inline-flex items-center gap-2\"\n   462→          >\n   463→            {saving ? (\n   464→              <>\n   465→                <Loader2 size={16} className=\"animate-spin\" />\n   466→                Guardando...\n   467→              </>\n   468→            ) : (\n   469→              <>\n   470→                <Save size={16} />\n   471→                Guardar en Context Lake\n   472→              </>\n   473→            )}\n   474→          </button>\n   475→        </div>\n   476→      </div>\n   477→    </div>,\n   478→    document.body\n   479→  )\n   480→}\n   481→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"668fe8a9-e757-4a4d-a84b-42516fb581d2","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/SaveToContextLakeModal.tsx","content":"'use client'\n\nimport { useState, useEffect, useRef } from 'react'\nimport { createPortal } from 'react-dom'\nimport { X, Save, FileText, Tag, Folder, Building2, FolderKanban, User, Clock, Cpu, Sparkles, Loader2, Info } from 'lucide-react'\nimport { PlaybookStepSourceMetadata } from '@/hooks/useDocuments'\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface StepOutputContext {\n  // Step info\n  stepId: string\n  stepName: string\n  stepOrder: number\n  // Campaign info\n  campaignId: string\n  campaignName: string\n  campaignVariables?: Record<string, string>\n  // Playbook info\n  playbookId: string\n  playbookName: string\n  // Execution info\n  executedAt?: string\n  modelUsed?: string\n  modelProvider?: string\n  inputTokens?: number\n  outputTokens?: number\n  // Input references\n  inputDocumentIds?: string[]\n  inputPreviousStepIds?: string[]\n  // Was the content edited before saving?\n  wasEditedBeforeConversion: boolean\n}\n\nexport interface SaveToContextLakeModalProps {\n  isOpen: boolean\n  content: string\n  projectId: string\n  clientId: string\n  userId: string\n  stepContext: StepOutputContext\n  onSave: (savedDocId: string) => void\n  onClose: () => void\n}\n\n// Document categories\nconst DOCUMENT_CATEGORIES = [\n  { value: 'research', label: 'Investigación' },\n  { value: 'strategy', label: 'Estrategia' },\n  { value: 'content', label: 'Contenido' },\n  { value: 'analysis', label: 'Análisis' },\n  { value: 'persona', label: 'Persona/Avatar' },\n  { value: 'brief', label: 'Brief' },\n  { value: 'guidelines', label: 'Guías/Guidelines' },\n  { value: 'other', label: 'Otro' },\n]\n\n// ============================================\n// MODAL COMPONENT\n// ============================================\n\nexport default function SaveToContextLakeModal({\n  isOpen,\n  content,\n  projectId,\n  clientId,\n  userId,\n  stepContext,\n  onSave,\n  onClose,\n}: SaveToContextLakeModalProps) {\n  const [mounted, setMounted] = useState(false)\n  const [isVisible, setIsVisible] = useState(false)\n  const [saving, setSaving] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const modalRef = useRef<HTMLDivElement>(null)\n\n  // Form state\n  const defaultFilename = `${stepContext.stepName} - ${stepContext.campaignName} - ${new Date().toLocaleDateString('es-ES', { day: 'numeric', month: 'short', year: 'numeric' })}`\n  const [filename, setFilename] = useState(defaultFilename)\n  const [category, setCategory] = useState('content')\n  const [description, setDescription] = useState(`Output del paso \"${stepContext.stepName}\" del playbook ${stepContext.playbookName}.`)\n  const [tags, setTags] = useState<string[]>([stepContext.campaignName.toLowerCase().replace(/\\s+/g, '-')])\n  const [newTag, setNewTag] = useState('')\n  const [destination, setDestination] = useState<'project' | 'client'>('project')\n\n  useEffect(() => {\n    setMounted(true)\n  }, [])\n\n  useEffect(() => {\n    if (isOpen) {\n      requestAnimationFrame(() => setIsVisible(true))\n      // Reset form when opening\n      setFilename(defaultFilename)\n      setError(null)\n    } else {\n      setIsVisible(false)\n    }\n  }, [isOpen, defaultFilename])\n\n  // Handle escape key\n  useEffect(() => {\n    if (!isOpen) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') onClose()\n    }\n\n    document.addEventListener('keydown', handleKeyDown)\n    return () => document.removeEventListener('keydown', handleKeyDown)\n  }, [isOpen, onClose])\n\n  // Prevent body scroll\n  useEffect(() => {\n    if (isOpen) {\n      document.body.style.overflow = 'hidden'\n    } else {\n      document.body.style.overflow = ''\n    }\n    return () => {\n      document.body.style.overflow = ''\n    }\n  }, [isOpen])\n\n  const handleAddTag = () => {\n    const trimmedTag = newTag.trim().toLowerCase().replace(/\\s+/g, '-')\n    if (trimmedTag && !tags.includes(trimmedTag)) {\n      setTags([...tags, trimmedTag])\n      setNewTag('')\n    }\n  }\n\n  const handleRemoveTag = (tagToRemove: string) => {\n    setTags(tags.filter(t => t !== tagToRemove))\n  }\n\n  const handleSave = async () => {\n    if (!filename.trim()) {\n      setError('El nombre del documento es requerido')\n      return\n    }\n\n    setSaving(true)\n    setError(null)\n\n    try {\n      // Build source metadata\n      const sourceMetadata: PlaybookStepSourceMetadata = {\n        origin_type: 'flow_step_output',\n        playbook_id: stepContext.playbookId,\n        playbook_name: stepContext.playbookName,\n        campaign_id: stepContext.campaignId,\n        campaign_name: stepContext.campaignName,\n        campaign_variables: stepContext.campaignVariables || {},\n        step_id: stepContext.stepId,\n        step_name: stepContext.stepName,\n        step_order: stepContext.stepOrder,\n        executed_at: stepContext.executedAt || new Date().toISOString(),\n        model_used: stepContext.modelUsed || 'unknown',\n        model_provider: stepContext.modelProvider || 'unknown',\n        input_tokens: stepContext.inputTokens || 0,\n        output_tokens: stepContext.outputTokens || 0,\n        input_document_ids: stepContext.inputDocumentIds || [],\n        input_previous_step_ids: stepContext.inputPreviousStepIds || [],\n        converted_at: new Date().toISOString(),\n        converted_by: userId,\n        was_edited_before_conversion: stepContext.wasEditedBeforeConversion,\n      }\n\n      const response = await fetch('/api/documents/from-step-output', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          projectId: destination === 'project' ? projectId : null,\n          clientId,\n          filename: filename.trim(),\n          category,\n          content,\n          description: description.trim() || null,\n          tags: tags.length > 0 ? tags : null,\n          userId,\n          sourceMetadata,\n          sourceCampaignId: stepContext.campaignId,\n          sourceStepId: stepContext.stepId,\n          sourceStepName: stepContext.stepName,\n          sourcePlaybookId: stepContext.playbookId,\n        }),\n      })\n\n      const data = await response.json()\n\n      if (!response.ok) {\n        throw new Error(data.error || 'Error al guardar el documento')\n      }\n\n      onSave(data.document.id)\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Error desconocido')\n    } finally {\n      setSaving(false)\n    }\n  }\n\n  if (!mounted || !isOpen) return null\n\n  return createPortal(\n    <div\n      className={`fixed inset-0 z-[10000] flex items-center justify-center p-4 transition-all duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-labelledby=\"modal-title\"\n    >\n      {/* Backdrop */}\n      <div\n        className={`absolute inset-0 bg-gray-900/60 backdrop-blur-sm transition-opacity duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n        onClick={onClose}\n        aria-hidden=\"true\"\n      />\n\n      {/* Modal */}\n      <div\n        ref={modalRef}\n        className={`relative w-full max-w-2xl max-h-[90vh] overflow-y-auto bg-white dark:bg-gray-900 rounded-2xl shadow-2xl transform transition-all duration-200 ${isVisible ? 'scale-100 opacity-100' : 'scale-95 opacity-0'}`}\n      >\n        {/* Header */}\n        <div className=\"sticky top-0 bg-gradient-to-r from-indigo-600 to-purple-600 px-6 py-5 rounded-t-2xl z-10\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-3\">\n              <div className=\"p-3 bg-white/20 rounded-xl backdrop-blur-sm\">\n                <Save className=\"w-6 h-6 text-white\" />\n              </div>\n              <div>\n                <h2 id=\"modal-title\" className=\"text-xl font-bold text-white\">\n                  Guardar en Context Lake\n                </h2>\n                <p className=\"text-indigo-100 text-sm mt-0.5\">\n                  Crear documento permanente desde este output\n                </p>\n              </div>\n            </div>\n            <button\n              onClick={onClose}\n              className=\"p-2 text-white/70 hover:text-white hover:bg-white/10 rounded-lg transition-colors\"\n            >\n              <X size={20} />\n            </button>\n          </div>\n        </div>\n\n        {/* Content */}\n        <div className=\"p-6 space-y-6\">\n          {/* Error message */}\n          {error && (\n            <div className=\"p-4 bg-red-50 border border-red-200 text-red-700 rounded-xl text-sm\">\n              {error}\n            </div>\n          )}\n\n          {/* Filename */}\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n              <FileText size={14} className=\"inline mr-1.5\" />\n              Nombre del documento\n            </label>\n            <input\n              type=\"text\"\n              value={filename}\n              onChange={(e) => setFilename(e.target.value)}\n              className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n              placeholder=\"Nombre del documento...\"\n            />\n          </div>\n\n          {/* Category and Destination */}\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                <Folder size={14} className=\"inline mr-1.5\" />\n                Categoría\n              </label>\n              <select\n                value={category}\n                onChange={(e) => setCategory(e.target.value)}\n                className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n              >\n                {DOCUMENT_CATEGORIES.map((cat) => (\n                  <option key={cat.value} value={cat.value}>\n                    {cat.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                Guardar en\n              </label>\n              <div className=\"flex gap-2\">\n                <button\n                  type=\"button\"\n                  onClick={() => setDestination('project')}\n                  className={`flex-1 px-4 py-3 text-sm rounded-xl border transition-all flex items-center justify-center gap-2 ${\n                    destination === 'project'\n                      ? 'bg-indigo-50 border-indigo-300 text-indigo-700 dark:bg-indigo-900/30 dark:border-indigo-600 dark:text-indigo-300'\n                      : 'border-gray-200 text-gray-600 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800'\n                  }`}\n                >\n                  <FolderKanban size={16} />\n                  Proyecto\n                </button>\n                <button\n                  type=\"button\"\n                  onClick={() => setDestination('client')}\n                  className={`flex-1 px-4 py-3 text-sm rounded-xl border transition-all flex items-center justify-center gap-2 ${\n                    destination === 'client'\n                      ? 'bg-indigo-50 border-indigo-300 text-indigo-700 dark:bg-indigo-900/30 dark:border-indigo-600 dark:text-indigo-300'\n                      : 'border-gray-200 text-gray-600 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800'\n                  }`}\n                >\n                  <Building2 size={16} />\n                  Cliente\n                </button>\n              </div>\n              <p className=\"text-xs text-gray-500 mt-1.5\">\n                {destination === 'project'\n                  ? 'Visible solo en este proyecto'\n                  : 'Compartido con todos los proyectos del cliente'}\n              </p>\n            </div>\n          </div>\n\n          {/* Description */}\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n              Descripción (opcional)\n            </label>\n            <textarea\n              value={description}\n              onChange={(e) => setDescription(e.target.value)}\n              rows={2}\n              className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 resize-none\"\n              placeholder=\"Descripción del documento...\"\n            />\n          </div>\n\n          {/* Tags */}\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n              <Tag size={14} className=\"inline mr-1.5\" />\n              Tags\n            </label>\n            <div className=\"flex flex-wrap gap-2 mb-2\">\n              {tags.map((tag) => (\n                <span\n                  key={tag}\n                  className=\"inline-flex items-center gap-1 px-3 py-1.5 bg-indigo-50 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300 rounded-lg text-sm\"\n                >\n                  {tag}\n                  <button\n                    type=\"button\"\n                    onClick={() => handleRemoveTag(tag)}\n                    className=\"ml-1 text-indigo-400 hover:text-indigo-600\"\n                  >\n                    <X size={12} />\n                  </button>\n                </span>\n              ))}\n            </div>\n            <div className=\"flex gap-2\">\n              <input\n                type=\"text\"\n                value={newTag}\n                onChange={(e) => setNewTag(e.target.value)}\n                onKeyDown={(e) => {\n                  if (e.key === 'Enter') {\n                    e.preventDefault()\n                    handleAddTag()\n                  }\n                }}\n                className=\"flex-1 px-4 py-2 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n                placeholder=\"Agregar tag...\"\n              />\n              <button\n                type=\"button\"\n                onClick={handleAddTag}\n                className=\"px-4 py-2 text-sm bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 rounded-xl hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors\"\n              >\n                Agregar\n              </button>\n            </div>\n          </div>\n\n          {/* Traceability Info */}\n          <div className=\"p-4 bg-gray-50 dark:bg-gray-800/50 rounded-xl border border-gray-200 dark:border-gray-700\">\n            <div className=\"flex items-center gap-2 text-gray-700 dark:text-gray-300 font-medium text-sm mb-3\">\n              <Info size={16} />\n              Trazabilidad que se guardará\n            </div>\n            <div className=\"grid grid-cols-2 gap-3 text-sm\">\n              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n                <FolderKanban size={14} />\n                <span className=\"font-medium\">Campaña:</span>\n                <span className=\"truncate\">{stepContext.campaignName}</span>\n              </div>\n              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n                <Sparkles size={14} />\n                <span className=\"font-medium\">Paso:</span>\n                <span className=\"truncate\">{stepContext.stepName} (#{stepContext.stepOrder})</span>\n              </div>\n              {stepContext.modelUsed && (\n                <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n                  <Cpu size={14} />\n                  <span className=\"font-medium\">Modelo:</span>\n                  <span className=\"truncate\">{stepContext.modelUsed}</span>\n                </div>\n              )}\n              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n                <User size={14} />\n                <span className=\"font-medium\">Creado por:</span>\n                <span className=\"truncate\">Usuario actual</span>\n              </div>\n              {stepContext.wasEditedBeforeConversion && (\n                <div className=\"col-span-2 flex items-center gap-2 text-amber-600 dark:text-amber-400\">\n                  <Clock size={14} />\n                  <span>El output fue editado antes de guardarse</span>\n                </div>\n              )}\n            </div>\n          </div>\n\n          {/* Content Preview */}\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n              Vista previa del contenido ({content.length.toLocaleString()} caracteres)\n            </label>\n            <div className=\"max-h-40 overflow-y-auto p-4 bg-gray-50 dark:bg-gray-800/50 rounded-xl border border-gray-200 dark:border-gray-700 text-sm text-gray-600 dark:text-gray-400 font-mono whitespace-pre-wrap\">\n              {content.substring(0, 1000)}\n              {content.length > 1000 && (\n                <span className=\"text-gray-400\">... [{(content.length - 1000).toLocaleString()} caracteres más]</span>\n              )}\n            </div>\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"sticky bottom-0 flex items-center justify-end gap-3 px-6 py-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/50 rounded-b-2xl\">\n          <button\n            type=\"button\"\n            onClick={onClose}\n            className=\"px-5 py-2.5 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-xl hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors\"\n          >\n            Cancelar\n          </button>\n          <button\n            type=\"button\"\n            onClick={handleSave}\n            disabled={saving || !filename.trim()}\n            className=\"px-6 py-2.5 text-sm font-medium text-white bg-gradient-to-r from-indigo-600 to-purple-600 rounded-xl hover:from-indigo-700 hover:to-purple-700 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed transition-all shadow-md hover:shadow-lg inline-flex items-center gap-2\"\n          >\n            {saving ? (\n              <>\n                <Loader2 size={16} className=\"animate-spin\" />\n                Guardando...\n              </>\n            ) : (\n              <>\n                <Save size={16} />\n                Guardar en Context Lake\n              </>\n            )}\n          </button>\n        </div>\n      </div>\n    </div>,\n    document.body\n  )\n}\n","numLines":481,"startLine":1,"totalLines":481}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JAHyicE4UGSUreSLrtFuN8","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useEffect, useCallback } from 'react'\n     4→import {\n     5→  X,\n     6→  Search,\n     7→  Clock,\n     8→  ChevronRight,\n     9→  Loader2,\n    10→  History,\n    11→  Filter,\n    12→  Calendar,\n    13→  RefreshCw,\n    14→  Play,\n    15→} from 'lucide-react'\n    16→import { getPlaybookName, formatStepName } from '@/lib/playbook-metadata'\n    17→\n    18→interface Session {\n    19→  id: string\n    20→  name: string | null\n    21→  playbook_type: string\n    22→  status: string\n    23→  current_step: string | null\n    24→  created_at: string\n    25→  updated_at: string\n    26→  tags: string[] | null\n    27→}\n    28→\n    29→interface AllSessionsPanelProps {\n    30→  projectId: string\n    31→  playbookType?: string\n    32→  onSessionSelect: (sessionId: string) => void\n    33→  onClose: () => void\n    34→  onStartNew?: () => void\n    35→}\n    36→\n    37→type StatusFilter = 'all' | 'draft' | 'running' | 'paused' | 'completed' | 'failed'\n    38→\n    39→const STATUS_OPTIONS: { value: StatusFilter; label: string }[] = [\n    40→  { value: 'all', label: 'Todos' },\n    41→  { value: 'draft', label: 'Borrador' },\n    42→  { value: 'running', label: 'En progreso' },\n    43→  { value: 'paused', label: 'Pausado' },\n    44→  { value: 'completed', label: 'Completado' },\n    45→  { value: 'failed', label: 'Error' },\n    46→]\n    47→\n    48→/**\n    49→ * Full session history panel with search, status filter, and date range filter.\n    50→ * Shows all sessions for a project, sorted by updated_at descending.\n    51→ */\n    52→export default function AllSessionsPanel({\n    53→  projectId,\n    54→  playbookType,\n    55→  onSessionSelect,\n    56→  onClose,\n    57→  onStartNew,\n    58→}: AllSessionsPanelProps) {\n    59→  const [sessions, setSessions] = useState<Session[]>([])\n    60→  const [loading, setLoading] = useState(true)\n    61→  const [error, setError] = useState<string | null>(null)\n    62→\n    63→  // Filters\n    64→  const [searchQuery, setSearchQuery] = useState('')\n    65→  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all')\n    66→  const [dateFrom, setDateFrom] = useState('')\n    67→  const [dateTo, setDateTo] = useState('')\n    68→  const [showFilters, setShowFilters] = useState(false)\n    69→\n    70→  const loadSessions = useCallback(async () => {\n    71→    try {\n    72→      setLoading(true)\n    73→      setError(null)\n    74→\n    75→      const params = new URLSearchParams({ project_id: projectId })\n    76→\n    77→      if (playbookType) {\n    78→        params.append('playbook_type', playbookType)\n    79→      }\n    80→      if (searchQuery.trim()) {\n    81→        params.append('search', searchQuery.trim())\n    82→      }\n    83→      if (statusFilter !== 'all') {\n    84→        params.append('status', statusFilter)\n    85→      }\n    86→      if (dateFrom) {\n    87→        params.append('date_from', dateFrom)\n    88→      }\n    89→      if (dateTo) {\n    90→        params.append('date_to', dateTo)\n    91→      }\n    92→\n    93→      const response = await fetch(`/api/playbook/sessions?${params.toString()}`)\n    94→\n    95→      if (!response.ok) {\n    96→        throw new Error('Error al cargar las sesiones')\n    97→      }\n    98→\n    99→      const data = await response.json()\n   100→      setSessions(data.sessions || [])\n   101→    } catch (err) {\n   102→      console.error('Error loading sessions:', err)\n   103→      setError(err instanceof Error ? err.message : 'Error desconocido')\n   104→    } finally {\n   105→      setLoading(false)\n   106→    }\n   107→  }, [projectId, playbookType, searchQuery, statusFilter, dateFrom, dateTo])\n   108→\n   109→  useEffect(() => {\n   110→    loadSessions()\n   111→  }, [loadSessions])\n   112→\n   113→  const formatDate = (dateStr: string) => {\n   114→    return new Date(dateStr).toLocaleDateString('es-ES', {\n   115→      day: 'numeric',\n   116→      month: 'short',\n   117→      year: 'numeric',\n   118→      hour: '2-digit',\n   119→      minute: '2-digit',\n   120→    })\n   121→  }\n   122→\n   123→  const getStatusBadge = (status: string) => {\n   124→    const statusConfig: Record<string, { bg: string; text: string; label: string }> = {\n   125→      draft: { bg: 'bg-gray-100', text: 'text-gray-600', label: 'Borrador' },\n   126→      running: { bg: 'bg-blue-100', text: 'text-blue-700', label: 'En progreso' },\n   127→      paused: { bg: 'bg-yellow-100', text: 'text-yellow-700', label: 'Pausado' },\n   128→      completed: { bg: 'bg-green-100', text: 'text-green-700', label: 'Completado' },\n   129→      failed: { bg: 'bg-red-100', text: 'text-red-700', label: 'Error' },\n   130→      active: { bg: 'bg-blue-100', text: 'text-blue-700', label: 'Activo' },\n   131→    }\n   132→    const config = statusConfig[status] || statusConfig.draft\n   133→    return (\n   134→      <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${config.bg} ${config.text}`}>\n   135→        {config.label}\n   136→      </span>\n   137→    )\n   138→  }\n   139→\n   140→  const clearFilters = () => {\n   141→    setSearchQuery('')\n   142→    setStatusFilter('all')\n   143→    setDateFrom('')\n   144→    setDateTo('')\n   145→  }\n   146→\n   147→  const hasActiveFilters = searchQuery || statusFilter !== 'all' || dateFrom || dateTo\n   148→\n   149→  return (\n   150→    <div className=\"fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4\">\n   151→      <div className=\"bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-hidden flex flex-col\">\n   152→        {/* Header */}\n   153→        <div className=\"px-6 py-5 border-b border-gray-100 bg-gradient-to-r from-blue-50 to-indigo-50\">\n   154→          <div className=\"flex items-center justify-between\">\n   155→            <div className=\"flex items-center gap-3\">\n   156→              <div className=\"p-2.5 bg-blue-100 rounded-xl\">\n   157→                <History size={20} className=\"text-blue-600\" />\n   158→              </div>\n   159→              <div>\n   160→                <h2 className=\"text-lg font-semibold text-gray-900\">Historial de sesiones</h2>\n   161→                <p className=\"text-sm text-gray-600\">\n   162→                  {playbookType ? getPlaybookName(playbookType) : 'Todas las sesiones'}\n   163→                </p>\n   164→              </div>\n   165→            </div>\n   166→            <button\n   167→              onClick={onClose}\n   168→              className=\"p-2 text-gray-400 hover:text-gray-600 hover:bg-white/50 rounded-lg transition-colors\"\n   169→            >\n   170→              <X size={20} />\n   171→            </button>\n   172→          </div>\n   173→        </div>\n   174→\n   175→        {/* Search and Filters */}\n   176→        <div className=\"px-6 py-4 border-b border-gray-100 space-y-3\">\n   177→          {/* Search Bar */}\n   178→          <div className=\"flex gap-2\">\n   179→            <div className=\"flex-1 relative\">\n   180→              <Search\n   181→                size={16}\n   182→                className=\"absolute left-3 top-1/2 -translate-y-1/2 text-gray-400\"\n   183→              />\n   184→              <input\n   185→                type=\"text\"\n   186→                value={searchQuery}\n   187→                onChange={(e) => setSearchQuery(e.target.value)}\n   188→                placeholder=\"Buscar por nombre...\"\n   189→                className=\"w-full pl-9 pr-4 py-2 border border-gray-300 rounded-xl text-sm text-gray-900 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n   190→              />\n   191→            </div>\n   192→            <button\n   193→              onClick={() => setShowFilters(!showFilters)}\n   194→              className={`px-3 py-2 border rounded-xl flex items-center gap-2 text-sm font-medium transition-colors ${\n   195→                showFilters || hasActiveFilters\n   196→                  ? 'border-blue-300 bg-blue-50 text-blue-700'\n   197→                  : 'border-gray-300 text-gray-700 hover:bg-gray-50'\n   198→              }`}\n   199→            >\n   200→              <Filter size={16} />\n   201→              Filtros\n   202→              {hasActiveFilters && (\n   203→                <span className=\"w-2 h-2 rounded-full bg-blue-500\" />\n   204→              )}\n   205→            </button>\n   206→            <button\n   207→              onClick={loadSessions}\n   208→              className=\"px-3 py-2 border border-gray-300 rounded-xl text-gray-600 hover:bg-gray-50 transition-colors\"\n   209→              title=\"Actualizar\"\n   210→            >\n   211→              <RefreshCw size={16} />\n   212→            </button>\n   213→          </div>\n   214→\n   215→          {/* Expanded Filters */}\n   216→          {showFilters && (\n   217→            <div className=\"flex flex-wrap gap-3 pt-2\">\n   218→              {/* Status Filter */}\n   219→              <div className=\"flex items-center gap-2\">\n   220→                <label className=\"text-xs text-gray-500 font-medium\">Estado:</label>\n   221→                <select\n   222→                  value={statusFilter}\n   223→                  onChange={(e) => setStatusFilter(e.target.value as StatusFilter)}\n   224→                  className=\"px-3 py-1.5 border border-gray-300 rounded-lg text-sm text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n   225→                >\n   226→                  {STATUS_OPTIONS.map((option) => (\n   227→                    <option key={option.value} value={option.value}>\n   228→                      {option.label}\n   229→                    </option>\n   230→                  ))}\n   231→                </select>\n   232→              </div>\n   233→\n   234→              {/* Date Range */}\n   235→              <div className=\"flex items-center gap-2\">\n   236→                <Calendar size={14} className=\"text-gray-400\" />\n   237→                <label className=\"text-xs text-gray-500 font-medium\">Desde:</label>\n   238→                <input\n   239→                  type=\"date\"\n   240→                  value={dateFrom}\n   241→                  onChange={(e) => setDateFrom(e.target.value)}\n   242→                  className=\"px-2 py-1.5 border border-gray-300 rounded-lg text-sm text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n   243→                />\n   244→              </div>\n   245→\n   246→              <div className=\"flex items-center gap-2\">\n   247→                <label className=\"text-xs text-gray-500 font-medium\">Hasta:</label>\n   248→                <input\n   249→                  type=\"date\"\n   250→                  value={dateTo}\n   251→                  onChange={(e) => setDateTo(e.target.value)}\n   252→                  className=\"px-2 py-1.5 border border-gray-300 rounded-lg text-sm text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n   253→                />\n   254→              </div>\n   255→\n   256→              {hasActiveFilters && (\n   257→                <button\n   258→                  onClick={clearFilters}\n   259→                  className=\"px-3 py-1.5 text-xs text-red-600 hover:text-red-700 font-medium\"\n   260→                >\n   261→                  Limpiar filtros\n   262→                </button>\n   263→              )}\n   264→            </div>\n   265→          )}\n   266→        </div>\n   267→\n   268→        {/* Session List */}\n   269→        <div className=\"flex-1 overflow-y-auto\">\n   270→          {loading ? (\n   271→            <div className=\"flex items-center justify-center py-12\">\n   272→              <Loader2 size={24} className=\"animate-spin text-gray-400\" />\n   273→            </div>\n   274→          ) : error ? (\n   275→            <div className=\"p-6 text-center\">\n   276→              <div className=\"p-4 bg-red-50 border border-red-200 rounded-xl text-sm text-red-700\">\n   277→                {error}\n   278→              </div>\n   279→            </div>\n   280→          ) : sessions.length === 0 ? (\n   281→            <div className=\"p-6 text-center\">\n   282→              <div className=\"text-gray-400 mb-2\">\n   283→                <History size={48} className=\"mx-auto opacity-50\" />\n   284→              </div>\n   285→              <p className=\"text-gray-500 text-sm\">\n   286→                {hasActiveFilters\n   287→                  ? 'No se encontraron sesiones con los filtros aplicados'\n   288→                  : 'No hay sesiones registradas'}\n   289→              </p>\n   290→              {hasActiveFilters && (\n   291→                <button\n   292→                  onClick={clearFilters}\n   293→                  className=\"mt-2 text-sm text-blue-600 hover:text-blue-700 font-medium\"\n   294→                >\n   295→                  Limpiar filtros\n   296→                </button>\n   297→              )}\n   298→            </div>\n   299→          ) : (\n   300→            <div className=\"p-4 space-y-2\">\n   301→              {sessions.map((session) => (\n   302→                <button\n   303→                  key={session.id}\n   304→                  onClick={() => onSessionSelect(session.id)}\n   305→                  className=\"w-full flex items-center justify-between p-4 bg-gray-50 hover:bg-gray-100 rounded-xl transition-colors text-left group\"\n   306→                >\n   307→                  <div className=\"flex-1 min-w-0\">\n   308→                    <div className=\"flex items-center gap-2 flex-wrap\">\n   309→                      <span className=\"font-medium text-gray-900 truncate\">\n   310→                        {session.name || `Sesión ${session.id.slice(0, 8)}`}\n   311→                      </span>\n   312→                      {getStatusBadge(session.status)}\n   313→                      {!playbookType && (\n   314→                        <span className=\"text-xs text-gray-500 bg-gray-200 px-1.5 py-0.5 rounded\">\n   315→                          {getPlaybookName(session.playbook_type)}\n   316→                        </span>\n   317→                      )}\n   318→                    </div>\n   319→                    <div className=\"flex items-center gap-2 mt-1.5 flex-wrap\">\n   320→                      <Clock size={12} className=\"text-gray-400 flex-shrink-0\" />\n   321→                      <span className=\"text-xs text-gray-500\">\n   322→                        {formatDate(session.updated_at)}\n   323→                      </span>\n   324→                      {session.current_step && (\n   325→                        <span className=\"text-xs text-blue-600 bg-blue-50 px-1.5 py-0.5 rounded\">\n   326→                          {formatStepName(session.current_step)}\n   327→                        </span>\n   328→                      )}\n   329→                      {session.tags && session.tags.length > 0 && (\n   330→                        <span className=\"text-xs text-gray-400\">\n   331→                          · {session.tags.slice(0, 3).join(', ')}\n   332→                          {session.tags.length > 3 && ` +${session.tags.length - 3}`}\n   333→                        </span>\n   334→                      )}\n   335→                    </div>\n   336→                  </div>\n   337→                  <div className=\"flex items-center gap-2 ml-3\">\n   338→                    <span className=\"text-xs text-blue-600 font-medium opacity-0 group-hover:opacity-100 transition-opacity\">\n   339→                      Continuar\n   340→                    </span>\n   341→                    <ChevronRight\n   342→                      size={16}\n   343→                      className=\"text-gray-400 group-hover:text-blue-500 transition-colors flex-shrink-0\"\n   344→                    />\n   345→                  </div>\n   346→                </button>\n   347→              ))}\n   348→            </div>\n   349→          )}\n   350→        </div>\n   351→\n   352→        {/* Footer */}\n   353→        <div className=\"px-6 py-4 border-t border-gray-100 bg-gray-50 flex justify-between items-center\">\n   354→          <span className=\"text-xs text-gray-500\">\n   355→            {sessions.length} sesión{sessions.length !== 1 ? 'es' : ''} encontrada{sessions.length !== 1 ? 's' : ''}\n   356→          </span>\n   357→          <div className=\"flex gap-3\">\n   358→            <button\n   359→              onClick={onClose}\n   360→              className=\"px-4 py-2 border border-gray-300 text-gray-700 rounded-xl hover:bg-white font-medium text-sm transition-colors\"\n   361→            >\n   362→              Cerrar\n   363→            </button>\n   364→            {onStartNew && (\n   365→              <button\n   366→                onClick={onStartNew}\n   367→                className=\"px-4 py-2 bg-gradient-to-r from-blue-600 to-indigo-600 text-white rounded-xl hover:from-blue-700 hover:to-indigo-700 font-medium text-sm transition-all inline-flex items-center gap-2\"\n   368→              >\n   369→                <Play size={14} />\n   370→                Nueva sesión\n   371→              </button>\n   372→            )}\n   373→          </div>\n   374→        </div>\n   375→      </div>\n   376→    </div>\n   377→  )\n   378→}\n   379→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"d555c2a6-e18c-4ea2-96f2-02515bcb78e7","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/AllSessionsPanel.tsx","content":"'use client'\n\nimport { useState, useEffect, useCallback } from 'react'\nimport {\n  X,\n  Search,\n  Clock,\n  ChevronRight,\n  Loader2,\n  History,\n  Filter,\n  Calendar,\n  RefreshCw,\n  Play,\n} from 'lucide-react'\nimport { getPlaybookName, formatStepName } from '@/lib/playbook-metadata'\n\ninterface Session {\n  id: string\n  name: string | null\n  playbook_type: string\n  status: string\n  current_step: string | null\n  created_at: string\n  updated_at: string\n  tags: string[] | null\n}\n\ninterface AllSessionsPanelProps {\n  projectId: string\n  playbookType?: string\n  onSessionSelect: (sessionId: string) => void\n  onClose: () => void\n  onStartNew?: () => void\n}\n\ntype StatusFilter = 'all' | 'draft' | 'running' | 'paused' | 'completed' | 'failed'\n\nconst STATUS_OPTIONS: { value: StatusFilter; label: string }[] = [\n  { value: 'all', label: 'Todos' },\n  { value: 'draft', label: 'Borrador' },\n  { value: 'running', label: 'En progreso' },\n  { value: 'paused', label: 'Pausado' },\n  { value: 'completed', label: 'Completado' },\n  { value: 'failed', label: 'Error' },\n]\n\n/**\n * Full session history panel with search, status filter, and date range filter.\n * Shows all sessions for a project, sorted by updated_at descending.\n */\nexport default function AllSessionsPanel({\n  projectId,\n  playbookType,\n  onSessionSelect,\n  onClose,\n  onStartNew,\n}: AllSessionsPanelProps) {\n  const [sessions, setSessions] = useState<Session[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n\n  // Filters\n  const [searchQuery, setSearchQuery] = useState('')\n  const [statusFilter, setStatusFilter] = useState<StatusFilter>('all')\n  const [dateFrom, setDateFrom] = useState('')\n  const [dateTo, setDateTo] = useState('')\n  const [showFilters, setShowFilters] = useState(false)\n\n  const loadSessions = useCallback(async () => {\n    try {\n      setLoading(true)\n      setError(null)\n\n      const params = new URLSearchParams({ project_id: projectId })\n\n      if (playbookType) {\n        params.append('playbook_type', playbookType)\n      }\n      if (searchQuery.trim()) {\n        params.append('search', searchQuery.trim())\n      }\n      if (statusFilter !== 'all') {\n        params.append('status', statusFilter)\n      }\n      if (dateFrom) {\n        params.append('date_from', dateFrom)\n      }\n      if (dateTo) {\n        params.append('date_to', dateTo)\n      }\n\n      const response = await fetch(`/api/playbook/sessions?${params.toString()}`)\n\n      if (!response.ok) {\n        throw new Error('Error al cargar las sesiones')\n      }\n\n      const data = await response.json()\n      setSessions(data.sessions || [])\n    } catch (err) {\n      console.error('Error loading sessions:', err)\n      setError(err instanceof Error ? err.message : 'Error desconocido')\n    } finally {\n      setLoading(false)\n    }\n  }, [projectId, playbookType, searchQuery, statusFilter, dateFrom, dateTo])\n\n  useEffect(() => {\n    loadSessions()\n  }, [loadSessions])\n\n  const formatDate = (dateStr: string) => {\n    return new Date(dateStr).toLocaleDateString('es-ES', {\n      day: 'numeric',\n      month: 'short',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    })\n  }\n\n  const getStatusBadge = (status: string) => {\n    const statusConfig: Record<string, { bg: string; text: string; label: string }> = {\n      draft: { bg: 'bg-gray-100', text: 'text-gray-600', label: 'Borrador' },\n      running: { bg: 'bg-blue-100', text: 'text-blue-700', label: 'En progreso' },\n      paused: { bg: 'bg-yellow-100', text: 'text-yellow-700', label: 'Pausado' },\n      completed: { bg: 'bg-green-100', text: 'text-green-700', label: 'Completado' },\n      failed: { bg: 'bg-red-100', text: 'text-red-700', label: 'Error' },\n      active: { bg: 'bg-blue-100', text: 'text-blue-700', label: 'Activo' },\n    }\n    const config = statusConfig[status] || statusConfig.draft\n    return (\n      <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${config.bg} ${config.text}`}>\n        {config.label}\n      </span>\n    )\n  }\n\n  const clearFilters = () => {\n    setSearchQuery('')\n    setStatusFilter('all')\n    setDateFrom('')\n    setDateTo('')\n  }\n\n  const hasActiveFilters = searchQuery || statusFilter !== 'all' || dateFrom || dateTo\n\n  return (\n    <div className=\"fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4\">\n      <div className=\"bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-hidden flex flex-col\">\n        {/* Header */}\n        <div className=\"px-6 py-5 border-b border-gray-100 bg-gradient-to-r from-blue-50 to-indigo-50\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-3\">\n              <div className=\"p-2.5 bg-blue-100 rounded-xl\">\n                <History size={20} className=\"text-blue-600\" />\n              </div>\n              <div>\n                <h2 className=\"text-lg font-semibold text-gray-900\">Historial de sesiones</h2>\n                <p className=\"text-sm text-gray-600\">\n                  {playbookType ? getPlaybookName(playbookType) : 'Todas las sesiones'}\n                </p>\n              </div>\n            </div>\n            <button\n              onClick={onClose}\n              className=\"p-2 text-gray-400 hover:text-gray-600 hover:bg-white/50 rounded-lg transition-colors\"\n            >\n              <X size={20} />\n            </button>\n          </div>\n        </div>\n\n        {/* Search and Filters */}\n        <div className=\"px-6 py-4 border-b border-gray-100 space-y-3\">\n          {/* Search Bar */}\n          <div className=\"flex gap-2\">\n            <div className=\"flex-1 relative\">\n              <Search\n                size={16}\n                className=\"absolute left-3 top-1/2 -translate-y-1/2 text-gray-400\"\n              />\n              <input\n                type=\"text\"\n                value={searchQuery}\n                onChange={(e) => setSearchQuery(e.target.value)}\n                placeholder=\"Buscar por nombre...\"\n                className=\"w-full pl-9 pr-4 py-2 border border-gray-300 rounded-xl text-sm text-gray-900 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n              />\n            </div>\n            <button\n              onClick={() => setShowFilters(!showFilters)}\n              className={`px-3 py-2 border rounded-xl flex items-center gap-2 text-sm font-medium transition-colors ${\n                showFilters || hasActiveFilters\n                  ? 'border-blue-300 bg-blue-50 text-blue-700'\n                  : 'border-gray-300 text-gray-700 hover:bg-gray-50'\n              }`}\n            >\n              <Filter size={16} />\n              Filtros\n              {hasActiveFilters && (\n                <span className=\"w-2 h-2 rounded-full bg-blue-500\" />\n              )}\n            </button>\n            <button\n              onClick={loadSessions}\n              className=\"px-3 py-2 border border-gray-300 rounded-xl text-gray-600 hover:bg-gray-50 transition-colors\"\n              title=\"Actualizar\"\n            >\n              <RefreshCw size={16} />\n            </button>\n          </div>\n\n          {/* Expanded Filters */}\n          {showFilters && (\n            <div className=\"flex flex-wrap gap-3 pt-2\">\n              {/* Status Filter */}\n              <div className=\"flex items-center gap-2\">\n                <label className=\"text-xs text-gray-500 font-medium\">Estado:</label>\n                <select\n                  value={statusFilter}\n                  onChange={(e) => setStatusFilter(e.target.value as StatusFilter)}\n                  className=\"px-3 py-1.5 border border-gray-300 rounded-lg text-sm text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                >\n                  {STATUS_OPTIONS.map((option) => (\n                    <option key={option.value} value={option.value}>\n                      {option.label}\n                    </option>\n                  ))}\n                </select>\n              </div>\n\n              {/* Date Range */}\n              <div className=\"flex items-center gap-2\">\n                <Calendar size={14} className=\"text-gray-400\" />\n                <label className=\"text-xs text-gray-500 font-medium\">Desde:</label>\n                <input\n                  type=\"date\"\n                  value={dateFrom}\n                  onChange={(e) => setDateFrom(e.target.value)}\n                  className=\"px-2 py-1.5 border border-gray-300 rounded-lg text-sm text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                />\n              </div>\n\n              <div className=\"flex items-center gap-2\">\n                <label className=\"text-xs text-gray-500 font-medium\">Hasta:</label>\n                <input\n                  type=\"date\"\n                  value={dateTo}\n                  onChange={(e) => setDateTo(e.target.value)}\n                  className=\"px-2 py-1.5 border border-gray-300 rounded-lg text-sm text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                />\n              </div>\n\n              {hasActiveFilters && (\n                <button\n                  onClick={clearFilters}\n                  className=\"px-3 py-1.5 text-xs text-red-600 hover:text-red-700 font-medium\"\n                >\n                  Limpiar filtros\n                </button>\n              )}\n            </div>\n          )}\n        </div>\n\n        {/* Session List */}\n        <div className=\"flex-1 overflow-y-auto\">\n          {loading ? (\n            <div className=\"flex items-center justify-center py-12\">\n              <Loader2 size={24} className=\"animate-spin text-gray-400\" />\n            </div>\n          ) : error ? (\n            <div className=\"p-6 text-center\">\n              <div className=\"p-4 bg-red-50 border border-red-200 rounded-xl text-sm text-red-700\">\n                {error}\n              </div>\n            </div>\n          ) : sessions.length === 0 ? (\n            <div className=\"p-6 text-center\">\n              <div className=\"text-gray-400 mb-2\">\n                <History size={48} className=\"mx-auto opacity-50\" />\n              </div>\n              <p className=\"text-gray-500 text-sm\">\n                {hasActiveFilters\n                  ? 'No se encontraron sesiones con los filtros aplicados'\n                  : 'No hay sesiones registradas'}\n              </p>\n              {hasActiveFilters && (\n                <button\n                  onClick={clearFilters}\n                  className=\"mt-2 text-sm text-blue-600 hover:text-blue-700 font-medium\"\n                >\n                  Limpiar filtros\n                </button>\n              )}\n            </div>\n          ) : (\n            <div className=\"p-4 space-y-2\">\n              {sessions.map((session) => (\n                <button\n                  key={session.id}\n                  onClick={() => onSessionSelect(session.id)}\n                  className=\"w-full flex items-center justify-between p-4 bg-gray-50 hover:bg-gray-100 rounded-xl transition-colors text-left group\"\n                >\n                  <div className=\"flex-1 min-w-0\">\n                    <div className=\"flex items-center gap-2 flex-wrap\">\n                      <span className=\"font-medium text-gray-900 truncate\">\n                        {session.name || `Sesión ${session.id.slice(0, 8)}`}\n                      </span>\n                      {getStatusBadge(session.status)}\n                      {!playbookType && (\n                        <span className=\"text-xs text-gray-500 bg-gray-200 px-1.5 py-0.5 rounded\">\n                          {getPlaybookName(session.playbook_type)}\n                        </span>\n                      )}\n                    </div>\n                    <div className=\"flex items-center gap-2 mt-1.5 flex-wrap\">\n                      <Clock size={12} className=\"text-gray-400 flex-shrink-0\" />\n                      <span className=\"text-xs text-gray-500\">\n                        {formatDate(session.updated_at)}\n                      </span>\n                      {session.current_step && (\n                        <span className=\"text-xs text-blue-600 bg-blue-50 px-1.5 py-0.5 rounded\">\n                          {formatStepName(session.current_step)}\n                        </span>\n                      )}\n                      {session.tags && session.tags.length > 0 && (\n                        <span className=\"text-xs text-gray-400\">\n                          · {session.tags.slice(0, 3).join(', ')}\n                          {session.tags.length > 3 && ` +${session.tags.length - 3}`}\n                        </span>\n                      )}\n                    </div>\n                  </div>\n                  <div className=\"flex items-center gap-2 ml-3\">\n                    <span className=\"text-xs text-blue-600 font-medium opacity-0 group-hover:opacity-100 transition-opacity\">\n                      Continuar\n                    </span>\n                    <ChevronRight\n                      size={16}\n                      className=\"text-gray-400 group-hover:text-blue-500 transition-colors flex-shrink-0\"\n                    />\n                  </div>\n                </button>\n              ))}\n            </div>\n          )}\n        </div>\n\n        {/* Footer */}\n        <div className=\"px-6 py-4 border-t border-gray-100 bg-gray-50 flex justify-between items-center\">\n          <span className=\"text-xs text-gray-500\">\n            {sessions.length} sesión{sessions.length !== 1 ? 'es' : ''} encontrada{sessions.length !== 1 ? 's' : ''}\n          </span>\n          <div className=\"flex gap-3\">\n            <button\n              onClick={onClose}\n              className=\"px-4 py-2 border border-gray-300 text-gray-700 rounded-xl hover:bg-white font-medium text-sm transition-colors\"\n            >\n              Cerrar\n            </button>\n            {onStartNew && (\n              <button\n                onClick={onStartNew}\n                className=\"px-4 py-2 bg-gradient-to-r from-blue-600 to-indigo-600 text-white rounded-xl hover:from-blue-700 hover:to-indigo-700 font-medium text-sm transition-all inline-flex items-center gap-2\"\n              >\n                <Play size={14} />\n                Nueva sesión\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n","numLines":379,"startLine":1,"totalLines":379}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EMG3efWcmvzphVYA4YywK2","type":"tool_result","content":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/lib/auth-context.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/lib/niche-finder-context-lake.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/lib/openrouter-context.tsx","is_error":false}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"a17ab64d-7323-4495-9718-9075a18465c3","tool_use_result":{"stdout":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/lib/auth-context.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/lib/niche-finder-context-lake.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/lib/openrouter-context.tsx","stderr":"","interrupted":false,"isImage":false}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Dq7pyutyiF5UHJDSiWxH4h","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useEffect, useMemo, useRef } from 'react'\n     4→import { RefreshCw, Download, Table2, Shield, MessageSquare, Filter, X } from 'lucide-react'\n     5→import { useToast } from '@/components/ui'\n     6→\n     7→type SubTab = 'find-place' | 'prove-legit' | 'usp-uvp'\n     8→\n     9→interface FindPlaceRow {\n    10→  id: string\n    11→  ecp_name: string\n    12→  evaluation_criterion: string\n    13→  relevance: string\n    14→  justification: string\n    15→  competitor_scores: Record<string, { score: number | string }>\n    16→  analysis_opportunity: string\n    17→}\n    18→\n    19→interface ProveLegitRow {\n    20→  id: string\n    21→  ecp_name: string\n    22→  asset_name: string\n    23→  value_criteria: string\n    24→  category: string\n    25→  justification_differentiation: string\n    26→  competitive_advantage: string\n    27→  benefit_for_user: string\n    28→  proof: string\n    29→}\n    30→\n    31→interface UspUvpRow {\n    32→  id: string\n    33→  ecp_name: string\n    34→  message_category: string\n    35→  hypothesis: string\n    36→  value_criteria: string\n    37→  objective: string\n    38→  message_en: string\n    39→  message_es: string\n    40→}\n    41→\n    42→interface ColumnFilters {\n    43→  [columnKey: string]: string[]\n    44→}\n    45→\n    46→export default function ExportDataTab({ projectId }: { projectId: string }) {\n    47→  const toast = useToast()\n    48→  const [activeSubTab, setActiveSubTab] = useState<SubTab>('find-place')\n    49→  const [loading, setLoading] = useState(false)\n    50→  const [syncing, setSyncing] = useState(false)\n    51→\n    52→  const [findPlaceData, setFindPlaceData] = useState<FindPlaceRow[]>([])\n    53→  const [proveLegitData, setProveLegitData] = useState<ProveLegitRow[]>([])\n    54→  const [uspUvpData, setUspUvpData] = useState<UspUvpRow[]>([])\n    55→\n    56→  useEffect(() => {\n    57→    loadExportData()\n    58→  }, [projectId])\n    59→\n    60→  const loadExportData = async () => {\n    61→    setLoading(true)\n    62→    try {\n    63→      const response = await fetch(`/api/projects/${projectId}/export-data`)\n    64→      const data = await response.json()\n    65→      if (data.success) {\n    66→        setFindPlaceData(data.findPlace || [])\n    67→        setProveLegitData(data.proveLegit || [])\n    68→        setUspUvpData(data.uspUvp || [])\n    69→      }\n    70→    } catch (error) {\n    71→      console.error('Error loading export data:', error)\n    72→    } finally {\n    73→      setLoading(false)\n    74→    }\n    75→  }\n    76→\n    77→  const handleSync = async () => {\n    78→    setSyncing(true)\n    79→    try {\n    80→      const response = await fetch(`/api/projects/${projectId}/sync-export`, {\n    81→        method: 'POST'\n    82→      })\n    83→      const data = await response.json()\n    84→      if (data.success) {\n    85→        toast.success('Sincronizado', data.message)\n    86→        await loadExportData()\n    87→      } else {\n    88→        throw new Error(data.error)\n    89→      }\n    90→    } catch (error) {\n    91→      toast.error('Error', 'No se pudo sincronizar los datos')\n    92→    } finally {\n    93→      setSyncing(false)\n    94→    }\n    95→  }\n    96→\n    97→  const handleExportCSV = async () => {\n    98→    try {\n    99→      const response = await fetch(`/api/projects/${projectId}/export-csv`)\n   100→      if (!response.ok) throw new Error('Export failed')\n   101→\n   102→      const blob = await response.blob()\n   103→      const url = URL.createObjectURL(blob)\n   104→      const a = document.createElement('a')\n   105→      a.href = url\n   106→      a.download = 'ecp-export.zip'\n   107→      document.body.appendChild(a)\n   108→      a.click()\n   109→      document.body.removeChild(a)\n   110→      URL.revokeObjectURL(url)\n   111→\n   112→      toast.success('Exportado', 'Archivos CSV descargados')\n   113→    } catch (error) {\n   114→      toast.error('Error', 'No se pudo exportar los datos')\n   115→    }\n   116→  }\n   117→\n   118→  const subTabs = [\n   119→    { id: 'find-place' as SubTab, label: 'Find Your Place', icon: Table2, count: findPlaceData.length },\n   120→    { id: 'prove-legit' as SubTab, label: 'Prove Legit', icon: Shield, count: proveLegitData.length },\n   121→    { id: 'usp-uvp' as SubTab, label: 'USP & UVP', icon: MessageSquare, count: uspUvpData.length },\n   122→  ]\n   123→\n   124→  const totalCount = findPlaceData.length + proveLegitData.length + uspUvpData.length\n   125→\n   126→  return (\n   127→    <div className=\"space-y-6\">\n   128→      <div className=\"flex items-center justify-between\">\n   129→        <div>\n   130→          <h2 className=\"text-xl font-semibold text-gray-900\">Datos Consolidados</h2>\n   131→          <p className=\"text-sm text-gray-500 mt-1\">\n   132→            Visualiza y exporta los datos parseados de todas las campanas ({totalCount} registros)\n   133→          </p>\n   134→        </div>\n   135→        <div className=\"flex items-center gap-3\">\n   136→          <button\n   137→            onClick={handleSync}\n   138→            disabled={syncing}\n   139→            className=\"inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 transition-colors\"\n   140→          >\n   141→            <RefreshCw size={16} className={syncing ? 'animate-spin' : ''} />\n   142→            {syncing ? 'Sincronizando...' : 'Sincronizar'}\n   143→          </button>\n   144→          <button\n   145→            onClick={handleExportCSV}\n   146→            disabled={totalCount === 0}\n   147→            className=\"inline-flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 transition-colors\"\n   148→          >\n   149→            <Download size={16} />\n   150→            Exportar CSV\n   151→          </button>\n   152→        </div>\n   153→      </div>\n   154→\n   155→      <div className=\"border-b border-gray-200\">\n   156→        <nav className=\"flex gap-4\">\n   157→          {subTabs.map((tab) => {\n   158→            const Icon = tab.icon\n   159→            const isActive = activeSubTab === tab.id\n   160→            return (\n   161→              <button\n   162→                key={tab.id}\n   163→                onClick={() => setActiveSubTab(tab.id)}\n   164→                className={`\n   165→                  flex items-center gap-2 px-4 py-3 border-b-2 font-medium text-sm transition-colors\n   166→                  ${isActive\n   167→                    ? 'border-blue-600 text-blue-600'\n   168→                    : 'border-transparent text-gray-500 hover:text-gray-700'}\n   169→                `}\n   170→              >\n   171→                <Icon size={16} />\n   172→                {tab.label}\n   173→                <span className={`\n   174→                  px-2 py-0.5 rounded-full text-xs\n   175→                  ${isActive ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-600'}\n   176→                `}>\n   177→                  {tab.count}\n   178→                </span>\n   179→              </button>\n   180→            )\n   181→          })}\n   182→        </nav>\n   183→      </div>\n   184→\n   185→      {loading ? (\n   186→        <div className=\"flex items-center justify-center py-12\">\n   187→          <RefreshCw className=\"w-8 h-8 animate-spin text-gray-400\" />\n   188→        </div>\n   189→      ) : (\n   190→        <>\n   191→          {activeSubTab === 'find-place' && <FindPlaceTable data={findPlaceData} />}\n   192→          {activeSubTab === 'prove-legit' && <ProveLegitTable data={proveLegitData} />}\n   193→          {activeSubTab === 'usp-uvp' && <UspUvpTable data={uspUvpData} />}\n   194→        </>\n   195→      )}\n   196→    </div>\n   197→  )\n   198→}\n   199→\n   200→// Hook para manejar resize de columnas con drag\n   201→function useColumnResize(initialWidth: number) {\n   202→  const [width, setWidth] = useState(initialWidth)\n   203→  const isResizing = useRef(false)\n   204→  const startX = useRef(0)\n   205→  const startWidth = useRef(0)\n   206→\n   207→  const handleMouseDown = (e: React.MouseEvent) => {\n   208→    e.preventDefault()\n   209→    e.stopPropagation()\n   210→    isResizing.current = true\n   211→    startX.current = e.clientX\n   212→    startWidth.current = width\n   213→\n   214→    const handleMouseMove = (e: MouseEvent) => {\n   215→      if (!isResizing.current) return\n   216→      const delta = e.clientX - startX.current\n   217→      const newWidth = Math.max(60, Math.min(800, startWidth.current + delta))\n   218→      setWidth(newWidth)\n   219→    }\n   220→\n   221→    const handleMouseUp = () => {\n   222→      isResizing.current = false\n   223→      document.removeEventListener('mousemove', handleMouseMove)\n   224→      document.removeEventListener('mouseup', handleMouseUp)\n   225→      document.body.style.cursor = ''\n   226→      document.body.style.userSelect = ''\n   227→    }\n   228→\n   229→    document.addEventListener('mousemove', handleMouseMove)\n   230→    document.addEventListener('mouseup', handleMouseUp)\n   231→    document.body.style.cursor = 'col-resize'\n   232→    document.body.style.userSelect = 'none'\n   233→  }\n   234→\n   235→  return { width, handleMouseDown }\n   236→}\n   237→\n   238→// Componente de filtro dropdown\n   239→function FilterDropdown({\n   240→  values,\n   241→  selected,\n   242→  onChange,\n   243→  label\n   244→}: {\n   245→  values: string[]\n   246→  selected: string[]\n   247→  onChange: (selected: string[]) => void\n   248→  label: string\n   249→}) {\n   250→  const [open, setOpen] = useState(false)\n   251→  const dropdownRef = useRef<HTMLDivElement>(null)\n   252→\n   253→  useEffect(() => {\n   254→    function handleClickOutside(event: MouseEvent) {\n   255→      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {\n   256→        setOpen(false)\n   257→      }\n   258→    }\n   259→    document.addEventListener('mousedown', handleClickOutside)\n   260→    return () => document.removeEventListener('mousedown', handleClickOutside)\n   261→  }, [])\n   262→\n   263→  if (values.length === 0) return null\n   264→\n   265→  return (\n   266→    <div className=\"relative inline-block\" ref={dropdownRef}>\n   267→      <button\n   268→        onClick={() => setOpen(!open)}\n   269→        className={`p-1 rounded hover:bg-gray-200 transition-colors ${selected.length > 0 ? 'text-blue-600' : 'text-gray-400'}`}\n   270→        title={`Filtrar por ${label}`}\n   271→      >\n   272→        <Filter size={12} />\n   273→      </button>\n   274→      {open && (\n   275→        <div className=\"absolute left-0 z-20 mt-1 bg-white border border-gray-200 rounded-lg shadow-lg p-2 min-w-[180px] max-w-[250px]\">\n   276→          <div className=\"max-h-[200px] overflow-y-auto\">\n   277→            {values.map(value => (\n   278→              <label key={value} className=\"flex items-center gap-2 py-1 px-2 hover:bg-gray-50 rounded cursor-pointer\">\n   279→                <input\n   280→                  type=\"checkbox\"\n   281→                  checked={selected.includes(value)}\n   282→                  onChange={(e) => {\n   283→                    if (e.target.checked) {\n   284→                      onChange([...selected, value])\n   285→                    } else {\n   286→                      onChange(selected.filter(v => v !== value))\n   287→                    }\n   288→                  }}\n   289→                  className=\"rounded border-gray-300 text-blue-600 focus:ring-blue-500\"\n   290→                />\n   291→                <span className=\"text-xs text-gray-700 truncate\">{value}</span>\n   292→              </label>\n   293→            ))}\n   294→          </div>\n   295→          {selected.length > 0 && (\n   296→            <button\n   297→              className=\"w-full mt-2 px-2 py-1 text-xs text-blue-600 hover:bg-blue-50 rounded flex items-center justify-center gap-1\"\n   298→              onClick={() => onChange([])}\n   299→            >\n   300→              <X size={12} />\n   301→              Limpiar filtro\n   302→            </button>\n   303→          )}\n   304→        </div>\n   305→      )}\n   306→    </div>\n   307→  )\n   308→}\n   309→\n   310→function getUniqueValues<T>(data: T[], columnKey: keyof T): string[] {\n   311→  const values = new Set<string>()\n   312→  data.forEach(row => {\n   313→    const value = row[columnKey]\n   314→    if (value !== null && value !== undefined && value !== '') {\n   315→      values.add(String(value))\n   316→    }\n   317→  })\n   318→  return Array.from(values).sort()\n   319→}\n   320→\n   321→// Header redimensionable con drag handle\n   322→function ResizableTh({\n   323→  children,\n   324→  initialWidth = 150,\n   325→  filterValues,\n   326→  filterSelected,\n   327→  onFilterChange,\n   328→  label,\n   329→  className = ''\n   330→}: {\n   331→  children: React.ReactNode\n   332→  initialWidth?: number\n   333→  filterValues?: string[]\n   334→  filterSelected?: string[]\n   335→  onFilterChange?: (selected: string[]) => void\n   336→  label?: string\n   337→  className?: string\n   338→}) {\n   339→  const { width, handleMouseDown } = useColumnResize(initialWidth)\n   340→\n   341→  return (\n   342→    <th\n   343→      className={`relative px-3 py-2 text-left font-semibold text-gray-700 bg-gray-50 ${className}`}\n   344→      style={{ width: `${width}px`, minWidth: `${width}px`, maxWidth: `${width}px` }}\n   345→    >\n   346→      <div className=\"flex items-center gap-1 pr-2\">\n   347→        <span className=\"truncate\">{children}</span>\n   348→        {filterValues && onFilterChange && label && (\n   349→          <FilterDropdown\n   350→            values={filterValues}\n   351→            selected={filterSelected || []}\n   352→            onChange={onFilterChange}\n   353→            label={label}\n   354→          />\n   355→        )}\n   356→      </div>\n   357→      {/* Drag handle - borde derecho */}\n   358→      <div\n   359→        onMouseDown={handleMouseDown}\n   360→        className=\"absolute right-0 top-0 bottom-0 w-2 cursor-col-resize hover:bg-blue-400 active:bg-blue-500 transition-colors\"\n   361→        style={{ borderRight: '2px solid transparent' }}\n   362→        title=\"Arrastrar para redimensionar\"\n   363→      />\n   364→    </th>\n   365→  )\n   366→}\n   367→\n   368→// Tabla Find Your Place\n   369→function FindPlaceTable({ data }: { data: FindPlaceRow[] }) {\n   370→  const [filters, setFilters] = useState<ColumnFilters>({})\n   371→\n   372→  if (data.length === 0) {\n   373→    return <EmptyState message=\"No hay datos. Haz click en 'Sincronizar' para parsear las campanas.\" />\n   374→  }\n   375→\n   376→  const allCompetitors = new Set<string>()\n   377→  data.forEach(row => {\n   378→    if (row.competitor_scores) {\n   379→      Object.keys(row.competitor_scores).forEach(comp => allCompetitors.add(comp))\n   380→    }\n   381→  })\n   382→  const competitors = Array.from(allCompetitors).sort()\n   383→\n   384→  const filteredData = useMemo(() => {\n   385→    return data.filter(row => {\n   386→      return Object.entries(filters).every(([key, selectedValues]) => {\n   387→        if (selectedValues.length === 0) return true\n   388→        const value = String(row[key as keyof FindPlaceRow] || '')\n   389→        return selectedValues.includes(value)\n   390→      })\n   391→    })\n   392→  }, [data, filters])\n   393→\n   394→  const updateFilter = (key: string, values: string[]) => {\n   395→    setFilters(prev => ({ ...prev, [key]: values }))\n   396→  }\n   397→\n   398→  const activeFiltersCount = Object.values(filters).filter(v => v.length > 0).length\n   399→\n   400→  return (\n   401→    <div className=\"space-y-2\">\n   402→      {activeFiltersCount > 0 && (\n   403→        <div className=\"flex items-center gap-2 text-sm text-gray-600\">\n   404→          <span>{filteredData.length} de {data.length} registros</span>\n   405→          <button\n   406→            onClick={() => setFilters({})}\n   407→            className=\"text-blue-600 hover:text-blue-800 flex items-center gap-1\"\n   408→          >\n   409→            <X size={14} />\n   410→            Limpiar filtros\n   411→          </button>\n   412→        </div>\n   413→      )}\n   414→      <div className=\"overflow-x-auto rounded-lg border border-gray-200\">\n   415→        <div className=\"max-h-[600px] overflow-y-auto\">\n   416→          <table className=\"min-w-full divide-y divide-gray-200 text-xs\" style={{ tableLayout: 'fixed' }}>\n   417→            <thead className=\"bg-gray-50 sticky top-0 z-10\">\n   418→              <tr>\n   419→                <ResizableTh\n   420→                  initialWidth={180}\n   421→                  filterValues={getUniqueValues(data, 'ecp_name')}\n   422→                  filterSelected={filters['ecp_name']}\n   423→                  onFilterChange={(v) => updateFilter('ecp_name', v)}\n   424→                  label=\"ECP\"\n   425→                >\n   426→                  ECP\n   427→                </ResizableTh>\n   428→                <ResizableTh\n   429→                  initialWidth={200}\n   430→                  filterValues={getUniqueValues(data, 'evaluation_criterion')}\n   431→                  filterSelected={filters['evaluation_criterion']}\n   432→                  onFilterChange={(v) => updateFilter('evaluation_criterion', v)}\n   433→                  label=\"Criterion\"\n   434→                >\n   435→                  Evaluation Criterion\n   436→                </ResizableTh>\n   437→                <ResizableTh\n   438→                  initialWidth={100}\n   439→                  filterValues={getUniqueValues(data, 'relevance')}\n   440→                  filterSelected={filters['relevance']}\n   441→                  onFilterChange={(v) => updateFilter('relevance', v)}\n   442→                  label=\"Relevance\"\n   443→                >\n   444→                  Relevance\n   445→                </ResizableTh>\n   446→                <ResizableTh initialWidth={300}>Justification</ResizableTh>\n   447→                {competitors.map(comp => (\n   448→                  <th key={comp} className=\"px-2 py-2 text-center font-semibold text-gray-700 whitespace-nowrap bg-gray-50\" style={{ minWidth: '70px' }}>\n   449→                    {comp}\n   450→                  </th>\n   451→                ))}\n   452→                <ResizableTh initialWidth={300}>Analysis & Opportunity</ResizableTh>\n   453→              </tr>\n   454→            </thead>\n   455→            <tbody className=\"bg-white divide-y divide-gray-200\">\n   456→              {filteredData.map((row, idx) => (\n   457→                <tr key={row.id} className={idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>\n   458→                  <td className=\"px-3 py-2 text-gray-900\">{row.ecp_name}</td>\n   459→                  <td className=\"px-3 py-2 text-gray-700\">{row.evaluation_criterion}</td>\n   460→                  <td className=\"px-3 py-2\"><RelevanceBadge value={row.relevance} /></td>\n   461→                  <td className=\"px-3 py-2 text-gray-600\">{row.justification || '-'}</td>\n   462→                  {competitors.map(comp => {\n   463→                    const score = row.competitor_scores?.[comp]?.score\n   464→                    return (\n   465→                      <td key={comp} className=\"px-2 py-2 text-center\">\n   466→                        {score !== undefined ? (\n   467→                          <span className={`inline-flex items-center justify-center w-6 h-6 rounded-full text-xs font-medium ${getScoreColor(score)}`}>\n   468→                            {score}\n   469→                          </span>\n   470→                        ) : (\n   471→                          <span className=\"text-gray-300\">-</span>\n   472→                        )}\n   473→                      </td>\n   474→                    )\n   475→                  })}\n   476→                  <td className=\"px-3 py-2 text-gray-600\">{row.analysis_opportunity || '-'}</td>\n   477→                </tr>\n   478→              ))}\n   479→            </tbody>\n   480→          </table>\n   481→        </div>\n   482→      </div>\n   483→    </div>\n   484→  )\n   485→}\n   486→\n   487→// Tabla Prove Legit\n   488→function ProveLegitTable({ data }: { data: ProveLegitRow[] }) {\n   489→  const [filters, setFilters] = useState<ColumnFilters>({})\n   490→\n   491→  if (data.length === 0) {\n   492→    return <EmptyState message=\"No hay datos. Haz click en 'Sincronizar' para parsear las campanas.\" />\n   493→  }\n   494→\n   495→  const filteredData = useMemo(() => {\n   496→    return data.filter(row => {\n   497→      return Object.entries(filters).every(([key, selectedValues]) => {\n   498→        if (selectedValues.length === 0) return true\n   499→        const value = String(row[key as keyof ProveLegitRow] || '')\n   500→        return selectedValues.includes(value)\n   501→      })\n   502→    })\n   503→  }, [data, filters])\n   504→\n   505→  const updateFilter = (key: string, values: string[]) => {\n   506→    setFilters(prev => ({ ...prev, [key]: values }))\n   507→  }\n   508→\n   509→  const activeFiltersCount = Object.values(filters).filter(v => v.length > 0).length\n   510→\n   511→  return (\n   512→    <div className=\"space-y-2\">\n   513→      {activeFiltersCount > 0 && (\n   514→        <div className=\"flex items-center gap-2 text-sm text-gray-600\">\n   515→          <span>{filteredData.length} de {data.length} registros</span>\n   516→          <button\n   517→            onClick={() => setFilters({})}\n   518→            className=\"text-blue-600 hover:text-blue-800 flex items-center gap-1\"\n   519→          >\n   520→            <X size={14} />\n   521→            Limpiar filtros\n   522→          </button>\n   523→        </div>\n   524→      )}\n   525→      <div className=\"overflow-x-auto rounded-lg border border-gray-200\">\n   526→        <div className=\"max-h-[600px] overflow-y-auto\">\n   527→          <table className=\"min-w-full divide-y divide-gray-200 text-xs\" style={{ tableLayout: 'fixed' }}>\n   528→            <thead className=\"bg-gray-50 sticky top-0 z-10\">\n   529→              <tr>\n   530→                <ResizableTh\n   531→                  initialWidth={180}\n   532→                  filterValues={getUniqueValues(data, 'ecp_name')}\n   533→                  filterSelected={filters['ecp_name']}\n   534→                  onFilterChange={(v) => updateFilter('ecp_name', v)}\n   535→                  label=\"ECP\"\n   536→                >\n   537→                  ECP\n   538→                </ResizableTh>\n   539→                <ResizableTh\n   540→                  initialWidth={180}\n   541→                  filterValues={getUniqueValues(data, 'asset_name')}\n   542→                  filterSelected={filters['asset_name']}\n   543→                  onFilterChange={(v) => updateFilter('asset_name', v)}\n   544→                  label=\"Asset\"\n   545→                >\n   546→                  Asset\n   547→                </ResizableTh>\n   548→                <ResizableTh initialWidth={180}>Value Criteria</ResizableTh>\n   549→                <ResizableTh\n   550→                  initialWidth={120}\n   551→                  filterValues={getUniqueValues(data, 'category')}\n   552→                  filterSelected={filters['category']}\n   553→                  onFilterChange={(v) => updateFilter('category', v)}\n   554→                  label=\"Category\"\n   555→                >\n   556→                  Category\n   557→                </ResizableTh>\n   558→                <ResizableTh initialWidth={280}>Justification</ResizableTh>\n   559→                <ResizableTh initialWidth={280}>Competitive Advantage</ResizableTh>\n   560→                <ResizableTh initialWidth={280}>Benefit for User</ResizableTh>\n   561→                <ResizableTh initialWidth={280}>Proof</ResizableTh>\n   562→              </tr>\n   563→            </thead>\n   564→            <tbody className=\"bg-white divide-y divide-gray-200\">\n   565→              {filteredData.map((row, idx) => (\n   566→                <tr key={row.id} className={idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>\n   567→                  <td className=\"px-3 py-2 text-gray-900\">{row.ecp_name}</td>\n   568→                  <td className=\"px-3 py-2 text-gray-700\">{row.asset_name}</td>\n   569→                  <td className=\"px-3 py-2 text-gray-600\">{row.value_criteria || '-'}</td>\n   570→                  <td className=\"px-3 py-2\"><CategoryBadge value={row.category} /></td>\n   571→                  <td className=\"px-3 py-2 text-gray-600\">{row.justification_differentiation || '-'}</td>\n   572→                  <td className=\"px-3 py-2 text-gray-600\">{row.competitive_advantage || '-'}</td>\n   573→                  <td className=\"px-3 py-2 text-gray-600\">{row.benefit_for_user || '-'}</td>\n   574→                  <td className=\"px-3 py-2 text-gray-600\">{row.proof || '-'}</td>\n   575→                </tr>\n   576→              ))}\n   577→            </tbody>\n   578→          </table>\n   579→        </div>\n   580→      </div>\n   581→    </div>\n   582→  )\n   583→}\n   584→\n   585→// Tabla USP & UVP\n   586→function UspUvpTable({ data }: { data: UspUvpRow[] }) {\n   587→  const [filters, setFilters] = useState<ColumnFilters>({})\n   588→\n   589→  if (data.length === 0) {\n   590→    return <EmptyState message=\"No hay datos. Haz click en 'Sincronizar' para parsear las campanas.\" />\n   591→  }\n   592→\n   593→  const filteredData = useMemo(() => {\n   594→    return data.filter(row => {\n   595→      return Object.entries(filters).every(([key, selectedValues]) => {\n   596→        if (selectedValues.length === 0) return true\n   597→        const value = String(row[key as keyof UspUvpRow] || '')\n   598→        return selectedValues.includes(value)\n   599→      })\n   600→    })\n   601→  }, [data, filters])\n   602→\n   603→  const updateFilter = (key: string, values: string[]) => {\n   604→    setFilters(prev => ({ ...prev, [key]: values }))\n   605→  }\n   606→\n   607→  const activeFiltersCount = Object.values(filters).filter(v => v.length > 0).length\n   608→\n   609→  return (\n   610→    <div className=\"space-y-2\">\n   611→      {activeFiltersCount > 0 && (\n   612→        <div className=\"flex items-center gap-2 text-sm text-gray-600\">\n   613→          <span>{filteredData.length} de {data.length} registros</span>\n   614→          <button\n   615→            onClick={() => setFilters({})}\n   616→            className=\"text-blue-600 hover:text-blue-800 flex items-center gap-1\"\n   617→          >\n   618→            <X size={14} />\n   619→            Limpiar filtros\n   620→          </button>\n   621→        </div>\n   622→      )}\n   623→      <div className=\"overflow-x-auto rounded-lg border border-gray-200\">\n   624→        <div className=\"max-h-[600px] overflow-y-auto\">\n   625→          <table className=\"min-w-full divide-y divide-gray-200 text-xs\" style={{ tableLayout: 'fixed' }}>\n   626→            <thead className=\"bg-gray-50 sticky top-0 z-10\">\n   627→              <tr>\n   628→                <ResizableTh\n   629→                  initialWidth={180}\n   630→                  filterValues={getUniqueValues(data, 'ecp_name')}\n   631→                  filterSelected={filters['ecp_name']}\n   632→                  onFilterChange={(v) => updateFilter('ecp_name', v)}\n   633→                  label=\"ECP\"\n   634→                >\n   635→                  ECP\n   636→                </ResizableTh>\n   637→                <ResizableTh\n   638→                  initialWidth={160}\n   639→                  filterValues={getUniqueValues(data, 'message_category')}\n   640→                  filterSelected={filters['message_category']}\n   641→                  onFilterChange={(v) => updateFilter('message_category', v)}\n   642→                  label=\"Category\"\n   643→                >\n   644→                  Message Category\n   645→                </ResizableTh>\n   646→                <ResizableTh initialWidth={280}>Hypothesis</ResizableTh>\n   647→                <ResizableTh initialWidth={180}>Value Criteria</ResizableTh>\n   648→                <ResizableTh initialWidth={180}>Objective</ResizableTh>\n   649→                <ResizableTh initialWidth={320}>Message (EN)</ResizableTh>\n   650→                <ResizableTh initialWidth={320}>Message (ES)</ResizableTh>\n   651→              </tr>\n   652→            </thead>\n   653→            <tbody className=\"bg-white divide-y divide-gray-200\">\n   654→              {filteredData.map((row, idx) => (\n   655→                <tr key={row.id} className={idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>\n   656→                  <td className=\"px-3 py-2 text-gray-900\">{row.ecp_name}</td>\n   657→                  <td className=\"px-3 py-2 text-gray-700\">{row.message_category}</td>\n   658→                  <td className=\"px-3 py-2 text-gray-600\">{row.hypothesis || '-'}</td>\n   659→                  <td className=\"px-3 py-2 text-gray-600\">{row.value_criteria || '-'}</td>\n   660→                  <td className=\"px-3 py-2 text-gray-600\">{row.objective || '-'}</td>\n   661→                  <td className=\"px-3 py-2 text-gray-600\">{row.message_en || '-'}</td>\n   662→                  <td className=\"px-3 py-2 text-gray-600\">{row.message_es || '-'}</td>\n   663→                </tr>\n   664→              ))}\n   665→            </tbody>\n   666→          </table>\n   667→        </div>\n   668→      </div>\n   669→    </div>\n   670→  )\n   671→}\n   672→\n   673→// Utilidades\n   674→function RelevanceBadge({ value }: { value: string }) {\n   675→  const colors: Record<string, string> = {\n   676→    'Critical': 'bg-red-100 text-red-700',\n   677→    'High': 'bg-orange-100 text-orange-700',\n   678→    'Medium-High': 'bg-yellow-100 text-yellow-700',\n   679→    'Medium': 'bg-yellow-100 text-yellow-700',\n   680→    'Low': 'bg-gray-100 text-gray-600',\n   681→  }\n   682→  return (\n   683→    <span className={`px-2 py-0.5 rounded text-xs font-medium whitespace-nowrap ${colors[value] || 'bg-gray-100 text-gray-600'}`}>\n   684→      {value || '-'}\n   685→    </span>\n   686→  )\n   687→}\n   688→\n   689→function CategoryBadge({ value }: { value: string }) {\n   690→  const colors: Record<string, string> = {\n   691→    'Differentiator': 'bg-purple-100 text-purple-700',\n   692→    'Qualifier': 'bg-blue-100 text-blue-700',\n   693→  }\n   694→  return (\n   695→    <span className={`px-2 py-0.5 rounded text-xs font-medium whitespace-nowrap ${colors[value] || 'bg-gray-100 text-gray-600'}`}>\n   696→      {value || '-'}\n   697→    </span>\n   698→  )\n   699→}\n   700→\n   701→function getScoreColor(score: number | string): string {\n   702→  const numScore = typeof score === 'string' ? parseInt(score, 10) : score\n   703→  if (isNaN(numScore)) return 'bg-gray-100 text-gray-600'\n   704→  if (numScore >= 4) return 'bg-green-100 text-green-700'\n   705→  if (numScore >= 3) return 'bg-yellow-100 text-yellow-700'\n   706→  if (numScore >= 2) return 'bg-orange-100 text-orange-700'\n   707→  return 'bg-red-100 text-red-700'\n   708→}\n   709→\n   710→function EmptyState({ message }: { message: string }) {\n   711→  return (\n   712→    <div className=\"text-center py-12 bg-gray-50 rounded-xl border border-gray-200\">\n   713→      <Table2 className=\"w-12 h-12 mx-auto text-gray-300 mb-4\" />\n   714→      <p className=\"text-gray-500\">{message}</p>\n   715→    </div>\n   716→  )\n   717→}\n   718→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"6d7a5112-b5b3-4cec-b165-b5d755664713","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/project/ExportDataTab.tsx","content":"'use client'\n\nimport { useState, useEffect, useMemo, useRef } from 'react'\nimport { RefreshCw, Download, Table2, Shield, MessageSquare, Filter, X } from 'lucide-react'\nimport { useToast } from '@/components/ui'\n\ntype SubTab = 'find-place' | 'prove-legit' | 'usp-uvp'\n\ninterface FindPlaceRow {\n  id: string\n  ecp_name: string\n  evaluation_criterion: string\n  relevance: string\n  justification: string\n  competitor_scores: Record<string, { score: number | string }>\n  analysis_opportunity: string\n}\n\ninterface ProveLegitRow {\n  id: string\n  ecp_name: string\n  asset_name: string\n  value_criteria: string\n  category: string\n  justification_differentiation: string\n  competitive_advantage: string\n  benefit_for_user: string\n  proof: string\n}\n\ninterface UspUvpRow {\n  id: string\n  ecp_name: string\n  message_category: string\n  hypothesis: string\n  value_criteria: string\n  objective: string\n  message_en: string\n  message_es: string\n}\n\ninterface ColumnFilters {\n  [columnKey: string]: string[]\n}\n\nexport default function ExportDataTab({ projectId }: { projectId: string }) {\n  const toast = useToast()\n  const [activeSubTab, setActiveSubTab] = useState<SubTab>('find-place')\n  const [loading, setLoading] = useState(false)\n  const [syncing, setSyncing] = useState(false)\n\n  const [findPlaceData, setFindPlaceData] = useState<FindPlaceRow[]>([])\n  const [proveLegitData, setProveLegitData] = useState<ProveLegitRow[]>([])\n  const [uspUvpData, setUspUvpData] = useState<UspUvpRow[]>([])\n\n  useEffect(() => {\n    loadExportData()\n  }, [projectId])\n\n  const loadExportData = async () => {\n    setLoading(true)\n    try {\n      const response = await fetch(`/api/projects/${projectId}/export-data`)\n      const data = await response.json()\n      if (data.success) {\n        setFindPlaceData(data.findPlace || [])\n        setProveLegitData(data.proveLegit || [])\n        setUspUvpData(data.uspUvp || [])\n      }\n    } catch (error) {\n      console.error('Error loading export data:', error)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  const handleSync = async () => {\n    setSyncing(true)\n    try {\n      const response = await fetch(`/api/projects/${projectId}/sync-export`, {\n        method: 'POST'\n      })\n      const data = await response.json()\n      if (data.success) {\n        toast.success('Sincronizado', data.message)\n        await loadExportData()\n      } else {\n        throw new Error(data.error)\n      }\n    } catch (error) {\n      toast.error('Error', 'No se pudo sincronizar los datos')\n    } finally {\n      setSyncing(false)\n    }\n  }\n\n  const handleExportCSV = async () => {\n    try {\n      const response = await fetch(`/api/projects/${projectId}/export-csv`)\n      if (!response.ok) throw new Error('Export failed')\n\n      const blob = await response.blob()\n      const url = URL.createObjectURL(blob)\n      const a = document.createElement('a')\n      a.href = url\n      a.download = 'ecp-export.zip'\n      document.body.appendChild(a)\n      a.click()\n      document.body.removeChild(a)\n      URL.revokeObjectURL(url)\n\n      toast.success('Exportado', 'Archivos CSV descargados')\n    } catch (error) {\n      toast.error('Error', 'No se pudo exportar los datos')\n    }\n  }\n\n  const subTabs = [\n    { id: 'find-place' as SubTab, label: 'Find Your Place', icon: Table2, count: findPlaceData.length },\n    { id: 'prove-legit' as SubTab, label: 'Prove Legit', icon: Shield, count: proveLegitData.length },\n    { id: 'usp-uvp' as SubTab, label: 'USP & UVP', icon: MessageSquare, count: uspUvpData.length },\n  ]\n\n  const totalCount = findPlaceData.length + proveLegitData.length + uspUvpData.length\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h2 className=\"text-xl font-semibold text-gray-900\">Datos Consolidados</h2>\n          <p className=\"text-sm text-gray-500 mt-1\">\n            Visualiza y exporta los datos parseados de todas las campanas ({totalCount} registros)\n          </p>\n        </div>\n        <div className=\"flex items-center gap-3\">\n          <button\n            onClick={handleSync}\n            disabled={syncing}\n            className=\"inline-flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 transition-colors\"\n          >\n            <RefreshCw size={16} className={syncing ? 'animate-spin' : ''} />\n            {syncing ? 'Sincronizando...' : 'Sincronizar'}\n          </button>\n          <button\n            onClick={handleExportCSV}\n            disabled={totalCount === 0}\n            className=\"inline-flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 transition-colors\"\n          >\n            <Download size={16} />\n            Exportar CSV\n          </button>\n        </div>\n      </div>\n\n      <div className=\"border-b border-gray-200\">\n        <nav className=\"flex gap-4\">\n          {subTabs.map((tab) => {\n            const Icon = tab.icon\n            const isActive = activeSubTab === tab.id\n            return (\n              <button\n                key={tab.id}\n                onClick={() => setActiveSubTab(tab.id)}\n                className={`\n                  flex items-center gap-2 px-4 py-3 border-b-2 font-medium text-sm transition-colors\n                  ${isActive\n                    ? 'border-blue-600 text-blue-600'\n                    : 'border-transparent text-gray-500 hover:text-gray-700'}\n                `}\n              >\n                <Icon size={16} />\n                {tab.label}\n                <span className={`\n                  px-2 py-0.5 rounded-full text-xs\n                  ${isActive ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-600'}\n                `}>\n                  {tab.count}\n                </span>\n              </button>\n            )\n          })}\n        </nav>\n      </div>\n\n      {loading ? (\n        <div className=\"flex items-center justify-center py-12\">\n          <RefreshCw className=\"w-8 h-8 animate-spin text-gray-400\" />\n        </div>\n      ) : (\n        <>\n          {activeSubTab === 'find-place' && <FindPlaceTable data={findPlaceData} />}\n          {activeSubTab === 'prove-legit' && <ProveLegitTable data={proveLegitData} />}\n          {activeSubTab === 'usp-uvp' && <UspUvpTable data={uspUvpData} />}\n        </>\n      )}\n    </div>\n  )\n}\n\n// Hook para manejar resize de columnas con drag\nfunction useColumnResize(initialWidth: number) {\n  const [width, setWidth] = useState(initialWidth)\n  const isResizing = useRef(false)\n  const startX = useRef(0)\n  const startWidth = useRef(0)\n\n  const handleMouseDown = (e: React.MouseEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    isResizing.current = true\n    startX.current = e.clientX\n    startWidth.current = width\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!isResizing.current) return\n      const delta = e.clientX - startX.current\n      const newWidth = Math.max(60, Math.min(800, startWidth.current + delta))\n      setWidth(newWidth)\n    }\n\n    const handleMouseUp = () => {\n      isResizing.current = false\n      document.removeEventListener('mousemove', handleMouseMove)\n      document.removeEventListener('mouseup', handleMouseUp)\n      document.body.style.cursor = ''\n      document.body.style.userSelect = ''\n    }\n\n    document.addEventListener('mousemove', handleMouseMove)\n    document.addEventListener('mouseup', handleMouseUp)\n    document.body.style.cursor = 'col-resize'\n    document.body.style.userSelect = 'none'\n  }\n\n  return { width, handleMouseDown }\n}\n\n// Componente de filtro dropdown\nfunction FilterDropdown({\n  values,\n  selected,\n  onChange,\n  label\n}: {\n  values: string[]\n  selected: string[]\n  onChange: (selected: string[]) => void\n  label: string\n}) {\n  const [open, setOpen] = useState(false)\n  const dropdownRef = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    function handleClickOutside(event: MouseEvent) {\n      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {\n        setOpen(false)\n      }\n    }\n    document.addEventListener('mousedown', handleClickOutside)\n    return () => document.removeEventListener('mousedown', handleClickOutside)\n  }, [])\n\n  if (values.length === 0) return null\n\n  return (\n    <div className=\"relative inline-block\" ref={dropdownRef}>\n      <button\n        onClick={() => setOpen(!open)}\n        className={`p-1 rounded hover:bg-gray-200 transition-colors ${selected.length > 0 ? 'text-blue-600' : 'text-gray-400'}`}\n        title={`Filtrar por ${label}`}\n      >\n        <Filter size={12} />\n      </button>\n      {open && (\n        <div className=\"absolute left-0 z-20 mt-1 bg-white border border-gray-200 rounded-lg shadow-lg p-2 min-w-[180px] max-w-[250px]\">\n          <div className=\"max-h-[200px] overflow-y-auto\">\n            {values.map(value => (\n              <label key={value} className=\"flex items-center gap-2 py-1 px-2 hover:bg-gray-50 rounded cursor-pointer\">\n                <input\n                  type=\"checkbox\"\n                  checked={selected.includes(value)}\n                  onChange={(e) => {\n                    if (e.target.checked) {\n                      onChange([...selected, value])\n                    } else {\n                      onChange(selected.filter(v => v !== value))\n                    }\n                  }}\n                  className=\"rounded border-gray-300 text-blue-600 focus:ring-blue-500\"\n                />\n                <span className=\"text-xs text-gray-700 truncate\">{value}</span>\n              </label>\n            ))}\n          </div>\n          {selected.length > 0 && (\n            <button\n              className=\"w-full mt-2 px-2 py-1 text-xs text-blue-600 hover:bg-blue-50 rounded flex items-center justify-center gap-1\"\n              onClick={() => onChange([])}\n            >\n              <X size={12} />\n              Limpiar filtro\n            </button>\n          )}\n        </div>\n      )}\n    </div>\n  )\n}\n\nfunction getUniqueValues<T>(data: T[], columnKey: keyof T): string[] {\n  const values = new Set<string>()\n  data.forEach(row => {\n    const value = row[columnKey]\n    if (value !== null && value !== undefined && value !== '') {\n      values.add(String(value))\n    }\n  })\n  return Array.from(values).sort()\n}\n\n// Header redimensionable con drag handle\nfunction ResizableTh({\n  children,\n  initialWidth = 150,\n  filterValues,\n  filterSelected,\n  onFilterChange,\n  label,\n  className = ''\n}: {\n  children: React.ReactNode\n  initialWidth?: number\n  filterValues?: string[]\n  filterSelected?: string[]\n  onFilterChange?: (selected: string[]) => void\n  label?: string\n  className?: string\n}) {\n  const { width, handleMouseDown } = useColumnResize(initialWidth)\n\n  return (\n    <th\n      className={`relative px-3 py-2 text-left font-semibold text-gray-700 bg-gray-50 ${className}`}\n      style={{ width: `${width}px`, minWidth: `${width}px`, maxWidth: `${width}px` }}\n    >\n      <div className=\"flex items-center gap-1 pr-2\">\n        <span className=\"truncate\">{children}</span>\n        {filterValues && onFilterChange && label && (\n          <FilterDropdown\n            values={filterValues}\n            selected={filterSelected || []}\n            onChange={onFilterChange}\n            label={label}\n          />\n        )}\n      </div>\n      {/* Drag handle - borde derecho */}\n      <div\n        onMouseDown={handleMouseDown}\n        className=\"absolute right-0 top-0 bottom-0 w-2 cursor-col-resize hover:bg-blue-400 active:bg-blue-500 transition-colors\"\n        style={{ borderRight: '2px solid transparent' }}\n        title=\"Arrastrar para redimensionar\"\n      />\n    </th>\n  )\n}\n\n// Tabla Find Your Place\nfunction FindPlaceTable({ data }: { data: FindPlaceRow[] }) {\n  const [filters, setFilters] = useState<ColumnFilters>({})\n\n  if (data.length === 0) {\n    return <EmptyState message=\"No hay datos. Haz click en 'Sincronizar' para parsear las campanas.\" />\n  }\n\n  const allCompetitors = new Set<string>()\n  data.forEach(row => {\n    if (row.competitor_scores) {\n      Object.keys(row.competitor_scores).forEach(comp => allCompetitors.add(comp))\n    }\n  })\n  const competitors = Array.from(allCompetitors).sort()\n\n  const filteredData = useMemo(() => {\n    return data.filter(row => {\n      return Object.entries(filters).every(([key, selectedValues]) => {\n        if (selectedValues.length === 0) return true\n        const value = String(row[key as keyof FindPlaceRow] || '')\n        return selectedValues.includes(value)\n      })\n    })\n  }, [data, filters])\n\n  const updateFilter = (key: string, values: string[]) => {\n    setFilters(prev => ({ ...prev, [key]: values }))\n  }\n\n  const activeFiltersCount = Object.values(filters).filter(v => v.length > 0).length\n\n  return (\n    <div className=\"space-y-2\">\n      {activeFiltersCount > 0 && (\n        <div className=\"flex items-center gap-2 text-sm text-gray-600\">\n          <span>{filteredData.length} de {data.length} registros</span>\n          <button\n            onClick={() => setFilters({})}\n            className=\"text-blue-600 hover:text-blue-800 flex items-center gap-1\"\n          >\n            <X size={14} />\n            Limpiar filtros\n          </button>\n        </div>\n      )}\n      <div className=\"overflow-x-auto rounded-lg border border-gray-200\">\n        <div className=\"max-h-[600px] overflow-y-auto\">\n          <table className=\"min-w-full divide-y divide-gray-200 text-xs\" style={{ tableLayout: 'fixed' }}>\n            <thead className=\"bg-gray-50 sticky top-0 z-10\">\n              <tr>\n                <ResizableTh\n                  initialWidth={180}\n                  filterValues={getUniqueValues(data, 'ecp_name')}\n                  filterSelected={filters['ecp_name']}\n                  onFilterChange={(v) => updateFilter('ecp_name', v)}\n                  label=\"ECP\"\n                >\n                  ECP\n                </ResizableTh>\n                <ResizableTh\n                  initialWidth={200}\n                  filterValues={getUniqueValues(data, 'evaluation_criterion')}\n                  filterSelected={filters['evaluation_criterion']}\n                  onFilterChange={(v) => updateFilter('evaluation_criterion', v)}\n                  label=\"Criterion\"\n                >\n                  Evaluation Criterion\n                </ResizableTh>\n                <ResizableTh\n                  initialWidth={100}\n                  filterValues={getUniqueValues(data, 'relevance')}\n                  filterSelected={filters['relevance']}\n                  onFilterChange={(v) => updateFilter('relevance', v)}\n                  label=\"Relevance\"\n                >\n                  Relevance\n                </ResizableTh>\n                <ResizableTh initialWidth={300}>Justification</ResizableTh>\n                {competitors.map(comp => (\n                  <th key={comp} className=\"px-2 py-2 text-center font-semibold text-gray-700 whitespace-nowrap bg-gray-50\" style={{ minWidth: '70px' }}>\n                    {comp}\n                  </th>\n                ))}\n                <ResizableTh initialWidth={300}>Analysis & Opportunity</ResizableTh>\n              </tr>\n            </thead>\n            <tbody className=\"bg-white divide-y divide-gray-200\">\n              {filteredData.map((row, idx) => (\n                <tr key={row.id} className={idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>\n                  <td className=\"px-3 py-2 text-gray-900\">{row.ecp_name}</td>\n                  <td className=\"px-3 py-2 text-gray-700\">{row.evaluation_criterion}</td>\n                  <td className=\"px-3 py-2\"><RelevanceBadge value={row.relevance} /></td>\n                  <td className=\"px-3 py-2 text-gray-600\">{row.justification || '-'}</td>\n                  {competitors.map(comp => {\n                    const score = row.competitor_scores?.[comp]?.score\n                    return (\n                      <td key={comp} className=\"px-2 py-2 text-center\">\n                        {score !== undefined ? (\n                          <span className={`inline-flex items-center justify-center w-6 h-6 rounded-full text-xs font-medium ${getScoreColor(score)}`}>\n                            {score}\n                          </span>\n                        ) : (\n                          <span className=\"text-gray-300\">-</span>\n                        )}\n                      </td>\n                    )\n                  })}\n                  <td className=\"px-3 py-2 text-gray-600\">{row.analysis_opportunity || '-'}</td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n  )\n}\n\n// Tabla Prove Legit\nfunction ProveLegitTable({ data }: { data: ProveLegitRow[] }) {\n  const [filters, setFilters] = useState<ColumnFilters>({})\n\n  if (data.length === 0) {\n    return <EmptyState message=\"No hay datos. Haz click en 'Sincronizar' para parsear las campanas.\" />\n  }\n\n  const filteredData = useMemo(() => {\n    return data.filter(row => {\n      return Object.entries(filters).every(([key, selectedValues]) => {\n        if (selectedValues.length === 0) return true\n        const value = String(row[key as keyof ProveLegitRow] || '')\n        return selectedValues.includes(value)\n      })\n    })\n  }, [data, filters])\n\n  const updateFilter = (key: string, values: string[]) => {\n    setFilters(prev => ({ ...prev, [key]: values }))\n  }\n\n  const activeFiltersCount = Object.values(filters).filter(v => v.length > 0).length\n\n  return (\n    <div className=\"space-y-2\">\n      {activeFiltersCount > 0 && (\n        <div className=\"flex items-center gap-2 text-sm text-gray-600\">\n          <span>{filteredData.length} de {data.length} registros</span>\n          <button\n            onClick={() => setFilters({})}\n            className=\"text-blue-600 hover:text-blue-800 flex items-center gap-1\"\n          >\n            <X size={14} />\n            Limpiar filtros\n          </button>\n        </div>\n      )}\n      <div className=\"overflow-x-auto rounded-lg border border-gray-200\">\n        <div className=\"max-h-[600px] overflow-y-auto\">\n          <table className=\"min-w-full divide-y divide-gray-200 text-xs\" style={{ tableLayout: 'fixed' }}>\n            <thead className=\"bg-gray-50 sticky top-0 z-10\">\n              <tr>\n                <ResizableTh\n                  initialWidth={180}\n                  filterValues={getUniqueValues(data, 'ecp_name')}\n                  filterSelected={filters['ecp_name']}\n                  onFilterChange={(v) => updateFilter('ecp_name', v)}\n                  label=\"ECP\"\n                >\n                  ECP\n                </ResizableTh>\n                <ResizableTh\n                  initialWidth={180}\n                  filterValues={getUniqueValues(data, 'asset_name')}\n                  filterSelected={filters['asset_name']}\n                  onFilterChange={(v) => updateFilter('asset_name', v)}\n                  label=\"Asset\"\n                >\n                  Asset\n                </ResizableTh>\n                <ResizableTh initialWidth={180}>Value Criteria</ResizableTh>\n                <ResizableTh\n                  initialWidth={120}\n                  filterValues={getUniqueValues(data, 'category')}\n                  filterSelected={filters['category']}\n                  onFilterChange={(v) => updateFilter('category', v)}\n                  label=\"Category\"\n                >\n                  Category\n                </ResizableTh>\n                <ResizableTh initialWidth={280}>Justification</ResizableTh>\n                <ResizableTh initialWidth={280}>Competitive Advantage</ResizableTh>\n                <ResizableTh initialWidth={280}>Benefit for User</ResizableTh>\n                <ResizableTh initialWidth={280}>Proof</ResizableTh>\n              </tr>\n            </thead>\n            <tbody className=\"bg-white divide-y divide-gray-200\">\n              {filteredData.map((row, idx) => (\n                <tr key={row.id} className={idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>\n                  <td className=\"px-3 py-2 text-gray-900\">{row.ecp_name}</td>\n                  <td className=\"px-3 py-2 text-gray-700\">{row.asset_name}</td>\n                  <td className=\"px-3 py-2 text-gray-600\">{row.value_criteria || '-'}</td>\n                  <td className=\"px-3 py-2\"><CategoryBadge value={row.category} /></td>\n                  <td className=\"px-3 py-2 text-gray-600\">{row.justification_differentiation || '-'}</td>\n                  <td className=\"px-3 py-2 text-gray-600\">{row.competitive_advantage || '-'}</td>\n                  <td className=\"px-3 py-2 text-gray-600\">{row.benefit_for_user || '-'}</td>\n                  <td className=\"px-3 py-2 text-gray-600\">{row.proof || '-'}</td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n  )\n}\n\n// Tabla USP & UVP\nfunction UspUvpTable({ data }: { data: UspUvpRow[] }) {\n  const [filters, setFilters] = useState<ColumnFilters>({})\n\n  if (data.length === 0) {\n    return <EmptyState message=\"No hay datos. Haz click en 'Sincronizar' para parsear las campanas.\" />\n  }\n\n  const filteredData = useMemo(() => {\n    return data.filter(row => {\n      return Object.entries(filters).every(([key, selectedValues]) => {\n        if (selectedValues.length === 0) return true\n        const value = String(row[key as keyof UspUvpRow] || '')\n        return selectedValues.includes(value)\n      })\n    })\n  }, [data, filters])\n\n  const updateFilter = (key: string, values: string[]) => {\n    setFilters(prev => ({ ...prev, [key]: values }))\n  }\n\n  const activeFiltersCount = Object.values(filters).filter(v => v.length > 0).length\n\n  return (\n    <div className=\"space-y-2\">\n      {activeFiltersCount > 0 && (\n        <div className=\"flex items-center gap-2 text-sm text-gray-600\">\n          <span>{filteredData.length} de {data.length} registros</span>\n          <button\n            onClick={() => setFilters({})}\n            className=\"text-blue-600 hover:text-blue-800 flex items-center gap-1\"\n          >\n            <X size={14} />\n            Limpiar filtros\n          </button>\n        </div>\n      )}\n      <div className=\"overflow-x-auto rounded-lg border border-gray-200\">\n        <div className=\"max-h-[600px] overflow-y-auto\">\n          <table className=\"min-w-full divide-y divide-gray-200 text-xs\" style={{ tableLayout: 'fixed' }}>\n            <thead className=\"bg-gray-50 sticky top-0 z-10\">\n              <tr>\n                <ResizableTh\n                  initialWidth={180}\n                  filterValues={getUniqueValues(data, 'ecp_name')}\n                  filterSelected={filters['ecp_name']}\n                  onFilterChange={(v) => updateFilter('ecp_name', v)}\n                  label=\"ECP\"\n                >\n                  ECP\n                </ResizableTh>\n                <ResizableTh\n                  initialWidth={160}\n                  filterValues={getUniqueValues(data, 'message_category')}\n                  filterSelected={filters['message_category']}\n                  onFilterChange={(v) => updateFilter('message_category', v)}\n                  label=\"Category\"\n                >\n                  Message Category\n                </ResizableTh>\n                <ResizableTh initialWidth={280}>Hypothesis</ResizableTh>\n                <ResizableTh initialWidth={180}>Value Criteria</ResizableTh>\n                <ResizableTh initialWidth={180}>Objective</ResizableTh>\n                <ResizableTh initialWidth={320}>Message (EN)</ResizableTh>\n                <ResizableTh initialWidth={320}>Message (ES)</ResizableTh>\n              </tr>\n            </thead>\n            <tbody className=\"bg-white divide-y divide-gray-200\">\n              {filteredData.map((row, idx) => (\n                <tr key={row.id} className={idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>\n                  <td className=\"px-3 py-2 text-gray-900\">{row.ecp_name}</td>\n                  <td className=\"px-3 py-2 text-gray-700\">{row.message_category}</td>\n                  <td className=\"px-3 py-2 text-gray-600\">{row.hypothesis || '-'}</td>\n                  <td className=\"px-3 py-2 text-gray-600\">{row.value_criteria || '-'}</td>\n                  <td className=\"px-3 py-2 text-gray-600\">{row.objective || '-'}</td>\n                  <td className=\"px-3 py-2 text-gray-600\">{row.message_en || '-'}</td>\n                  <td className=\"px-3 py-2 text-gray-600\">{row.message_es || '-'}</td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n  )\n}\n\n// Utilidades\nfunction RelevanceBadge({ value }: { value: string }) {\n  const colors: Record<string, string> = {\n    'Critical': 'bg-red-100 text-red-700',\n    'High': 'bg-orange-100 text-orange-700',\n    'Medium-High': 'bg-yellow-100 text-yellow-700',\n    'Medium': 'bg-yellow-100 text-yellow-700',\n    'Low': 'bg-gray-100 text-gray-600',\n  }\n  return (\n    <span className={`px-2 py-0.5 rounded text-xs font-medium whitespace-nowrap ${colors[value] || 'bg-gray-100 text-gray-600'}`}>\n      {value || '-'}\n    </span>\n  )\n}\n\nfunction CategoryBadge({ value }: { value: string }) {\n  const colors: Record<string, string> = {\n    'Differentiator': 'bg-purple-100 text-purple-700',\n    'Qualifier': 'bg-blue-100 text-blue-700',\n  }\n  return (\n    <span className={`px-2 py-0.5 rounded text-xs font-medium whitespace-nowrap ${colors[value] || 'bg-gray-100 text-gray-600'}`}>\n      {value || '-'}\n    </span>\n  )\n}\n\nfunction getScoreColor(score: number | string): string {\n  const numScore = typeof score === 'string' ? parseInt(score, 10) : score\n  if (isNaN(numScore)) return 'bg-gray-100 text-gray-600'\n  if (numScore >= 4) return 'bg-green-100 text-green-700'\n  if (numScore >= 3) return 'bg-yellow-100 text-yellow-700'\n  if (numScore >= 2) return 'bg-orange-100 text-orange-700'\n  return 'bg-red-100 text-red-700'\n}\n\nfunction EmptyState({ message }: { message: string }) {\n  return (\n    <div className=\"text-center py-12 bg-gray-50 rounded-xl border border-gray-200\">\n      <Table2 className=\"w-12 h-12 mx-auto text-gray-300 mb-4\" />\n      <p className=\"text-gray-500\">{message}</p>\n    </div>\n  )\n}\n","numLines":718,"startLine":1,"totalLines":718}}}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VmiiqBjmyQ4aXUiRxiAQ6u","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01B71AzMgbZaDC9Tj2ZpdWCz","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/lib/auth-context.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":130,"cache_creation_input_tokens":23622,"cache_read_input_tokens":46278,"cache_creation":{"ephemeral_5m_input_tokens":23622,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"2b958627-ce5e-49e9-bb55-5cbb1768d793"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VmiiqBjmyQ4aXUiRxiAQ6u","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HBR2JezDAbQTwntVD69skS","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepInspectionPanel.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":130,"cache_creation_input_tokens":23622,"cache_read_input_tokens":46278,"cache_creation":{"ephemeral_5m_input_tokens":23622,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"ee2e06ba-9373-4f19-bc0a-11bca3eceb9f"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01VmiiqBjmyQ4aXUiRxiAQ6u","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S22p4i8A3qc2RLy6rYqec9","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Modal/ModalContext.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":130,"cache_creation_input_tokens":23622,"cache_read_input_tokens":46278,"cache_creation":{"ephemeral_5m_input_tokens":23622,"ephemeral_1h_input_tokens":0},"output_tokens":240,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"47b7e3e4-fe12-475e-9e4d-dc6825b2d759"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B71AzMgbZaDC9Tj2ZpdWCz","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { createContext, useContext, useEffect, useState } from 'react'\n     4→import { User, Session } from '@supabase/supabase-js'\n     5→import { createClient } from '@/lib/supabase-browser'\n     6→\n     7→type AuthContextType = {\n     8→  user: User | null\n     9→  session: Session | null\n    10→  loading: boolean\n    11→  signOut: () => Promise<void>\n    12→}\n    13→\n    14→const AuthContext = createContext<AuthContextType | undefined>(undefined)\n    15→\n    16→export function AuthProvider({ children }: { children: React.ReactNode }) {\n    17→  const [user, setUser] = useState<User | null>(null)\n    18→  const [session, setSession] = useState<Session | null>(null)\n    19→  const [loading, setLoading] = useState(true)\n    20→  const supabase = createClient()\n    21→\n    22→  useEffect(() => {\n    23→    // Get initial session\n    24→    const getInitialSession = async () => {\n    25→      const { data: { session } } = await supabase.auth.getSession()\n    26→      setSession(session)\n    27→      setUser(session?.user ?? null)\n    28→      setLoading(false)\n    29→    }\n    30→\n    31→    getInitialSession()\n    32→\n    33→    // Listen for auth changes\n    34→    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n    35→      async (event, session) => {\n    36→        setSession(session)\n    37→        setUser(session?.user ?? null)\n    38→        setLoading(false)\n    39→      }\n    40→    )\n    41→\n    42→    return () => {\n    43→      subscription.unsubscribe()\n    44→    }\n    45→  }, [supabase])\n    46→\n    47→  const signOut = async () => {\n    48→    await supabase.auth.signOut()\n    49→  }\n    50→\n    51→  return (\n    52→    <AuthContext.Provider value={{ user, session, loading, signOut }}>\n    53→      {children}\n    54→    </AuthContext.Provider>\n    55→  )\n    56→}\n    57→\n    58→export function useAuth() {\n    59→  const context = useContext(AuthContext)\n    60→  if (context === undefined) {\n    61→    throw new Error('useAuth must be used within an AuthProvider')\n    62→  }\n    63→  return context\n    64→}\n    65→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"aecf6b64-3d3c-4f2f-9b19-ddf50c1e39f8","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/lib/auth-context.tsx","content":"'use client'\n\nimport { createContext, useContext, useEffect, useState } from 'react'\nimport { User, Session } from '@supabase/supabase-js'\nimport { createClient } from '@/lib/supabase-browser'\n\ntype AuthContextType = {\n  user: User | null\n  session: Session | null\n  loading: boolean\n  signOut: () => Promise<void>\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\n  const [user, setUser] = useState<User | null>(null)\n  const [session, setSession] = useState<Session | null>(null)\n  const [loading, setLoading] = useState(true)\n  const supabase = createClient()\n\n  useEffect(() => {\n    // Get initial session\n    const getInitialSession = async () => {\n      const { data: { session } } = await supabase.auth.getSession()\n      setSession(session)\n      setUser(session?.user ?? null)\n      setLoading(false)\n    }\n\n    getInitialSession()\n\n    // Listen for auth changes\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      async (event, session) => {\n        setSession(session)\n        setUser(session?.user ?? null)\n        setLoading(false)\n      }\n    )\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [supabase])\n\n  const signOut = async () => {\n    await supabase.auth.signOut()\n  }\n\n  return (\n    <AuthContext.Provider value={{ user, session, loading, signOut }}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider')\n  }\n  return context\n}\n","numLines":65,"startLine":1,"totalLines":65}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HBR2JezDAbQTwntVD69skS","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { X } from 'lucide-react'\n     4→import { StepDefinition, StepState } from './types'\n     5→import { InputContextSection } from './inspection/InputContextSection'\n     6→import { ExecutionSection } from './inspection/ExecutionSection'\n     7→import { OutputSection } from './inspection/OutputSection'\n     8→\n     9→export interface StepInfo {\n    10→  definition: StepDefinition\n    11→  state: StepState\n    12→}\n    13→\n    14→interface StepInspectionPanelProps {\n    15→  step: StepDefinition\n    16→  stepState: StepState\n    17→  playbookContext: Record<string, unknown>\n    18→  allSteps: StepInfo[]\n    19→  onClose?: () => void\n    20→  onRetry?: () => void\n    21→}\n    22→\n    23→export function StepInspectionPanel({\n    24→  step,\n    25→  stepState,\n    26→  playbookContext,\n    27→  allSteps,\n    28→  onClose,\n    29→  onRetry,\n    30→}: StepInspectionPanelProps) {\n    31→  const hasError = stepState.status === 'error'\n    32→\n    33→  return (\n    34→    <div className=\"border-t border-gray-200 bg-gray-50/50\">\n    35→      {/* Header */}\n    36→      <div className=\"flex items-center justify-between px-4 py-2 border-b border-gray-200 bg-white\">\n    37→        <h3 className=\"text-sm font-medium text-gray-700\">\n    38→          Inspector: {step.name}\n    39→        </h3>\n    40→        {onClose && (\n    41→          <button\n    42→            onClick={onClose}\n    43→            className=\"p-1 text-gray-400 hover:text-gray-600 rounded\"\n    44→            title=\"Cerrar inspector\"\n    45→          >\n    46→            <X size={16} />\n    47→          </button>\n    48→        )}\n    49→      </div>\n    50→\n    51→      {/* Content */}\n    52→      <div className=\"p-4 space-y-3\">\n    53→        {/* Input Context - collapsed by default unless empty */}\n    54→        <InputContextSection\n    55→          step={step}\n    56→          stepState={stepState}\n    57→          allSteps={allSteps}\n    58→          playbookContext={playbookContext}\n    59→          defaultExpanded={false}\n    60→        />\n    61→\n    62→        {/* Execution - expanded if in progress */}\n    63→        <ExecutionSection\n    64→          step={step}\n    65→          stepState={stepState}\n    66→          playbookContext={playbookContext}\n    67→          defaultExpanded={stepState.status === 'in_progress'}\n    68→        />\n    69→\n    70→        {/* Output/Error - expanded if error */}\n    71→        <OutputSection\n    72→          step={step}\n    73→          stepState={stepState}\n    74→          onRetry={onRetry}\n    75→          defaultExpanded={hasError || stepState.status === 'completed'}\n    76→        />\n    77→      </div>\n    78→    </div>\n    79→  )\n    80→}\n    81→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"19c0a934-0932-4dd9-b656-5fc66be993ac","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepInspectionPanel.tsx","content":"'use client'\n\nimport { X } from 'lucide-react'\nimport { StepDefinition, StepState } from './types'\nimport { InputContextSection } from './inspection/InputContextSection'\nimport { ExecutionSection } from './inspection/ExecutionSection'\nimport { OutputSection } from './inspection/OutputSection'\n\nexport interface StepInfo {\n  definition: StepDefinition\n  state: StepState\n}\n\ninterface StepInspectionPanelProps {\n  step: StepDefinition\n  stepState: StepState\n  playbookContext: Record<string, unknown>\n  allSteps: StepInfo[]\n  onClose?: () => void\n  onRetry?: () => void\n}\n\nexport function StepInspectionPanel({\n  step,\n  stepState,\n  playbookContext,\n  allSteps,\n  onClose,\n  onRetry,\n}: StepInspectionPanelProps) {\n  const hasError = stepState.status === 'error'\n\n  return (\n    <div className=\"border-t border-gray-200 bg-gray-50/50\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between px-4 py-2 border-b border-gray-200 bg-white\">\n        <h3 className=\"text-sm font-medium text-gray-700\">\n          Inspector: {step.name}\n        </h3>\n        {onClose && (\n          <button\n            onClick={onClose}\n            className=\"p-1 text-gray-400 hover:text-gray-600 rounded\"\n            title=\"Cerrar inspector\"\n          >\n            <X size={16} />\n          </button>\n        )}\n      </div>\n\n      {/* Content */}\n      <div className=\"p-4 space-y-3\">\n        {/* Input Context - collapsed by default unless empty */}\n        <InputContextSection\n          step={step}\n          stepState={stepState}\n          allSteps={allSteps}\n          playbookContext={playbookContext}\n          defaultExpanded={false}\n        />\n\n        {/* Execution - expanded if in progress */}\n        <ExecutionSection\n          step={step}\n          stepState={stepState}\n          playbookContext={playbookContext}\n          defaultExpanded={stepState.status === 'in_progress'}\n        />\n\n        {/* Output/Error - expanded if error */}\n        <OutputSection\n          step={step}\n          stepState={stepState}\n          onRetry={onRetry}\n          defaultExpanded={hasError || stepState.status === 'completed'}\n        />\n      </div>\n    </div>\n  )\n}\n","numLines":81,"startLine":1,"totalLines":81}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S22p4i8A3qc2RLy6rYqec9","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { createContext, useContext, useCallback, useState, useMemo, ReactNode } from 'react'\n     4→import { ConfirmModalConfig, ConfirmModalState, ModalContextValue } from './types'\n     5→import { ConfirmModal } from './ConfirmModal'\n     6→\n     7→const ModalContext = createContext<ModalContextValue | null>(null)\n     8→\n     9→interface ModalProviderProps {\n    10→  children: ReactNode\n    11→}\n    12→\n    13→// Default state - Closed modal\n    14→const defaultModalState: ConfirmModalState = {\n    15→  isOpen: false,\n    16→  title: '',\n    17→  message: '',\n    18→  onConfirm: () => {},\n    19→  onCancel: () => {},\n    20→}\n    21→\n    22→export function ModalProvider({ children }: ModalProviderProps) {\n    23→  const [modalState, setModalState] = useState<ConfirmModalState>(defaultModalState)\n    24→\n    25→  const closeModal = useCallback(() => {\n    26→    setModalState((prev) => ({ ...prev, isOpen: false }))\n    27→  }, [])\n    28→\n    29→  const confirm = useCallback((config: ConfirmModalConfig): Promise<boolean> => {\n    30→    return new Promise((resolve) => {\n    31→      setModalState({\n    32→        isOpen: true,\n    33→        title: config.title,\n    34→        message: config.message,\n    35→        confirmText: config.confirmText ?? 'Confirmar',\n    36→        cancelText: config.cancelText ?? 'Cancelar',\n    37→        variant: config.variant ?? 'default',\n    38→        icon: config.icon,\n    39→        onConfirm: () => {\n    40→          setModalState((prev) => ({ ...prev, isOpen: false }))\n    41→          resolve(true)\n    42→        },\n    43→        onCancel: () => {\n    44→          setModalState((prev) => ({ ...prev, isOpen: false }))\n    45→          resolve(false)\n    46→        },\n    47→      })\n    48→    })\n    49→  }, [])\n    50→\n    51→  const value = useMemo(\n    52→    () => ({\n    53→      confirm,\n    54→      closeModal,\n    55→    }),\n    56→    [confirm, closeModal]\n    57→  )\n    58→\n    59→  return (\n    60→    <ModalContext.Provider value={value}>\n    61→      {children}\n    62→      <ConfirmModal {...modalState} />\n    63→    </ModalContext.Provider>\n    64→  )\n    65→}\n    66→\n    67→// Custom hook with proper error handling\n    68→export function useModal(): ModalContextValue {\n    69→  const context = useContext(ModalContext)\n    70→  if (!context) {\n    71→    throw new Error('useModal must be used within a ModalProvider')\n    72→  }\n    73→  return context\n    74→}\n    75→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"644442d1-fe2b-4e45-9525-8472b04f12d2","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Modal/ModalContext.tsx","content":"'use client'\n\nimport { createContext, useContext, useCallback, useState, useMemo, ReactNode } from 'react'\nimport { ConfirmModalConfig, ConfirmModalState, ModalContextValue } from './types'\nimport { ConfirmModal } from './ConfirmModal'\n\nconst ModalContext = createContext<ModalContextValue | null>(null)\n\ninterface ModalProviderProps {\n  children: ReactNode\n}\n\n// Default state - Closed modal\nconst defaultModalState: ConfirmModalState = {\n  isOpen: false,\n  title: '',\n  message: '',\n  onConfirm: () => {},\n  onCancel: () => {},\n}\n\nexport function ModalProvider({ children }: ModalProviderProps) {\n  const [modalState, setModalState] = useState<ConfirmModalState>(defaultModalState)\n\n  const closeModal = useCallback(() => {\n    setModalState((prev) => ({ ...prev, isOpen: false }))\n  }, [])\n\n  const confirm = useCallback((config: ConfirmModalConfig): Promise<boolean> => {\n    return new Promise((resolve) => {\n      setModalState({\n        isOpen: true,\n        title: config.title,\n        message: config.message,\n        confirmText: config.confirmText ?? 'Confirmar',\n        cancelText: config.cancelText ?? 'Cancelar',\n        variant: config.variant ?? 'default',\n        icon: config.icon,\n        onConfirm: () => {\n          setModalState((prev) => ({ ...prev, isOpen: false }))\n          resolve(true)\n        },\n        onCancel: () => {\n          setModalState((prev) => ({ ...prev, isOpen: false }))\n          resolve(false)\n        },\n      })\n    })\n  }, [])\n\n  const value = useMemo(\n    () => ({\n      confirm,\n      closeModal,\n    }),\n    [confirm, closeModal]\n  )\n\n  return (\n    <ModalContext.Provider value={value}>\n      {children}\n      <ConfirmModal {...modalState} />\n    </ModalContext.Provider>\n  )\n}\n\n// Custom hook with proper error handling\nexport function useModal(): ModalContextValue {\n  const context = useContext(ModalContext)\n  if (!context) {\n    throw new Error('useModal must be used within a ModalProvider')\n  }\n  return context\n}\n","numLines":75,"startLine":1,"totalLines":75}}}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Dd6XKfxUBwLCrkb4ZcGXxt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01E2LLVNA8siw7XSNGooL3mE","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/InputContextSection.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":3247,"cache_read_input_tokens":69900,"cache_creation":{"ephemeral_5m_input_tokens":3247,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"e262ce2f-7ab3-4971-bf56-58d5ad1964cb"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Dd6XKfxUBwLCrkb4ZcGXxt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AXYFoaYwq7NJonG4SP3doq","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/OutputSection.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":3247,"cache_read_input_tokens":69900,"cache_creation":{"ephemeral_5m_input_tokens":3247,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"db6a95e0-e840-4584-b180-34384d964c4b"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Dd6XKfxUBwLCrkb4ZcGXxt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Qt21jj7xsopZAwqgcgoet1","name":"Grep","input":{"pattern":"export.*Session|interface.*Session|type.*Session","glob":"src/**/*.ts","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":3247,"cache_read_input_tokens":69900,"cache_creation":{"ephemeral_5m_input_tokens":3247,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"db5d5888-fd2f-4ece-ac09-b7a57058cef5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01E2LLVNA8siw7XSNGooL3mE","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { ChevronDown, ChevronRight, Check, Clock, AlertCircle } from 'lucide-react'\n     4→import { useState } from 'react'\n     5→import { StepDefinition, StepState } from '../types'\n     6→\n     7→interface StepInfo {\n     8→  definition: StepDefinition\n     9→  state: StepState\n    10→}\n    11→\n    12→interface InputContextSectionProps {\n    13→  step: StepDefinition\n    14→  stepState: StepState\n    15→  allSteps: StepInfo[]\n    16→  playbookContext: Record<string, unknown>\n    17→  defaultExpanded?: boolean\n    18→}\n    19→\n    20→// Get status icon for a step\n    21→function StepStatusIcon({ status }: { status: StepState['status'] }) {\n    22→  switch (status) {\n    23→    case 'completed':\n    24→      return <Check size={12} className=\"text-green-600\" />\n    25→    case 'in_progress':\n    26→      return <Clock size={12} className=\"text-blue-600 animate-pulse\" />\n    27→    case 'error':\n    28→      return <AlertCircle size={12} className=\"text-red-600\" />\n    29→    default:\n    30→      return <div className=\"w-3 h-3 rounded-full bg-gray-300\" />\n    31→  }\n    32→}\n    33→\n    34→export function InputContextSection({\n    35→  step,\n    36→  stepState,\n    37→  allSteps,\n    38→  playbookContext,\n    39→  defaultExpanded = false,\n    40→}: InputContextSectionProps) {\n    41→  const [isExpanded, setIsExpanded] = useState(defaultExpanded)\n    42→\n    43→  // Find dependent steps\n    44→  const dependentSteps = (step.dependsOn || [])\n    45→    .map(depId => allSteps.find(s => s.definition.id === depId))\n    46→    .filter(Boolean) as StepInfo[]\n    47→\n    48→  // Extract relevant context variables (excluding internal ones)\n    49→  const relevantContext = Object.entries(playbookContext).filter(([key]) => {\n    50→    // Skip internal keys\n    51→    if (key.endsWith('_output')) return false\n    52→    if (key === 'serpJobId') return false\n    53→    if (key === 'latestJobId') return false\n    54→    return true\n    55→  })\n    56→\n    57→  // Get jobId if present in context\n    58→  const jobId = playbookContext.serpJobId as string | undefined\n    59→\n    60→  // Get input data if present\n    61→  const inputData = stepState.input\n    62→\n    63→  const hasContent = dependentSteps.length > 0 || relevantContext.length > 0 || jobId || inputData\n    64→\n    65→  if (!hasContent) {\n    66→    return null\n    67→  }\n    68→\n    69→  return (\n    70→    <div className=\"border border-gray-200 rounded-lg overflow-hidden\">\n    71→      <button\n    72→        onClick={() => setIsExpanded(!isExpanded)}\n    73→        className=\"w-full flex items-center justify-between p-3 bg-gray-50 hover:bg-gray-100 transition-colors\"\n    74→      >\n    75→        <div className=\"flex items-center gap-2\">\n    76→          {isExpanded ? (\n    77→            <ChevronDown size={16} className=\"text-gray-500\" />\n    78→          ) : (\n    79→            <ChevronRight size={16} className=\"text-gray-500\" />\n    80→          )}\n    81→          <span className=\"text-sm font-medium text-gray-700\">Contexto de Entrada</span>\n    82→        </div>\n    83→        {!isExpanded && (\n    84→          <span className=\"text-xs text-gray-500\">\n    85→            {dependentSteps.length > 0 && `${dependentSteps.length} dependencia(s)`}\n    86→            {relevantContext.length > 0 && ` · ${relevantContext.length} variable(s)`}\n    87→          </span>\n    88→        )}\n    89→      </button>\n    90→\n    91→      {isExpanded && (\n    92→        <div className=\"p-3 space-y-3 bg-white\">\n    93→          {/* Dependencies */}\n    94→          {dependentSteps.length > 0 && (\n    95→            <div>\n    96→              <h4 className=\"text-xs font-medium text-gray-500 uppercase tracking-wide mb-2\">\n    97→                Depende de\n    98→              </h4>\n    99→              <div className=\"space-y-1\">\n   100→                {dependentSteps.map(dep => (\n   101→                  <div\n   102→                    key={dep.definition.id}\n   103→                    className=\"flex items-center gap-2 text-sm text-gray-700\"\n   104→                  >\n   105→                    <StepStatusIcon status={dep.state.status} />\n   106→                    <span>{dep.definition.name}</span>\n   107→                    {dep.state.status === 'completed' && dep.state.output && (\n   108→                      <span className=\"text-xs text-gray-400\">\n   109→                        ({typeof dep.state.output === 'object' && 'jobId' in dep.state.output\n   110→                          ? 'jobId: ' + (dep.state.output.jobId as string).slice(0, 8) + '...'\n   111→                          : 'con output'})\n   112→                      </span>\n   113→                    )}\n   114→                  </div>\n   115→                ))}\n   116→              </div>\n   117→            </div>\n   118→          )}\n   119→\n   120→          {/* Job ID */}\n   121→          {jobId && (\n   122→            <div>\n   123→              <h4 className=\"text-xs font-medium text-gray-500 uppercase tracking-wide mb-2\">\n   124→                Job ID\n   125→              </h4>\n   126→              <code className=\"text-xs bg-gray-100 px-2 py-1 rounded text-gray-700 font-mono\">\n   127→                {jobId}\n   128→              </code>\n   129→            </div>\n   130→          )}\n   131→\n   132→          {/* Context Variables */}\n   133→          {relevantContext.length > 0 && (\n   134→            <div>\n   135→              <h4 className=\"text-xs font-medium text-gray-500 uppercase tracking-wide mb-2\">\n   136→                Variables\n   137→              </h4>\n   138→              <div className=\"space-y-1\">\n   139→                {relevantContext.slice(0, 5).map(([key, value]) => (\n   140→                  <div key={key} className=\"flex items-start gap-2 text-sm\">\n   141→                    <span className=\"text-gray-500 font-mono text-xs\">{key}:</span>\n   142→                    <span className=\"text-gray-700 text-xs truncate max-w-[200px]\">\n   143→                      {Array.isArray(value)\n   144→                        ? `[${value.length} items]`\n   145→                        : typeof value === 'object'\n   146→                          ? JSON.stringify(value).slice(0, 50) + '...'\n   147→                          : String(value).slice(0, 50)}\n   148→                    </span>\n   149→                  </div>\n   150→                ))}\n   151→                {relevantContext.length > 5 && (\n   152→                  <span className=\"text-xs text-gray-400\">\n   153→                    +{relevantContext.length - 5} más\n   154→                  </span>\n   155→                )}\n   156→              </div>\n   157→            </div>\n   158→          )}\n   159→\n   160→          {/* Input data */}\n   161→          {inputData && (\n   162→            <div>\n   163→              <h4 className=\"text-xs font-medium text-gray-500 uppercase tracking-wide mb-2\">\n   164→                Input\n   165→              </h4>\n   166→              <pre className=\"text-xs bg-gray-100 p-2 rounded overflow-auto max-h-24 text-gray-700\">\n   167→                {typeof inputData === 'string'\n   168→                  ? inputData.slice(0, 200)\n   169→                  : JSON.stringify(inputData, null, 2).slice(0, 200)}\n   170→                {(typeof inputData === 'string' ? inputData.length : JSON.stringify(inputData).length) > 200 && '...'}\n   171→              </pre>\n   172→            </div>\n   173→          )}\n   174→        </div>\n   175→      )}\n   176→    </div>\n   177→  )\n   178→}\n   179→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"fc005f39-60bb-4418-8f3f-0b13917aa4eb","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/InputContextSection.tsx","content":"'use client'\n\nimport { ChevronDown, ChevronRight, Check, Clock, AlertCircle } from 'lucide-react'\nimport { useState } from 'react'\nimport { StepDefinition, StepState } from '../types'\n\ninterface StepInfo {\n  definition: StepDefinition\n  state: StepState\n}\n\ninterface InputContextSectionProps {\n  step: StepDefinition\n  stepState: StepState\n  allSteps: StepInfo[]\n  playbookContext: Record<string, unknown>\n  defaultExpanded?: boolean\n}\n\n// Get status icon for a step\nfunction StepStatusIcon({ status }: { status: StepState['status'] }) {\n  switch (status) {\n    case 'completed':\n      return <Check size={12} className=\"text-green-600\" />\n    case 'in_progress':\n      return <Clock size={12} className=\"text-blue-600 animate-pulse\" />\n    case 'error':\n      return <AlertCircle size={12} className=\"text-red-600\" />\n    default:\n      return <div className=\"w-3 h-3 rounded-full bg-gray-300\" />\n  }\n}\n\nexport function InputContextSection({\n  step,\n  stepState,\n  allSteps,\n  playbookContext,\n  defaultExpanded = false,\n}: InputContextSectionProps) {\n  const [isExpanded, setIsExpanded] = useState(defaultExpanded)\n\n  // Find dependent steps\n  const dependentSteps = (step.dependsOn || [])\n    .map(depId => allSteps.find(s => s.definition.id === depId))\n    .filter(Boolean) as StepInfo[]\n\n  // Extract relevant context variables (excluding internal ones)\n  const relevantContext = Object.entries(playbookContext).filter(([key]) => {\n    // Skip internal keys\n    if (key.endsWith('_output')) return false\n    if (key === 'serpJobId') return false\n    if (key === 'latestJobId') return false\n    return true\n  })\n\n  // Get jobId if present in context\n  const jobId = playbookContext.serpJobId as string | undefined\n\n  // Get input data if present\n  const inputData = stepState.input\n\n  const hasContent = dependentSteps.length > 0 || relevantContext.length > 0 || jobId || inputData\n\n  if (!hasContent) {\n    return null\n  }\n\n  return (\n    <div className=\"border border-gray-200 rounded-lg overflow-hidden\">\n      <button\n        onClick={() => setIsExpanded(!isExpanded)}\n        className=\"w-full flex items-center justify-between p-3 bg-gray-50 hover:bg-gray-100 transition-colors\"\n      >\n        <div className=\"flex items-center gap-2\">\n          {isExpanded ? (\n            <ChevronDown size={16} className=\"text-gray-500\" />\n          ) : (\n            <ChevronRight size={16} className=\"text-gray-500\" />\n          )}\n          <span className=\"text-sm font-medium text-gray-700\">Contexto de Entrada</span>\n        </div>\n        {!isExpanded && (\n          <span className=\"text-xs text-gray-500\">\n            {dependentSteps.length > 0 && `${dependentSteps.length} dependencia(s)`}\n            {relevantContext.length > 0 && ` · ${relevantContext.length} variable(s)`}\n          </span>\n        )}\n      </button>\n\n      {isExpanded && (\n        <div className=\"p-3 space-y-3 bg-white\">\n          {/* Dependencies */}\n          {dependentSteps.length > 0 && (\n            <div>\n              <h4 className=\"text-xs font-medium text-gray-500 uppercase tracking-wide mb-2\">\n                Depende de\n              </h4>\n              <div className=\"space-y-1\">\n                {dependentSteps.map(dep => (\n                  <div\n                    key={dep.definition.id}\n                    className=\"flex items-center gap-2 text-sm text-gray-700\"\n                  >\n                    <StepStatusIcon status={dep.state.status} />\n                    <span>{dep.definition.name}</span>\n                    {dep.state.status === 'completed' && dep.state.output && (\n                      <span className=\"text-xs text-gray-400\">\n                        ({typeof dep.state.output === 'object' && 'jobId' in dep.state.output\n                          ? 'jobId: ' + (dep.state.output.jobId as string).slice(0, 8) + '...'\n                          : 'con output'})\n                      </span>\n                    )}\n                  </div>\n                ))}\n              </div>\n            </div>\n          )}\n\n          {/* Job ID */}\n          {jobId && (\n            <div>\n              <h4 className=\"text-xs font-medium text-gray-500 uppercase tracking-wide mb-2\">\n                Job ID\n              </h4>\n              <code className=\"text-xs bg-gray-100 px-2 py-1 rounded text-gray-700 font-mono\">\n                {jobId}\n              </code>\n            </div>\n          )}\n\n          {/* Context Variables */}\n          {relevantContext.length > 0 && (\n            <div>\n              <h4 className=\"text-xs font-medium text-gray-500 uppercase tracking-wide mb-2\">\n                Variables\n              </h4>\n              <div className=\"space-y-1\">\n                {relevantContext.slice(0, 5).map(([key, value]) => (\n                  <div key={key} className=\"flex items-start gap-2 text-sm\">\n                    <span className=\"text-gray-500 font-mono text-xs\">{key}:</span>\n                    <span className=\"text-gray-700 text-xs truncate max-w-[200px]\">\n                      {Array.isArray(value)\n                        ? `[${value.length} items]`\n                        : typeof value === 'object'\n                          ? JSON.stringify(value).slice(0, 50) + '...'\n                          : String(value).slice(0, 50)}\n                    </span>\n                  </div>\n                ))}\n                {relevantContext.length > 5 && (\n                  <span className=\"text-xs text-gray-400\">\n                    +{relevantContext.length - 5} más\n                  </span>\n                )}\n              </div>\n            </div>\n          )}\n\n          {/* Input data */}\n          {inputData && (\n            <div>\n              <h4 className=\"text-xs font-medium text-gray-500 uppercase tracking-wide mb-2\">\n                Input\n              </h4>\n              <pre className=\"text-xs bg-gray-100 p-2 rounded overflow-auto max-h-24 text-gray-700\">\n                {typeof inputData === 'string'\n                  ? inputData.slice(0, 200)\n                  : JSON.stringify(inputData, null, 2).slice(0, 200)}\n                {(typeof inputData === 'string' ? inputData.length : JSON.stringify(inputData).length) > 200 && '...'}\n              </pre>\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  )\n}\n","numLines":179,"startLine":1,"totalLines":179}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AXYFoaYwq7NJonG4SP3doq","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { ChevronDown, ChevronRight, AlertCircle, Check, ExternalLink, RefreshCw, Settings } from 'lucide-react'\n     4→import { useState } from 'react'\n     5→import { useRouter } from 'next/navigation'\n     6→import { StepDefinition, StepState } from '../types'\n     7→import { analyzeError, getErrorCategoryColor, ErrorAction } from './ErrorAnalyzer'\n     8→\n     9→interface OutputSectionProps {\n    10→  step: StepDefinition\n    11→  stepState: StepState\n    12→  onRetry?: () => void\n    13→  defaultExpanded?: boolean\n    14→}\n    15→\n    16→// Format output for display\n    17→function formatOutput(output: unknown): string {\n    18→  if (output === null || output === undefined) {\n    19→    return 'Sin output'\n    20→  }\n    21→\n    22→  if (typeof output === 'string') {\n    23→    return output\n    24→  }\n    25→\n    26→  return JSON.stringify(output, null, 2)\n    27→}\n    28→\n    29→// Check if output is just a jobId wrapper\n    30→function isJobIdOutput(output: unknown): output is { jobId: string } {\n    31→  return (\n    32→    typeof output === 'object' &&\n    33→    output !== null &&\n    34→    'jobId' in output &&\n    35→    Object.keys(output).length <= 3 // jobId + maybe scrapedCount, failedCount\n    36→  )\n    37→}\n    38→\n    39→export function OutputSection({\n    40→  step,\n    41→  stepState,\n    42→  onRetry,\n    43→  defaultExpanded = false,\n    44→}: OutputSectionProps) {\n    45→  const router = useRouter()\n    46→  const hasError = stepState.status === 'error' && stepState.error\n    47→  const [isExpanded, setIsExpanded] = useState(defaultExpanded || hasError)\n    48→\n    49→  // Analyze error if present\n    50→  const errorAnalysis = hasError ? analyzeError(stepState.error!, step) : null\n    51→\n    52→  // Handle action clicks\n    53→  const handleAction = (action: ErrorAction) => {\n    54→    switch (action.type) {\n    55→      case 'navigate':\n    56→        if (action.href) {\n    57→          // If it's a query param, update current URL\n    58→          if (action.href.startsWith('?')) {\n    59→            const url = new URL(window.location.href)\n    60→            const params = new URLSearchParams(action.href.slice(1))\n    61→            params.forEach((value, key) => {\n    62→              url.searchParams.set(key, value)\n    63→            })\n    64→            router.push(url.toString())\n    65→          } else {\n    66→            router.push(action.href)\n    67→          }\n    68→        }\n    69→        break\n    70→      case 'retry':\n    71→        if (onRetry) onRetry()\n    72→        break\n    73→      case 'configure':\n    74→        router.push('?tab=setup')\n    75→        break\n    76→      case 'external':\n    77→        if (action.onClick) action.onClick()\n    78→        break\n    79→    }\n    80→  }\n    81→\n    82→  const output = stepState.output\n    83→  const hasOutput = output !== null && output !== undefined\n    84→\n    85→  return (\n    86→    <div\n    87→      className={`border rounded-lg overflow-hidden ${\n    88→        hasError ? getErrorCategoryColor(errorAnalysis!.category) : 'border-gray-200'\n    89→      }`}\n    90→    >\n    91→      <button\n    92→        onClick={() => setIsExpanded(!isExpanded)}\n    93→        className={`w-full flex items-center justify-between p-3 transition-colors ${\n    94→          hasError ? 'hover:opacity-90' : 'bg-gray-50 hover:bg-gray-100'\n    95→        }`}\n    96→      >\n    97→        <div className=\"flex items-center gap-2\">\n    98→          {isExpanded ? (\n    99→            <ChevronDown size={16} className={hasError ? 'opacity-70' : 'text-gray-500'} />\n   100→          ) : (\n   101→            <ChevronRight size={16} className={hasError ? 'opacity-70' : 'text-gray-500'} />\n   102→          )}\n   103→          <span className={`text-sm font-medium ${hasError ? '' : 'text-gray-700'}`}>\n   104→            {hasError ? 'Error' : 'Resultado'}\n   105→          </span>\n   106→          {hasError && <AlertCircle size={14} />}\n   107→          {stepState.status === 'completed' && !hasError && (\n   108→            <Check size={14} className=\"text-green-600\" />\n   109→          )}\n   110→        </div>\n   111→        {!isExpanded && !hasError && hasOutput && (\n   112→          <span className=\"text-xs text-gray-500\">\n   113→            {isJobIdOutput(output) ? `Job: ${output.jobId.slice(0, 8)}...` : 'Ver resultado'}\n   114→          </span>\n   115→        )}\n   116→      </button>\n   117→\n   118→      {isExpanded && (\n   119→        <div className={`p-3 space-y-3 ${hasError ? '' : 'bg-white'}`}>\n   120→          {/* Error Display */}\n   121→          {hasError && errorAnalysis && (\n   122→            <div className=\"space-y-3\">\n   123→              {/* Human readable message */}\n   124→              <div>\n   125→                <h4 className=\"font-medium\">{errorAnalysis.humanMessage}</h4>\n   126→                <p className=\"text-sm mt-1 opacity-80\">{errorAnalysis.suggestion}</p>\n   127→              </div>\n   128→\n   129→              {/* Actions */}\n   130→              <div className=\"flex flex-wrap gap-2\">\n   131→                {errorAnalysis.actions.map((action, idx) => (\n   132→                  <button\n   133→                    key={idx}\n   134→                    onClick={() => handleAction(action)}\n   135→                    className={`flex items-center gap-1.5 px-3 py-1.5 rounded text-sm font-medium transition-colors ${\n   136→                      action.type === 'navigate' || action.type === 'configure'\n   137→                        ? 'bg-blue-600 text-white hover:bg-blue-700'\n   138→                        : action.type === 'retry'\n   139→                          ? 'bg-white/50 hover:bg-white/70 border'\n   140→                          : 'bg-white/30 hover:bg-white/50'\n   141→                    }`}\n   142→                  >\n   143→                    {action.type === 'navigate' || action.type === 'configure' ? (\n   144→                      <Settings size={14} />\n   145→                    ) : action.type === 'retry' ? (\n   146→                      <RefreshCw size={14} />\n   147→                    ) : (\n   148→                      <ExternalLink size={14} />\n   149→                    )}\n   150→                    {action.label}\n   151→                  </button>\n   152→                ))}\n   153→              </div>\n   154→\n   155→              {/* Raw error (collapsible) */}\n   156→              <details className=\"text-xs opacity-60\">\n   157→                <summary className=\"cursor-pointer hover:opacity-100\">\n   158→                  Ver error completo\n   159→                </summary>\n   160→                <pre className=\"mt-2 p-2 bg-black/10 rounded overflow-auto max-h-32 font-mono\">\n   161→                  {stepState.error}\n   162→                </pre>\n   163→              </details>\n   164→            </div>\n   165→          )}\n   166→\n   167→          {/* Success Output */}\n   168→          {!hasError && hasOutput && (\n   169→            <div>\n   170→              {/* Special handling for jobId outputs */}\n   171→              {isJobIdOutput(output) ? (\n   172→                <div className=\"space-y-2\">\n   173→                  <div className=\"flex items-center gap-2\">\n   174→                    <span className=\"text-xs text-gray-500\">Job ID:</span>\n   175→                    <code className=\"text-xs bg-gray-100 px-2 py-0.5 rounded font-mono\">\n   176→                      {output.jobId}\n   177→                    </code>\n   178→                  </div>\n   179→                  {(output as Record<string, unknown>).scrapedCount !== undefined && (\n   180→                    <div className=\"text-xs text-gray-600\">\n   181→                      {String((output as Record<string, unknown>).scrapedCount)} URLs scrapeadas\n   182→                    </div>\n   183→                  )}\n   184→                  {(output as Record<string, unknown>).failedCount !== undefined &&\n   185→                    ((output as Record<string, unknown>).failedCount as number) > 0 && (\n   186→                      <div className=\"text-xs text-amber-600\">\n   187→                        {String((output as Record<string, unknown>).failedCount)} URLs fallidas\n   188→                      </div>\n   189→                    )}\n   190→                </div>\n   191→              ) : (\n   192→                /* Generic output display */\n   193→                <div>\n   194→                  <pre className=\"text-xs bg-gray-100 p-2 rounded overflow-auto max-h-48 text-gray-700 font-mono whitespace-pre-wrap\">\n   195→                    {formatOutput(output).slice(0, 2000)}\n   196→                    {formatOutput(output).length > 2000 && '\\n\\n... (truncado)'}\n   197→                  </pre>\n   198→                </div>\n   199→              )}\n   200→            </div>\n   201→          )}\n   202→\n   203→          {/* No output */}\n   204→          {!hasError && !hasOutput && stepState.status === 'completed' && (\n   205→            <div className=\"text-sm text-gray-500 italic\">\n   206→              Paso completado sin output\n   207→            </div>\n   208→          )}\n   209→\n   210→          {/* Pending state */}\n   211→          {!hasError && !hasOutput && stepState.status === 'pending' && (\n   212→            <div className=\"text-sm text-gray-400 italic\">\n   213→              Pendiente de ejecución\n   214→            </div>\n   215→          )}\n   216→        </div>\n   217→      )}\n   218→    </div>\n   219→  )\n   220→}\n   221→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"d552ca97-4a03-4f6d-9f27-d771b56e1d58","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/OutputSection.tsx","content":"'use client'\n\nimport { ChevronDown, ChevronRight, AlertCircle, Check, ExternalLink, RefreshCw, Settings } from 'lucide-react'\nimport { useState } from 'react'\nimport { useRouter } from 'next/navigation'\nimport { StepDefinition, StepState } from '../types'\nimport { analyzeError, getErrorCategoryColor, ErrorAction } from './ErrorAnalyzer'\n\ninterface OutputSectionProps {\n  step: StepDefinition\n  stepState: StepState\n  onRetry?: () => void\n  defaultExpanded?: boolean\n}\n\n// Format output for display\nfunction formatOutput(output: unknown): string {\n  if (output === null || output === undefined) {\n    return 'Sin output'\n  }\n\n  if (typeof output === 'string') {\n    return output\n  }\n\n  return JSON.stringify(output, null, 2)\n}\n\n// Check if output is just a jobId wrapper\nfunction isJobIdOutput(output: unknown): output is { jobId: string } {\n  return (\n    typeof output === 'object' &&\n    output !== null &&\n    'jobId' in output &&\n    Object.keys(output).length <= 3 // jobId + maybe scrapedCount, failedCount\n  )\n}\n\nexport function OutputSection({\n  step,\n  stepState,\n  onRetry,\n  defaultExpanded = false,\n}: OutputSectionProps) {\n  const router = useRouter()\n  const hasError = stepState.status === 'error' && stepState.error\n  const [isExpanded, setIsExpanded] = useState(defaultExpanded || hasError)\n\n  // Analyze error if present\n  const errorAnalysis = hasError ? analyzeError(stepState.error!, step) : null\n\n  // Handle action clicks\n  const handleAction = (action: ErrorAction) => {\n    switch (action.type) {\n      case 'navigate':\n        if (action.href) {\n          // If it's a query param, update current URL\n          if (action.href.startsWith('?')) {\n            const url = new URL(window.location.href)\n            const params = new URLSearchParams(action.href.slice(1))\n            params.forEach((value, key) => {\n              url.searchParams.set(key, value)\n            })\n            router.push(url.toString())\n          } else {\n            router.push(action.href)\n          }\n        }\n        break\n      case 'retry':\n        if (onRetry) onRetry()\n        break\n      case 'configure':\n        router.push('?tab=setup')\n        break\n      case 'external':\n        if (action.onClick) action.onClick()\n        break\n    }\n  }\n\n  const output = stepState.output\n  const hasOutput = output !== null && output !== undefined\n\n  return (\n    <div\n      className={`border rounded-lg overflow-hidden ${\n        hasError ? getErrorCategoryColor(errorAnalysis!.category) : 'border-gray-200'\n      }`}\n    >\n      <button\n        onClick={() => setIsExpanded(!isExpanded)}\n        className={`w-full flex items-center justify-between p-3 transition-colors ${\n          hasError ? 'hover:opacity-90' : 'bg-gray-50 hover:bg-gray-100'\n        }`}\n      >\n        <div className=\"flex items-center gap-2\">\n          {isExpanded ? (\n            <ChevronDown size={16} className={hasError ? 'opacity-70' : 'text-gray-500'} />\n          ) : (\n            <ChevronRight size={16} className={hasError ? 'opacity-70' : 'text-gray-500'} />\n          )}\n          <span className={`text-sm font-medium ${hasError ? '' : 'text-gray-700'}`}>\n            {hasError ? 'Error' : 'Resultado'}\n          </span>\n          {hasError && <AlertCircle size={14} />}\n          {stepState.status === 'completed' && !hasError && (\n            <Check size={14} className=\"text-green-600\" />\n          )}\n        </div>\n        {!isExpanded && !hasError && hasOutput && (\n          <span className=\"text-xs text-gray-500\">\n            {isJobIdOutput(output) ? `Job: ${output.jobId.slice(0, 8)}...` : 'Ver resultado'}\n          </span>\n        )}\n      </button>\n\n      {isExpanded && (\n        <div className={`p-3 space-y-3 ${hasError ? '' : 'bg-white'}`}>\n          {/* Error Display */}\n          {hasError && errorAnalysis && (\n            <div className=\"space-y-3\">\n              {/* Human readable message */}\n              <div>\n                <h4 className=\"font-medium\">{errorAnalysis.humanMessage}</h4>\n                <p className=\"text-sm mt-1 opacity-80\">{errorAnalysis.suggestion}</p>\n              </div>\n\n              {/* Actions */}\n              <div className=\"flex flex-wrap gap-2\">\n                {errorAnalysis.actions.map((action, idx) => (\n                  <button\n                    key={idx}\n                    onClick={() => handleAction(action)}\n                    className={`flex items-center gap-1.5 px-3 py-1.5 rounded text-sm font-medium transition-colors ${\n                      action.type === 'navigate' || action.type === 'configure'\n                        ? 'bg-blue-600 text-white hover:bg-blue-700'\n                        : action.type === 'retry'\n                          ? 'bg-white/50 hover:bg-white/70 border'\n                          : 'bg-white/30 hover:bg-white/50'\n                    }`}\n                  >\n                    {action.type === 'navigate' || action.type === 'configure' ? (\n                      <Settings size={14} />\n                    ) : action.type === 'retry' ? (\n                      <RefreshCw size={14} />\n                    ) : (\n                      <ExternalLink size={14} />\n                    )}\n                    {action.label}\n                  </button>\n                ))}\n              </div>\n\n              {/* Raw error (collapsible) */}\n              <details className=\"text-xs opacity-60\">\n                <summary className=\"cursor-pointer hover:opacity-100\">\n                  Ver error completo\n                </summary>\n                <pre className=\"mt-2 p-2 bg-black/10 rounded overflow-auto max-h-32 font-mono\">\n                  {stepState.error}\n                </pre>\n              </details>\n            </div>\n          )}\n\n          {/* Success Output */}\n          {!hasError && hasOutput && (\n            <div>\n              {/* Special handling for jobId outputs */}\n              {isJobIdOutput(output) ? (\n                <div className=\"space-y-2\">\n                  <div className=\"flex items-center gap-2\">\n                    <span className=\"text-xs text-gray-500\">Job ID:</span>\n                    <code className=\"text-xs bg-gray-100 px-2 py-0.5 rounded font-mono\">\n                      {output.jobId}\n                    </code>\n                  </div>\n                  {(output as Record<string, unknown>).scrapedCount !== undefined && (\n                    <div className=\"text-xs text-gray-600\">\n                      {String((output as Record<string, unknown>).scrapedCount)} URLs scrapeadas\n                    </div>\n                  )}\n                  {(output as Record<string, unknown>).failedCount !== undefined &&\n                    ((output as Record<string, unknown>).failedCount as number) > 0 && (\n                      <div className=\"text-xs text-amber-600\">\n                        {String((output as Record<string, unknown>).failedCount)} URLs fallidas\n                      </div>\n                    )}\n                </div>\n              ) : (\n                /* Generic output display */\n                <div>\n                  <pre className=\"text-xs bg-gray-100 p-2 rounded overflow-auto max-h-48 text-gray-700 font-mono whitespace-pre-wrap\">\n                    {formatOutput(output).slice(0, 2000)}\n                    {formatOutput(output).length > 2000 && '\\n\\n... (truncado)'}\n                  </pre>\n                </div>\n              )}\n            </div>\n          )}\n\n          {/* No output */}\n          {!hasError && !hasOutput && stepState.status === 'completed' && (\n            <div className=\"text-sm text-gray-500 italic\">\n              Paso completado sin output\n            </div>\n          )}\n\n          {/* Pending state */}\n          {!hasError && !hasOutput && stepState.status === 'pending' && (\n            <div className=\"text-sm text-gray-400 italic\">\n              Pendiente de ejecución\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  )\n}\n","numLines":221,"startLine":1,"totalLines":221}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Qt21jj7xsopZAwqgcgoet1","type":"tool_result","content":"Found 2 files\nsrc/components/playbook/index.ts\nsrc/app/api/playbook/sessions/route.ts"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"358ffb33-8031-4132-a347-0078d25331e7","tool_use_result":{"mode":"files_with_matches","filenames":["src/components/playbook/index.ts","src/app/api/playbook/sessions/route.ts"],"numFiles":2}}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GFEQGdxXqJsrYdsoRhfohX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015TKhpmXaMEWFvCgiBAdLTa","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/route.ts","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":5927,"cache_read_input_tokens":73147,"cache_creation":{"ephemeral_5m_input_tokens":5927,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"4b59e932-015f-4454-964a-1591087ff72d"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GFEQGdxXqJsrYdsoRhfohX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SzzzN3KhHDMzMzrWpiMGWe","name":"Bash","input":{"command":"find /Users/martin/Gattaca-Secuenciador-de-Prompts/src -type f -name \"*.tsx\" -o -name \"*.ts\" | xargs grep -l \"useDocuments\\|DocumentList\\|artifact\" | head -10"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":5927,"cache_read_input_tokens":73147,"cache_creation":{"ephemeral_5m_input_tokens":5927,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"0f889dfa-dddd-47d0-8c6a-261a4228d0e0"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GFEQGdxXqJsrYdsoRhfohX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016b3b6sJQBFhbYVNXXAGzLP","name":"Grep","input":{"pattern":"export.*useDocuments|export.*useSession|interface.*Document","glob":"src/hooks/**/*.ts","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":5927,"cache_read_input_tokens":73147,"cache_creation":{"ephemeral_5m_input_tokens":5927,"ephemeral_1h_input_tokens":0},"output_tokens":312,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"7e0a61e3-0a90-4f2d-8c43-556d4facd22f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015TKhpmXaMEWFvCgiBAdLTa","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from 'next/server'\n     2→import { createClient } from '@supabase/supabase-js'\n     3→\n     4→export const dynamic = 'force-dynamic'\n     5→\n     6→interface CreateSessionRequest {\n     7→  project_id: string\n     8→  playbook_type: 'niche_finder' | 'ecp' | 'video_viral' | 'signal_based_outreach' | 'competitor_analysis'\n     9→  name?: string\n    10→  tags?: string[] | null\n    11→  config?: Record<string, unknown>\n    12→  variables?: Record<string, unknown>\n    13→}\n    14→\n    15→interface Session {\n    16→  id: string\n    17→  project_id: string\n    18→  playbook_type: string\n    19→  name: string | null\n    20→  tags: string[] | null\n    21→  status: string\n    22→  current_phase: string | null\n    23→  current_step: string | null\n    24→  config: Record<string, unknown>\n    25→  variables: Record<string, unknown>\n    26→  created_at: string\n    27→  updated_at: string\n    28→  completed_at: string | null\n    29→  active_job_id: string | null\n    30→}\n    31→\n    32→export async function POST(request: NextRequest) {\n    33→  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n    34→  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n    35→\n    36→  if (!supabaseUrl || !supabaseServiceKey) {\n    37→    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n    38→  }\n    39→\n    40→  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n    41→\n    42→  try {\n    43→    const body: CreateSessionRequest = await request.json()\n    44→    const { project_id, playbook_type, name, tags, config = {}, variables = {} } = body\n    45→\n    46→    if (!project_id || !playbook_type) {\n    47→      return NextResponse.json(\n    48→        { error: 'project_id and playbook_type are required' },\n    49→        { status: 400 }\n    50→      )\n    51→    }\n    52→\n    53→    // Create new session (always create new, let dialog handle resume via list)\n    54→    const { data: newSession, error: insertError } = await supabase\n    55→      .from('playbook_sessions')\n    56→      .insert({\n    57→        project_id,\n    58→        playbook_type,\n    59→        name: name || null,\n    60→        tags: tags || null,\n    61→        status: 'draft',\n    62→        config,\n    63→        variables,\n    64→      })\n    65→      .select()\n    66→      .single()\n    67→\n    68→    if (insertError) {\n    69→      console.error('Error creating session:', insertError)\n    70→      return NextResponse.json(\n    71→        { error: `Failed to create session: ${insertError.message}` },\n    72→        { status: 500 }\n    73→      )\n    74→    }\n    75→\n    76→    return NextResponse.json({\n    77→      session: newSession as Session,\n    78→      created: true,\n    79→    })\n    80→  } catch (error) {\n    81→    console.error('Error in sessions endpoint:', error)\n    82→    return NextResponse.json(\n    83→      { error: error instanceof Error ? error.message : 'Unknown error' },\n    84→      { status: 500 }\n    85→    )\n    86→  }\n    87→}\n    88→\n    89→// GET: List sessions for a project\n    90→export async function GET(request: NextRequest) {\n    91→  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n    92→  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n    93→\n    94→  if (!supabaseUrl || !supabaseServiceKey) {\n    95→    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n    96→  }\n    97→\n    98→  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n    99→\n   100→  const searchParams = request.nextUrl.searchParams\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"857e098a-b363-4cad-998f-20353cb33cb0","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@supabase/supabase-js'\n\nexport const dynamic = 'force-dynamic'\n\ninterface CreateSessionRequest {\n  project_id: string\n  playbook_type: 'niche_finder' | 'ecp' | 'video_viral' | 'signal_based_outreach' | 'competitor_analysis'\n  name?: string\n  tags?: string[] | null\n  config?: Record<string, unknown>\n  variables?: Record<string, unknown>\n}\n\ninterface Session {\n  id: string\n  project_id: string\n  playbook_type: string\n  name: string | null\n  tags: string[] | null\n  status: string\n  current_phase: string | null\n  current_step: string | null\n  config: Record<string, unknown>\n  variables: Record<string, unknown>\n  created_at: string\n  updated_at: string\n  completed_at: string | null\n  active_job_id: string | null\n}\n\nexport async function POST(request: NextRequest) {\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n\n  if (!supabaseUrl || !supabaseServiceKey) {\n    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n  }\n\n  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n\n  try {\n    const body: CreateSessionRequest = await request.json()\n    const { project_id, playbook_type, name, tags, config = {}, variables = {} } = body\n\n    if (!project_id || !playbook_type) {\n      return NextResponse.json(\n        { error: 'project_id and playbook_type are required' },\n        { status: 400 }\n      )\n    }\n\n    // Create new session (always create new, let dialog handle resume via list)\n    const { data: newSession, error: insertError } = await supabase\n      .from('playbook_sessions')\n      .insert({\n        project_id,\n        playbook_type,\n        name: name || null,\n        tags: tags || null,\n        status: 'draft',\n        config,\n        variables,\n      })\n      .select()\n      .single()\n\n    if (insertError) {\n      console.error('Error creating session:', insertError)\n      return NextResponse.json(\n        { error: `Failed to create session: ${insertError.message}` },\n        { status: 500 }\n      )\n    }\n\n    return NextResponse.json({\n      session: newSession as Session,\n      created: true,\n    })\n  } catch (error) {\n    console.error('Error in sessions endpoint:', error)\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    )\n  }\n}\n\n// GET: List sessions for a project\nexport async function GET(request: NextRequest) {\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n\n  if (!supabaseUrl || !supabaseServiceKey) {\n    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n  }\n\n  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n\n  const searchParams = request.nextUrl.searchParams","numLines":100,"startLine":1,"totalLines":165}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016b3b6sJQBFhbYVNXXAGzLP","type":"tool_result","content":"Found 2 files\nsrc/hooks/useDocuments.ts\nsrc/hooks/useDocumentVersions.ts"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"02a66b1b-f4e3-4624-8e91-60655b2635ae","tool_use_result":{"mode":"files_with_matches","filenames":["src/hooks/useDocuments.ts","src/hooks/useDocumentVersions.ts"],"numFiles":2}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SzzzN3KhHDMzMzrWpiMGWe","type":"tool_result","content":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/clients/[clientId]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/projects/[projectId]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/documents/from-step-output/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentFolderView.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentSelector.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/SaveToContextLakeModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentList.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/hooks/useDocumentVersions.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/hooks/useDocuments.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/lib/niche-finder-context-lake.ts","is_error":false}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"e5f75372-4653-42fe-ad74-f0f8aacb4934","tool_use_result":{"stdout":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/clients/[clientId]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/projects/[projectId]/page.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/documents/from-step-output/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentFolderView.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentSelector.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/SaveToContextLakeModal.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentList.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/hooks/useDocumentVersions.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/hooks/useDocuments.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/lib/niche-finder-context-lake.ts","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01MATeZJkmgfL3uAGMdNDXwt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015aZ1XVHqsdXLEbNR7UEj1G","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/hooks/useDocuments.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":56,"cache_creation_input_tokens":2044,"cache_read_input_tokens":79074,"cache_creation":{"ephemeral_5m_input_tokens":2044,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"b469f91d-5c99-489c-935f-92a8b865b96d"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01MATeZJkmgfL3uAGMdNDXwt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019BeoQsK2tGrEA9YBAugawQ","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentList.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":56,"cache_creation_input_tokens":2044,"cache_read_input_tokens":79074,"cache_creation":{"ephemeral_5m_input_tokens":2044,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"6d71ef5b-6cc8-4384-adfd-52267031f507"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01MATeZJkmgfL3uAGMdNDXwt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011TLf3SFWQApjC8y2iZrUgQ","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentFolderView.tsx","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":56,"cache_creation_input_tokens":2044,"cache_read_input_tokens":79074,"cache_creation":{"ephemeral_5m_input_tokens":2044,"ephemeral_1h_input_tokens":0},"output_tokens":244,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"fd2fd46f-44f1-46d3-a4e4-a18bcdd01df3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015aZ1XVHqsdXLEbNR7UEj1G","type":"tool_result","content":"     1→import { useState, useEffect, useCallback } from 'react'\n     2→import { createClient } from '@/lib/supabase-browser'\n     3→\n     4→// ============================================\n     5→// TYPES\n     6→// ============================================\n     7→export type DocumentSourceType = 'import' | 'scraper' | 'playbook' | 'api'\n     8→\n     9→export type DocumentChangeType =\n    10→  | 'created'\n    11→  | 'manual_edit'\n    12→  | 'ai_suggestion'\n    13→  | 'regenerated'\n    14→  | 'imported'\n    15→  | 'merged'\n    16→  | 'restored'\n    17→\n    18→export interface Document {\n    19→  id: string\n    20→  project_id?: string | null\n    21→  client_id?: string | null\n    22→  filename: string\n    23→  category: string\n    24→  extracted_content: string | null\n    25→  file_size_bytes: number | null\n    26→  mime_type: string | null\n    27→  storage_path?: string | null\n    28→  source_type: DocumentSourceType\n    29→  source_playbook_id?: string | null\n    30→  source_job_id?: string | null\n    31→  source_url?: string | null\n    32→  source_metadata?: Record<string, unknown>\n    33→  description?: string | null\n    34→  token_count?: number | null\n    35→  tags?: string[] | null\n    36→  campaign_id?: string | null\n    37→  created_at: string\n    38→  updated_at?: string\n    39→  // Traceability fields\n    40→  created_by?: string | null\n    41→  updated_by?: string | null\n    42→  source_campaign_id?: string | null\n    43→  source_step_id?: string | null\n    44→  source_step_name?: string | null\n    45→  // Soft delete\n    46→  is_deleted?: boolean\n    47→  deleted_at?: string | null\n    48→  deleted_by?: string | null\n    49→  // Folder organization\n    50→  folder?: string | null\n    51→  // Reference fields (for linking to Context Lake docs)\n    52→  is_reference?: boolean\n    53→  source_doc_id?: string | null\n    54→  // UI-only fields\n    55→  isShared?: boolean\n    56→  projectName?: string\n    57→  version_count?: number\n    58→}\n    59→\n    60→export interface DocumentVersion {\n    61→  id: string\n    62→  document_id: string\n    63→  version_number: number\n    64→  extracted_content: string\n    65→  token_count: number | null\n    66→  change_type: DocumentChangeType\n    67→  change_summary: string | null\n    68→  created_by: string | null\n    69→  created_at: string\n    70→}\n    71→\n    72→// Metadata structure for playbook step outputs\n    73→export interface PlaybookStepSourceMetadata {\n    74→  origin_type: 'flow_step_output'\n    75→  // Playbook context\n    76→  playbook_id: string\n    77→  playbook_name: string\n    78→  // Campaign context\n    79→  campaign_id: string\n    80→  campaign_name: string\n    81→  campaign_variables: {\n    82→    ecp_name?: string\n    83→    problem_core?: string\n    84→    country?: string\n    85→    industry?: string\n    86→    [key: string]: string | undefined\n    87→  }\n    88→  // Step context\n    89→  step_id: string\n    90→  step_name: string\n    91→  step_order: number\n    92→  // Execution info\n    93→  executed_at: string\n    94→  model_used: string\n    95→  model_provider: string\n    96→  input_tokens: number\n    97→  output_tokens: number\n    98→  // Input references\n    99→  input_document_ids: string[]\n   100→  input_previous_step_ids: string[]\n   101→  // Conversion info\n   102→  converted_at: string\n   103→  converted_by: string\n   104→  was_edited_before_conversion: boolean\n   105→}\n   106→\n   107→export interface DocumentFilters {\n   108→  sourceType?: DocumentSourceType\n   109→  category?: string\n   110→  folder?: string | null // null = uncategorized, undefined = all\n   111→}\n   112→\n   113→// ============================================\n   114→// FOLDER UTILITIES\n   115→// ============================================\n   116→\n   117→/** Get unique folder names from documents */\n   118→export function getFolders(docs: Document[]): string[] {\n   119→  const folders = docs\n   120→    .map(d => d.folder)\n   121→    .filter((f): f is string => f !== null && f !== undefined)\n   122→  return [...new Set(folders)].sort()\n   123→}\n   124→\n   125→/** Group documents by folder */\n   126→export function groupByFolder(docs: Document[]): Record<string, Document[]> {\n   127→  return docs.reduce((acc, doc) => {\n   128→    const folder = doc.folder || '__uncategorized__'\n   129→    if (!acc[folder]) acc[folder] = []\n   130→    acc[folder].push(doc)\n   131→    return acc\n   132→  }, {} as Record<string, Document[]>)\n   133→}\n   134→\n   135→/** Get folder display name */\n   136→export function getFolderDisplayName(folder: string): string {\n   137→  return folder === '__uncategorized__' ? 'Sin carpeta' : folder\n   138→}\n   139→\n   140→// ============================================\n   141→// HOOK: useDocuments (project-level)\n   142→// ============================================\n   143→export function useDocuments(projectId: string, filters?: DocumentFilters) {\n   144→  const [documents, setDocuments] = useState<Document[]>([])\n   145→  const [loading, setLoading] = useState(true)\n   146→  const [error, setError] = useState<string | null>(null)\n   147→\n   148→  const loadDocuments = useCallback(async () => {\n   149→    if (!projectId) return\n   150→\n   151→    try {\n   152→      setLoading(true)\n   153→      const supabase = createClient()\n   154→      let query = supabase\n   155→        .from('knowledge_base_docs')\n   156→        .select('*')\n   157→        .eq('project_id', projectId)\n   158→        .or('is_deleted.is.null,is_deleted.eq.false') // Filter out soft-deleted docs\n   159→\n   160→      // Apply filters\n   161→      if (filters?.sourceType) {\n   162→        query = query.eq('source_type', filters.sourceType)\n   163→      }\n   164→      if (filters?.category) {\n   165→        query = query.eq('category', filters.category)\n   166→      }\n   167→\n   168→      const { data, error } = await query\n   169→        .order('created_at', { ascending: false })\n   170→\n   171→      if (error) throw error\n   172→\n   173→      setDocuments(data || [])\n   174→    } catch (err) {\n   175→      setError(err instanceof Error ? err.message : 'Unknown error')\n   176→    } finally {\n   177→      setLoading(false)\n   178→    }\n   179→  }, [projectId, filters?.sourceType, filters?.category])\n   180→\n   181→  useEffect(() => {\n   182→    loadDocuments()\n   183→  }, [loadDocuments])\n   184→\n   185→  return { documents, loading, error, reload: loadDocuments }\n   186→}\n   187→\n   188→// ============================================\n   189→// HOOK: useClientDocuments (client-level shared docs)\n   190→// ============================================\n   191→export function useClientDocuments(clientId: string, filters?: DocumentFilters) {\n   192→  const [documents, setDocuments] = useState<Document[]>([])\n   193→  const [loading, setLoading] = useState(true)\n   194→  const [error, setError] = useState<string | null>(null)\n   195→\n   196→  const loadDocuments = useCallback(async () => {\n   197→    if (!clientId) return\n   198→\n   199→    try {\n   200→      setLoading(true)\n   201→      const supabase = createClient()\n   202→      let query = supabase\n   203→        .from('knowledge_base_docs')\n   204→        .select('*')\n   205→        .eq('client_id', clientId)\n   206→        .is('project_id', null) // Only client-level docs\n   207→        .or('is_deleted.is.null,is_deleted.eq.false') // Filter out soft-deleted docs\n   208→\n   209→      // Apply filters\n   210→      if (filters?.sourceType) {\n   211→        query = query.eq('source_type', filters.sourceType)\n   212→      }\n   213→      if (filters?.category) {\n   214→        query = query.eq('category', filters.category)\n   215→      }\n   216→\n   217→      const { data, error } = await query\n   218→        .order('created_at', { ascending: false })\n   219→\n   220→      if (error) throw error\n   221→\n   222→      setDocuments(data || [])\n   223→    } catch (err) {\n   224→      setError(err instanceof Error ? err.message : 'Unknown error')\n   225→    } finally {\n   226→      setLoading(false)\n   227→    }\n   228→  }, [clientId, filters?.sourceType, filters?.category])\n   229→\n   230→  useEffect(() => {\n   231→    loadDocuments()\n   232→  }, [loadDocuments])\n   233→\n   234→  return { documents, loading, error, reload: loadDocuments }\n   235→}\n   236→\n   237→// ============================================\n   238→// HOOK: useContextLake (combined project + client docs)\n   239→// ============================================\n   240→export function useContextLake(projectId: string, clientId?: string, filters?: DocumentFilters) {\n   241→  const [documents, setDocuments] = useState<Document[]>([])\n   242→  const [loading, setLoading] = useState(true)\n   243→  const [error, setError] = useState<string | null>(null)\n   244→\n   245→  const loadDocuments = useCallback(async () => {\n   246→    if (!projectId) return\n   247→\n   248→    try {\n   249→      setLoading(true)\n   250→      const supabase = createClient()\n   251→\n   252→      // Get project documents\n   253→      let projectQuery = supabase\n   254→        .from('knowledge_base_docs')\n   255→        .select('*')\n   256→        .eq('project_id', projectId)\n   257→        .or('is_deleted.is.null,is_deleted.eq.false')\n   258→\n   259→      if (filters?.sourceType) projectQuery = projectQuery.eq('source_type', filters.sourceType)\n   260→      if (filters?.category) projectQuery = projectQuery.eq('category', filters.category)\n   261→\n   262→      const { data: projectDocs, error: projectError } = await projectQuery\n   263→\n   264→      if (projectError) throw projectError\n   265→\n   266→      let allDocs = projectDocs || []\n   267→\n   268→      // If clientId is provided, also get client-level docs\n   269→      if (clientId) {\n   270→        let clientQuery = supabase\n   271→          .from('knowledge_base_docs')\n   272→          .select('*')\n   273→          .eq('client_id', clientId)\n   274→          .is('project_id', null)\n   275→          .or('is_deleted.is.null,is_deleted.eq.false')\n   276→\n   277→        if (filters?.sourceType) clientQuery = clientQuery.eq('source_type', filters.sourceType)\n   278→        if (filters?.category) clientQuery = clientQuery.eq('category', filters.category)\n   279→\n   280→        const { data: clientDocs, error: clientError } = await clientQuery\n   281→\n   282→        if (clientError) throw clientError\n   283→\n   284→        // Mark client docs as shared\n   285→        const sharedDocs = (clientDocs || []).map(doc => ({\n   286→          ...doc,\n   287→          isShared: true\n   288→        }))\n   289→\n   290→        allDocs = [...allDocs, ...sharedDocs]\n   291→      }\n   292→\n   293→      // Sort by date\n   294→      allDocs.sort((a, b) => {\n   295→        return new Date(b.created_at).getTime() - new Date(a.created_at).getTime()\n   296→      })\n   297→\n   298→      setDocuments(allDocs)\n   299→    } catch (err) {\n   300→      setError(err instanceof Error ? err.message : 'Unknown error')\n   301→    } finally {\n   302→      setLoading(false)\n   303→    }\n   304→  }, [projectId, clientId, filters?.sourceType, filters?.category])\n   305→\n   306→  useEffect(() => {\n   307→    loadDocuments()\n   308→  }, [loadDocuments])\n   309→\n   310→  return { documents, loading, error, reload: loadDocuments }\n   311→}\n   312→\n   313→// Soft delete document (preserves for audit trail)\n   314→export async function deleteDocument(docId: string, userId?: string) {\n   315→  const supabase = createClient()\n   316→  const { error } = await supabase\n   317→    .from('knowledge_base_docs')\n   318→    .update({\n   319→      is_deleted: true,\n   320→      deleted_at: new Date().toISOString(),\n   321→      deleted_by: userId || null,\n   322→    })\n   323→    .eq('id', docId)\n   324→\n   325→  if (error) throw error\n   326→}\n   327→\n   328→// Permanently delete document (use with caution)\n   329→export async function hardDeleteDocument(docId: string) {\n   330→  const supabase = createClient()\n   331→  const { error } = await supabase\n   332→    .from('knowledge_base_docs')\n   333→    .delete()\n   334→    .eq('id', docId)\n   335→\n   336→  if (error) throw error\n   337→}\n   338→\n   339→// Restore soft-deleted document\n   340→export async function restoreDocument(docId: string) {\n   341→  const supabase = createClient()\n   342→  const { error } = await supabase\n   343→    .from('knowledge_base_docs')\n   344→    .update({\n   345→      is_deleted: false,\n   346→      deleted_at: null,\n   347→      deleted_by: null,\n   348→    })\n   349→    .eq('id', docId)\n   350→\n   351→  if (error) throw error\n   352→}\n   353→\n   354→export async function createDocumentFromText(data: {\n   355→  projectId?: string\n   356→  clientId?: string\n   357→  filename: string\n   358→  category: string\n   359→  content: string\n   360→  sourceType?: DocumentSourceType\n   361→  sourcePlaybookId?: string\n   362→  description?: string\n   363→}) {\n   364→  const supabase = createClient()\n   365→  const { data: newDoc, error } = await supabase\n   366→    .from('knowledge_base_docs')\n   367→    .insert({\n   368→      project_id: data.projectId || null,\n   369→      client_id: data.clientId || null,\n   370→      filename: data.filename,\n   371→      category: data.category,\n   372→      extracted_content: data.content,\n   373→      file_size_bytes: data.content.length,\n   374→      mime_type: 'text/plain',\n   375→      source_type: data.sourceType || 'import',\n   376→      source_playbook_id: data.sourcePlaybookId || null,\n   377→      description: data.description || null,\n   378→    })\n   379→    .select()\n   380→    .single()\n   381→\n   382→  if (error) throw error\n   383→  return newDoc\n   384→}\n   385→\n   386→// ============================================\n   387→// UPDATE DOCUMENT\n   388→// ============================================\n   389→export async function updateDocument(docId: string, updates: Partial<Document>) {\n   390→  const supabase = createClient()\n   391→  const { data, error } = await supabase\n   392→    .from('knowledge_base_docs')\n   393→    .update(updates)\n   394→    .eq('id', docId)\n   395→    .select()\n   396→    .single()\n   397→\n   398→  if (error) throw error\n   399→  return data\n   400→}\n   401→\n   402→// ============================================\n   403→// HOOK: useAllClientDocuments (ALL docs for a client including all projects)\n   404→// ============================================\n   405→export function useAllClientDocuments(clientId: string, filters?: DocumentFilters) {\n   406→  const [documents, setDocuments] = useState<Document[]>([])\n   407→  const [loading, setLoading] = useState(true)\n   408→  const [error, setError] = useState<string | null>(null)\n   409→  const [projectsMap, setProjectsMap] = useState<Record<string, string>>({})\n   410→\n   411→  const loadDocuments = useCallback(async () => {\n   412→    if (!clientId) return\n   413→\n   414→    try {\n   415→      setLoading(true)\n   416→      const supabase = createClient()\n   417→\n   418→      // First, get all projects for this client\n   419→      const { data: projects, error: projectsError } = await supabase\n   420→        .from('projects')\n   421→        .select('id, name')\n   422→        .eq('client_id', clientId)\n   423→\n   424→      if (projectsError) throw projectsError\n   425→\n   426→      const projectIds = projects?.map(p => p.id) || []\n   427→      const projectNames: Record<string, string> = {}\n   428→      projects?.forEach(p => {\n   429→        projectNames[p.id] = p.name\n   430→      })\n   431→      setProjectsMap(projectNames)\n   432→\n   433→      // Get client-level documents\n   434→      let clientQuery = supabase\n   435→        .from('knowledge_base_docs')\n   436→        .select('*')\n   437→        .eq('client_id', clientId)\n   438→        .is('project_id', null)\n   439→        .or('is_deleted.is.null,is_deleted.eq.false') // Filter out soft-deleted docs\n   440→\n   441→      if (filters?.sourceType) clientQuery = clientQuery.eq('source_type', filters.sourceType)\n   442→      if (filters?.category) clientQuery = clientQuery.eq('category', filters.category)\n   443→\n   444→      const { data: clientDocs, error: clientError } = await clientQuery\n   445→\n   446→      if (clientError) throw clientError\n   447→\n   448→      // Get documents from all projects\n   449→      let projectDocs: Document[] = []\n   450→      if (projectIds.length > 0) {\n   451→        let projectQuery = supabase\n   452→          .from('knowledge_base_docs')\n   453→          .select('*')\n   454→          .in('project_id', projectIds)\n   455→          .or('is_deleted.is.null,is_deleted.eq.false') // Filter out soft-deleted docs\n   456→\n   457→        if (filters?.sourceType) projectQuery = projectQuery.eq('source_type', filters.sourceType)\n   458→        if (filters?.category) projectQuery = projectQuery.eq('category', filters.category)\n   459→\n   460→        const { data, error: projectError } = await projectQuery\n   461→\n   462→        if (projectError) throw projectError\n   463→        projectDocs = data || []\n   464→      }\n   465→\n   466→      // Mark client docs as shared, project docs with their project name\n   467→      const sharedDocs = (clientDocs || []).map(doc => ({\n   468→        ...doc,\n   469→        isShared: true,\n   470→        projectName: 'Cliente (compartido)'\n   471→      }))\n   472→\n   473→      const allProjectDocs = projectDocs.map(doc => ({\n   474→        ...doc,\n   475→        isShared: false,\n   476→        projectName: projectNames[doc.project_id || ''] || 'Proyecto'\n   477→      }))\n   478→\n   479→      // Combine and sort by date\n   480→      const allDocs = [...sharedDocs, ...allProjectDocs]\n   481→      allDocs.sort((a, b) => {\n   482→        return new Date(b.created_at).getTime() - new Date(a.created_at).getTime()\n   483→      })\n   484→\n   485→      setDocuments(allDocs as Document[])\n   486→    } catch (err) {\n   487→      setError(err instanceof Error ? err.message : 'Unknown error')\n   488→    } finally {\n   489→      setLoading(false)\n   490→    }\n   491→  }, [clientId, filters?.sourceType, filters?.category])\n   492→\n   493→  useEffect(() => {\n   494→    loadDocuments()\n   495→  }, [loadDocuments])\n   496→\n   497→  return { documents, loading, error, reload: loadDocuments, projectsMap }\n   498→}\n   499→\n   500→// ============================================\n   501→// CREATE DOCUMENT FROM STEP OUTPUT\n   502→// ============================================\n   503→export interface CreateFromStepOutputData {\n   504→  // Target location\n   505→  projectId?: string\n   506→  clientId?: string\n   507→  // Document info\n   508→  filename: string\n   509→  category: string\n   510→  content: string\n   511→  description?: string\n   512→  tags?: string[]\n   513→  // Traceability\n   514→  userId: string\n   515→  // Source metadata (playbook step context)\n   516→  sourceMetadata: PlaybookStepSourceMetadata\n   517→  // Source linkage\n   518→  sourceCampaignId: string\n   519→  sourceStepId: string\n   520→  sourceStepName: string\n   521→  sourcePlaybookId?: string\n   522→}\n   523→\n   524→export async function createDocumentFromStepOutput(data: CreateFromStepOutputData) {\n   525→  const supabase = createClient()\n   526→\n   527→  const { data: newDoc, error } = await supabase\n   528→    .from('knowledge_base_docs')\n   529→    .insert({\n   530→      project_id: data.projectId || null,\n   531→      client_id: data.clientId || null,\n   532→      filename: data.filename,\n   533→      category: data.category,\n   534→      extracted_content: data.content,\n   535→      file_size_bytes: new Blob([data.content]).size,\n   536→      mime_type: 'text/plain',\n   537→      source_type: 'playbook' as DocumentSourceType,\n   538→      source_playbook_id: data.sourcePlaybookId || null,\n   539→      source_metadata: data.sourceMetadata,\n   540→      description: data.description || null,\n   541→      tags: data.tags || null,\n   542→      // Traceability fields\n   543→      created_by: data.userId,\n   544→      updated_by: data.userId,\n   545→      source_campaign_id: data.sourceCampaignId,\n   546→      source_step_id: data.sourceStepId,\n   547→      source_step_name: data.sourceStepName,\n   548→    })\n   549→    .select()\n   550→    .single()\n   551→\n   552→  if (error) throw error\n   553→  return newDoc\n   554→}\n   555→\n   556→// ============================================\n   557→// GET DOCUMENT WITH VERSION COUNT\n   558→// ============================================\n   559→export async function getDocumentWithVersionCount(docId: string): Promise<Document | null> {\n   560→  const supabase = createClient()\n   561→\n   562→  // Get document\n   563→  const { data: doc, error: docError } = await supabase\n   564→    .from('knowledge_base_docs')\n   565→    .select('*')\n   566→    .eq('id', docId)\n   567→    .single()\n   568→\n   569→  if (docError) throw docError\n   570→  if (!doc) return null\n   571→\n   572→  // Get version count\n   573→  const { count, error: countError } = await supabase\n   574→    .from('document_versions')\n   575→    .select('*', { count: 'exact', head: true })\n   576→    .eq('document_id', docId)\n   577→\n   578→  if (countError) throw countError\n   579→\n   580→  return {\n   581→    ...doc,\n   582→    version_count: count || 0\n   583→  }\n   584→}\n   585→\n   586→// ============================================\n   587→// FOLDER OPERATIONS\n   588→// ============================================\n   589→\n   590→/** Update document folder */\n   591→export async function updateDocumentFolder(docId: string, folder: string | null) {\n   592→  const supabase = createClient()\n   593→  const { data, error } = await supabase\n   594→    .from('knowledge_base_docs')\n   595→    .update({ folder })\n   596→    .eq('id', docId)\n   597→    .select()\n   598→    .single()\n   599→\n   600→  if (error) throw error\n   601→  return data\n   602→}\n   603→\n   604→/** Move multiple documents to a folder */\n   605→export async function moveDocumentsToFolder(docIds: string[], folder: string | null) {\n   606→  const supabase = createClient()\n   607→  const { error } = await supabase\n   608→    .from('knowledge_base_docs')\n   609→    .update({ folder })\n   610→    .in('id', docIds)\n   611→\n   612→  if (error) throw error\n   613→}\n   614→\n   615→// ============================================\n   616→// REFERENCE OPERATIONS\n   617→// ============================================\n   618→\n   619→/** Create a reference to a Context Lake document in a project */\n   620→export async function createDocumentReference(\n   621→  sourceDocId: string,\n   622→  projectId: string,\n   623→  folder?: string | null\n   624→): Promise<Document> {\n   625→  const supabase = createClient()\n   626→\n   627→  // First, get the source document\n   628→  const { data: sourceDoc, error: fetchError } = await supabase\n   629→    .from('knowledge_base_docs')\n   630→    .select('*')\n   631→    .eq('id', sourceDocId)\n   632→    .single()\n   633→\n   634→  if (fetchError) throw fetchError\n   635→  if (!sourceDoc) throw new Error('Source document not found')\n   636→\n   637→  // Verify it's a Context Lake document (no project_id)\n   638→  if (sourceDoc.project_id) {\n   639→    throw new Error('Can only reference Context Lake documents (documents without a project)')\n   640→  }\n   641→\n   642→  // Create the reference\n   643→  const { data: refDoc, error: insertError } = await supabase\n   644→    .from('knowledge_base_docs')\n   645→    .insert({\n   646→      filename: sourceDoc.filename,\n   647→      project_id: projectId,\n   648→      client_id: sourceDoc.client_id,\n   649→      category: sourceDoc.category,\n   650→      mime_type: sourceDoc.mime_type,\n   651→      file_size_bytes: sourceDoc.file_size_bytes,\n   652→      source_type: sourceDoc.source_type,\n   653→      description: sourceDoc.description,\n   654→      tags: sourceDoc.tags,\n   655→      folder: folder || null,\n   656→      is_reference: true,\n   657→      source_doc_id: sourceDocId,\n   658→      // Note: extracted_content is NOT copied - it's read from source\n   659→    })\n   660→    .select()\n   661→    .single()\n   662→\n   663→  if (insertError) throw insertError\n   664→  return refDoc\n   665→}\n   666→\n   667→/** Get the actual content of a document, following references if needed */\n   668→export async function getDocumentContent(doc: Document): Promise<string | null> {\n   669→  if (!doc.is_reference || !doc.source_doc_id) {\n   670→    return doc.extracted_content\n   671→  }\n   672→\n   673→  // Fetch content from source document\n   674→  const supabase = createClient()\n   675→  const { data: sourceDoc, error } = await supabase\n   676→    .from('knowledge_base_docs')\n   677→    .select('extracted_content')\n   678→    .eq('id', doc.source_doc_id)\n   679→    .single()\n   680→\n   681→  if (error) throw error\n   682→  return sourceDoc?.extracted_content || null\n   683→}\n   684→\n   685→/** Promote a project document to Context Lake */\n   686→export async function promoteToContextLake(\n   687→  docId: string,\n   688→  options: {\n   689→    convertToReference?: boolean\n   690→    targetFolder?: string | null\n   691→  } = {}\n   692→): Promise<Document> {\n   693→  const supabase = createClient()\n   694→\n   695→  // Get the original document\n   696→  const { data: originalDoc, error: fetchError } = await supabase\n   697→    .from('knowledge_base_docs')\n   698→    .select('*')\n   699→    .eq('id', docId)\n   700→    .single()\n   701→\n   702→  if (fetchError) throw fetchError\n   703→  if (!originalDoc) throw new Error('Document not found')\n   704→  if (!originalDoc.project_id) {\n   705→    throw new Error('Document is already in Context Lake')\n   706→  }\n   707→  if (originalDoc.is_reference) {\n   708→    throw new Error('Cannot promote a reference document')\n   709→  }\n   710→\n   711→  // Create copy in Context Lake (no project_id)\n   712→  const { data: newDoc, error: insertError } = await supabase\n   713→    .from('knowledge_base_docs')\n   714→    .insert({\n   715→      filename: originalDoc.filename,\n   716→      client_id: originalDoc.client_id,\n   717→      project_id: null, // This makes it a Context Lake doc\n   718→      category: originalDoc.category,\n   719→      extracted_content: originalDoc.extracted_content,\n   720→      mime_type: originalDoc.mime_type,\n   721→      file_size_bytes: originalDoc.file_size_bytes,\n   722→      storage_path: originalDoc.storage_path,\n   723→      source_type: originalDoc.source_type,\n   724→      description: originalDoc.description,\n   725→      tags: originalDoc.tags,\n   726→      token_count: originalDoc.token_count,\n   727→      folder: options.targetFolder || null,\n   728→      is_reference: false,\n   729→      source_doc_id: null,\n   730→    })\n   731→    .select()\n   732→    .single()\n   733→\n   734→  if (insertError) throw insertError\n   735→\n   736→  // Optionally convert original to a reference\n   737→  if (options.convertToReference) {\n   738→    const { error: updateError } = await supabase\n   739→      .from('knowledge_base_docs')\n   740→      .update({\n   741→        is_reference: true,\n   742→        source_doc_id: newDoc.id,\n   743→        extracted_content: null, // Clear content since it's now a reference\n   744→      })\n   745→      .eq('id', docId)\n   746→\n   747→    if (updateError) throw updateError\n   748→  }\n   749→\n   750→  return newDoc\n   751→}\n   752→\n   753→/** Get documents that reference a given source document */\n   754→export async function getDocumentReferences(sourceDocId: string): Promise<Document[]> {\n   755→  const supabase = createClient()\n   756→  const { data, error } = await supabase\n   757→    .from('knowledge_base_docs')\n   758→    .select('*, projects(name)')\n   759→    .eq('source_doc_id', sourceDocId)\n   760→    .or('is_deleted.is.null,is_deleted.eq.false')\n   761→\n   762→  if (error) throw error\n   763→  return data || []\n   764→}\n   765→\n   766→/** Check if a document can be deleted (has no active references) */\n   767→export async function canDeleteDocument(docId: string): Promise<{\n   768→  canDelete: boolean\n   769→  referenceCount: number\n   770→  referencingProjects: string[]\n   771→}> {\n   772→  const refs = await getDocumentReferences(docId)\n   773→  const projectNames = refs\n   774→    .map(r => (r as Document & { projects?: { name: string } }).projects?.name)\n   775→    .filter((name): name is string => !!name)\n   776→\n   777→  return {\n   778→    canDelete: refs.length === 0,\n   779→    referenceCount: refs.length,\n   780→    referencingProjects: [...new Set(projectNames)]\n   781→  }\n   782→}\n   783→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"76c71f48-5b5b-4b8a-8e43-f6dbea114b34","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/hooks/useDocuments.ts","content":"import { useState, useEffect, useCallback } from 'react'\nimport { createClient } from '@/lib/supabase-browser'\n\n// ============================================\n// TYPES\n// ============================================\nexport type DocumentSourceType = 'import' | 'scraper' | 'playbook' | 'api'\n\nexport type DocumentChangeType =\n  | 'created'\n  | 'manual_edit'\n  | 'ai_suggestion'\n  | 'regenerated'\n  | 'imported'\n  | 'merged'\n  | 'restored'\n\nexport interface Document {\n  id: string\n  project_id?: string | null\n  client_id?: string | null\n  filename: string\n  category: string\n  extracted_content: string | null\n  file_size_bytes: number | null\n  mime_type: string | null\n  storage_path?: string | null\n  source_type: DocumentSourceType\n  source_playbook_id?: string | null\n  source_job_id?: string | null\n  source_url?: string | null\n  source_metadata?: Record<string, unknown>\n  description?: string | null\n  token_count?: number | null\n  tags?: string[] | null\n  campaign_id?: string | null\n  created_at: string\n  updated_at?: string\n  // Traceability fields\n  created_by?: string | null\n  updated_by?: string | null\n  source_campaign_id?: string | null\n  source_step_id?: string | null\n  source_step_name?: string | null\n  // Soft delete\n  is_deleted?: boolean\n  deleted_at?: string | null\n  deleted_by?: string | null\n  // Folder organization\n  folder?: string | null\n  // Reference fields (for linking to Context Lake docs)\n  is_reference?: boolean\n  source_doc_id?: string | null\n  // UI-only fields\n  isShared?: boolean\n  projectName?: string\n  version_count?: number\n}\n\nexport interface DocumentVersion {\n  id: string\n  document_id: string\n  version_number: number\n  extracted_content: string\n  token_count: number | null\n  change_type: DocumentChangeType\n  change_summary: string | null\n  created_by: string | null\n  created_at: string\n}\n\n// Metadata structure for playbook step outputs\nexport interface PlaybookStepSourceMetadata {\n  origin_type: 'flow_step_output'\n  // Playbook context\n  playbook_id: string\n  playbook_name: string\n  // Campaign context\n  campaign_id: string\n  campaign_name: string\n  campaign_variables: {\n    ecp_name?: string\n    problem_core?: string\n    country?: string\n    industry?: string\n    [key: string]: string | undefined\n  }\n  // Step context\n  step_id: string\n  step_name: string\n  step_order: number\n  // Execution info\n  executed_at: string\n  model_used: string\n  model_provider: string\n  input_tokens: number\n  output_tokens: number\n  // Input references\n  input_document_ids: string[]\n  input_previous_step_ids: string[]\n  // Conversion info\n  converted_at: string\n  converted_by: string\n  was_edited_before_conversion: boolean\n}\n\nexport interface DocumentFilters {\n  sourceType?: DocumentSourceType\n  category?: string\n  folder?: string | null // null = uncategorized, undefined = all\n}\n\n// ============================================\n// FOLDER UTILITIES\n// ============================================\n\n/** Get unique folder names from documents */\nexport function getFolders(docs: Document[]): string[] {\n  const folders = docs\n    .map(d => d.folder)\n    .filter((f): f is string => f !== null && f !== undefined)\n  return [...new Set(folders)].sort()\n}\n\n/** Group documents by folder */\nexport function groupByFolder(docs: Document[]): Record<string, Document[]> {\n  return docs.reduce((acc, doc) => {\n    const folder = doc.folder || '__uncategorized__'\n    if (!acc[folder]) acc[folder] = []\n    acc[folder].push(doc)\n    return acc\n  }, {} as Record<string, Document[]>)\n}\n\n/** Get folder display name */\nexport function getFolderDisplayName(folder: string): string {\n  return folder === '__uncategorized__' ? 'Sin carpeta' : folder\n}\n\n// ============================================\n// HOOK: useDocuments (project-level)\n// ============================================\nexport function useDocuments(projectId: string, filters?: DocumentFilters) {\n  const [documents, setDocuments] = useState<Document[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n\n  const loadDocuments = useCallback(async () => {\n    if (!projectId) return\n\n    try {\n      setLoading(true)\n      const supabase = createClient()\n      let query = supabase\n        .from('knowledge_base_docs')\n        .select('*')\n        .eq('project_id', projectId)\n        .or('is_deleted.is.null,is_deleted.eq.false') // Filter out soft-deleted docs\n\n      // Apply filters\n      if (filters?.sourceType) {\n        query = query.eq('source_type', filters.sourceType)\n      }\n      if (filters?.category) {\n        query = query.eq('category', filters.category)\n      }\n\n      const { data, error } = await query\n        .order('created_at', { ascending: false })\n\n      if (error) throw error\n\n      setDocuments(data || [])\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error')\n    } finally {\n      setLoading(false)\n    }\n  }, [projectId, filters?.sourceType, filters?.category])\n\n  useEffect(() => {\n    loadDocuments()\n  }, [loadDocuments])\n\n  return { documents, loading, error, reload: loadDocuments }\n}\n\n// ============================================\n// HOOK: useClientDocuments (client-level shared docs)\n// ============================================\nexport function useClientDocuments(clientId: string, filters?: DocumentFilters) {\n  const [documents, setDocuments] = useState<Document[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n\n  const loadDocuments = useCallback(async () => {\n    if (!clientId) return\n\n    try {\n      setLoading(true)\n      const supabase = createClient()\n      let query = supabase\n        .from('knowledge_base_docs')\n        .select('*')\n        .eq('client_id', clientId)\n        .is('project_id', null) // Only client-level docs\n        .or('is_deleted.is.null,is_deleted.eq.false') // Filter out soft-deleted docs\n\n      // Apply filters\n      if (filters?.sourceType) {\n        query = query.eq('source_type', filters.sourceType)\n      }\n      if (filters?.category) {\n        query = query.eq('category', filters.category)\n      }\n\n      const { data, error } = await query\n        .order('created_at', { ascending: false })\n\n      if (error) throw error\n\n      setDocuments(data || [])\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error')\n    } finally {\n      setLoading(false)\n    }\n  }, [clientId, filters?.sourceType, filters?.category])\n\n  useEffect(() => {\n    loadDocuments()\n  }, [loadDocuments])\n\n  return { documents, loading, error, reload: loadDocuments }\n}\n\n// ============================================\n// HOOK: useContextLake (combined project + client docs)\n// ============================================\nexport function useContextLake(projectId: string, clientId?: string, filters?: DocumentFilters) {\n  const [documents, setDocuments] = useState<Document[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n\n  const loadDocuments = useCallback(async () => {\n    if (!projectId) return\n\n    try {\n      setLoading(true)\n      const supabase = createClient()\n\n      // Get project documents\n      let projectQuery = supabase\n        .from('knowledge_base_docs')\n        .select('*')\n        .eq('project_id', projectId)\n        .or('is_deleted.is.null,is_deleted.eq.false')\n\n      if (filters?.sourceType) projectQuery = projectQuery.eq('source_type', filters.sourceType)\n      if (filters?.category) projectQuery = projectQuery.eq('category', filters.category)\n\n      const { data: projectDocs, error: projectError } = await projectQuery\n\n      if (projectError) throw projectError\n\n      let allDocs = projectDocs || []\n\n      // If clientId is provided, also get client-level docs\n      if (clientId) {\n        let clientQuery = supabase\n          .from('knowledge_base_docs')\n          .select('*')\n          .eq('client_id', clientId)\n          .is('project_id', null)\n          .or('is_deleted.is.null,is_deleted.eq.false')\n\n        if (filters?.sourceType) clientQuery = clientQuery.eq('source_type', filters.sourceType)\n        if (filters?.category) clientQuery = clientQuery.eq('category', filters.category)\n\n        const { data: clientDocs, error: clientError } = await clientQuery\n\n        if (clientError) throw clientError\n\n        // Mark client docs as shared\n        const sharedDocs = (clientDocs || []).map(doc => ({\n          ...doc,\n          isShared: true\n        }))\n\n        allDocs = [...allDocs, ...sharedDocs]\n      }\n\n      // Sort by date\n      allDocs.sort((a, b) => {\n        return new Date(b.created_at).getTime() - new Date(a.created_at).getTime()\n      })\n\n      setDocuments(allDocs)\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error')\n    } finally {\n      setLoading(false)\n    }\n  }, [projectId, clientId, filters?.sourceType, filters?.category])\n\n  useEffect(() => {\n    loadDocuments()\n  }, [loadDocuments])\n\n  return { documents, loading, error, reload: loadDocuments }\n}\n\n// Soft delete document (preserves for audit trail)\nexport async function deleteDocument(docId: string, userId?: string) {\n  const supabase = createClient()\n  const { error } = await supabase\n    .from('knowledge_base_docs')\n    .update({\n      is_deleted: true,\n      deleted_at: new Date().toISOString(),\n      deleted_by: userId || null,\n    })\n    .eq('id', docId)\n\n  if (error) throw error\n}\n\n// Permanently delete document (use with caution)\nexport async function hardDeleteDocument(docId: string) {\n  const supabase = createClient()\n  const { error } = await supabase\n    .from('knowledge_base_docs')\n    .delete()\n    .eq('id', docId)\n\n  if (error) throw error\n}\n\n// Restore soft-deleted document\nexport async function restoreDocument(docId: string) {\n  const supabase = createClient()\n  const { error } = await supabase\n    .from('knowledge_base_docs')\n    .update({\n      is_deleted: false,\n      deleted_at: null,\n      deleted_by: null,\n    })\n    .eq('id', docId)\n\n  if (error) throw error\n}\n\nexport async function createDocumentFromText(data: {\n  projectId?: string\n  clientId?: string\n  filename: string\n  category: string\n  content: string\n  sourceType?: DocumentSourceType\n  sourcePlaybookId?: string\n  description?: string\n}) {\n  const supabase = createClient()\n  const { data: newDoc, error } = await supabase\n    .from('knowledge_base_docs')\n    .insert({\n      project_id: data.projectId || null,\n      client_id: data.clientId || null,\n      filename: data.filename,\n      category: data.category,\n      extracted_content: data.content,\n      file_size_bytes: data.content.length,\n      mime_type: 'text/plain',\n      source_type: data.sourceType || 'import',\n      source_playbook_id: data.sourcePlaybookId || null,\n      description: data.description || null,\n    })\n    .select()\n    .single()\n\n  if (error) throw error\n  return newDoc\n}\n\n// ============================================\n// UPDATE DOCUMENT\n// ============================================\nexport async function updateDocument(docId: string, updates: Partial<Document>) {\n  const supabase = createClient()\n  const { data, error } = await supabase\n    .from('knowledge_base_docs')\n    .update(updates)\n    .eq('id', docId)\n    .select()\n    .single()\n\n  if (error) throw error\n  return data\n}\n\n// ============================================\n// HOOK: useAllClientDocuments (ALL docs for a client including all projects)\n// ============================================\nexport function useAllClientDocuments(clientId: string, filters?: DocumentFilters) {\n  const [documents, setDocuments] = useState<Document[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n  const [projectsMap, setProjectsMap] = useState<Record<string, string>>({})\n\n  const loadDocuments = useCallback(async () => {\n    if (!clientId) return\n\n    try {\n      setLoading(true)\n      const supabase = createClient()\n\n      // First, get all projects for this client\n      const { data: projects, error: projectsError } = await supabase\n        .from('projects')\n        .select('id, name')\n        .eq('client_id', clientId)\n\n      if (projectsError) throw projectsError\n\n      const projectIds = projects?.map(p => p.id) || []\n      const projectNames: Record<string, string> = {}\n      projects?.forEach(p => {\n        projectNames[p.id] = p.name\n      })\n      setProjectsMap(projectNames)\n\n      // Get client-level documents\n      let clientQuery = supabase\n        .from('knowledge_base_docs')\n        .select('*')\n        .eq('client_id', clientId)\n        .is('project_id', null)\n        .or('is_deleted.is.null,is_deleted.eq.false') // Filter out soft-deleted docs\n\n      if (filters?.sourceType) clientQuery = clientQuery.eq('source_type', filters.sourceType)\n      if (filters?.category) clientQuery = clientQuery.eq('category', filters.category)\n\n      const { data: clientDocs, error: clientError } = await clientQuery\n\n      if (clientError) throw clientError\n\n      // Get documents from all projects\n      let projectDocs: Document[] = []\n      if (projectIds.length > 0) {\n        let projectQuery = supabase\n          .from('knowledge_base_docs')\n          .select('*')\n          .in('project_id', projectIds)\n          .or('is_deleted.is.null,is_deleted.eq.false') // Filter out soft-deleted docs\n\n        if (filters?.sourceType) projectQuery = projectQuery.eq('source_type', filters.sourceType)\n        if (filters?.category) projectQuery = projectQuery.eq('category', filters.category)\n\n        const { data, error: projectError } = await projectQuery\n\n        if (projectError) throw projectError\n        projectDocs = data || []\n      }\n\n      // Mark client docs as shared, project docs with their project name\n      const sharedDocs = (clientDocs || []).map(doc => ({\n        ...doc,\n        isShared: true,\n        projectName: 'Cliente (compartido)'\n      }))\n\n      const allProjectDocs = projectDocs.map(doc => ({\n        ...doc,\n        isShared: false,\n        projectName: projectNames[doc.project_id || ''] || 'Proyecto'\n      }))\n\n      // Combine and sort by date\n      const allDocs = [...sharedDocs, ...allProjectDocs]\n      allDocs.sort((a, b) => {\n        return new Date(b.created_at).getTime() - new Date(a.created_at).getTime()\n      })\n\n      setDocuments(allDocs as Document[])\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error')\n    } finally {\n      setLoading(false)\n    }\n  }, [clientId, filters?.sourceType, filters?.category])\n\n  useEffect(() => {\n    loadDocuments()\n  }, [loadDocuments])\n\n  return { documents, loading, error, reload: loadDocuments, projectsMap }\n}\n\n// ============================================\n// CREATE DOCUMENT FROM STEP OUTPUT\n// ============================================\nexport interface CreateFromStepOutputData {\n  // Target location\n  projectId?: string\n  clientId?: string\n  // Document info\n  filename: string\n  category: string\n  content: string\n  description?: string\n  tags?: string[]\n  // Traceability\n  userId: string\n  // Source metadata (playbook step context)\n  sourceMetadata: PlaybookStepSourceMetadata\n  // Source linkage\n  sourceCampaignId: string\n  sourceStepId: string\n  sourceStepName: string\n  sourcePlaybookId?: string\n}\n\nexport async function createDocumentFromStepOutput(data: CreateFromStepOutputData) {\n  const supabase = createClient()\n\n  const { data: newDoc, error } = await supabase\n    .from('knowledge_base_docs')\n    .insert({\n      project_id: data.projectId || null,\n      client_id: data.clientId || null,\n      filename: data.filename,\n      category: data.category,\n      extracted_content: data.content,\n      file_size_bytes: new Blob([data.content]).size,\n      mime_type: 'text/plain',\n      source_type: 'playbook' as DocumentSourceType,\n      source_playbook_id: data.sourcePlaybookId || null,\n      source_metadata: data.sourceMetadata,\n      description: data.description || null,\n      tags: data.tags || null,\n      // Traceability fields\n      created_by: data.userId,\n      updated_by: data.userId,\n      source_campaign_id: data.sourceCampaignId,\n      source_step_id: data.sourceStepId,\n      source_step_name: data.sourceStepName,\n    })\n    .select()\n    .single()\n\n  if (error) throw error\n  return newDoc\n}\n\n// ============================================\n// GET DOCUMENT WITH VERSION COUNT\n// ============================================\nexport async function getDocumentWithVersionCount(docId: string): Promise<Document | null> {\n  const supabase = createClient()\n\n  // Get document\n  const { data: doc, error: docError } = await supabase\n    .from('knowledge_base_docs')\n    .select('*')\n    .eq('id', docId)\n    .single()\n\n  if (docError) throw docError\n  if (!doc) return null\n\n  // Get version count\n  const { count, error: countError } = await supabase\n    .from('document_versions')\n    .select('*', { count: 'exact', head: true })\n    .eq('document_id', docId)\n\n  if (countError) throw countError\n\n  return {\n    ...doc,\n    version_count: count || 0\n  }\n}\n\n// ============================================\n// FOLDER OPERATIONS\n// ============================================\n\n/** Update document folder */\nexport async function updateDocumentFolder(docId: string, folder: string | null) {\n  const supabase = createClient()\n  const { data, error } = await supabase\n    .from('knowledge_base_docs')\n    .update({ folder })\n    .eq('id', docId)\n    .select()\n    .single()\n\n  if (error) throw error\n  return data\n}\n\n/** Move multiple documents to a folder */\nexport async function moveDocumentsToFolder(docIds: string[], folder: string | null) {\n  const supabase = createClient()\n  const { error } = await supabase\n    .from('knowledge_base_docs')\n    .update({ folder })\n    .in('id', docIds)\n\n  if (error) throw error\n}\n\n// ============================================\n// REFERENCE OPERATIONS\n// ============================================\n\n/** Create a reference to a Context Lake document in a project */\nexport async function createDocumentReference(\n  sourceDocId: string,\n  projectId: string,\n  folder?: string | null\n): Promise<Document> {\n  const supabase = createClient()\n\n  // First, get the source document\n  const { data: sourceDoc, error: fetchError } = await supabase\n    .from('knowledge_base_docs')\n    .select('*')\n    .eq('id', sourceDocId)\n    .single()\n\n  if (fetchError) throw fetchError\n  if (!sourceDoc) throw new Error('Source document not found')\n\n  // Verify it's a Context Lake document (no project_id)\n  if (sourceDoc.project_id) {\n    throw new Error('Can only reference Context Lake documents (documents without a project)')\n  }\n\n  // Create the reference\n  const { data: refDoc, error: insertError } = await supabase\n    .from('knowledge_base_docs')\n    .insert({\n      filename: sourceDoc.filename,\n      project_id: projectId,\n      client_id: sourceDoc.client_id,\n      category: sourceDoc.category,\n      mime_type: sourceDoc.mime_type,\n      file_size_bytes: sourceDoc.file_size_bytes,\n      source_type: sourceDoc.source_type,\n      description: sourceDoc.description,\n      tags: sourceDoc.tags,\n      folder: folder || null,\n      is_reference: true,\n      source_doc_id: sourceDocId,\n      // Note: extracted_content is NOT copied - it's read from source\n    })\n    .select()\n    .single()\n\n  if (insertError) throw insertError\n  return refDoc\n}\n\n/** Get the actual content of a document, following references if needed */\nexport async function getDocumentContent(doc: Document): Promise<string | null> {\n  if (!doc.is_reference || !doc.source_doc_id) {\n    return doc.extracted_content\n  }\n\n  // Fetch content from source document\n  const supabase = createClient()\n  const { data: sourceDoc, error } = await supabase\n    .from('knowledge_base_docs')\n    .select('extracted_content')\n    .eq('id', doc.source_doc_id)\n    .single()\n\n  if (error) throw error\n  return sourceDoc?.extracted_content || null\n}\n\n/** Promote a project document to Context Lake */\nexport async function promoteToContextLake(\n  docId: string,\n  options: {\n    convertToReference?: boolean\n    targetFolder?: string | null\n  } = {}\n): Promise<Document> {\n  const supabase = createClient()\n\n  // Get the original document\n  const { data: originalDoc, error: fetchError } = await supabase\n    .from('knowledge_base_docs')\n    .select('*')\n    .eq('id', docId)\n    .single()\n\n  if (fetchError) throw fetchError\n  if (!originalDoc) throw new Error('Document not found')\n  if (!originalDoc.project_id) {\n    throw new Error('Document is already in Context Lake')\n  }\n  if (originalDoc.is_reference) {\n    throw new Error('Cannot promote a reference document')\n  }\n\n  // Create copy in Context Lake (no project_id)\n  const { data: newDoc, error: insertError } = await supabase\n    .from('knowledge_base_docs')\n    .insert({\n      filename: originalDoc.filename,\n      client_id: originalDoc.client_id,\n      project_id: null, // This makes it a Context Lake doc\n      category: originalDoc.category,\n      extracted_content: originalDoc.extracted_content,\n      mime_type: originalDoc.mime_type,\n      file_size_bytes: originalDoc.file_size_bytes,\n      storage_path: originalDoc.storage_path,\n      source_type: originalDoc.source_type,\n      description: originalDoc.description,\n      tags: originalDoc.tags,\n      token_count: originalDoc.token_count,\n      folder: options.targetFolder || null,\n      is_reference: false,\n      source_doc_id: null,\n    })\n    .select()\n    .single()\n\n  if (insertError) throw insertError\n\n  // Optionally convert original to a reference\n  if (options.convertToReference) {\n    const { error: updateError } = await supabase\n      .from('knowledge_base_docs')\n      .update({\n        is_reference: true,\n        source_doc_id: newDoc.id,\n        extracted_content: null, // Clear content since it's now a reference\n      })\n      .eq('id', docId)\n\n    if (updateError) throw updateError\n  }\n\n  return newDoc\n}\n\n/** Get documents that reference a given source document */\nexport async function getDocumentReferences(sourceDocId: string): Promise<Document[]> {\n  const supabase = createClient()\n  const { data, error } = await supabase\n    .from('knowledge_base_docs')\n    .select('*, projects(name)')\n    .eq('source_doc_id', sourceDocId)\n    .or('is_deleted.is.null,is_deleted.eq.false')\n\n  if (error) throw error\n  return data || []\n}\n\n/** Check if a document can be deleted (has no active references) */\nexport async function canDeleteDocument(docId: string): Promise<{\n  canDelete: boolean\n  referenceCount: number\n  referencingProjects: string[]\n}> {\n  const refs = await getDocumentReferences(docId)\n  const projectNames = refs\n    .map(r => (r as Document & { projects?: { name: string } }).projects?.name)\n    .filter((name): name is string => !!name)\n\n  return {\n    canDelete: refs.length === 0,\n    referenceCount: refs.length,\n    referencingProjects: [...new Set(projectNames)]\n  }\n}\n","numLines":783,"startLine":1,"totalLines":783}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011TLf3SFWQApjC8y2iZrUgQ","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useMemo } from 'react'\n     4→import { ChevronDown, ChevronRight, FolderOpen, Folder, Plus, X, Link2, FolderInput } from 'lucide-react'\n     5→import { Document, groupByFolder, getFolderDisplayName, getFolders } from '@/hooks/useDocuments'\n     6→\n     7→interface DocumentFolderViewProps {\n     8→  documents: Document[]\n     9→  onFolderClick?: (folder: string | null) => void\n    10→  onDocumentClick?: (doc: Document) => void\n    11→  onCreateFolder?: (folderName: string) => void\n    12→  onMoveToFolder?: (docId: string, folder: string | null) => Promise<void>\n    13→  selectedDocIds?: Set<string>\n    14→  onToggleDocSelection?: (docId: string) => void\n    15→  showCreateFolder?: boolean\n    16→  emptyMessage?: string\n    17→  /** Additional empty folders to display (created manually but not yet used) */\n    18→  emptyFolders?: string[]\n    19→}\n    20→\n    21→export default function DocumentFolderView({\n    22→  documents,\n    23→  onFolderClick,\n    24→  onDocumentClick,\n    25→  onCreateFolder,\n    26→  onMoveToFolder,\n    27→  selectedDocIds,\n    28→  onToggleDocSelection,\n    29→  showCreateFolder = false,\n    30→  emptyMessage = 'No hay documentos',\n    31→  emptyFolders = [],\n    32→}: DocumentFolderViewProps) {\n    33→  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set(['__uncategorized__']))\n    34→  const [creatingFolder, setCreatingFolder] = useState(false)\n    35→  const [newFolderName, setNewFolderName] = useState('')\n    36→\n    37→  // Group documents by folder\n    38→  const groupedDocs = useMemo(() => {\n    39→    const grouped = groupByFolder(documents)\n    40→    // Add empty folders that don't have documents yet\n    41→    for (const folder of emptyFolders) {\n    42→      if (!grouped[folder]) {\n    43→        grouped[folder] = []\n    44→      }\n    45→    }\n    46→    return grouped\n    47→  }, [documents, emptyFolders])\n    48→  const folders = useMemo(() => getFolders(documents), [documents])\n    49→\n    50→  // Sort folders: named folders first (alphabetically), then uncategorized\n    51→  const sortedFolderKeys = useMemo(() => {\n    52→    const keys = Object.keys(groupedDocs)\n    53→    return keys.sort((a, b) => {\n    54→      if (a === '__uncategorized__') return 1\n    55→      if (b === '__uncategorized__') return -1\n    56→      return a.localeCompare(b)\n    57→    })\n    58→  }, [groupedDocs])\n    59→\n    60→  const toggleFolder = (folder: string) => {\n    61→    setExpandedFolders(prev => {\n    62→      const next = new Set(prev)\n    63→      if (next.has(folder)) {\n    64→        next.delete(folder)\n    65→      } else {\n    66→        next.add(folder)\n    67→      }\n    68→      return next\n    69→    })\n    70→  }\n    71→\n    72→  const handleCreateFolder = () => {\n    73→    if (!newFolderName.trim() || !onCreateFolder) return\n    74→    onCreateFolder(newFolderName.trim())\n    75→    setNewFolderName('')\n    76→    setCreatingFolder(false)\n    77→  }\n    78→\n    79→  if (documents.length === 0) {\n    80→    return (\n    81→      <div className=\"text-center py-12\">\n    82→        <div className=\"inline-block p-4 bg-gray-100 rounded-2xl mb-4\">\n    83→          <FolderOpen className=\"w-10 h-10 text-gray-400\" />\n    84→        </div>\n    85→        <p className=\"text-gray-500 text-sm\">{emptyMessage}</p>\n    86→      </div>\n    87→    )\n    88→  }\n    89→\n    90→  return (\n    91→    <div className=\"space-y-2\">\n    92→      {/* Create folder button/input */}\n    93→      {showCreateFolder && onCreateFolder && (\n    94→        <div className=\"mb-4\">\n    95→          {creatingFolder ? (\n    96→            <div className=\"flex items-center gap-2\">\n    97→              <input\n    98→                type=\"text\"\n    99→                value={newFolderName}\n   100→                onChange={(e) => setNewFolderName(e.target.value)}\n   101→                onKeyDown={(e) => {\n   102→                  if (e.key === 'Enter') handleCreateFolder()\n   103→                  if (e.key === 'Escape') {\n   104→                    setCreatingFolder(false)\n   105→                    setNewFolderName('')\n   106→                  }\n   107→                }}\n   108→                placeholder=\"Nombre de la carpeta...\"\n   109→                className=\"flex-1 px-3 py-2 text-sm text-gray-900 placeholder-gray-400 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n   110→                autoFocus\n   111→              />\n   112→              <button\n   113→                onClick={handleCreateFolder}\n   114→                disabled={!newFolderName.trim()}\n   115→                className=\"px-3 py-2 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50\"\n   116→              >\n   117→                Crear\n   118→              </button>\n   119→              <button\n   120→                onClick={() => {\n   121→                  setCreatingFolder(false)\n   122→                  setNewFolderName('')\n   123→                }}\n   124→                className=\"p-2 text-gray-400 hover:text-gray-600\"\n   125→              >\n   126→                <X size={18} />\n   127→              </button>\n   128→            </div>\n   129→          ) : (\n   130→            <button\n   131→              onClick={() => setCreatingFolder(true)}\n   132→              className=\"flex items-center gap-2 px-3 py-2 text-sm text-gray-600 hover:text-blue-600 hover:bg-blue-50 rounded-lg transition-colors\"\n   133→            >\n   134→              <Plus size={16} />\n   135→              Nueva carpeta\n   136→            </button>\n   137→          )}\n   138→        </div>\n   139→      )}\n   140→\n   141→      {/* Folder list */}\n   142→      {sortedFolderKeys.map((folder) => {\n   143→        const docs = groupedDocs[folder]\n   144→        const isExpanded = expandedFolders.has(folder)\n   145→        const folderName = getFolderDisplayName(folder)\n   146→        const isUncategorized = folder === '__uncategorized__'\n   147→\n   148→        return (\n   149→          <div key={folder} className=\"border border-gray-100 rounded-xl\">\n   150→            {/* Folder header */}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"4328fd37-7cd5-4fb0-87a2-577b4a460161","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentFolderView.tsx","content":"'use client'\n\nimport { useState, useMemo } from 'react'\nimport { ChevronDown, ChevronRight, FolderOpen, Folder, Plus, X, Link2, FolderInput } from 'lucide-react'\nimport { Document, groupByFolder, getFolderDisplayName, getFolders } from '@/hooks/useDocuments'\n\ninterface DocumentFolderViewProps {\n  documents: Document[]\n  onFolderClick?: (folder: string | null) => void\n  onDocumentClick?: (doc: Document) => void\n  onCreateFolder?: (folderName: string) => void\n  onMoveToFolder?: (docId: string, folder: string | null) => Promise<void>\n  selectedDocIds?: Set<string>\n  onToggleDocSelection?: (docId: string) => void\n  showCreateFolder?: boolean\n  emptyMessage?: string\n  /** Additional empty folders to display (created manually but not yet used) */\n  emptyFolders?: string[]\n}\n\nexport default function DocumentFolderView({\n  documents,\n  onFolderClick,\n  onDocumentClick,\n  onCreateFolder,\n  onMoveToFolder,\n  selectedDocIds,\n  onToggleDocSelection,\n  showCreateFolder = false,\n  emptyMessage = 'No hay documentos',\n  emptyFolders = [],\n}: DocumentFolderViewProps) {\n  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set(['__uncategorized__']))\n  const [creatingFolder, setCreatingFolder] = useState(false)\n  const [newFolderName, setNewFolderName] = useState('')\n\n  // Group documents by folder\n  const groupedDocs = useMemo(() => {\n    const grouped = groupByFolder(documents)\n    // Add empty folders that don't have documents yet\n    for (const folder of emptyFolders) {\n      if (!grouped[folder]) {\n        grouped[folder] = []\n      }\n    }\n    return grouped\n  }, [documents, emptyFolders])\n  const folders = useMemo(() => getFolders(documents), [documents])\n\n  // Sort folders: named folders first (alphabetically), then uncategorized\n  const sortedFolderKeys = useMemo(() => {\n    const keys = Object.keys(groupedDocs)\n    return keys.sort((a, b) => {\n      if (a === '__uncategorized__') return 1\n      if (b === '__uncategorized__') return -1\n      return a.localeCompare(b)\n    })\n  }, [groupedDocs])\n\n  const toggleFolder = (folder: string) => {\n    setExpandedFolders(prev => {\n      const next = new Set(prev)\n      if (next.has(folder)) {\n        next.delete(folder)\n      } else {\n        next.add(folder)\n      }\n      return next\n    })\n  }\n\n  const handleCreateFolder = () => {\n    if (!newFolderName.trim() || !onCreateFolder) return\n    onCreateFolder(newFolderName.trim())\n    setNewFolderName('')\n    setCreatingFolder(false)\n  }\n\n  if (documents.length === 0) {\n    return (\n      <div className=\"text-center py-12\">\n        <div className=\"inline-block p-4 bg-gray-100 rounded-2xl mb-4\">\n          <FolderOpen className=\"w-10 h-10 text-gray-400\" />\n        </div>\n        <p className=\"text-gray-500 text-sm\">{emptyMessage}</p>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-2\">\n      {/* Create folder button/input */}\n      {showCreateFolder && onCreateFolder && (\n        <div className=\"mb-4\">\n          {creatingFolder ? (\n            <div className=\"flex items-center gap-2\">\n              <input\n                type=\"text\"\n                value={newFolderName}\n                onChange={(e) => setNewFolderName(e.target.value)}\n                onKeyDown={(e) => {\n                  if (e.key === 'Enter') handleCreateFolder()\n                  if (e.key === 'Escape') {\n                    setCreatingFolder(false)\n                    setNewFolderName('')\n                  }\n                }}\n                placeholder=\"Nombre de la carpeta...\"\n                className=\"flex-1 px-3 py-2 text-sm text-gray-900 placeholder-gray-400 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n                autoFocus\n              />\n              <button\n                onClick={handleCreateFolder}\n                disabled={!newFolderName.trim()}\n                className=\"px-3 py-2 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50\"\n              >\n                Crear\n              </button>\n              <button\n                onClick={() => {\n                  setCreatingFolder(false)\n                  setNewFolderName('')\n                }}\n                className=\"p-2 text-gray-400 hover:text-gray-600\"\n              >\n                <X size={18} />\n              </button>\n            </div>\n          ) : (\n            <button\n              onClick={() => setCreatingFolder(true)}\n              className=\"flex items-center gap-2 px-3 py-2 text-sm text-gray-600 hover:text-blue-600 hover:bg-blue-50 rounded-lg transition-colors\"\n            >\n              <Plus size={16} />\n              Nueva carpeta\n            </button>\n          )}\n        </div>\n      )}\n\n      {/* Folder list */}\n      {sortedFolderKeys.map((folder) => {\n        const docs = groupedDocs[folder]\n        const isExpanded = expandedFolders.has(folder)\n        const folderName = getFolderDisplayName(folder)\n        const isUncategorized = folder === '__uncategorized__'\n\n        return (\n          <div key={folder} className=\"border border-gray-100 rounded-xl\">\n            {/* Folder header */}","numLines":150,"startLine":1,"totalLines":420}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019BeoQsK2tGrEA9YBAugawQ","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useMemo, useRef, useEffect } from 'react'\n     4→import { Trash2, Link2, Search, Filter, FolderOpen, X, Edit2, Check, Loader2, Tag, ChevronDown, ChevronRight, Maximize2, History, FolderInput, Plus } from 'lucide-react'\n     5→import { DocCategory } from '@/types/database.types'\n     6→import { formatTokenCount } from '@/lib/supabase'\n     7→import { useModal } from '@/components/ui'\n     8→import CSVTableViewer from './CSVTableViewer'\n     9→import JSONViewer from './JSONViewer'\n    10→\n    11→type DocumentTier = 'T1' | 'T2' | 'T3'\n    12→type DocumentSourceType = 'import' | 'scraper' | 'playbook' | 'api'\n    13→\n    14→interface Document {\n    15→  id: string\n    16→  filename: string\n    17→  category: DocCategory\n    18→  description?: string\n    19→  token_count: number | null\n    20→  file_size_bytes: number | null\n    21→  created_at: string\n    22→  campaign_id?: string | null\n    23→  extracted_content?: string | null\n    24→  tags?: string[] | null\n    25→  source_type?: DocumentSourceType | string | null\n    26→  tier?: DocumentTier | null\n    27→  project_id?: string | null\n    28→  client_id?: string | null\n    29→  isShared?: boolean\n    30→  version_count?: number\n    31→  folder?: string | null\n    32→}\n    33→\n    34→interface Campaign {\n    35→  id: string\n    36→  ecp_name: string\n    37→}\n    38→\n    39→interface DocumentListProps {\n    40→  documents: Document[]\n    41→  campaigns?: Campaign[]\n    42→  onDelete: (id: string) => void\n    43→  onView: (doc: Document) => void\n    44→  onCampaignChange?: (docId: string, campaignId: string | null) => void\n    45→  onRename?: (docId: string, newName: string) => Promise<void>\n    46→  onUpdateDescription?: (docId: string, description: string) => Promise<void>\n    47→  onTierChange?: (docId: string, tier: DocumentTier) => Promise<void>\n    48→  onMoveToFolder?: (docId: string, folder: string | null) => Promise<void>\n    49→  availableFolders?: string[]\n    50→  showContextLakeFilters?: boolean\n    51→}\n    52→\n    53→const CATEGORY_STYLES: Record<string, { bg: string; text: string; icon: string }> = {\n    54→  product: { bg: 'bg-blue-50', text: 'text-blue-700', icon: '📦' },\n    55→  competitor: { bg: 'bg-purple-50', text: 'text-purple-700', icon: '🎯' },\n    56→  research: { bg: 'bg-green-50', text: 'text-green-700', icon: '🔬' },\n    57→  output: { bg: 'bg-orange-50', text: 'text-orange-700', icon: '📝' },\n    58→}\n    59→\n    60→const SOURCE_TYPE_STYLES: Record<string, { bg: string; text: string; icon: string; label: string }> = {\n    61→  import: { bg: 'bg-gray-50', text: 'text-gray-600', icon: '📥', label: 'Importado' },\n    62→  scraper: { bg: 'bg-green-50', text: 'text-green-600', icon: '🔍', label: 'Scraper' },\n    63→  playbook: { bg: 'bg-blue-50', text: 'text-blue-600', icon: '🎯', label: 'Playbook' },\n    64→  api: { bg: 'bg-purple-50', text: 'text-purple-600', icon: '🔗', label: 'API' },\n    65→  // Legacy values mapped to import\n    66→  manual: { bg: 'bg-gray-50', text: 'text-gray-600', icon: '📥', label: 'Importado' },\n    67→  upload: { bg: 'bg-gray-50', text: 'text-gray-600', icon: '📥', label: 'Importado' },\n    68→}\n    69→\n    70→const TIER_STYLES: Record<DocumentTier, { bg: string; text: string; label: string; description: string }> = {\n    71→  T1: { bg: 'bg-emerald-50', text: 'text-emerald-700', label: 'T1', description: 'Siempre incluido' },\n    72→  T2: { bg: 'bg-yellow-50', text: 'text-yellow-700', label: 'T2', description: 'Si es relevante' },\n    73→  T3: { bg: 'bg-gray-50', text: 'text-gray-500', label: 'T3', description: 'Opcional' },\n    74→}\n    75→\n    76→export default function DocumentList({\n    77→  documents,\n    78→  campaigns = [],\n    79→  onDelete,\n    80→  onView,\n    81→  onCampaignChange,\n    82→  onRename,\n    83→  onUpdateDescription,\n    84→  onTierChange,\n    85→  onMoveToFolder,\n    86→  availableFolders = [],\n    87→  showContextLakeFilters = false,\n    88→}: DocumentListProps) {\n    89→  const modal = useModal()\n    90→\n    91→  const [updatingDoc, setUpdatingDoc] = useState<string | null>(null)\n    92→  const [searchQuery, setSearchQuery] = useState('')\n    93→  const [searchInContent, setSearchInContent] = useState(false)\n    94→  const [categoryFilter, setCategoryFilter] = useState<string>('all')\n    95→  const [assignmentFilter, setAssignmentFilter] = useState<'all' | 'global' | 'assigned'>('all')\n    96→  const [tagFilter, setTagFilter] = useState<string>('all')\n    97→  const [sourceTypeFilter, setSourceTypeFilter] = useState<string>('all')\n    98→  const [tierFilter, setTierFilter] = useState<string>('all')\n    99→  const [sharedFilter, setSharedFilter] = useState<'all' | 'project' | 'shared'>('all')\n   100→\n   101→  // State for inline editing\n   102→  const [editingDocId, setEditingDocId] = useState<string | null>(null)\n   103→  const [editingName, setEditingName] = useState('')\n   104→  const [savingName, setSavingName] = useState(false)\n   105→\n   106→  // State for description editing\n   107→  const [editingDescDocId, setEditingDescDocId] = useState<string | null>(null)\n   108→  const [editingDescription, setEditingDescription] = useState('')\n   109→  const [savingDescription, setSavingDescription] = useState(false)\n   110→\n   111→  // State for expanded content\n   112→  const [expandedDocId, setExpandedDocId] = useState<string | null>(null)\n   113→\n   114→  // State for bulk selection\n   115→  const [selectedDocs, setSelectedDocs] = useState<Set<string>>(new Set())\n   116→  const [bulkDeleting, setBulkDeleting] = useState(false)\n   117→  const selectAllRef = useRef<HTMLInputElement>(null)\n   118→\n   119→  // State for folder menu\n   120→  const [folderMenuDocId, setFolderMenuDocId] = useState<string | null>(null)\n   121→  const [movingToFolder, setMovingToFolder] = useState(false)\n   122→  const [newFolderInput, setNewFolderInput] = useState('')\n   123→  const [showNewFolderInput, setShowNewFolderInput] = useState(false)\n   124→\n   125→  // Get unique categories\n   126→  const categories = useMemo(() => {\n   127→    return Array.from(new Set(documents.map(d => d.category))).sort()\n   128→  }, [documents])\n   129→\n   130→  // Get unique tags with counts\n   131→  const allTags = useMemo(() => {\n   132→    const tagCounts: Record<string, number> = {}\n   133→    documents.forEach(doc => {\n   134→      doc.tags?.forEach(tag => {\n   135→        tagCounts[tag] = (tagCounts[tag] || 0) + 1\n   136→      })\n   137→    })\n   138→    return Object.entries(tagCounts)\n   139→      .sort((a, b) => b[1] - a[1]) // Sort by count descending\n   140→      .map(([tag, count]) => ({ tag, count }))\n   141→  }, [documents])\n   142→\n   143→  // Filter documents\n   144→  const filteredDocs = useMemo(() => {\n   145→    return documents.filter(doc => {\n   146→      // Search filter\n   147→      if (searchQuery) {\n   148→        const query = searchQuery.toLowerCase()\n   149→        const matchesFilename = doc.filename.toLowerCase().includes(query)\n   150→        const matchesContent = searchInContent && doc.extracted_content?.toLowerCase().includes(query)\n   151→        const matchesTags = doc.tags?.some(tag => tag.toLowerCase().includes(query))\n   152→        if (!matchesFilename && !matchesContent && !matchesTags) {\n   153→          return false\n   154→        }\n   155→      }\n   156→      // Category filter\n   157→      if (categoryFilter !== 'all' && doc.category !== categoryFilter) {\n   158→        return false\n   159→      }\n   160→      // Tag filter\n   161→      if (tagFilter !== 'all' && !doc.tags?.includes(tagFilter)) {\n   162→        return false\n   163→      }\n   164→      // Assignment filter\n   165→      if (assignmentFilter === 'global' && doc.campaign_id) {\n   166→        return false\n   167→      }\n   168→      if (assignmentFilter === 'assigned' && !doc.campaign_id) {\n   169→        return false\n   170→      }\n   171→      // Context Lake filters\n   172→      if (sourceTypeFilter !== 'all' && doc.source_type !== sourceTypeFilter) {\n   173→        return false\n   174→      }\n   175→      if (tierFilter !== 'all' && doc.tier !== tierFilter) {\n   176→        return false\n   177→      }\n   178→      if (sharedFilter === 'project' && doc.isShared) {\n   179→        return false\n   180→      }\n   181→      if (sharedFilter === 'shared' && !doc.isShared) {\n   182→        return false\n   183→      }\n   184→      return true\n   185→    })\n   186→  }, [documents, searchQuery, searchInContent, categoryFilter, tagFilter, assignmentFilter, sourceTypeFilter, tierFilter, sharedFilter])\n   187→\n   188→  // Get content match snippet\n   189→  const getContentMatchSnippet = (content: string | null | undefined, query: string): string | null => {\n   190→    if (!content || !query) return null\n   191→    const lowerContent = content.toLowerCase()\n   192→    const lowerQuery = query.toLowerCase()\n   193→    const index = lowerContent.indexOf(lowerQuery)\n   194→    if (index === -1) return null\n   195→\n   196→    const start = Math.max(0, index - 50)\n   197→    const end = Math.min(content.length, index + query.length + 50)\n   198→    let snippet = content.substring(start, end)\n   199→    if (start > 0) snippet = '...' + snippet\n   200→    if (end < content.length) snippet = snippet + '...'\n   201→    return snippet\n   202→  }\n   203→\n   204→  const handleCampaignChange = async (docId: string, campaignId: string) => {\n   205→    if (!onCampaignChange) return\n   206→\n   207→    setUpdatingDoc(docId)\n   208→    try {\n   209→      await onCampaignChange(docId, campaignId === '' ? null : campaignId)\n   210→    } finally {\n   211→      setUpdatingDoc(null)\n   212→    }\n   213→  }\n   214→\n   215→  // Handle starting the edit mode\n   216→  const handleStartEdit = (doc: Document) => {\n   217→    setEditingDocId(doc.id)\n   218→    setEditingName(doc.filename)\n   219→  }\n   220→\n   221→  // Handle canceling the edit\n   222→  const handleCancelEdit = () => {\n   223→    setEditingDocId(null)\n   224→    setEditingName('')\n   225→  }\n   226→\n   227→  // Handle saving the new name\n   228→  const handleSaveName = async (docId: string) => {\n   229→    if (!onRename || !editingName.trim()) return\n   230→\n   231→    setSavingName(true)\n   232→    try {\n   233→      await onRename(docId, editingName.trim())\n   234→      setEditingDocId(null)\n   235→      setEditingName('')\n   236→    } catch (error) {\n   237→      console.error('Error renaming document:', error)\n   238→    } finally {\n   239→      setSavingName(false)\n   240→    }\n   241→  }\n   242→\n   243→  // Handle key press in the edit input\n   244→  const handleEditKeyDown = (e: React.KeyboardEvent, docId: string) => {\n   245→    if (e.key === 'Enter') {\n   246→      e.preventDefault()\n   247→      handleSaveName(docId)\n   248→    } else if (e.key === 'Escape') {\n   249→      handleCancelEdit()\n   250→    }\n   251→  }\n   252→\n   253→  // Handle starting description edit\n   254→  const handleStartDescEdit = (doc: Document) => {\n   255→    setEditingDescDocId(doc.id)\n   256→    setEditingDescription(doc.description || '')\n   257→  }\n   258→\n   259→  // Handle canceling description edit\n   260→  const handleCancelDescEdit = () => {\n   261→    setEditingDescDocId(null)\n   262→    setEditingDescription('')\n   263→  }\n   264→\n   265→  // Handle saving description\n   266→  const handleSaveDescription = async (docId: string) => {\n   267→    if (!onUpdateDescription) return\n   268→\n   269→    setSavingDescription(true)\n   270→    try {\n   271→      await onUpdateDescription(docId, editingDescription.trim())\n   272→      setEditingDescDocId(null)\n   273→      setEditingDescription('')\n   274→    } catch (error) {\n   275→      console.error('Error updating description:', error)\n   276→    } finally {\n   277→      setSavingDescription(false)\n   278→    }\n   279→  }\n   280→\n   281→  // Handle key press in description textarea\n   282→  const handleDescKeyDown = (e: React.KeyboardEvent, docId: string) => {\n   283→    if (e.key === 'Enter' && e.metaKey) {\n   284→      e.preventDefault()\n   285→      handleSaveDescription(docId)\n   286→    } else if (e.key === 'Escape') {\n   287→      handleCancelDescEdit()\n   288→    }\n   289→  }\n   290→\n   291→  // Handle moving document to folder\n   292→  const handleMoveToFolder = async (docId: string, folder: string | null) => {\n   293→    if (!onMoveToFolder) return\n   294→    setMovingToFolder(true)\n   295→    try {\n   296→      await onMoveToFolder(docId, folder)\n   297→      setFolderMenuDocId(null)\n   298→      setShowNewFolderInput(false)\n   299→      setNewFolderInput('')\n   300→    } catch (error) {\n   301→      console.error('Error moving to folder:', error)\n   302→    } finally {\n   303→      setMovingToFolder(false)\n   304→    }\n   305→  }\n   306→\n   307→  // Handle creating new folder and moving doc to it\n   308→  const handleCreateFolderAndMove = async (docId: string) => {\n   309→    if (!newFolderInput.trim()) return\n   310→    await handleMoveToFolder(docId, newFolderInput.trim())\n   311→  }\n   312→\n   313→  const getCategoryBadge = (category: DocCategory) => {\n   314→    const style = CATEGORY_STYLES[category] || { bg: 'bg-gray-50', text: 'text-gray-700', icon: '🏷️' }\n   315→    const label = category.charAt(0).toUpperCase() + category.slice(1)\n   316→\n   317→    return (\n   318→      <span className={`inline-flex items-center gap-1 px-1.5 py-0.5 rounded text-[10px] font-medium ${style.bg} ${style.text}`}>\n   319→        <span className=\"text-[10px]\">{style.icon}</span>\n   320→        {label}\n   321→      </span>\n   322→    )\n   323→  }\n   324→\n   325→  // Detect content type for inline viewer\n   326→  const getContentType = (content: string | null | undefined): 'json' | 'csv' | 'text' => {\n   327→    if (!content) return 'text'\n   328→    const trimmed = content.trim()\n   329→    const firstLine = content.split('\\n')[0] || ''\n   330→\n   331→    // Check if JSON\n   332→    if (trimmed.startsWith('[') || trimmed.startsWith('{')) {\n   333→      try {\n   334→        JSON.parse(trimmed)\n   335→        return 'json'\n   336→      } catch {\n   337→        if ((trimmed.startsWith('[') && trimmed.includes(']')) ||\n   338→            (trimmed.startsWith('{') && trimmed.includes('}'))) {\n   339→          return 'json'\n   340→        }\n   341→      }\n   342→    }\n   343→\n   344→    // Check if CSV\n   345→    if (firstLine.includes(',') && firstLine.split(',').length >= 3) {\n   346→      return 'csv'\n   347→    }\n   348→\n   349→    return 'text'\n   350→  }\n   351→\n   352→  const toggleExpand = (docId: string) => {\n   353→    setExpandedDocId(expandedDocId === docId ? null : docId)\n   354→  }\n   355→\n   356→  // Handle select all checkbox indeterminate state\n   357→  useEffect(() => {\n   358→    if (selectAllRef.current) {\n   359→      const allSelected = selectedDocs.size === filteredDocs.length && filteredDocs.length > 0\n   360→      const someSelected = selectedDocs.size > 0 && selectedDocs.size < filteredDocs.length\n   361→      selectAllRef.current.indeterminate = someSelected\n   362→      selectAllRef.current.checked = allSelected\n   363→    }\n   364→  }, [selectedDocs.size, filteredDocs.length])\n   365→\n   366→  // Toggle selection for a document\n   367→  const toggleDocSelection = (docId: string, event: React.MouseEvent) => {\n   368→    event.stopPropagation()\n   369→    const newSelected = new Set(selectedDocs)\n   370→    if (newSelected.has(docId)) {\n   371→      newSelected.delete(docId)\n   372→    } else {\n   373→      newSelected.add(docId)\n   374→    }\n   375→    setSelectedDocs(newSelected)\n   376→  }\n   377→\n   378→  // Toggle select all\n   379→  const toggleSelectAll = () => {\n   380→    if (selectedDocs.size === filteredDocs.length) {\n   381→      setSelectedDocs(new Set())\n   382→    } else {\n   383→      setSelectedDocs(new Set(filteredDocs.map(d => d.id)))\n   384→    }\n   385→  }\n   386→\n   387→  // Handle bulk delete\n   388→  const handleBulkDelete = async () => {\n   389→    const confirmed = await modal.confirm({\n   390→      title: 'Eliminar documentos',\n   391→      message: `¿Eliminar ${selectedDocs.size} documento(s)? Esta acción no se puede deshacer.`,\n   392→      confirmText: 'Eliminar todos',\n   393→      cancelText: 'Cancelar',\n   394→      variant: 'danger',\n   395→    })\n   396→\n   397→    if (confirmed) {\n   398→      setBulkDeleting(true)\n   399→      try {\n   400→        for (const docId of selectedDocs) {\n   401→          await onDelete(docId)\n   402→        }\n   403→        setSelectedDocs(new Set())\n   404→      } finally {\n   405→        setBulkDeleting(false)\n   406→      }\n   407→    }\n   408→  }\n   409→\n   410→  if (documents.length === 0) {\n   411→    return (\n   412→      <div className=\"text-center py-16\">\n   413→        <div className=\"inline-block p-4 bg-gray-100 rounded-2xl mb-4\">\n   414→          <FolderOpen className=\"w-12 h-12 text-gray-400\" />\n   415→        </div>\n   416→        <h3 className=\"text-lg font-medium text-gray-900 mb-1\">No hay documentos</h3>\n   417→        <p className=\"text-gray-500 text-sm\">\n   418→          Sube PDFs o DOCX con información de producto, competidores o research\n   419→        </p>\n   420→      </div>\n   421→    )\n   422→  }\n   423→\n   424→  return (\n   425→    <div className=\"space-y-4\">\n   426→      {/* Search and Filters */}\n   427→      <div className=\"flex flex-wrap items-center gap-3\">\n   428→        {/* Search */}\n   429→        <div className=\"flex-1 min-w-[200px]\">\n   430→          <div className=\"relative\">\n   431→            <Search size={18} className=\"absolute left-4 top-1/2 -translate-y-1/2 text-gray-400\" />\n   432→            <input\n   433→              type=\"text\"\n   434→              value={searchQuery}\n   435→              onChange={(e) => setSearchQuery(e.target.value)}\n   436→              placeholder={searchInContent ? \"Buscar en nombre y contenido...\" : \"Buscar por nombre...\"}\n   437→              className=\"w-full pl-11 pr-4 py-2.5 border border-gray-200 rounded-xl text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900 placeholder:text-gray-400\"\n   438→            />\n   439→            {searchQuery && (\n   440→              <button\n   441→                onClick={() => setSearchQuery('')}\n   442→                className=\"absolute right-3 top-1/2 -translate-y-1/2 p-1 text-gray-400 hover:text-gray-600\"\n   443→              >\n   444→                <X size={16} />\n   445→              </button>\n   446→            )}\n   447→          </div>\n   448→          <label className=\"flex items-center gap-2 mt-2 cursor-pointer\">\n   449→            <input\n   450→              type=\"checkbox\"\n   451→              checked={searchInContent}\n   452→              onChange={(e) => setSearchInContent(e.target.checked)}\n   453→              className=\"w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500\"\n   454→            />\n   455→            <span className=\"text-xs text-gray-500\">Buscar dentro del contenido</span>\n   456→          </label>\n   457→        </div>\n   458→\n   459→        {/* Category Filter */}\n   460→        <div className=\"flex items-center gap-2\">\n   461→          <Filter size={16} className=\"text-gray-400\" />\n   462→          <select\n   463→            value={categoryFilter}\n   464→            onChange={(e) => setCategoryFilter(e.target.value)}\n   465→            className=\"px-3 py-2.5 border border-gray-200 rounded-xl text-sm text-gray-700 bg-white focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n   466→          >\n   467→            <option value=\"all\">Todas ({documents.length})</option>\n   468→            {categories.map(cat => {\n   469→              const count = documents.filter(d => d.category === cat).length\n   470→              const style = CATEGORY_STYLES[cat]\n   471→              return (\n   472→                <option key={cat} value={cat}>\n   473→                  {style?.icon || '🏷️'} {cat} ({count})\n   474→                </option>\n   475→              )\n   476→            })}\n   477→          </select>\n   478→        </div>\n   479→\n   480→        {/* Tag Filter */}\n   481→        {allTags.length > 0 && (\n   482→          <div className=\"flex items-center gap-2\">\n   483→            <Tag size={16} className=\"text-gray-400\" />\n   484→            <select\n   485→              value={tagFilter}\n   486→              onChange={(e) => setTagFilter(e.target.value)}\n   487→              className=\"px-3 py-2.5 border border-gray-200 rounded-xl text-sm text-gray-700 bg-white focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n   488→            >\n   489→              <option value=\"all\">Tags: Todos</option>\n   490→              {allTags.map(({ tag, count }) => (\n   491→                <option key={tag} value={tag}>\n   492→                  {tag} ({count})\n   493→                </option>\n   494→              ))}\n   495→            </select>\n   496→          </div>\n   497→        )}\n   498→\n   499→        {/* Assignment Filter */}\n   500→        {campaigns.length > 0 && (\n   501→          <div className=\"flex items-center gap-1 bg-gray-100 rounded-xl p-1\">\n   502→            {[\n   503→              { value: 'all', label: 'Todos' },\n   504→              { value: 'global', label: 'Globales' },\n   505→              { value: 'assigned', label: 'Asignados' },\n   506→            ].map((filter) => (\n   507→              <button\n   508→                key={filter.value}\n   509→                onClick={() => setAssignmentFilter(filter.value as typeof assignmentFilter)}\n   510→                className={`px-3 py-1.5 text-xs font-medium rounded-lg transition-all ${\n   511→                  assignmentFilter === filter.value\n   512→                    ? 'bg-white text-gray-900 shadow-sm'\n   513→                    : 'text-gray-600 hover:text-gray-900'\n   514→                }`}\n   515→              >\n   516→                {filter.label}\n   517→              </button>\n   518→            ))}\n   519→          </div>\n   520→        )}\n   521→      </div>\n   522→\n   523→      {/* Context Lake Filters */}\n   524→      {showContextLakeFilters && (\n   525→        <div className=\"flex flex-wrap items-center gap-3 pt-2 border-t border-gray-100\">\n   526→          {/* Source Type Filter */}\n   527→          <div className=\"flex items-center gap-2\">\n   528→            <span className=\"text-xs text-gray-500\">Origen:</span>\n   529→            <select\n   530→              value={sourceTypeFilter}\n   531→              onChange={(e) => setSourceTypeFilter(e.target.value)}\n   532→              className=\"px-2 py-1.5 border border-gray-200 rounded-lg text-xs text-gray-700 bg-white focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n   533→            >\n   534→              <option value=\"all\">Todos</option>\n   535→              {Object.entries(SOURCE_TYPE_STYLES).map(([key, style]) => (\n   536→                <option key={key} value={key}>\n   537→                  {style.icon} {style.label}\n   538→                </option>\n   539→              ))}\n   540→            </select>\n   541→          </div>\n   542→\n   543→          {/* Tier Filter */}\n   544→          <div className=\"flex items-center gap-2\">\n   545→            <span className=\"text-xs text-gray-500\">Tier:</span>\n   546→            <div className=\"flex items-center gap-1 bg-gray-100 rounded-lg p-0.5\">\n   547→              <button\n   548→                onClick={() => setTierFilter('all')}\n   549→                className={`px-2 py-1 text-xs font-medium rounded transition-all ${\n   550→                  tierFilter === 'all' ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-600 hover:text-gray-900'\n   551→                }`}\n   552→              >\n   553→                Todos\n   554→              </button>\n   555→              {(['T1', 'T2', 'T3'] as DocumentTier[]).map((tier) => {\n   556→                const style = TIER_STYLES[tier]\n   557→                return (\n   558→                  <button\n   559→                    key={tier}\n   560→                    onClick={() => setTierFilter(tier)}\n   561→                    title={style.description}\n   562→                    className={`px-2 py-1 text-xs font-medium rounded transition-all ${\n   563→                      tierFilter === tier ? `${style.bg} ${style.text} shadow-sm` : 'text-gray-600 hover:text-gray-900'\n   564→                    }`}\n   565→                  >\n   566→                    {tier}\n   567→                  </button>\n   568→                )\n   569→              })}\n   570→            </div>\n   571→          </div>\n   572→\n   573→          {/* Shared/Project Filter */}\n   574→          <div className=\"flex items-center gap-1 bg-gray-100 rounded-lg p-0.5\">\n   575→            {[\n   576→              { value: 'all', label: 'Todo' },\n   577→              { value: 'project', label: '📁 Proyecto' },\n   578→              { value: 'shared', label: '🔗 Compartido' },\n   579→            ].map((filter) => (\n   580→              <button\n   581→                key={filter.value}\n   582→                onClick={() => setSharedFilter(filter.value as typeof sharedFilter)}\n   583→                className={`px-2 py-1 text-xs font-medium rounded transition-all ${\n   584→                  sharedFilter === filter.value ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-600 hover:text-gray-900'\n   585→                }`}\n   586→              >\n   587→                {filter.label}\n   588→              </button>\n   589→            ))}\n   590→          </div>\n   591→        </div>\n   592→      )}\n   593→\n   594→      {/* Results count */}\n   595→      {(searchQuery || categoryFilter !== 'all' || tagFilter !== 'all' || assignmentFilter !== 'all' || sourceTypeFilter !== 'all' || tierFilter !== 'all' || sharedFilter !== 'all') && (\n   596→        <div className=\"flex items-center justify-between text-sm text-gray-500\">\n   597→          <span>\n   598→            Mostrando {filteredDocs.length} de {documents.length} documentos\n   599→            {searchQuery && (\n   600→              <span className=\"ml-1\">\n   601→                para &quot;{searchQuery}&quot;\n   602→                {searchInContent && <span className=\"text-blue-600 ml-1\">(en contenido)</span>}\n   603→              </span>\n   604→            )}\n   605→            {tagFilter !== 'all' && (\n   606→              <span className=\"ml-1\">\n   607→                con tag <span className=\"bg-purple-100 text-purple-700 px-1.5 py-0.5 rounded text-xs\">{tagFilter}</span>\n   608→              </span>\n   609→            )}\n   610→            {tierFilter !== 'all' && (\n   611→              <span className=\"ml-1\">\n   612→                tier <span className={`${TIER_STYLES[tierFilter as DocumentTier]?.bg} ${TIER_STYLES[tierFilter as DocumentTier]?.text} px-1.5 py-0.5 rounded text-xs`}>{tierFilter}</span>\n   613→              </span>\n   614→            )}\n   615→          </span>\n   616→          <button\n   617→            onClick={() => {\n   618→              setSearchQuery('')\n   619→              setCategoryFilter('all')\n   620→              setTagFilter('all')\n   621→              setAssignmentFilter('all')\n   622→              setSourceTypeFilter('all')\n   623→              setTierFilter('all')\n   624→              setSharedFilter('all')\n   625→            }}\n   626→            className=\"text-blue-600 hover:text-blue-700 font-medium\"\n   627→          >\n   628→            Limpiar filtros\n   629→          </button>\n   630→        </div>\n   631→      )}\n   632→\n   633→      {/* Bulk Actions Toolbar */}\n   634→      {selectedDocs.size > 0 && (\n   635→        <div className=\"flex items-center gap-3 p-3 bg-blue-50 border border-blue-200 rounded-xl\">\n   636→          <span className=\"text-sm font-medium text-blue-700\">\n   637→            {selectedDocs.size} documento(s) seleccionado(s)\n   638→          </span>\n   639→          <button\n   640→            onClick={handleBulkDelete}\n   641→            disabled={bulkDeleting}\n   642→            className=\"px-3 py-1.5 text-xs bg-red-600 text-white rounded-lg hover:bg-red-700 disabled:opacity-50 inline-flex items-center gap-1.5 font-medium\"\n   643→          >\n   644→            {bulkDeleting ? <Loader2 size={14} className=\"animate-spin\" /> : <Trash2 size={14} />}\n   645→            Eliminar seleccionados\n   646→          </button>\n   647→          <button\n   648→            onClick={() => setSelectedDocs(new Set())}\n   649→            className=\"px-3 py-1.5 text-xs text-gray-600 hover:bg-white/50 rounded-lg font-medium\"\n   650→          >\n   651→            Cancelar selección\n   652→          </button>\n   653→        </div>\n   654→      )}\n   655→\n   656→      {/* Select All Header */}\n   657→      {filteredDocs.length > 0 && (\n   658→        <div className=\"flex items-center gap-2 px-1\">\n   659→          <input\n   660→            ref={selectAllRef}\n   661→            type=\"checkbox\"\n   662→            onChange={toggleSelectAll}\n   663→            className=\"w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500 cursor-pointer\"\n   664→          />\n   665→          <span className=\"text-xs text-gray-500\">\n   666→            {selectedDocs.size > 0\n   667→              ? `${selectedDocs.size} de ${filteredDocs.length} seleccionados`\n   668→              : 'Seleccionar todos'}\n   669→          </span>\n   670→        </div>\n   671→      )}\n   672→\n   673→      {/* Document List */}\n   674→      {filteredDocs.length === 0 ? (\n   675→        <div className=\"text-center py-12\">\n   676→          <Search className=\"w-10 h-10 text-gray-300 mx-auto mb-3\" />\n   677→          <p className=\"text-gray-500\">No hay documentos que coincidan</p>\n   678→          <button\n   679→            onClick={() => {\n   680→              setSearchQuery('')\n   681→              setCategoryFilter('all')\n   682→              setTagFilter('all')\n   683→              setAssignmentFilter('all')\n   684→              setSourceTypeFilter('all')\n   685→              setTierFilter('all')\n   686→              setSharedFilter('all')\n   687→            }}\n   688→            className=\"mt-2 text-blue-600 hover:text-blue-700 text-sm font-medium\"\n   689→          >\n   690→            Limpiar filtros\n   691→          </button>\n   692→        </div>\n   693→      ) : (\n   694→        <div className=\"space-y-2\">\n   695→          {filteredDocs.map((doc) => {\n   696→            const isExpanded = expandedDocId === doc.id\n   697→            const contentType = getContentType(doc.extracted_content)\n   698→\n   699→            return (\n   700→              <div\n   701→                key={doc.id}\n   702→                className={`group bg-white border rounded-xl transition-all ${\n   703→                  isExpanded ? 'border-blue-200 shadow-sm' : 'border-gray-100 hover:border-blue-200 hover:shadow-sm'\n   704→                }`}\n   705→              >\n   706→                {/* Main row - single line layout */}\n   707→                <div\n   708→                  className=\"flex items-center gap-3 px-3 py-2.5 cursor-pointer\"\n   709→                  onClick={() => toggleExpand(doc.id)}\n   710→                >\n   711→                  {/* Selection checkbox */}\n   712→                  <input\n   713→                    type=\"checkbox\"\n   714→                    checked={selectedDocs.has(doc.id)}\n   715→                    onChange={() => {}}\n   716→                    onClick={(e) => toggleDocSelection(doc.id, e)}\n   717→                    className=\"w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500 flex-shrink-0 cursor-pointer\"\n   718→                  />\n   719→\n   720→                  {/* Expand chevron */}\n   721→                  <div className=\"flex-shrink-0 text-gray-400\">\n   722→                    {isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />}\n   723→                  </div>\n   724→\n   725→                  {/* Title & Badges */}\n   726→                  <div className=\"flex-1 min-w-0 flex items-center gap-2\">\n   727→                    {editingDocId === doc.id ? (\n   728→                      <div className=\"flex items-center gap-2 flex-1\" onClick={(e) => e.stopPropagation()}>\n   729→                        <input\n   730→                          type=\"text\"\n   731→                          value={editingName}\n   732→                          onChange={(e) => setEditingName(e.target.value)}\n   733→                          onKeyDown={(e) => handleEditKeyDown(e, doc.id)}\n   734→                          className=\"flex-1 px-2 py-1 text-sm border border-blue-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900\"\n   735→                          autoFocus\n   736→                          disabled={savingName}\n   737→                        />\n   738→                        <button\n   739→                          onClick={() => handleSaveName(doc.id)}\n   740→                          disabled={savingName || !editingName.trim()}\n   741→                          className=\"p-1 text-green-600 hover:bg-green-50 rounded disabled:opacity-50 disabled:cursor-not-allowed\"\n   742→                          title=\"Guardar\"\n   743→                        >\n   744→                          {savingName ? <Loader2 size={14} className=\"animate-spin\" /> : <Check size={14} />}\n   745→                        </button>\n   746→                        <button\n   747→                          onClick={handleCancelEdit}\n   748→                          disabled={savingName}\n   749→                          className=\"p-1 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded disabled:opacity-50\"\n   750→                          title=\"Cancelar\"\n   751→                        >\n   752→                          <X size={14} />\n   753→                        </button>\n   754→                      </div>\n   755→                    ) : (\n   756→                      <>\n   757→                        <h3 className=\"font-medium text-sm text-gray-900 truncate group-hover:text-blue-600 transition-colors\">\n   758→                          {doc.filename}\n   759→                        </h3>\n   760→                        {onRename && (\n   761→                          <button\n   762→                            onClick={(e) => { e.stopPropagation(); handleStartEdit(doc) }}\n   763→                            className=\"p-0.5 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded opacity-0 group-hover:opacity-100 transition-all flex-shrink-0\"\n   764→                            title=\"Editar nombre\"\n   765→                          >\n   766→                            <Edit2 size={12} />\n   767→                          </button>\n   768→                        )}\n   769→                      </>\n   770→                    )}\n   771→                  </div>\n   772→\n   773→                  {/* Inline badges */}\n   774→                  <div className=\"flex items-center gap-1.5 flex-shrink-0\">\n   775→                    {/* Shared badge */}\n   776→                    {doc.isShared && (\n   777→                      <span className=\"inline-flex items-center gap-0.5 px-1.5 py-0.5 rounded text-[10px] font-medium bg-indigo-50 text-indigo-600\" title=\"Documento compartido del cliente\">\n   778→                        🔗\n   779→                      </span>\n   780→                    )}\n   781→                    {/* Tier badge */}\n   782→                    {doc.tier && onTierChange ? (\n   783→                      <select\n   784→                        value={doc.tier}\n   785→                        onChange={async (e) => {\n   786→                          e.stopPropagation()\n   787→                          await onTierChange(doc.id, e.target.value as DocumentTier)\n   788→                        }}\n   789→                        onClick={(e) => e.stopPropagation()}\n   790→                        className={`px-1.5 py-0.5 rounded text-[10px] font-medium border-0 cursor-pointer ${TIER_STYLES[doc.tier as DocumentTier]?.bg || 'bg-gray-50'} ${TIER_STYLES[doc.tier as DocumentTier]?.text || 'text-gray-600'}`}\n   791→                        title={TIER_STYLES[doc.tier as DocumentTier]?.description}\n   792→                      >\n   793→                        <option value=\"T1\">T1</option>\n   794→                        <option value=\"T2\">T2</option>\n   795→                        <option value=\"T3\">T3</option>\n   796→                      </select>\n   797→                    ) : doc.tier && (\n   798→                      <span\n   799→                        className={`inline-flex items-center px-1.5 py-0.5 rounded text-[10px] font-medium ${TIER_STYLES[doc.tier as DocumentTier]?.bg || 'bg-gray-50'} ${TIER_STYLES[doc.tier as DocumentTier]?.text || 'text-gray-600'}`}\n   800→                        title={TIER_STYLES[doc.tier as DocumentTier]?.description}\n   801→                      >\n   802→                        {doc.tier}\n   803→                      </span>\n   804→                    )}\n   805→                    {/* Source type badge - ALWAYS shown */}\n   806→                    <span\n   807→                      className={`inline-flex items-center gap-0.5 px-1.5 py-0.5 rounded text-[10px] font-medium ${\n   808→                        doc.source_type\n   809→                          ? (SOURCE_TYPE_STYLES[doc.source_type]?.bg || 'bg-gray-50')\n   810→                          : 'bg-gray-50'\n   811→                      } ${\n   812→                        doc.source_type\n   813→                          ? (SOURCE_TYPE_STYLES[doc.source_type]?.text || 'text-gray-600')\n   814→                          : 'text-gray-600'\n   815→                      }`}\n   816→                      title={`Origen: ${doc.source_type ? (SOURCE_TYPE_STYLES[doc.source_type]?.label || doc.source_type) : 'Importado'}`}\n   817→                    >\n   818→                      <span>{doc.source_type ? (SOURCE_TYPE_STYLES[doc.source_type]?.icon || '📥') : '📥'}</span>\n   819→                      {doc.source_type ? (SOURCE_TYPE_STYLES[doc.source_type]?.label || doc.source_type) : 'Importado'}\n   820→                    </span>\n   821→                    {/* Version indicator */}\n   822→                    {doc.version_count && doc.version_count > 1 && (\n   823→                      <span\n   824→                        className=\"inline-flex items-center gap-0.5 px-1.5 py-0.5 rounded text-[10px] font-medium bg-amber-50 text-amber-700\"\n   825→                        title={`${doc.version_count} versiones disponibles`}\n   826→                      >\n   827→                        <History size={10} />\n   828→                        v{doc.version_count}\n   829→                      </span>\n   830→                    )}\n   831→                    {getCategoryBadge(doc.category)}\n   832→                    {doc.token_count && (\n   833→                      <span className=\"text-xs text-gray-400 whitespace-nowrap\">\n   834→                        {formatTokenCount(doc.token_count)}\n   835→                      </span>\n   836→                    )}\n   837→                  </div>\n   838→\n   839→                  {/* Tags inline */}\n   840→                  {doc.tags && doc.tags.length > 0 && (\n   841→                    <div className=\"hidden sm:flex items-center gap-1 flex-shrink-0\" onClick={(e) => e.stopPropagation()}>\n   842→                      {doc.tags.slice(0, 3).map((tag, idx) => (\n   843→                        <button\n   844→                          key={idx}\n   845→                          onClick={() => setTagFilter(tag)}\n   846→                          className={`px-1.5 py-0.5 text-[10px] rounded-full transition-colors ${\n   847→                            tagFilter === tag\n   848→                              ? 'bg-purple-600 text-white'\n   849→                              : 'bg-purple-50 text-purple-600 hover:bg-purple-100'\n   850→                          }`}\n   851→                          title={`Filtrar por \"${tag}\"`}\n   852→                        >\n   853→                          {tag}\n   854→                        </button>\n   855→                      ))}\n   856→                      {doc.tags.length > 3 && (\n   857→                        <span className=\"text-[10px] text-gray-400\">+{doc.tags.length - 3}</span>\n   858→                      )}\n   859→                    </div>\n   860→                  )}\n   861→\n   862→                  {/* Campaign dropdown - compact */}\n   863→                  {campaigns.length > 0 && onCampaignChange && (\n   864→                    <div className=\"hidden md:flex items-center gap-1.5 flex-shrink-0\" onClick={(e) => e.stopPropagation()}>\n   865→                      <Link2 size={12} className=\"text-gray-300\" />\n   866→                      <select\n   867→                        value={doc.campaign_id || ''}\n   868→                        onChange={(e) => handleCampaignChange(doc.id, e.target.value)}\n   869→                        disabled={updatingDoc === doc.id}\n   870→                        className=\"text-xs border border-gray-200 rounded-lg px-2 py-1 text-gray-600 bg-white focus:ring-1 focus:ring-blue-500 disabled:bg-gray-50 max-w-[180px] truncate\"\n   871→                      >\n   872→                        <option value=\"\">Documento global (todas las campañas)</option>\n   873→                        {campaigns.map(campaign => (\n   874→                          <option key={campaign.id} value={campaign.id}>\n   875→                            {campaign.ecp_name}\n   876→                          </option>\n   877→                        ))}\n   878→                      </select>\n   879→                      {updatingDoc === doc.id && <Loader2 size={12} className=\"text-gray-400 animate-spin\" />}\n   880→                    </div>\n   881→                  )}\n   882→\n   883→                  {/* Actions */}\n   884→                  <div className=\"flex items-center gap-0.5 flex-shrink-0\" onClick={(e) => e.stopPropagation()}>\n   885→                    {/* Move to folder */}\n   886→                    {onMoveToFolder && (\n   887→                      <div className=\"relative\">\n   888→                        <button\n   889→                          onClick={() => setFolderMenuDocId(folderMenuDocId === doc.id ? null : doc.id)}\n   890→                          className=\"p-1.5 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg transition-colors\"\n   891→                          title=\"Mover a carpeta\"\n   892→                        >\n   893→                          <FolderInput size={16} />\n   894→                        </button>\n   895→                        {folderMenuDocId === doc.id && (\n   896→                          <div className=\"absolute right-0 top-8 z-50 w-56 bg-white rounded-xl shadow-lg border border-gray-200 py-2\">\n   897→                            <div className=\"px-3 py-1.5 text-xs font-medium text-gray-500 border-b border-gray-100 mb-1\">\n   898→                              Mover a carpeta\n   899→                            </div>\n   900→                            {/* Current folder indicator */}\n   901→                            {doc.folder && (\n   902→                              <div className=\"px-3 py-1 text-xs text-gray-400 italic\">\n   903→                                Actual: {doc.folder}\n   904→                              </div>\n   905→                            )}\n   906→                            {/* Remove from folder option */}\n   907→                            {doc.folder && (\n   908→                              <button\n   909→                                onClick={() => handleMoveToFolder(doc.id, null)}\n   910→                                disabled={movingToFolder}\n   911→                                className=\"w-full px-3 py-2 text-left text-sm text-gray-600 hover:bg-gray-50 flex items-center gap-2 disabled:opacity-50\"\n   912→                              >\n   913→                                <X size={14} className=\"text-gray-400\" />\n   914→                                Sin carpeta\n   915→                              </button>\n   916→                            )}\n   917→                            {/* Existing folders */}\n   918→                            {availableFolders.filter(f => f !== doc.folder).map(folder => (\n   919→                              <button\n   920→                                key={folder}\n   921→                                onClick={() => handleMoveToFolder(doc.id, folder)}\n   922→                                disabled={movingToFolder}\n   923→                                className=\"w-full px-3 py-2 text-left text-sm text-gray-700 hover:bg-indigo-50 flex items-center gap-2 disabled:opacity-50\"\n   924→                              >\n   925→                                <FolderOpen size={14} className=\"text-indigo-500\" />\n   926→                                {folder}\n   927→                              </button>\n   928→                            ))}\n   929→                            {/* New folder input */}\n   930→                            {showNewFolderInput ? (\n   931→                              <div className=\"px-2 py-2 border-t border-gray-100 mt-1\">\n   932→                                <input\n   933→                                  type=\"text\"\n   934→                                  value={newFolderInput}\n   935→                                  onChange={(e) => setNewFolderInput(e.target.value)}\n   936→                                  onKeyDown={(e) => {\n   937→                                    if (e.key === 'Enter') handleCreateFolderAndMove(doc.id)\n   938→                                    if (e.key === 'Escape') {\n   939→                                      setShowNewFolderInput(false)\n   940→                                      setNewFolderInput('')\n   941→                                    }\n   942→                                  }}\n   943→                                  placeholder=\"Nombre de carpeta...\"\n   944→                                  className=\"w-full px-2 py-1.5 text-sm text-gray-900 placeholder-gray-400 border border-gray-200 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent\"\n   945→                                  autoFocus\n   946→                                />\n   947→                                <div className=\"flex gap-1 mt-1.5\">\n   948→                                  <button\n   949→                                    onClick={() => handleCreateFolderAndMove(doc.id)}\n   950→                                    disabled={!newFolderInput.trim() || movingToFolder}\n   951→                                    className=\"flex-1 px-2 py-1 text-xs bg-indigo-600 text-white rounded hover:bg-indigo-700 disabled:opacity-50\"\n   952→                                  >\n   953→                                    {movingToFolder ? 'Moviendo...' : 'Crear y mover'}\n   954→                                  </button>\n   955→                                  <button\n   956→                                    onClick={() => {\n   957→                                      setShowNewFolderInput(false)\n   958→                                      setNewFolderInput('')\n   959→                                    }}\n   960→                                    className=\"px-2 py-1 text-xs text-gray-500 hover:bg-gray-100 rounded\"\n   961→                                  >\n   962→                                    Cancelar\n   963→                                  </button>\n   964→                                </div>\n   965→                              </div>\n   966→                            ) : (\n   967→                              <button\n   968→                                onClick={() => setShowNewFolderInput(true)}\n   969→                                className=\"w-full px-3 py-2 text-left text-sm text-indigo-600 hover:bg-indigo-50 flex items-center gap-2 border-t border-gray-100 mt-1\"\n   970→                              >\n   971→                                <Plus size={14} />\n   972→                                Nueva carpeta...\n   973→                              </button>\n   974→                            )}\n   975→                            {/* Close button */}\n   976→                            <button\n   977→                              onClick={() => {\n   978→                                setFolderMenuDocId(null)\n   979→                                setShowNewFolderInput(false)\n   980→                                setNewFolderInput('')\n   981→                              }}\n   982→                              className=\"w-full px-3 py-1.5 text-xs text-gray-400 hover:text-gray-600 border-t border-gray-100 mt-1\"\n   983→                            >\n   984→                              Cerrar\n   985→                            </button>\n   986→                          </div>\n   987→                        )}\n   988→                      </div>\n   989→                    )}\n   990→                    <button\n   991→                      onClick={() => onView(doc)}\n   992→                      className=\"p-1.5 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded-lg transition-colors\"\n   993→                      title=\"Abrir en pantalla completa\"\n   994→                    >\n   995→                      <Maximize2 size={16} />\n   996→                    </button>\n   997→                    <button\n   998→                      onClick={async () => {\n   999→                        const confirmed = await modal.confirm({\n  1000→                          title: 'Eliminar documento',\n  1001→                          message: `¿Eliminar \"${doc.filename}\"? Esta acción no se puede deshacer.`,\n  1002→                          confirmText: 'Eliminar',\n  1003→                          cancelText: 'Cancelar',\n  1004→                          variant: 'danger',\n  1005→                        })\n  1006→                        if (confirmed) {\n  1007→                          onDelete(doc.id)\n  1008→                        }\n  1009→                      }}\n  1010→                      className=\"p-1.5 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-lg transition-colors\"\n  1011→                      title=\"Eliminar\"\n  1012→                    >\n  1013→                      <Trash2 size={16} />\n  1014→                    </button>\n  1015→                  </div>\n  1016→                </div>\n  1017→\n  1018→                {/* Description row - only when exists, compact */}\n  1019→                {editingDescDocId === doc.id ? (\n  1020→                  <div className=\"mt-2 ml-8 px-3 pb-3 space-y-1.5\">\n  1021→                    <textarea\n  1022→                      value={editingDescription}\n  1023→                      onChange={(e) => setEditingDescription(e.target.value)}\n  1024→                      onKeyDown={(e) => handleDescKeyDown(e, doc.id)}\n  1025→                      placeholder=\"Describe el contenido del documento...\"\n  1026→                      rows={2}\n  1027→                      className=\"w-full px-2 py-1.5 text-xs border border-blue-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900 placeholder:text-gray-400 resize-none\"\n  1028→                      autoFocus\n  1029→                      disabled={savingDescription}\n  1030→                    />\n  1031→                    <div className=\"flex items-center gap-2\">\n  1032→                      <button\n  1033→                        onClick={() => handleSaveDescription(doc.id)}\n  1034→                        disabled={savingDescription}\n  1035→                        className=\"px-2 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 inline-flex items-center gap-1\"\n  1036→                      >\n  1037→                        {savingDescription ? <Loader2 size={10} className=\"animate-spin\" /> : <Check size={10} />}\n  1038→                        Guardar\n  1039→                      </button>\n  1040→                      <button\n  1041→                        onClick={handleCancelDescEdit}\n  1042→                        disabled={savingDescription}\n  1043→                        className=\"px-2 py-1 text-xs text-gray-500 hover:bg-gray-100 rounded disabled:opacity-50\"\n  1044→                      >\n  1045→                        Cancelar\n  1046→                      </button>\n  1047→                    </div>\n  1048→                  </div>\n  1049→                ) : doc.description && !isExpanded ? (\n  1050→                  <div className=\"ml-8 px-3 pb-2 group/desc\">\n  1051→                    <p className=\"text-xs text-gray-500 truncate max-w-2xl\">\n  1052→                      {doc.description}\n  1053→                      {onUpdateDescription && (\n  1054→                        <button\n  1055→                          onClick={() => handleStartDescEdit(doc)}\n  1056→                          className=\"ml-1.5 text-gray-400 hover:text-blue-600 opacity-0 group-hover/desc:opacity-100 transition-opacity\"\n  1057→                          title=\"Editar descripcion\"\n  1058→                        >\n  1059→                          <Edit2 size={10} className=\"inline\" />\n  1060→                        </button>\n  1061→                      )}\n  1062→                    </p>\n  1063→                  </div>\n  1064→                ) : onUpdateDescription && !isExpanded ? (\n  1065→                  <button\n  1066→                    onClick={() => handleStartDescEdit(doc)}\n  1067→                    className=\"ml-8 px-3 pb-2 text-[10px] text-gray-400 hover:text-blue-600\"\n  1068→                  >\n  1069→                    + Descripción\n  1070→                  </button>\n  1071→                ) : null}\n  1072→\n  1073→                {/* Content match snippet - only when searching */}\n  1074→                {searchInContent && searchQuery && !isExpanded && (() => {\n  1075→                  const snippet = getContentMatchSnippet(doc.extracted_content, searchQuery)\n  1076→                  if (!snippet) return null\n  1077→                  const parts = snippet.split(new RegExp(`(${searchQuery.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')})`, 'gi'))\n  1078→                  return (\n  1079→                    <div className=\"mx-3 mb-2 ml-8 p-1.5 bg-yellow-50 border border-yellow-100 rounded-lg text-xs text-gray-600\">\n  1080→                      <span className=\"text-yellow-600 font-medium mr-1\">Coincidencia:</span>\n  1081→                      {parts.map((part, i) =>\n  1082→                        part.toLowerCase() === searchQuery.toLowerCase()\n  1083→                          ? <mark key={i} className=\"bg-yellow-200 px-0.5 rounded\">{part}</mark>\n  1084→                          : <span key={i}>{part}</span>\n  1085→                      )}\n  1086→                    </div>\n  1087→                  )\n  1088→                })()}\n  1089→\n  1090→                {/* Mobile: Tags & Campaign on second row */}\n  1091→                {!isExpanded && (\n  1092→                  <>\n  1093→                    <div className=\"sm:hidden px-3 pb-2 ml-5 flex flex-wrap items-center gap-1.5\">\n  1094→                      {doc.tags && doc.tags.length > 0 && doc.tags.map((tag, idx) => (\n  1095→                        <button\n  1096→                          key={idx}\n  1097→                          onClick={() => setTagFilter(tag)}\n  1098→                          className={`px-1.5 py-0.5 text-[10px] rounded-full ${\n  1099→                            tagFilter === tag ? 'bg-purple-600 text-white' : 'bg-purple-50 text-purple-600'\n  1100→                          }`}\n  1101→                        >\n  1102→                          {tag}\n  1103→                        </button>\n  1104→                      ))}\n  1105→                    </div>\n  1106→                    {campaigns.length > 0 && onCampaignChange && (\n  1107→                      <div className=\"md:hidden px-3 pb-2 ml-5 flex items-center gap-1.5\">\n  1108→                        <Link2 size={11} className=\"text-gray-300\" />\n  1109→                        <select\n  1110→                          value={doc.campaign_id || ''}\n  1111→                          onChange={(e) => handleCampaignChange(doc.id, e.target.value)}\n  1112→                          disabled={updatingDoc === doc.id}\n  1113→                          className=\"flex-1 text-xs border border-gray-200 rounded px-2 py-1 text-gray-600 bg-white\"\n  1114→                        >\n  1115→                          <option value=\"\">Global (todas las campañas)</option>\n  1116→                          {campaigns.map(campaign => (\n  1117→                            <option key={campaign.id} value={campaign.id}>{campaign.ecp_name}</option>\n  1118→                          ))}\n  1119→                        </select>\n  1120→                      </div>\n  1121→                    )}\n  1122→                  </>\n  1123→                )}\n  1124→\n  1125→                {/* Expanded content */}\n  1126→                {isExpanded && doc.extracted_content && (\n  1127→                  <div className=\"border-t border-gray-100 bg-gray-50 rounded-b-xl\">\n  1128→                    <div className=\"p-3 max-h-[500px] overflow-hidden flex flex-col\">\n  1129→                      {contentType === 'json' ? (\n  1130→                        <JSONViewer content={doc.extracted_content} filename={doc.filename} />\n  1131→                      ) : contentType === 'csv' ? (\n  1132→                        <CSVTableViewer content={doc.extracted_content} filename={doc.filename} />\n  1133→                      ) : (\n  1134→                        <pre className=\"text-xs text-gray-700 whitespace-pre-wrap font-mono bg-white p-3 rounded-lg border border-gray-200 overflow-auto max-h-[450px]\">\n  1135→                          {doc.extracted_content}\n  1136→                        </pre>\n  1137→                      )}\n  1138→                    </div>\n  1139→                  </div>\n  1140→                )}\n  1141→              </div>\n  1142→            )\n  1143→          })}\n  1144→        </div>\n  1145→      )}\n  1146→    </div>\n  1147→  )\n  1148→}\n  1149→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"dd89b981-6524-4410-8b8c-24255d844839","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/DocumentList.tsx","content":"'use client'\n\nimport { useState, useMemo, useRef, useEffect } from 'react'\nimport { Trash2, Link2, Search, Filter, FolderOpen, X, Edit2, Check, Loader2, Tag, ChevronDown, ChevronRight, Maximize2, History, FolderInput, Plus } from 'lucide-react'\nimport { DocCategory } from '@/types/database.types'\nimport { formatTokenCount } from '@/lib/supabase'\nimport { useModal } from '@/components/ui'\nimport CSVTableViewer from './CSVTableViewer'\nimport JSONViewer from './JSONViewer'\n\ntype DocumentTier = 'T1' | 'T2' | 'T3'\ntype DocumentSourceType = 'import' | 'scraper' | 'playbook' | 'api'\n\ninterface Document {\n  id: string\n  filename: string\n  category: DocCategory\n  description?: string\n  token_count: number | null\n  file_size_bytes: number | null\n  created_at: string\n  campaign_id?: string | null\n  extracted_content?: string | null\n  tags?: string[] | null\n  source_type?: DocumentSourceType | string | null\n  tier?: DocumentTier | null\n  project_id?: string | null\n  client_id?: string | null\n  isShared?: boolean\n  version_count?: number\n  folder?: string | null\n}\n\ninterface Campaign {\n  id: string\n  ecp_name: string\n}\n\ninterface DocumentListProps {\n  documents: Document[]\n  campaigns?: Campaign[]\n  onDelete: (id: string) => void\n  onView: (doc: Document) => void\n  onCampaignChange?: (docId: string, campaignId: string | null) => void\n  onRename?: (docId: string, newName: string) => Promise<void>\n  onUpdateDescription?: (docId: string, description: string) => Promise<void>\n  onTierChange?: (docId: string, tier: DocumentTier) => Promise<void>\n  onMoveToFolder?: (docId: string, folder: string | null) => Promise<void>\n  availableFolders?: string[]\n  showContextLakeFilters?: boolean\n}\n\nconst CATEGORY_STYLES: Record<string, { bg: string; text: string; icon: string }> = {\n  product: { bg: 'bg-blue-50', text: 'text-blue-700', icon: '📦' },\n  competitor: { bg: 'bg-purple-50', text: 'text-purple-700', icon: '🎯' },\n  research: { bg: 'bg-green-50', text: 'text-green-700', icon: '🔬' },\n  output: { bg: 'bg-orange-50', text: 'text-orange-700', icon: '📝' },\n}\n\nconst SOURCE_TYPE_STYLES: Record<string, { bg: string; text: string; icon: string; label: string }> = {\n  import: { bg: 'bg-gray-50', text: 'text-gray-600', icon: '📥', label: 'Importado' },\n  scraper: { bg: 'bg-green-50', text: 'text-green-600', icon: '🔍', label: 'Scraper' },\n  playbook: { bg: 'bg-blue-50', text: 'text-blue-600', icon: '🎯', label: 'Playbook' },\n  api: { bg: 'bg-purple-50', text: 'text-purple-600', icon: '🔗', label: 'API' },\n  // Legacy values mapped to import\n  manual: { bg: 'bg-gray-50', text: 'text-gray-600', icon: '📥', label: 'Importado' },\n  upload: { bg: 'bg-gray-50', text: 'text-gray-600', icon: '📥', label: 'Importado' },\n}\n\nconst TIER_STYLES: Record<DocumentTier, { bg: string; text: string; label: string; description: string }> = {\n  T1: { bg: 'bg-emerald-50', text: 'text-emerald-700', label: 'T1', description: 'Siempre incluido' },\n  T2: { bg: 'bg-yellow-50', text: 'text-yellow-700', label: 'T2', description: 'Si es relevante' },\n  T3: { bg: 'bg-gray-50', text: 'text-gray-500', label: 'T3', description: 'Opcional' },\n}\n\nexport default function DocumentList({\n  documents,\n  campaigns = [],\n  onDelete,\n  onView,\n  onCampaignChange,\n  onRename,\n  onUpdateDescription,\n  onTierChange,\n  onMoveToFolder,\n  availableFolders = [],\n  showContextLakeFilters = false,\n}: DocumentListProps) {\n  const modal = useModal()\n\n  const [updatingDoc, setUpdatingDoc] = useState<string | null>(null)\n  const [searchQuery, setSearchQuery] = useState('')\n  const [searchInContent, setSearchInContent] = useState(false)\n  const [categoryFilter, setCategoryFilter] = useState<string>('all')\n  const [assignmentFilter, setAssignmentFilter] = useState<'all' | 'global' | 'assigned'>('all')\n  const [tagFilter, setTagFilter] = useState<string>('all')\n  const [sourceTypeFilter, setSourceTypeFilter] = useState<string>('all')\n  const [tierFilter, setTierFilter] = useState<string>('all')\n  const [sharedFilter, setSharedFilter] = useState<'all' | 'project' | 'shared'>('all')\n\n  // State for inline editing\n  const [editingDocId, setEditingDocId] = useState<string | null>(null)\n  const [editingName, setEditingName] = useState('')\n  const [savingName, setSavingName] = useState(false)\n\n  // State for description editing\n  const [editingDescDocId, setEditingDescDocId] = useState<string | null>(null)\n  const [editingDescription, setEditingDescription] = useState('')\n  const [savingDescription, setSavingDescription] = useState(false)\n\n  // State for expanded content\n  const [expandedDocId, setExpandedDocId] = useState<string | null>(null)\n\n  // State for bulk selection\n  const [selectedDocs, setSelectedDocs] = useState<Set<string>>(new Set())\n  const [bulkDeleting, setBulkDeleting] = useState(false)\n  const selectAllRef = useRef<HTMLInputElement>(null)\n\n  // State for folder menu\n  const [folderMenuDocId, setFolderMenuDocId] = useState<string | null>(null)\n  const [movingToFolder, setMovingToFolder] = useState(false)\n  const [newFolderInput, setNewFolderInput] = useState('')\n  const [showNewFolderInput, setShowNewFolderInput] = useState(false)\n\n  // Get unique categories\n  const categories = useMemo(() => {\n    return Array.from(new Set(documents.map(d => d.category))).sort()\n  }, [documents])\n\n  // Get unique tags with counts\n  const allTags = useMemo(() => {\n    const tagCounts: Record<string, number> = {}\n    documents.forEach(doc => {\n      doc.tags?.forEach(tag => {\n        tagCounts[tag] = (tagCounts[tag] || 0) + 1\n      })\n    })\n    return Object.entries(tagCounts)\n      .sort((a, b) => b[1] - a[1]) // Sort by count descending\n      .map(([tag, count]) => ({ tag, count }))\n  }, [documents])\n\n  // Filter documents\n  const filteredDocs = useMemo(() => {\n    return documents.filter(doc => {\n      // Search filter\n      if (searchQuery) {\n        const query = searchQuery.toLowerCase()\n        const matchesFilename = doc.filename.toLowerCase().includes(query)\n        const matchesContent = searchInContent && doc.extracted_content?.toLowerCase().includes(query)\n        const matchesTags = doc.tags?.some(tag => tag.toLowerCase().includes(query))\n        if (!matchesFilename && !matchesContent && !matchesTags) {\n          return false\n        }\n      }\n      // Category filter\n      if (categoryFilter !== 'all' && doc.category !== categoryFilter) {\n        return false\n      }\n      // Tag filter\n      if (tagFilter !== 'all' && !doc.tags?.includes(tagFilter)) {\n        return false\n      }\n      // Assignment filter\n      if (assignmentFilter === 'global' && doc.campaign_id) {\n        return false\n      }\n      if (assignmentFilter === 'assigned' && !doc.campaign_id) {\n        return false\n      }\n      // Context Lake filters\n      if (sourceTypeFilter !== 'all' && doc.source_type !== sourceTypeFilter) {\n        return false\n      }\n      if (tierFilter !== 'all' && doc.tier !== tierFilter) {\n        return false\n      }\n      if (sharedFilter === 'project' && doc.isShared) {\n        return false\n      }\n      if (sharedFilter === 'shared' && !doc.isShared) {\n        return false\n      }\n      return true\n    })\n  }, [documents, searchQuery, searchInContent, categoryFilter, tagFilter, assignmentFilter, sourceTypeFilter, tierFilter, sharedFilter])\n\n  // Get content match snippet\n  const getContentMatchSnippet = (content: string | null | undefined, query: string): string | null => {\n    if (!content || !query) return null\n    const lowerContent = content.toLowerCase()\n    const lowerQuery = query.toLowerCase()\n    const index = lowerContent.indexOf(lowerQuery)\n    if (index === -1) return null\n\n    const start = Math.max(0, index - 50)\n    const end = Math.min(content.length, index + query.length + 50)\n    let snippet = content.substring(start, end)\n    if (start > 0) snippet = '...' + snippet\n    if (end < content.length) snippet = snippet + '...'\n    return snippet\n  }\n\n  const handleCampaignChange = async (docId: string, campaignId: string) => {\n    if (!onCampaignChange) return\n\n    setUpdatingDoc(docId)\n    try {\n      await onCampaignChange(docId, campaignId === '' ? null : campaignId)\n    } finally {\n      setUpdatingDoc(null)\n    }\n  }\n\n  // Handle starting the edit mode\n  const handleStartEdit = (doc: Document) => {\n    setEditingDocId(doc.id)\n    setEditingName(doc.filename)\n  }\n\n  // Handle canceling the edit\n  const handleCancelEdit = () => {\n    setEditingDocId(null)\n    setEditingName('')\n  }\n\n  // Handle saving the new name\n  const handleSaveName = async (docId: string) => {\n    if (!onRename || !editingName.trim()) return\n\n    setSavingName(true)\n    try {\n      await onRename(docId, editingName.trim())\n      setEditingDocId(null)\n      setEditingName('')\n    } catch (error) {\n      console.error('Error renaming document:', error)\n    } finally {\n      setSavingName(false)\n    }\n  }\n\n  // Handle key press in the edit input\n  const handleEditKeyDown = (e: React.KeyboardEvent, docId: string) => {\n    if (e.key === 'Enter') {\n      e.preventDefault()\n      handleSaveName(docId)\n    } else if (e.key === 'Escape') {\n      handleCancelEdit()\n    }\n  }\n\n  // Handle starting description edit\n  const handleStartDescEdit = (doc: Document) => {\n    setEditingDescDocId(doc.id)\n    setEditingDescription(doc.description || '')\n  }\n\n  // Handle canceling description edit\n  const handleCancelDescEdit = () => {\n    setEditingDescDocId(null)\n    setEditingDescription('')\n  }\n\n  // Handle saving description\n  const handleSaveDescription = async (docId: string) => {\n    if (!onUpdateDescription) return\n\n    setSavingDescription(true)\n    try {\n      await onUpdateDescription(docId, editingDescription.trim())\n      setEditingDescDocId(null)\n      setEditingDescription('')\n    } catch (error) {\n      console.error('Error updating description:', error)\n    } finally {\n      setSavingDescription(false)\n    }\n  }\n\n  // Handle key press in description textarea\n  const handleDescKeyDown = (e: React.KeyboardEvent, docId: string) => {\n    if (e.key === 'Enter' && e.metaKey) {\n      e.preventDefault()\n      handleSaveDescription(docId)\n    } else if (e.key === 'Escape') {\n      handleCancelDescEdit()\n    }\n  }\n\n  // Handle moving document to folder\n  const handleMoveToFolder = async (docId: string, folder: string | null) => {\n    if (!onMoveToFolder) return\n    setMovingToFolder(true)\n    try {\n      await onMoveToFolder(docId, folder)\n      setFolderMenuDocId(null)\n      setShowNewFolderInput(false)\n      setNewFolderInput('')\n    } catch (error) {\n      console.error('Error moving to folder:', error)\n    } finally {\n      setMovingToFolder(false)\n    }\n  }\n\n  // Handle creating new folder and moving doc to it\n  const handleCreateFolderAndMove = async (docId: string) => {\n    if (!newFolderInput.trim()) return\n    await handleMoveToFolder(docId, newFolderInput.trim())\n  }\n\n  const getCategoryBadge = (category: DocCategory) => {\n    const style = CATEGORY_STYLES[category] || { bg: 'bg-gray-50', text: 'text-gray-700', icon: '🏷️' }\n    const label = category.charAt(0).toUpperCase() + category.slice(1)\n\n    return (\n      <span className={`inline-flex items-center gap-1 px-1.5 py-0.5 rounded text-[10px] font-medium ${style.bg} ${style.text}`}>\n        <span className=\"text-[10px]\">{style.icon}</span>\n        {label}\n      </span>\n    )\n  }\n\n  // Detect content type for inline viewer\n  const getContentType = (content: string | null | undefined): 'json' | 'csv' | 'text' => {\n    if (!content) return 'text'\n    const trimmed = content.trim()\n    const firstLine = content.split('\\n')[0] || ''\n\n    // Check if JSON\n    if (trimmed.startsWith('[') || trimmed.startsWith('{')) {\n      try {\n        JSON.parse(trimmed)\n        return 'json'\n      } catch {\n        if ((trimmed.startsWith('[') && trimmed.includes(']')) ||\n            (trimmed.startsWith('{') && trimmed.includes('}'))) {\n          return 'json'\n        }\n      }\n    }\n\n    // Check if CSV\n    if (firstLine.includes(',') && firstLine.split(',').length >= 3) {\n      return 'csv'\n    }\n\n    return 'text'\n  }\n\n  const toggleExpand = (docId: string) => {\n    setExpandedDocId(expandedDocId === docId ? null : docId)\n  }\n\n  // Handle select all checkbox indeterminate state\n  useEffect(() => {\n    if (selectAllRef.current) {\n      const allSelected = selectedDocs.size === filteredDocs.length && filteredDocs.length > 0\n      const someSelected = selectedDocs.size > 0 && selectedDocs.size < filteredDocs.length\n      selectAllRef.current.indeterminate = someSelected\n      selectAllRef.current.checked = allSelected\n    }\n  }, [selectedDocs.size, filteredDocs.length])\n\n  // Toggle selection for a document\n  const toggleDocSelection = (docId: string, event: React.MouseEvent) => {\n    event.stopPropagation()\n    const newSelected = new Set(selectedDocs)\n    if (newSelected.has(docId)) {\n      newSelected.delete(docId)\n    } else {\n      newSelected.add(docId)\n    }\n    setSelectedDocs(newSelected)\n  }\n\n  // Toggle select all\n  const toggleSelectAll = () => {\n    if (selectedDocs.size === filteredDocs.length) {\n      setSelectedDocs(new Set())\n    } else {\n      setSelectedDocs(new Set(filteredDocs.map(d => d.id)))\n    }\n  }\n\n  // Handle bulk delete\n  const handleBulkDelete = async () => {\n    const confirmed = await modal.confirm({\n      title: 'Eliminar documentos',\n      message: `¿Eliminar ${selectedDocs.size} documento(s)? Esta acción no se puede deshacer.`,\n      confirmText: 'Eliminar todos',\n      cancelText: 'Cancelar',\n      variant: 'danger',\n    })\n\n    if (confirmed) {\n      setBulkDeleting(true)\n      try {\n        for (const docId of selectedDocs) {\n          await onDelete(docId)\n        }\n        setSelectedDocs(new Set())\n      } finally {\n        setBulkDeleting(false)\n      }\n    }\n  }\n\n  if (documents.length === 0) {\n    return (\n      <div className=\"text-center py-16\">\n        <div className=\"inline-block p-4 bg-gray-100 rounded-2xl mb-4\">\n          <FolderOpen className=\"w-12 h-12 text-gray-400\" />\n        </div>\n        <h3 className=\"text-lg font-medium text-gray-900 mb-1\">No hay documentos</h3>\n        <p className=\"text-gray-500 text-sm\">\n          Sube PDFs o DOCX con información de producto, competidores o research\n        </p>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Search and Filters */}\n      <div className=\"flex flex-wrap items-center gap-3\">\n        {/* Search */}\n        <div className=\"flex-1 min-w-[200px]\">\n          <div className=\"relative\">\n            <Search size={18} className=\"absolute left-4 top-1/2 -translate-y-1/2 text-gray-400\" />\n            <input\n              type=\"text\"\n              value={searchQuery}\n              onChange={(e) => setSearchQuery(e.target.value)}\n              placeholder={searchInContent ? \"Buscar en nombre y contenido...\" : \"Buscar por nombre...\"}\n              className=\"w-full pl-11 pr-4 py-2.5 border border-gray-200 rounded-xl text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900 placeholder:text-gray-400\"\n            />\n            {searchQuery && (\n              <button\n                onClick={() => setSearchQuery('')}\n                className=\"absolute right-3 top-1/2 -translate-y-1/2 p-1 text-gray-400 hover:text-gray-600\"\n              >\n                <X size={16} />\n              </button>\n            )}\n          </div>\n          <label className=\"flex items-center gap-2 mt-2 cursor-pointer\">\n            <input\n              type=\"checkbox\"\n              checked={searchInContent}\n              onChange={(e) => setSearchInContent(e.target.checked)}\n              className=\"w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500\"\n            />\n            <span className=\"text-xs text-gray-500\">Buscar dentro del contenido</span>\n          </label>\n        </div>\n\n        {/* Category Filter */}\n        <div className=\"flex items-center gap-2\">\n          <Filter size={16} className=\"text-gray-400\" />\n          <select\n            value={categoryFilter}\n            onChange={(e) => setCategoryFilter(e.target.value)}\n            className=\"px-3 py-2.5 border border-gray-200 rounded-xl text-sm text-gray-700 bg-white focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n          >\n            <option value=\"all\">Todas ({documents.length})</option>\n            {categories.map(cat => {\n              const count = documents.filter(d => d.category === cat).length\n              const style = CATEGORY_STYLES[cat]\n              return (\n                <option key={cat} value={cat}>\n                  {style?.icon || '🏷️'} {cat} ({count})\n                </option>\n              )\n            })}\n          </select>\n        </div>\n\n        {/* Tag Filter */}\n        {allTags.length > 0 && (\n          <div className=\"flex items-center gap-2\">\n            <Tag size={16} className=\"text-gray-400\" />\n            <select\n              value={tagFilter}\n              onChange={(e) => setTagFilter(e.target.value)}\n              className=\"px-3 py-2.5 border border-gray-200 rounded-xl text-sm text-gray-700 bg-white focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n            >\n              <option value=\"all\">Tags: Todos</option>\n              {allTags.map(({ tag, count }) => (\n                <option key={tag} value={tag}>\n                  {tag} ({count})\n                </option>\n              ))}\n            </select>\n          </div>\n        )}\n\n        {/* Assignment Filter */}\n        {campaigns.length > 0 && (\n          <div className=\"flex items-center gap-1 bg-gray-100 rounded-xl p-1\">\n            {[\n              { value: 'all', label: 'Todos' },\n              { value: 'global', label: 'Globales' },\n              { value: 'assigned', label: 'Asignados' },\n            ].map((filter) => (\n              <button\n                key={filter.value}\n                onClick={() => setAssignmentFilter(filter.value as typeof assignmentFilter)}\n                className={`px-3 py-1.5 text-xs font-medium rounded-lg transition-all ${\n                  assignmentFilter === filter.value\n                    ? 'bg-white text-gray-900 shadow-sm'\n                    : 'text-gray-600 hover:text-gray-900'\n                }`}\n              >\n                {filter.label}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Context Lake Filters */}\n      {showContextLakeFilters && (\n        <div className=\"flex flex-wrap items-center gap-3 pt-2 border-t border-gray-100\">\n          {/* Source Type Filter */}\n          <div className=\"flex items-center gap-2\">\n            <span className=\"text-xs text-gray-500\">Origen:</span>\n            <select\n              value={sourceTypeFilter}\n              onChange={(e) => setSourceTypeFilter(e.target.value)}\n              className=\"px-2 py-1.5 border border-gray-200 rounded-lg text-xs text-gray-700 bg-white focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n            >\n              <option value=\"all\">Todos</option>\n              {Object.entries(SOURCE_TYPE_STYLES).map(([key, style]) => (\n                <option key={key} value={key}>\n                  {style.icon} {style.label}\n                </option>\n              ))}\n            </select>\n          </div>\n\n          {/* Tier Filter */}\n          <div className=\"flex items-center gap-2\">\n            <span className=\"text-xs text-gray-500\">Tier:</span>\n            <div className=\"flex items-center gap-1 bg-gray-100 rounded-lg p-0.5\">\n              <button\n                onClick={() => setTierFilter('all')}\n                className={`px-2 py-1 text-xs font-medium rounded transition-all ${\n                  tierFilter === 'all' ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-600 hover:text-gray-900'\n                }`}\n              >\n                Todos\n              </button>\n              {(['T1', 'T2', 'T3'] as DocumentTier[]).map((tier) => {\n                const style = TIER_STYLES[tier]\n                return (\n                  <button\n                    key={tier}\n                    onClick={() => setTierFilter(tier)}\n                    title={style.description}\n                    className={`px-2 py-1 text-xs font-medium rounded transition-all ${\n                      tierFilter === tier ? `${style.bg} ${style.text} shadow-sm` : 'text-gray-600 hover:text-gray-900'\n                    }`}\n                  >\n                    {tier}\n                  </button>\n                )\n              })}\n            </div>\n          </div>\n\n          {/* Shared/Project Filter */}\n          <div className=\"flex items-center gap-1 bg-gray-100 rounded-lg p-0.5\">\n            {[\n              { value: 'all', label: 'Todo' },\n              { value: 'project', label: '📁 Proyecto' },\n              { value: 'shared', label: '🔗 Compartido' },\n            ].map((filter) => (\n              <button\n                key={filter.value}\n                onClick={() => setSharedFilter(filter.value as typeof sharedFilter)}\n                className={`px-2 py-1 text-xs font-medium rounded transition-all ${\n                  sharedFilter === filter.value ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-600 hover:text-gray-900'\n                }`}\n              >\n                {filter.label}\n              </button>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Results count */}\n      {(searchQuery || categoryFilter !== 'all' || tagFilter !== 'all' || assignmentFilter !== 'all' || sourceTypeFilter !== 'all' || tierFilter !== 'all' || sharedFilter !== 'all') && (\n        <div className=\"flex items-center justify-between text-sm text-gray-500\">\n          <span>\n            Mostrando {filteredDocs.length} de {documents.length} documentos\n            {searchQuery && (\n              <span className=\"ml-1\">\n                para &quot;{searchQuery}&quot;\n                {searchInContent && <span className=\"text-blue-600 ml-1\">(en contenido)</span>}\n              </span>\n            )}\n            {tagFilter !== 'all' && (\n              <span className=\"ml-1\">\n                con tag <span className=\"bg-purple-100 text-purple-700 px-1.5 py-0.5 rounded text-xs\">{tagFilter}</span>\n              </span>\n            )}\n            {tierFilter !== 'all' && (\n              <span className=\"ml-1\">\n                tier <span className={`${TIER_STYLES[tierFilter as DocumentTier]?.bg} ${TIER_STYLES[tierFilter as DocumentTier]?.text} px-1.5 py-0.5 rounded text-xs`}>{tierFilter}</span>\n              </span>\n            )}\n          </span>\n          <button\n            onClick={() => {\n              setSearchQuery('')\n              setCategoryFilter('all')\n              setTagFilter('all')\n              setAssignmentFilter('all')\n              setSourceTypeFilter('all')\n              setTierFilter('all')\n              setSharedFilter('all')\n            }}\n            className=\"text-blue-600 hover:text-blue-700 font-medium\"\n          >\n            Limpiar filtros\n          </button>\n        </div>\n      )}\n\n      {/* Bulk Actions Toolbar */}\n      {selectedDocs.size > 0 && (\n        <div className=\"flex items-center gap-3 p-3 bg-blue-50 border border-blue-200 rounded-xl\">\n          <span className=\"text-sm font-medium text-blue-700\">\n            {selectedDocs.size} documento(s) seleccionado(s)\n          </span>\n          <button\n            onClick={handleBulkDelete}\n            disabled={bulkDeleting}\n            className=\"px-3 py-1.5 text-xs bg-red-600 text-white rounded-lg hover:bg-red-700 disabled:opacity-50 inline-flex items-center gap-1.5 font-medium\"\n          >\n            {bulkDeleting ? <Loader2 size={14} className=\"animate-spin\" /> : <Trash2 size={14} />}\n            Eliminar seleccionados\n          </button>\n          <button\n            onClick={() => setSelectedDocs(new Set())}\n            className=\"px-3 py-1.5 text-xs text-gray-600 hover:bg-white/50 rounded-lg font-medium\"\n          >\n            Cancelar selección\n          </button>\n        </div>\n      )}\n\n      {/* Select All Header */}\n      {filteredDocs.length > 0 && (\n        <div className=\"flex items-center gap-2 px-1\">\n          <input\n            ref={selectAllRef}\n            type=\"checkbox\"\n            onChange={toggleSelectAll}\n            className=\"w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500 cursor-pointer\"\n          />\n          <span className=\"text-xs text-gray-500\">\n            {selectedDocs.size > 0\n              ? `${selectedDocs.size} de ${filteredDocs.length} seleccionados`\n              : 'Seleccionar todos'}\n          </span>\n        </div>\n      )}\n\n      {/* Document List */}\n      {filteredDocs.length === 0 ? (\n        <div className=\"text-center py-12\">\n          <Search className=\"w-10 h-10 text-gray-300 mx-auto mb-3\" />\n          <p className=\"text-gray-500\">No hay documentos que coincidan</p>\n          <button\n            onClick={() => {\n              setSearchQuery('')\n              setCategoryFilter('all')\n              setTagFilter('all')\n              setAssignmentFilter('all')\n              setSourceTypeFilter('all')\n              setTierFilter('all')\n              setSharedFilter('all')\n            }}\n            className=\"mt-2 text-blue-600 hover:text-blue-700 text-sm font-medium\"\n          >\n            Limpiar filtros\n          </button>\n        </div>\n      ) : (\n        <div className=\"space-y-2\">\n          {filteredDocs.map((doc) => {\n            const isExpanded = expandedDocId === doc.id\n            const contentType = getContentType(doc.extracted_content)\n\n            return (\n              <div\n                key={doc.id}\n                className={`group bg-white border rounded-xl transition-all ${\n                  isExpanded ? 'border-blue-200 shadow-sm' : 'border-gray-100 hover:border-blue-200 hover:shadow-sm'\n                }`}\n              >\n                {/* Main row - single line layout */}\n                <div\n                  className=\"flex items-center gap-3 px-3 py-2.5 cursor-pointer\"\n                  onClick={() => toggleExpand(doc.id)}\n                >\n                  {/* Selection checkbox */}\n                  <input\n                    type=\"checkbox\"\n                    checked={selectedDocs.has(doc.id)}\n                    onChange={() => {}}\n                    onClick={(e) => toggleDocSelection(doc.id, e)}\n                    className=\"w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500 flex-shrink-0 cursor-pointer\"\n                  />\n\n                  {/* Expand chevron */}\n                  <div className=\"flex-shrink-0 text-gray-400\">\n                    {isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />}\n                  </div>\n\n                  {/* Title & Badges */}\n                  <div className=\"flex-1 min-w-0 flex items-center gap-2\">\n                    {editingDocId === doc.id ? (\n                      <div className=\"flex items-center gap-2 flex-1\" onClick={(e) => e.stopPropagation()}>\n                        <input\n                          type=\"text\"\n                          value={editingName}\n                          onChange={(e) => setEditingName(e.target.value)}\n                          onKeyDown={(e) => handleEditKeyDown(e, doc.id)}\n                          className=\"flex-1 px-2 py-1 text-sm border border-blue-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900\"\n                          autoFocus\n                          disabled={savingName}\n                        />\n                        <button\n                          onClick={() => handleSaveName(doc.id)}\n                          disabled={savingName || !editingName.trim()}\n                          className=\"p-1 text-green-600 hover:bg-green-50 rounded disabled:opacity-50 disabled:cursor-not-allowed\"\n                          title=\"Guardar\"\n                        >\n                          {savingName ? <Loader2 size={14} className=\"animate-spin\" /> : <Check size={14} />}\n                        </button>\n                        <button\n                          onClick={handleCancelEdit}\n                          disabled={savingName}\n                          className=\"p-1 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded disabled:opacity-50\"\n                          title=\"Cancelar\"\n                        >\n                          <X size={14} />\n                        </button>\n                      </div>\n                    ) : (\n                      <>\n                        <h3 className=\"font-medium text-sm text-gray-900 truncate group-hover:text-blue-600 transition-colors\">\n                          {doc.filename}\n                        </h3>\n                        {onRename && (\n                          <button\n                            onClick={(e) => { e.stopPropagation(); handleStartEdit(doc) }}\n                            className=\"p-0.5 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded opacity-0 group-hover:opacity-100 transition-all flex-shrink-0\"\n                            title=\"Editar nombre\"\n                          >\n                            <Edit2 size={12} />\n                          </button>\n                        )}\n                      </>\n                    )}\n                  </div>\n\n                  {/* Inline badges */}\n                  <div className=\"flex items-center gap-1.5 flex-shrink-0\">\n                    {/* Shared badge */}\n                    {doc.isShared && (\n                      <span className=\"inline-flex items-center gap-0.5 px-1.5 py-0.5 rounded text-[10px] font-medium bg-indigo-50 text-indigo-600\" title=\"Documento compartido del cliente\">\n                        🔗\n                      </span>\n                    )}\n                    {/* Tier badge */}\n                    {doc.tier && onTierChange ? (\n                      <select\n                        value={doc.tier}\n                        onChange={async (e) => {\n                          e.stopPropagation()\n                          await onTierChange(doc.id, e.target.value as DocumentTier)\n                        }}\n                        onClick={(e) => e.stopPropagation()}\n                        className={`px-1.5 py-0.5 rounded text-[10px] font-medium border-0 cursor-pointer ${TIER_STYLES[doc.tier as DocumentTier]?.bg || 'bg-gray-50'} ${TIER_STYLES[doc.tier as DocumentTier]?.text || 'text-gray-600'}`}\n                        title={TIER_STYLES[doc.tier as DocumentTier]?.description}\n                      >\n                        <option value=\"T1\">T1</option>\n                        <option value=\"T2\">T2</option>\n                        <option value=\"T3\">T3</option>\n                      </select>\n                    ) : doc.tier && (\n                      <span\n                        className={`inline-flex items-center px-1.5 py-0.5 rounded text-[10px] font-medium ${TIER_STYLES[doc.tier as DocumentTier]?.bg || 'bg-gray-50'} ${TIER_STYLES[doc.tier as DocumentTier]?.text || 'text-gray-600'}`}\n                        title={TIER_STYLES[doc.tier as DocumentTier]?.description}\n                      >\n                        {doc.tier}\n                      </span>\n                    )}\n                    {/* Source type badge - ALWAYS shown */}\n                    <span\n                      className={`inline-flex items-center gap-0.5 px-1.5 py-0.5 rounded text-[10px] font-medium ${\n                        doc.source_type\n                          ? (SOURCE_TYPE_STYLES[doc.source_type]?.bg || 'bg-gray-50')\n                          : 'bg-gray-50'\n                      } ${\n                        doc.source_type\n                          ? (SOURCE_TYPE_STYLES[doc.source_type]?.text || 'text-gray-600')\n                          : 'text-gray-600'\n                      }`}\n                      title={`Origen: ${doc.source_type ? (SOURCE_TYPE_STYLES[doc.source_type]?.label || doc.source_type) : 'Importado'}`}\n                    >\n                      <span>{doc.source_type ? (SOURCE_TYPE_STYLES[doc.source_type]?.icon || '📥') : '📥'}</span>\n                      {doc.source_type ? (SOURCE_TYPE_STYLES[doc.source_type]?.label || doc.source_type) : 'Importado'}\n                    </span>\n                    {/* Version indicator */}\n                    {doc.version_count && doc.version_count > 1 && (\n                      <span\n                        className=\"inline-flex items-center gap-0.5 px-1.5 py-0.5 rounded text-[10px] font-medium bg-amber-50 text-amber-700\"\n                        title={`${doc.version_count} versiones disponibles`}\n                      >\n                        <History size={10} />\n                        v{doc.version_count}\n                      </span>\n                    )}\n                    {getCategoryBadge(doc.category)}\n                    {doc.token_count && (\n                      <span className=\"text-xs text-gray-400 whitespace-nowrap\">\n                        {formatTokenCount(doc.token_count)}\n                      </span>\n                    )}\n                  </div>\n\n                  {/* Tags inline */}\n                  {doc.tags && doc.tags.length > 0 && (\n                    <div className=\"hidden sm:flex items-center gap-1 flex-shrink-0\" onClick={(e) => e.stopPropagation()}>\n                      {doc.tags.slice(0, 3).map((tag, idx) => (\n                        <button\n                          key={idx}\n                          onClick={() => setTagFilter(tag)}\n                          className={`px-1.5 py-0.5 text-[10px] rounded-full transition-colors ${\n                            tagFilter === tag\n                              ? 'bg-purple-600 text-white'\n                              : 'bg-purple-50 text-purple-600 hover:bg-purple-100'\n                          }`}\n                          title={`Filtrar por \"${tag}\"`}\n                        >\n                          {tag}\n                        </button>\n                      ))}\n                      {doc.tags.length > 3 && (\n                        <span className=\"text-[10px] text-gray-400\">+{doc.tags.length - 3}</span>\n                      )}\n                    </div>\n                  )}\n\n                  {/* Campaign dropdown - compact */}\n                  {campaigns.length > 0 && onCampaignChange && (\n                    <div className=\"hidden md:flex items-center gap-1.5 flex-shrink-0\" onClick={(e) => e.stopPropagation()}>\n                      <Link2 size={12} className=\"text-gray-300\" />\n                      <select\n                        value={doc.campaign_id || ''}\n                        onChange={(e) => handleCampaignChange(doc.id, e.target.value)}\n                        disabled={updatingDoc === doc.id}\n                        className=\"text-xs border border-gray-200 rounded-lg px-2 py-1 text-gray-600 bg-white focus:ring-1 focus:ring-blue-500 disabled:bg-gray-50 max-w-[180px] truncate\"\n                      >\n                        <option value=\"\">Documento global (todas las campañas)</option>\n                        {campaigns.map(campaign => (\n                          <option key={campaign.id} value={campaign.id}>\n                            {campaign.ecp_name}\n                          </option>\n                        ))}\n                      </select>\n                      {updatingDoc === doc.id && <Loader2 size={12} className=\"text-gray-400 animate-spin\" />}\n                    </div>\n                  )}\n\n                  {/* Actions */}\n                  <div className=\"flex items-center gap-0.5 flex-shrink-0\" onClick={(e) => e.stopPropagation()}>\n                    {/* Move to folder */}\n                    {onMoveToFolder && (\n                      <div className=\"relative\">\n                        <button\n                          onClick={() => setFolderMenuDocId(folderMenuDocId === doc.id ? null : doc.id)}\n                          className=\"p-1.5 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg transition-colors\"\n                          title=\"Mover a carpeta\"\n                        >\n                          <FolderInput size={16} />\n                        </button>\n                        {folderMenuDocId === doc.id && (\n                          <div className=\"absolute right-0 top-8 z-50 w-56 bg-white rounded-xl shadow-lg border border-gray-200 py-2\">\n                            <div className=\"px-3 py-1.5 text-xs font-medium text-gray-500 border-b border-gray-100 mb-1\">\n                              Mover a carpeta\n                            </div>\n                            {/* Current folder indicator */}\n                            {doc.folder && (\n                              <div className=\"px-3 py-1 text-xs text-gray-400 italic\">\n                                Actual: {doc.folder}\n                              </div>\n                            )}\n                            {/* Remove from folder option */}\n                            {doc.folder && (\n                              <button\n                                onClick={() => handleMoveToFolder(doc.id, null)}\n                                disabled={movingToFolder}\n                                className=\"w-full px-3 py-2 text-left text-sm text-gray-600 hover:bg-gray-50 flex items-center gap-2 disabled:opacity-50\"\n                              >\n                                <X size={14} className=\"text-gray-400\" />\n                                Sin carpeta\n                              </button>\n                            )}\n                            {/* Existing folders */}\n                            {availableFolders.filter(f => f !== doc.folder).map(folder => (\n                              <button\n                                key={folder}\n                                onClick={() => handleMoveToFolder(doc.id, folder)}\n                                disabled={movingToFolder}\n                                className=\"w-full px-3 py-2 text-left text-sm text-gray-700 hover:bg-indigo-50 flex items-center gap-2 disabled:opacity-50\"\n                              >\n                                <FolderOpen size={14} className=\"text-indigo-500\" />\n                                {folder}\n                              </button>\n                            ))}\n                            {/* New folder input */}\n                            {showNewFolderInput ? (\n                              <div className=\"px-2 py-2 border-t border-gray-100 mt-1\">\n                                <input\n                                  type=\"text\"\n                                  value={newFolderInput}\n                                  onChange={(e) => setNewFolderInput(e.target.value)}\n                                  onKeyDown={(e) => {\n                                    if (e.key === 'Enter') handleCreateFolderAndMove(doc.id)\n                                    if (e.key === 'Escape') {\n                                      setShowNewFolderInput(false)\n                                      setNewFolderInput('')\n                                    }\n                                  }}\n                                  placeholder=\"Nombre de carpeta...\"\n                                  className=\"w-full px-2 py-1.5 text-sm text-gray-900 placeholder-gray-400 border border-gray-200 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent\"\n                                  autoFocus\n                                />\n                                <div className=\"flex gap-1 mt-1.5\">\n                                  <button\n                                    onClick={() => handleCreateFolderAndMove(doc.id)}\n                                    disabled={!newFolderInput.trim() || movingToFolder}\n                                    className=\"flex-1 px-2 py-1 text-xs bg-indigo-600 text-white rounded hover:bg-indigo-700 disabled:opacity-50\"\n                                  >\n                                    {movingToFolder ? 'Moviendo...' : 'Crear y mover'}\n                                  </button>\n                                  <button\n                                    onClick={() => {\n                                      setShowNewFolderInput(false)\n                                      setNewFolderInput('')\n                                    }}\n                                    className=\"px-2 py-1 text-xs text-gray-500 hover:bg-gray-100 rounded\"\n                                  >\n                                    Cancelar\n                                  </button>\n                                </div>\n                              </div>\n                            ) : (\n                              <button\n                                onClick={() => setShowNewFolderInput(true)}\n                                className=\"w-full px-3 py-2 text-left text-sm text-indigo-600 hover:bg-indigo-50 flex items-center gap-2 border-t border-gray-100 mt-1\"\n                              >\n                                <Plus size={14} />\n                                Nueva carpeta...\n                              </button>\n                            )}\n                            {/* Close button */}\n                            <button\n                              onClick={() => {\n                                setFolderMenuDocId(null)\n                                setShowNewFolderInput(false)\n                                setNewFolderInput('')\n                              }}\n                              className=\"w-full px-3 py-1.5 text-xs text-gray-400 hover:text-gray-600 border-t border-gray-100 mt-1\"\n                            >\n                              Cerrar\n                            </button>\n                          </div>\n                        )}\n                      </div>\n                    )}\n                    <button\n                      onClick={() => onView(doc)}\n                      className=\"p-1.5 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded-lg transition-colors\"\n                      title=\"Abrir en pantalla completa\"\n                    >\n                      <Maximize2 size={16} />\n                    </button>\n                    <button\n                      onClick={async () => {\n                        const confirmed = await modal.confirm({\n                          title: 'Eliminar documento',\n                          message: `¿Eliminar \"${doc.filename}\"? Esta acción no se puede deshacer.`,\n                          confirmText: 'Eliminar',\n                          cancelText: 'Cancelar',\n                          variant: 'danger',\n                        })\n                        if (confirmed) {\n                          onDelete(doc.id)\n                        }\n                      }}\n                      className=\"p-1.5 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-lg transition-colors\"\n                      title=\"Eliminar\"\n                    >\n                      <Trash2 size={16} />\n                    </button>\n                  </div>\n                </div>\n\n                {/* Description row - only when exists, compact */}\n                {editingDescDocId === doc.id ? (\n                  <div className=\"mt-2 ml-8 px-3 pb-3 space-y-1.5\">\n                    <textarea\n                      value={editingDescription}\n                      onChange={(e) => setEditingDescription(e.target.value)}\n                      onKeyDown={(e) => handleDescKeyDown(e, doc.id)}\n                      placeholder=\"Describe el contenido del documento...\"\n                      rows={2}\n                      className=\"w-full px-2 py-1.5 text-xs border border-blue-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900 placeholder:text-gray-400 resize-none\"\n                      autoFocus\n                      disabled={savingDescription}\n                    />\n                    <div className=\"flex items-center gap-2\">\n                      <button\n                        onClick={() => handleSaveDescription(doc.id)}\n                        disabled={savingDescription}\n                        className=\"px-2 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 inline-flex items-center gap-1\"\n                      >\n                        {savingDescription ? <Loader2 size={10} className=\"animate-spin\" /> : <Check size={10} />}\n                        Guardar\n                      </button>\n                      <button\n                        onClick={handleCancelDescEdit}\n                        disabled={savingDescription}\n                        className=\"px-2 py-1 text-xs text-gray-500 hover:bg-gray-100 rounded disabled:opacity-50\"\n                      >\n                        Cancelar\n                      </button>\n                    </div>\n                  </div>\n                ) : doc.description && !isExpanded ? (\n                  <div className=\"ml-8 px-3 pb-2 group/desc\">\n                    <p className=\"text-xs text-gray-500 truncate max-w-2xl\">\n                      {doc.description}\n                      {onUpdateDescription && (\n                        <button\n                          onClick={() => handleStartDescEdit(doc)}\n                          className=\"ml-1.5 text-gray-400 hover:text-blue-600 opacity-0 group-hover/desc:opacity-100 transition-opacity\"\n                          title=\"Editar descripcion\"\n                        >\n                          <Edit2 size={10} className=\"inline\" />\n                        </button>\n                      )}\n                    </p>\n                  </div>\n                ) : onUpdateDescription && !isExpanded ? (\n                  <button\n                    onClick={() => handleStartDescEdit(doc)}\n                    className=\"ml-8 px-3 pb-2 text-[10px] text-gray-400 hover:text-blue-600\"\n                  >\n                    + Descripción\n                  </button>\n                ) : null}\n\n                {/* Content match snippet - only when searching */}\n                {searchInContent && searchQuery && !isExpanded && (() => {\n                  const snippet = getContentMatchSnippet(doc.extracted_content, searchQuery)\n                  if (!snippet) return null\n                  const parts = snippet.split(new RegExp(`(${searchQuery.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')})`, 'gi'))\n                  return (\n                    <div className=\"mx-3 mb-2 ml-8 p-1.5 bg-yellow-50 border border-yellow-100 rounded-lg text-xs text-gray-600\">\n                      <span className=\"text-yellow-600 font-medium mr-1\">Coincidencia:</span>\n                      {parts.map((part, i) =>\n                        part.toLowerCase() === searchQuery.toLowerCase()\n                          ? <mark key={i} className=\"bg-yellow-200 px-0.5 rounded\">{part}</mark>\n                          : <span key={i}>{part}</span>\n                      )}\n                    </div>\n                  )\n                })()}\n\n                {/* Mobile: Tags & Campaign on second row */}\n                {!isExpanded && (\n                  <>\n                    <div className=\"sm:hidden px-3 pb-2 ml-5 flex flex-wrap items-center gap-1.5\">\n                      {doc.tags && doc.tags.length > 0 && doc.tags.map((tag, idx) => (\n                        <button\n                          key={idx}\n                          onClick={() => setTagFilter(tag)}\n                          className={`px-1.5 py-0.5 text-[10px] rounded-full ${\n                            tagFilter === tag ? 'bg-purple-600 text-white' : 'bg-purple-50 text-purple-600'\n                          }`}\n                        >\n                          {tag}\n                        </button>\n                      ))}\n                    </div>\n                    {campaigns.length > 0 && onCampaignChange && (\n                      <div className=\"md:hidden px-3 pb-2 ml-5 flex items-center gap-1.5\">\n                        <Link2 size={11} className=\"text-gray-300\" />\n                        <select\n                          value={doc.campaign_id || ''}\n                          onChange={(e) => handleCampaignChange(doc.id, e.target.value)}\n                          disabled={updatingDoc === doc.id}\n                          className=\"flex-1 text-xs border border-gray-200 rounded px-2 py-1 text-gray-600 bg-white\"\n                        >\n                          <option value=\"\">Global (todas las campañas)</option>\n                          {campaigns.map(campaign => (\n                            <option key={campaign.id} value={campaign.id}>{campaign.ecp_name}</option>\n                          ))}\n                        </select>\n                      </div>\n                    )}\n                  </>\n                )}\n\n                {/* Expanded content */}\n                {isExpanded && doc.extracted_content && (\n                  <div className=\"border-t border-gray-100 bg-gray-50 rounded-b-xl\">\n                    <div className=\"p-3 max-h-[500px] overflow-hidden flex flex-col\">\n                      {contentType === 'json' ? (\n                        <JSONViewer content={doc.extracted_content} filename={doc.filename} />\n                      ) : contentType === 'csv' ? (\n                        <CSVTableViewer content={doc.extracted_content} filename={doc.filename} />\n                      ) : (\n                        <pre className=\"text-xs text-gray-700 whitespace-pre-wrap font-mono bg-white p-3 rounded-lg border border-gray-200 overflow-auto max-h-[450px]\">\n                          {doc.extracted_content}\n                        </pre>\n                      )}\n                    </div>\n                  </div>\n                )}\n              </div>\n            )\n          })}\n        </div>\n      )}\n    </div>\n  )\n}\n","numLines":1149,"startLine":1,"totalLines":1149}}}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01HEVj4fcdZWWLzR42NdE189","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SD479ZSJ3Ssxh4gu6PYcr5","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Toast/ToastContext.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2114,"cache_creation_input_tokens":27547,"cache_read_input_tokens":81118,"cache_creation":{"ephemeral_5m_input_tokens":27547,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"90b554bf-7f10-4760-ad44-8429abb1f555"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01HEVj4fcdZWWLzR42NdE189","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SJcgijBTX2j37hvu464Tjn","name":"Bash","input":{"command":"find /Users/martin/Gattaca-Secuenciador-de-Prompts/src -type f -name \"*.tsx\" | xargs grep -l \"StepOutputEditor\\|OutputSection\\|expandable\" | head -5"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2114,"cache_creation_input_tokens":27547,"cache_read_input_tokens":81118,"cache_creation":{"ephemeral_5m_input_tokens":27547,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"034ecf95-1f31-4127-a2f6-f81263446a78"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01HEVj4fcdZWWLzR42NdE189","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F1zQs2h2oN9n2n7gmKHC7y","name":"Bash","input":{"command":"ls -la /Users/martin/Gattaca-Secuenciador-de-Prompts/src/types/"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2114,"cache_creation_input_tokens":27547,"cache_read_input_tokens":81118,"cache_creation":{"ephemeral_5m_input_tokens":27547,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"2aebae4c-9b5c-492a-a29d-a60ed9fedc25"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SD479ZSJ3Ssxh4gu6PYcr5","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { createContext, useContext, useCallback, useState, useMemo, ReactNode } from 'react'\n     4→import { Toast, ToastConfig, ToastContextValue, ToastType } from './types'\n     5→\n     6→const ToastContext = createContext<ToastContextValue | null>(null)\n     7→\n     8→// Default durations per type - Open/Closed Principle: easily extensible\n     9→const DEFAULT_DURATIONS: Record<ToastType, number> = {\n    10→  success: 4000,\n    11→  error: 6000,\n    12→  warning: 5000,\n    13→  info: 4000,\n    14→}\n    15→\n    16→interface ToastProviderProps {\n    17→  children: ReactNode\n    18→}\n    19→\n    20→export function ToastProvider({ children }: ToastProviderProps) {\n    21→  const [toasts, setToasts] = useState<Toast[]>([])\n    22→\n    23→  const generateId = useCallback(() => {\n    24→    return `toast-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`\n    25→  }, [])\n    26→\n    27→  const removeToast = useCallback((id: string) => {\n    28→    setToasts((prev) => prev.filter((toast) => toast.id !== id))\n    29→  }, [])\n    30→\n    31→  const addToast = useCallback(\n    32→    (type: ToastType, config: ToastConfig): string => {\n    33→      const id = generateId()\n    34→      const duration = config.duration ?? DEFAULT_DURATIONS[type]\n    35→      const dismissible = config.dismissible ?? true\n    36→\n    37→      const newToast: Toast = {\n    38→        id,\n    39→        type,\n    40→        title: config.title,\n    41→        message: config.message,\n    42→        duration,\n    43→        dismissible,\n    44→      }\n    45→\n    46→      setToasts((prev) => [...prev, newToast])\n    47→\n    48→      // Auto-remove after duration\n    49→      if (duration > 0) {\n    50→        setTimeout(() => {\n    51→          removeToast(id)\n    52→        }, duration)\n    53→      }\n    54→\n    55→      return id\n    56→    },\n    57→    [generateId, removeToast]\n    58→  )\n    59→\n    60→  // Convenience methods - Single Responsibility for each type\n    61→  const success = useCallback(\n    62→    (title: string, message?: string) => addToast('success', { title, message }),\n    63→    [addToast]\n    64→  )\n    65→\n    66→  const error = useCallback(\n    67→    (title: string, message?: string) => addToast('error', { title, message }),\n    68→    [addToast]\n    69→  )\n    70→\n    71→  const warning = useCallback(\n    72→    (title: string, message?: string) => addToast('warning', { title, message }),\n    73→    [addToast]\n    74→  )\n    75→\n    76→  const info = useCallback(\n    77→    (title: string, message?: string) => addToast('info', { title, message }),\n    78→    [addToast]\n    79→  )\n    80→\n    81→  const value = useMemo(\n    82→    () => ({\n    83→      toasts,\n    84→      addToast,\n    85→      removeToast,\n    86→      success,\n    87→      error,\n    88→      warning,\n    89→      info,\n    90→    }),\n    91→    [toasts, addToast, removeToast, success, error, warning, info]\n    92→  )\n    93→\n    94→  return <ToastContext.Provider value={value}>{children}</ToastContext.Provider>\n    95→}\n    96→\n    97→// Custom hook with proper error handling\n    98→export function useToast(): ToastContextValue {\n    99→  const context = useContext(ToastContext)\n   100→  if (!context) {\n   101→    throw new Error('useToast must be used within a ToastProvider')\n   102→  }\n   103→  return context\n   104→}\n   105→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"82843a93-e7a4-44fb-8cdc-47b0041fdfb2","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/ui/Toast/ToastContext.tsx","content":"'use client'\n\nimport { createContext, useContext, useCallback, useState, useMemo, ReactNode } from 'react'\nimport { Toast, ToastConfig, ToastContextValue, ToastType } from './types'\n\nconst ToastContext = createContext<ToastContextValue | null>(null)\n\n// Default durations per type - Open/Closed Principle: easily extensible\nconst DEFAULT_DURATIONS: Record<ToastType, number> = {\n  success: 4000,\n  error: 6000,\n  warning: 5000,\n  info: 4000,\n}\n\ninterface ToastProviderProps {\n  children: ReactNode\n}\n\nexport function ToastProvider({ children }: ToastProviderProps) {\n  const [toasts, setToasts] = useState<Toast[]>([])\n\n  const generateId = useCallback(() => {\n    return `toast-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`\n  }, [])\n\n  const removeToast = useCallback((id: string) => {\n    setToasts((prev) => prev.filter((toast) => toast.id !== id))\n  }, [])\n\n  const addToast = useCallback(\n    (type: ToastType, config: ToastConfig): string => {\n      const id = generateId()\n      const duration = config.duration ?? DEFAULT_DURATIONS[type]\n      const dismissible = config.dismissible ?? true\n\n      const newToast: Toast = {\n        id,\n        type,\n        title: config.title,\n        message: config.message,\n        duration,\n        dismissible,\n      }\n\n      setToasts((prev) => [...prev, newToast])\n\n      // Auto-remove after duration\n      if (duration > 0) {\n        setTimeout(() => {\n          removeToast(id)\n        }, duration)\n      }\n\n      return id\n    },\n    [generateId, removeToast]\n  )\n\n  // Convenience methods - Single Responsibility for each type\n  const success = useCallback(\n    (title: string, message?: string) => addToast('success', { title, message }),\n    [addToast]\n  )\n\n  const error = useCallback(\n    (title: string, message?: string) => addToast('error', { title, message }),\n    [addToast]\n  )\n\n  const warning = useCallback(\n    (title: string, message?: string) => addToast('warning', { title, message }),\n    [addToast]\n  )\n\n  const info = useCallback(\n    (title: string, message?: string) => addToast('info', { title, message }),\n    [addToast]\n  )\n\n  const value = useMemo(\n    () => ({\n      toasts,\n      addToast,\n      removeToast,\n      success,\n      error,\n      warning,\n      info,\n    }),\n    [toasts, addToast, removeToast, success, error, warning, info]\n  )\n\n  return <ToastContext.Provider value={value}>{children}</ToastContext.Provider>\n}\n\n// Custom hook with proper error handling\nexport function useToast(): ToastContextValue {\n  const context = useContext(ToastContext)\n  if (!context) {\n    throw new Error('useToast must be used within a ToastProvider')\n  }\n  return context\n}\n","numLines":105,"startLine":1,"totalLines":105}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F1zQs2h2oN9n2n7gmKHC7y","type":"tool_result","content":"total 80\ndrwxr-xr-x  5 martin  staff    160 Jan 22 22:56 .\ndrwxr-xr-x  9 martin  staff    288 Jan 22 17:59 ..\n-rw-r--r--@ 1 martin  staff   7966 Jan 17 19:18 database.types.ts\n-rw-r--r--@ 1 martin  staff   8878 Jan 17 02:09 flow.types.ts\n-rw-r--r--@ 1 martin  staff  20313 Jan 22 22:56 scraper.types.ts","is_error":false}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"393198c7-1593-46a3-83af-bc63a5edcd7b","tool_use_result":{"stdout":"total 80\ndrwxr-xr-x  5 martin  staff    160 Jan 22 22:56 .\ndrwxr-xr-x  9 martin  staff    288 Jan 22 17:59 ..\n-rw-r--r--@ 1 martin  staff   7966 Jan 17 19:18 database.types.ts\n-rw-r--r--@ 1 martin  staff   8878 Jan 17 02:09 flow.types.ts\n-rw-r--r--@ 1 martin  staff  20313 Jan 22 22:56 scraper.types.ts","stderr":"","interrupted":false,"isImage":false}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SJcgijBTX2j37hvu464Tjn","type":"tool_result","content":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SearchWithPreviewPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepInspectionPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/OutputSection.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/QueryPreviewPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/StepOutputEditor.tsx","is_error":false}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"0bce3b7b-355c-4fb9-a306-22cf0a65fe06","tool_use_result":{"stdout":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SearchWithPreviewPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepInspectionPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/OutputSection.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/QueryPreviewPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/StepOutputEditor.tsx","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Qaw74jGfPgvWGiaMhC9Ccq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CXCntMwuNwK9UhxL7Tystq","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/types/database.types.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":188,"cache_creation_input_tokens":3866,"cache_read_input_tokens":108665,"cache_creation":{"ephemeral_5m_input_tokens":3866,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"8f8f10b8-e6e5-4e00-bd81-c6c454867bff"}
{"type":"assistant","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Qaw74jGfPgvWGiaMhC9Ccq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q2vw66DPQLc7ZDhpNedAEe","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/StepOutputEditor.tsx","limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":188,"cache_creation_input_tokens":3866,"cache_read_input_tokens":108665,"cache_creation":{"ephemeral_5m_input_tokens":3866,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"c072c4e8-fd58-4cb4-a5a3-9e2af73a08aa"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CXCntMwuNwK9UhxL7Tystq","type":"tool_result","content":"     1→export type Json =\n     2→  | string\n     3→  | number\n     4→  | boolean\n     5→  | null\n     6→  | { [key: string]: Json | undefined }\n     7→  | Json[]\n     8→\n     9→// Base categories + custom string categories are allowed\n    10→export type DocCategory = 'product' | 'competitor' | 'research' | 'output' | string\n    11→\n    12→export type CampaignStatus =\n    13→  | 'pending_research'\n    14→  | 'research_complete'\n    15→  | 'step_1_running'\n    16→  | 'step_1_complete'\n    17→  | 'step_2_running'\n    18→  | 'step_2_complete'\n    19→  | 'step_3_running'\n    20→  | 'step_3_complete'\n    21→  | 'step_4_running'\n    22→  | 'completed'\n    23→  | 'error'\n    24→\n    25→export type PlaybookType = 'ecp' | 'niche_finder' | 'competitor_analysis' | 'signal_based_outreach' | 'video_viral_ia' | 'custom'\n    26→\n    27→export interface Database {\n    28→  public: {\n    29→    Tables: {\n    30→      projects: {\n    31→        Row: {\n    32→          id: string\n    33→          user_id: string\n    34→          name: string\n    35→          description: string | null\n    36→          created_at: string\n    37→          updated_at: string\n    38→          context_config: Json\n    39→          prompt_deep_research: string\n    40→          prompt_1_find_place: string\n    41→          prompt_2_select_assets: string\n    42→          prompt_3_proof_legit: string\n    43→          prompt_4_final_output: string\n    44→          step_1_guidance: string | null\n    45→          step_2_guidance: string | null\n    46→          step_3_guidance: string | null\n    47→          step_4_guidance: string | null\n    48→          flow_config: Json | null\n    49→          variable_definitions: Json\n    50→          deep_research_prompts: Json\n    51→          campaign_docs_guide: string | null\n    52→          playbook_type: PlaybookType\n    53→        }\n    54→        Insert: {\n    55→          id?: string\n    56→          user_id: string\n    57→          name: string\n    58→          description?: string | null\n    59→          created_at?: string\n    60→          updated_at?: string\n    61→          context_config?: Json\n    62→          prompt_deep_research?: string\n    63→          prompt_1_find_place?: string\n    64→          prompt_2_select_assets?: string\n    65→          prompt_3_proof_legit?: string\n    66→          prompt_4_final_output?: string\n    67→          step_1_guidance?: string | null\n    68→          step_2_guidance?: string | null\n    69→          step_3_guidance?: string | null\n    70→          step_4_guidance?: string | null\n    71→          flow_config?: Json | null\n    72→          variable_definitions?: Json\n    73→          deep_research_prompts?: Json\n    74→          campaign_docs_guide?: string | null\n    75→          playbook_type?: PlaybookType\n    76→        }\n    77→        Update: {\n    78→          id?: string\n    79→          user_id?: string\n    80→          name?: string\n    81→          description?: string | null\n    82→          created_at?: string\n    83→          updated_at?: string\n    84→          context_config?: Json\n    85→          prompt_deep_research?: string\n    86→          prompt_1_find_place?: string\n    87→          prompt_2_select_assets?: string\n    88→          prompt_3_proof_legit?: string\n    89→          prompt_4_final_output?: string\n    90→          step_1_guidance?: string | null\n    91→          step_2_guidance?: string | null\n    92→          step_3_guidance?: string | null\n    93→          step_4_guidance?: string | null\n    94→          flow_config?: Json | null\n    95→          variable_definitions?: Json\n    96→          deep_research_prompts?: Json\n    97→          campaign_docs_guide?: string | null\n    98→          playbook_type?: PlaybookType\n    99→        }\n   100→      }\n   101→      knowledge_base_docs: {\n   102→        Row: {\n   103→          id: string\n   104→          project_id: string\n   105→          filename: string\n   106→          category: DocCategory\n   107→          extracted_content: string\n   108→          description: string\n   109→          file_size_bytes: number | null\n   110→          token_count: number | null\n   111→          mime_type: string | null\n   112→          created_at: string\n   113→        }\n   114→        Insert: {\n   115→          id?: string\n   116→          project_id: string\n   117→          filename: string\n   118→          category: DocCategory\n   119→          extracted_content: string\n   120→          description?: string\n   121→          file_size_bytes?: number | null\n   122→          token_count?: number | null\n   123→          mime_type?: string | null\n   124→          created_at?: string\n   125→        }\n   126→        Update: {\n   127→          id?: string\n   128→          project_id?: string\n   129→          filename?: string\n   130→          category?: DocCategory\n   131→          extracted_content?: string\n   132→          description?: string\n   133→          file_size_bytes?: number | null\n   134→          token_count?: number | null\n   135→          mime_type?: string | null\n   136→          created_at?: string\n   137→        }\n   138→      }\n   139→      ecp_campaigns: {\n   140→        Row: {\n   141→          id: string\n   142→          project_id: string\n   143→          ecp_name: string\n   144→          problem_core: string\n   145→          country: string\n   146→          industry: string\n   147→          status: CampaignStatus\n   148→          deep_research_text: string | null\n   149→          deep_research_tokens: number | null\n   150→          output_1_find_place: string | null\n   151→          output_1_tokens: number | null\n   152→          output_2_select_assets: string | null\n   153→          output_2_tokens: number | null\n   154→          output_3_proof_legit: string | null\n   155→          output_3_tokens: number | null\n   156→          output_final_messages: string | null\n   157→          output_final_tokens: number | null\n   158→          created_at: string\n   159→          updated_at: string\n   160→          error_message: string | null\n   161→          custom_variables: Json\n   162→        }\n   163→        Insert: {\n   164→          id?: string\n   165→          project_id: string\n   166→          ecp_name: string\n   167→          problem_core: string\n   168→          country: string\n   169→          industry: string\n   170→          status?: CampaignStatus\n   171→          deep_research_text?: string | null\n   172→          deep_research_tokens?: number | null\n   173→          output_1_find_place?: string | null\n   174→          output_1_tokens?: number | null\n   175→          output_2_select_assets?: string | null\n   176→          output_2_tokens?: number | null\n   177→          output_3_proof_legit?: string | null\n   178→          output_3_tokens?: number | null\n   179→          output_final_messages?: string | null\n   180→          output_final_tokens?: number | null\n   181→          created_at?: string\n   182→          updated_at?: string\n   183→          error_message?: string | null\n   184→          custom_variables?: Json\n   185→        }\n   186→        Update: {\n   187→          id?: string\n   188→          project_id?: string\n   189→          ecp_name?: string\n   190→          problem_core?: string\n   191→          country?: string\n   192→          industry?: string\n   193→          status?: CampaignStatus\n   194→          deep_research_text?: string | null\n   195→          deep_research_tokens?: number | null\n   196→          output_1_find_place?: string | null\n   197→          output_1_tokens?: number | null\n   198→          output_2_select_assets?: string | null\n   199→          output_2_tokens?: number | null\n   200→          output_3_proof_legit?: string | null\n   201→          output_3_tokens?: number | null\n   202→          output_final_messages?: string | null\n   203→          output_final_tokens?: number | null\n   204→          created_at?: string\n   205→          updated_at?: string\n   206→          error_message?: string | null\n   207→          custom_variables?: Json\n   208→        }\n   209→      }\n   210→      execution_logs: {\n   211→        Row: {\n   212→          id: string\n   213→          campaign_id: string\n   214→          step_name: string\n   215→          status: 'started' | 'completed' | 'error'\n   216→          input_tokens: number | null\n   217→          output_tokens: number | null\n   218→          duration_ms: number | null\n   219→          model_used: string | null\n   220→          error_details: string | null\n   221→          created_at: string\n   222→        }\n   223→        Insert: {\n   224→          id?: string\n   225→          campaign_id: string\n   226→          step_name: string\n   227→          status: 'started' | 'completed' | 'error'\n   228→          input_tokens?: number | null\n   229→          output_tokens?: number | null\n   230→          duration_ms?: number | null\n   231→          model_used?: string | null\n   232→          error_details?: string | null\n   233→          created_at?: string\n   234→        }\n   235→        Update: {\n   236→          id?: string\n   237→          campaign_id?: string\n   238→          step_name?: string\n   239→          status?: 'started' | 'completed' | 'error'\n   240→          input_tokens?: number | null\n   241→          output_tokens?: number | null\n   242→          duration_ms?: number | null\n   243→          model_used?: string | null\n   244→          error_details?: string | null\n   245→          created_at?: string\n   246→        }\n   247→      }\n   248→    }\n   249→    Views: {\n   250→      [_ in never]: never\n   251→    }\n   252→    Functions: {\n   253→      [_ in never]: never\n   254→    }\n   255→    Enums: {\n   256→      doc_category: DocCategory\n   257→    }\n   258→  }\n   259→}\n   260→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"a8e216a4-96dc-476c-b7e7-ceaaad5ca920","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/types/database.types.ts","content":"export type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: Json | undefined }\n  | Json[]\n\n// Base categories + custom string categories are allowed\nexport type DocCategory = 'product' | 'competitor' | 'research' | 'output' | string\n\nexport type CampaignStatus =\n  | 'pending_research'\n  | 'research_complete'\n  | 'step_1_running'\n  | 'step_1_complete'\n  | 'step_2_running'\n  | 'step_2_complete'\n  | 'step_3_running'\n  | 'step_3_complete'\n  | 'step_4_running'\n  | 'completed'\n  | 'error'\n\nexport type PlaybookType = 'ecp' | 'niche_finder' | 'competitor_analysis' | 'signal_based_outreach' | 'video_viral_ia' | 'custom'\n\nexport interface Database {\n  public: {\n    Tables: {\n      projects: {\n        Row: {\n          id: string\n          user_id: string\n          name: string\n          description: string | null\n          created_at: string\n          updated_at: string\n          context_config: Json\n          prompt_deep_research: string\n          prompt_1_find_place: string\n          prompt_2_select_assets: string\n          prompt_3_proof_legit: string\n          prompt_4_final_output: string\n          step_1_guidance: string | null\n          step_2_guidance: string | null\n          step_3_guidance: string | null\n          step_4_guidance: string | null\n          flow_config: Json | null\n          variable_definitions: Json\n          deep_research_prompts: Json\n          campaign_docs_guide: string | null\n          playbook_type: PlaybookType\n        }\n        Insert: {\n          id?: string\n          user_id: string\n          name: string\n          description?: string | null\n          created_at?: string\n          updated_at?: string\n          context_config?: Json\n          prompt_deep_research?: string\n          prompt_1_find_place?: string\n          prompt_2_select_assets?: string\n          prompt_3_proof_legit?: string\n          prompt_4_final_output?: string\n          step_1_guidance?: string | null\n          step_2_guidance?: string | null\n          step_3_guidance?: string | null\n          step_4_guidance?: string | null\n          flow_config?: Json | null\n          variable_definitions?: Json\n          deep_research_prompts?: Json\n          campaign_docs_guide?: string | null\n          playbook_type?: PlaybookType\n        }\n        Update: {\n          id?: string\n          user_id?: string\n          name?: string\n          description?: string | null\n          created_at?: string\n          updated_at?: string\n          context_config?: Json\n          prompt_deep_research?: string\n          prompt_1_find_place?: string\n          prompt_2_select_assets?: string\n          prompt_3_proof_legit?: string\n          prompt_4_final_output?: string\n          step_1_guidance?: string | null\n          step_2_guidance?: string | null\n          step_3_guidance?: string | null\n          step_4_guidance?: string | null\n          flow_config?: Json | null\n          variable_definitions?: Json\n          deep_research_prompts?: Json\n          campaign_docs_guide?: string | null\n          playbook_type?: PlaybookType\n        }\n      }\n      knowledge_base_docs: {\n        Row: {\n          id: string\n          project_id: string\n          filename: string\n          category: DocCategory\n          extracted_content: string\n          description: string\n          file_size_bytes: number | null\n          token_count: number | null\n          mime_type: string | null\n          created_at: string\n        }\n        Insert: {\n          id?: string\n          project_id: string\n          filename: string\n          category: DocCategory\n          extracted_content: string\n          description?: string\n          file_size_bytes?: number | null\n          token_count?: number | null\n          mime_type?: string | null\n          created_at?: string\n        }\n        Update: {\n          id?: string\n          project_id?: string\n          filename?: string\n          category?: DocCategory\n          extracted_content?: string\n          description?: string\n          file_size_bytes?: number | null\n          token_count?: number | null\n          mime_type?: string | null\n          created_at?: string\n        }\n      }\n      ecp_campaigns: {\n        Row: {\n          id: string\n          project_id: string\n          ecp_name: string\n          problem_core: string\n          country: string\n          industry: string\n          status: CampaignStatus\n          deep_research_text: string | null\n          deep_research_tokens: number | null\n          output_1_find_place: string | null\n          output_1_tokens: number | null\n          output_2_select_assets: string | null\n          output_2_tokens: number | null\n          output_3_proof_legit: string | null\n          output_3_tokens: number | null\n          output_final_messages: string | null\n          output_final_tokens: number | null\n          created_at: string\n          updated_at: string\n          error_message: string | null\n          custom_variables: Json\n        }\n        Insert: {\n          id?: string\n          project_id: string\n          ecp_name: string\n          problem_core: string\n          country: string\n          industry: string\n          status?: CampaignStatus\n          deep_research_text?: string | null\n          deep_research_tokens?: number | null\n          output_1_find_place?: string | null\n          output_1_tokens?: number | null\n          output_2_select_assets?: string | null\n          output_2_tokens?: number | null\n          output_3_proof_legit?: string | null\n          output_3_tokens?: number | null\n          output_final_messages?: string | null\n          output_final_tokens?: number | null\n          created_at?: string\n          updated_at?: string\n          error_message?: string | null\n          custom_variables?: Json\n        }\n        Update: {\n          id?: string\n          project_id?: string\n          ecp_name?: string\n          problem_core?: string\n          country?: string\n          industry?: string\n          status?: CampaignStatus\n          deep_research_text?: string | null\n          deep_research_tokens?: number | null\n          output_1_find_place?: string | null\n          output_1_tokens?: number | null\n          output_2_select_assets?: string | null\n          output_2_tokens?: number | null\n          output_3_proof_legit?: string | null\n          output_3_tokens?: number | null\n          output_final_messages?: string | null\n          output_final_tokens?: number | null\n          created_at?: string\n          updated_at?: string\n          error_message?: string | null\n          custom_variables?: Json\n        }\n      }\n      execution_logs: {\n        Row: {\n          id: string\n          campaign_id: string\n          step_name: string\n          status: 'started' | 'completed' | 'error'\n          input_tokens: number | null\n          output_tokens: number | null\n          duration_ms: number | null\n          model_used: string | null\n          error_details: string | null\n          created_at: string\n        }\n        Insert: {\n          id?: string\n          campaign_id: string\n          step_name: string\n          status: 'started' | 'completed' | 'error'\n          input_tokens?: number | null\n          output_tokens?: number | null\n          duration_ms?: number | null\n          model_used?: string | null\n          error_details?: string | null\n          created_at?: string\n        }\n        Update: {\n          id?: string\n          campaign_id?: string\n          step_name?: string\n          status?: 'started' | 'completed' | 'error'\n          input_tokens?: number | null\n          output_tokens?: number | null\n          duration_ms?: number | null\n          model_used?: string | null\n          error_details?: string | null\n          created_at?: string\n        }\n      }\n    }\n    Views: {\n      [_ in never]: never\n    }\n    Functions: {\n      [_ in never]: never\n    }\n    Enums: {\n      doc_category: DocCategory\n    }\n  }\n}\n","numLines":260,"startLine":1,"totalLines":260}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q2vw66DPQLc7ZDhpNedAEe","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useMemo, useRef, useEffect } from 'react'\n     4→import { X, Save, RotateCcw, Edit2, AlertTriangle, Table, Download, Sparkles, Loader2, Check, XCircle, MousePointer2, ChevronDown, ChevronUp, FileOutput, Clock, Hash, Type, Cpu, Settings, Maximize2, Minimize2, Database } from 'lucide-react'\n     5→import MarkdownRenderer, { extractTables, tablesToCSV } from '../common/MarkdownRenderer'\n     6→import { useToast, useModal } from '@/components/ui'\n     7→import { useOpenRouter } from '@/lib/openrouter-context'\n     8→import OpenRouterModelSelector from '@/components/openrouter/OpenRouterModelSelector'\n     9→import SaveToContextLakeModal, { StepOutputContext } from '@/components/documents/SaveToContextLakeModal'\n    10→\n    11→// Token equivalence helper: 1 token ≈ 0.75 words, 500 words = 1 page\n    12→const getTokenEquivalence = (tokens: number) => {\n    13→  const words = Math.round(tokens * 0.75)\n    14→  const pages = (words / 500).toFixed(1)\n    15→  return { words, pages }\n    16→}\n    17→\n    18→interface StepDocument {\n    19→  id: string\n    20→  filename: string\n    21→  category: string\n    22→  extracted_content?: string\n    23→  token_count?: number\n    24→}\n    25→\n    26→interface StepOutputEditorProps {\n    27→  campaignId: string\n    28→  campaignName: string\n    29→  stepId: string\n    30→  stepName: string\n    31→  stepOrder: number\n    32→  currentOutput: {\n    33→    step_name: string\n    34→    output: string\n    35→    tokens?: number\n    36→    status: string\n    37→    completed_at?: string\n    38→    edited_at?: string\n    39→    original_output?: string\n    40→    model_used?: string\n    41→    model_provider?: string\n    42→    input_tokens?: number\n    43→    output_tokens?: number\n    44→  }\n    45→  allStepOutputs: Record<string, any>\n    46→  stepDocuments?: StepDocument[]\n    47→  onSave: (updatedStepOutputs: Record<string, any>) => void\n    48→  onClose: () => void\n    49→  // Context Lake integration\n    50→  projectId?: string\n    51→  clientId?: string\n    52→  userId?: string\n    53→  playbookId?: string\n    54→  playbookName?: string\n    55→  campaignVariables?: Record<string, string>\n    56→  onSaveToContextLake?: (docId: string) => void\n    57→}\n    58→\n    59→// Generate a simple summary of changes between two texts\n    60→function generateChangeSummary(original: string, modified: string): string[] {\n    61→  const changes: string[] = []\n    62→\n    63→  const origLines = original.split('\\n').filter(l => l.trim())\n    64→  const modLines = modified.split('\\n').filter(l => l.trim())\n    65→\n    66→  const origSet = new Set(origLines)\n    67→  const modSet = new Set(modLines)\n    68→\n    69→  // Find removed lines\n    70→  const removed = origLines.filter(l => !modSet.has(l))\n    71→  // Find added lines\n    72→  const added = modLines.filter(l => !origSet.has(l))\n    73→\n    74→  if (removed.length > 0) {\n    75→    changes.push(`${removed.length} línea(s) modificada(s)`)\n    76→  }\n    77→  if (added.length > 0) {\n    78→    changes.push(`${added.length} línea(s) nueva(s)`)\n    79→  }\n    80→\n    81→  // Character count change\n    82→  const charDiff = modified.length - original.length\n    83→  if (charDiff > 0) {\n    84→    changes.push(`+${charDiff} caracteres`)\n    85→  } else if (charDiff < 0) {\n    86→    changes.push(`${charDiff} caracteres`)\n    87→  }\n    88→\n    89→  return changes\n    90→}\n    91→\n    92→export default function StepOutputEditor({\n    93→  campaignId,\n    94→  campaignName,\n    95→  stepId,\n    96→  stepName,\n    97→  stepOrder,\n    98→  currentOutput,\n    99→  allStepOutputs,\n   100→  stepDocuments = [],\n   101→  onSave,\n   102→  onClose,\n   103→  // Context Lake integration\n   104→  projectId,\n   105→  clientId,\n   106→  userId,\n   107→  playbookId,\n   108→  playbookName,\n   109→  campaignVariables,\n   110→  onSaveToContextLake,\n   111→}: StepOutputEditorProps) {\n   112→  const toast = useToast()\n   113→  const modal = useModal()\n   114→\n   115→  // Context Lake modal state\n   116→  const [showContextLakeModal, setShowContextLakeModal] = useState(false)\n   117→\n   118→  const [editedOutput, setEditedOutput] = useState(currentOutput.output || '')\n   119→  const [saving, setSaving] = useState(false)\n   120→  const [isEditing, setIsEditing] = useState(false)\n   121→  const [hasChanges, setHasChanges] = useState(false)\n   122→\n   123→  // AI Assistant state\n   124→  const [aiPrompt, setAiPrompt] = useState('')\n   125→  const [isGenerating, setIsGenerating] = useState(false)\n   126→  const [aiSuggestion, setAiSuggestion] = useState<string | null>(null)\n   127→  const [showComparison, setShowComparison] = useState(false)\n   128→  const [showAiConfig, setShowAiConfig] = useState(false)\n   129→\n   130→  // OpenRouter context\n   131→  const { isConnected: isOpenRouterConnected } = useOpenRouter()\n   132→\n   133→  // AI Model configuration - load from localStorage if available\n   134→  const [aiModel, setAiModel] = useState(() => {\n   135→    if (typeof window !== 'undefined') {\n   136→      return localStorage.getItem('gatacca_suggest_model') || 'google/gemini-2.0-flash-exp:free'\n   137→    }\n   138→    return 'google/gemini-2.0-flash-exp:free'\n   139→  })\n   140→  const [aiTemperature, setAiTemperature] = useState(0.7)\n   141→  const [aiMaxTokens, setAiMaxTokens] = useState(8192)\n   142→  const [includeDocsInAi, setIncludeDocsInAi] = useState(true)\n   143→\n   144→  // Save model selection to localStorage\n   145→  useEffect(() => {\n   146→    if (aiModel) {\n   147→      localStorage.setItem('gatacca_suggest_model', aiModel)\n   148→    }\n   149→  }, [aiModel])\n   150→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"0ffa37e9-09f9-4b00-8ab3-b01474ca7d71","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/campaign/StepOutputEditor.tsx","content":"'use client'\n\nimport { useState, useMemo, useRef, useEffect } from 'react'\nimport { X, Save, RotateCcw, Edit2, AlertTriangle, Table, Download, Sparkles, Loader2, Check, XCircle, MousePointer2, ChevronDown, ChevronUp, FileOutput, Clock, Hash, Type, Cpu, Settings, Maximize2, Minimize2, Database } from 'lucide-react'\nimport MarkdownRenderer, { extractTables, tablesToCSV } from '../common/MarkdownRenderer'\nimport { useToast, useModal } from '@/components/ui'\nimport { useOpenRouter } from '@/lib/openrouter-context'\nimport OpenRouterModelSelector from '@/components/openrouter/OpenRouterModelSelector'\nimport SaveToContextLakeModal, { StepOutputContext } from '@/components/documents/SaveToContextLakeModal'\n\n// Token equivalence helper: 1 token ≈ 0.75 words, 500 words = 1 page\nconst getTokenEquivalence = (tokens: number) => {\n  const words = Math.round(tokens * 0.75)\n  const pages = (words / 500).toFixed(1)\n  return { words, pages }\n}\n\ninterface StepDocument {\n  id: string\n  filename: string\n  category: string\n  extracted_content?: string\n  token_count?: number\n}\n\ninterface StepOutputEditorProps {\n  campaignId: string\n  campaignName: string\n  stepId: string\n  stepName: string\n  stepOrder: number\n  currentOutput: {\n    step_name: string\n    output: string\n    tokens?: number\n    status: string\n    completed_at?: string\n    edited_at?: string\n    original_output?: string\n    model_used?: string\n    model_provider?: string\n    input_tokens?: number\n    output_tokens?: number\n  }\n  allStepOutputs: Record<string, any>\n  stepDocuments?: StepDocument[]\n  onSave: (updatedStepOutputs: Record<string, any>) => void\n  onClose: () => void\n  // Context Lake integration\n  projectId?: string\n  clientId?: string\n  userId?: string\n  playbookId?: string\n  playbookName?: string\n  campaignVariables?: Record<string, string>\n  onSaveToContextLake?: (docId: string) => void\n}\n\n// Generate a simple summary of changes between two texts\nfunction generateChangeSummary(original: string, modified: string): string[] {\n  const changes: string[] = []\n\n  const origLines = original.split('\\n').filter(l => l.trim())\n  const modLines = modified.split('\\n').filter(l => l.trim())\n\n  const origSet = new Set(origLines)\n  const modSet = new Set(modLines)\n\n  // Find removed lines\n  const removed = origLines.filter(l => !modSet.has(l))\n  // Find added lines\n  const added = modLines.filter(l => !origSet.has(l))\n\n  if (removed.length > 0) {\n    changes.push(`${removed.length} línea(s) modificada(s)`)\n  }\n  if (added.length > 0) {\n    changes.push(`${added.length} línea(s) nueva(s)`)\n  }\n\n  // Character count change\n  const charDiff = modified.length - original.length\n  if (charDiff > 0) {\n    changes.push(`+${charDiff} caracteres`)\n  } else if (charDiff < 0) {\n    changes.push(`${charDiff} caracteres`)\n  }\n\n  return changes\n}\n\nexport default function StepOutputEditor({\n  campaignId,\n  campaignName,\n  stepId,\n  stepName,\n  stepOrder,\n  currentOutput,\n  allStepOutputs,\n  stepDocuments = [],\n  onSave,\n  onClose,\n  // Context Lake integration\n  projectId,\n  clientId,\n  userId,\n  playbookId,\n  playbookName,\n  campaignVariables,\n  onSaveToContextLake,\n}: StepOutputEditorProps) {\n  const toast = useToast()\n  const modal = useModal()\n\n  // Context Lake modal state\n  const [showContextLakeModal, setShowContextLakeModal] = useState(false)\n\n  const [editedOutput, setEditedOutput] = useState(currentOutput.output || '')\n  const [saving, setSaving] = useState(false)\n  const [isEditing, setIsEditing] = useState(false)\n  const [hasChanges, setHasChanges] = useState(false)\n\n  // AI Assistant state\n  const [aiPrompt, setAiPrompt] = useState('')\n  const [isGenerating, setIsGenerating] = useState(false)\n  const [aiSuggestion, setAiSuggestion] = useState<string | null>(null)\n  const [showComparison, setShowComparison] = useState(false)\n  const [showAiConfig, setShowAiConfig] = useState(false)\n\n  // OpenRouter context\n  const { isConnected: isOpenRouterConnected } = useOpenRouter()\n\n  // AI Model configuration - load from localStorage if available\n  const [aiModel, setAiModel] = useState(() => {\n    if (typeof window !== 'undefined') {\n      return localStorage.getItem('gatacca_suggest_model') || 'google/gemini-2.0-flash-exp:free'\n    }\n    return 'google/gemini-2.0-flash-exp:free'\n  })\n  const [aiTemperature, setAiTemperature] = useState(0.7)\n  const [aiMaxTokens, setAiMaxTokens] = useState(8192)\n  const [includeDocsInAi, setIncludeDocsInAi] = useState(true)\n\n  // Save model selection to localStorage\n  useEffect(() => {\n    if (aiModel) {\n      localStorage.setItem('gatacca_suggest_model', aiModel)\n    }\n  }, [aiModel])\n","numLines":150,"startLine":1,"totalLines":945}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NeTViCLxxDiXQemcH8frdz","type":"tool_result","content":[{"type":"text","text":"Perfect! Now I have a comprehensive understanding. Let me create a detailed analysis document:\n\n## Codebase Exploration Summary\n\nI've thoroughly explored your codebase and documented all the key patterns and implementations relevant to building the Artifact Browser. Here's my comprehensive analysis:\n\n---\n\n### 1. SESSION-RELATED COMPONENTS & STATE MANAGEMENT\n\n**Key Files:**\n- `/src/app/api/playbook/sessions/route.ts` - Session API (create, list)\n- `/src/components/playbook/AllSessionsPanel.tsx` - Session history panel\n\n**Patterns to Follow:**\n- Sessions stored in `playbook_sessions` table with fields: `id`, `project_id`, `playbook_type`, `name`, `status`, `current_step`, `created_at`, `updated_at`, `tags`\n- Status values: `'draft' | 'running' | 'paused' | 'completed' | 'failed'`\n- AllSessionsPanel uses:\n  - Debounced search/filter state\n  - Tab-based UI for filtering (status, date range)\n  - Collapsible filters section\n  - Real-time list updates via `useCallback` and `useEffect`\n\n---\n\n### 2. CONTEXT & SESSION DATA STORAGE\n\n**Key Files:**\n- `/src/hooks/useDocuments.ts` - Comprehensive document management hooks\n- `/src/lib/auth-context.tsx` - Authentication context pattern\n\n**Document Types:**\n```typescript\ninterface Document {\n  id: string\n  project_id?: string | null\n  client_id?: string | null\n  filename: string\n  category: string\n  extracted_content: string | null\n  source_type: 'import' | 'scraper' | 'playbook' | 'api'\n  source_metadata?: Record<string, unknown>\n  tags?: string[] | null\n  folder?: string | null\n  is_deleted?: boolean\n  version_count?: number\n  created_at: string\n}\n```\n\n**Key Hooks:**\n- `useDocuments(projectId)` - Project-level docs\n- `useClientDocuments(clientId)` - Client-level shared docs\n- `useContextLake(projectId, clientId?)` - Combined project + client docs\n- `useAllClientDocuments(clientId)` - All docs across all projects for a client\n\n**State Management Pattern:**\n- Context API + custom hooks with local state (`useState`)\n- Supabase client for data fetching\n- Soft delete pattern (preserves audit trail)\n- Document grouping by folder with `groupByFolder()` utility\n\n---\n\n### 3. MODAL PATTERNS\n\n**Files:**\n- `/src/components/ui/Modal/ModalContext.tsx` - Global modal context\n- `/src/components/documents/SaveToContextLakeModal.tsx` - Rich modal example\n- `/src/components/ui/Modal/ConfirmModal.tsx` - Simple confirm modal\n\n**SaveToContextLakeModal Pattern:**\n- Uses `createPortal()` for rendering outside DOM hierarchy\n- Manages mounted state separately from visibility (animation)\n- Form state management with multiple input types (text, select, textarea)\n- Tag management (add/remove dynamically)\n- Traceability section showing metadata\n- Content preview with character limit\n- Error state handling\n- Loading state with spinner\n- Header with icon and close button\n- Sticky header/footer pattern\n\n**ModalContext Pattern:**\n- Promise-based confirmation dialog\n- Returns boolean for async handling\n- Supports custom text, variant (danger/default), and icons\n- Single context for all modals (composable)\n\n---\n\n### 4. EXPANDABLE SECTIONS & TABS\n\n**Files:**\n- `/src/components/playbook/inspection/InputContextSection.tsx` - Expandable section\n- `/src/components/playbook/inspection/OutputSection.tsx` - Status-aware expandable\n- `/src/components/project/ExportDataTab.tsx` - Tab navigation pattern\n\n**InputContextSection Pattern:**\n```typescript\n- [isExpanded, setIsExpanded] = useState(defaultExpanded)\n- ChevronDown/ChevronRight icons for toggle\n- Conditional expansion with smooth reveal\n- Collapsible header with click handler\n- Summary text shown when collapsed (badge counts)\n```\n\n**ExportDataTab Pattern:**\n- Multiple sub-tabs with counts (e.g., \"Find Your Place (45)\")\n- Active tab styling with underline\n- Icon + label + count badge per tab\n- Tab switching updates rendered content\n- Filter dropdowns within tables\n\n---\n\n### 5. \"SAVE TO CONTEXT LAKE\" FUNCTIONALITY\n\n**Files:**\n- `/src/components/documents/SaveToContextLakeModal.tsx` - Main implementation\n- `/src/components/campaign/StepOutputEditor.tsx` - Usage example\n- `/src/app/api/documents/from-step-output/route.ts` - Backend API\n\n**Key Features:**\n1. **Form Fields:**\n   - Filename (required, pre-filled with smart default)\n   - Category dropdown (research, strategy, content, analysis, etc.)\n   - Destination toggle (project vs. client-level)\n   - Description textarea (optional)\n   - Tags (dynamic add/remove with Enter key)\n\n2. **Metadata Capture:**\n   ```typescript\n   interface PlaybookStepSourceMetadata {\n     origin_type: 'flow_step_output'\n     playbook_id, playbook_name\n     campaign_id, campaign_name, campaign_variables\n     step_id, step_name, step_order\n     executed_at, model_used, model_provider\n     input_tokens, output_tokens\n     input_document_ids, input_previous_step_ids\n     converted_at, converted_by\n     was_edited_before_conversion\n   }\n   ```\n\n3. **Traceability Display:**\n   - Info box showing campaign, step, model, creator\n   - Visual indication if output was edited before saving\n   - Character count in content preview\n\n4. **Error Handling:**\n   - Required field validation\n   - API error messages\n   - Loading state with spinner\n\n---\n\n### 6. EXPORT FUNCTIONALITY\n\n**Files:**\n- `/src/components/project/ExportDataTab.tsx` - CSV export with filtering\n\n**Patterns:**\n- CSV download via blob and `URL.createObjectURL()`\n- ZIP file downloads for multiple files\n- Column filtering dropdowns\n- Resizable columns using mouse drag handlers\n- Multi-tab table views (Find Place, Prove Legit, USP & UVP)\n- Toast notifications for success/error\n\n**Key Implementation:**\n```typescript\n// Export CSV\nconst response = await fetch(`/api/projects/${projectId}/export-csv`)\nconst blob = await response.blob()\nconst url = URL.createObjectURL(blob)\nconst a = document.createElement('a')\na.href = url\na.download = 'ecp-export.zip'\ndocument.body.appendChild(a)\na.click()\n```\n\n---\n\n### 7. UI PATTERNS & COMPONENT PATTERNS\n\n**Document List Pattern** (`/src/components/documents/DocumentList.tsx`):\n- Expandable rows with chevron icons\n- Inline search + multiple filter dropdowns\n- Bulk selection with \"select all\" checkbox\n- Hover state actions (edit, delete, more)\n- Tag-based filtering with quick filter buttons\n- Tier badges (T1, T2, T3) with hover tooltips\n- Source type badges with icons\n- Responsive two-tier layout (expanded info on second row for mobile)\n- Inline editing for names and descriptions\n\n**Folder View Pattern** (`/src/components/documents/DocumentFolderView.tsx`):\n- Hierarchical folder structure\n- Expandable folders with counts\n- \"Create new folder\" input\n- Drag-drop (implied but not fully shown)\n- Uncategorized default folder\n- Empty state messaging\n\n**Toast Pattern** (`/src/components/ui/Toast/ToastContext.tsx`):\n- Provider-based context\n- Convenience methods: `toast.success()`, `toast.error()`, `toast.warning()`, `toast.info()`\n- Auto-dismiss with configurable duration\n- Dismissible flag support\n\n---\n\n### 8. FORM & INPUT PATTERNS\n\n**Multi-select Tags:**\n```typescript\nconst [tags, setTags] = useState<string[]>([])\nconst [newTag, setNewTag] = useState('')\n\nconst handleAddTag = () => {\n  const trimmedTag = newTag.trim().toLowerCase()\n  if (trimmedTag && !tags.includes(trimmedTag)) {\n    setTags([...tags, trimmedTag])\n    setNewTag('')\n  }\n}\n\n// In JSX:\n{tags.map(tag => (\n  <span key={tag} className=\"inline-flex items-center\">\n    {tag}\n    <button onClick={() => setTags(tags.filter(t => t !== tag))}>×</button>\n  </span>\n))}\n```\n\n**Inline Editing Pattern:**\n```typescript\nconst [editingId, setEditingId] = useState<string | null>(null)\nconst [editingValue, setEditingValue] = useState('')\n\n// Toggle edit mode\nconst startEdit = (item) => {\n  setEditingId(item.id)\n  setEditingValue(item.value)\n}\n\n// Save with async handler\nconst handleSave = async (id) => {\n  setSaving(true)\n  try {\n    await onSave(id, editingValue)\n    setEditingId(null)\n  } finally {\n    setSaving(false)\n  }\n}\n```\n\n---\n\n### 9. DESIGN SYSTEM & STYLING\n\n**Color Scheme Used:**\n- Primary: `bg-blue-600`, `text-blue-600`\n- Secondary: `bg-indigo-600`, `text-indigo-600`\n- Success: `bg-green-600`, `text-green-600`\n- Danger: `bg-red-600`, `text-red-600`\n- Neutral: `bg-gray-50/100/200`, `text-gray-400/600/900`\n\n**Border Radius:** Consistently `rounded-xl` (large), `rounded-lg` (medium), `rounded` (small)\n\n**Spacing:** Gap system using `gap-2/3/4/6` consistently\n\n**Icons:** lucide-react library used throughout\n\n---\n\n### 10. RECOMMENDED STRUCTURE FOR ARTIFACT BROWSER\n\nBased on patterns observed:\n\n```\nArtifactBrowser/\n├── ArtifactBrowser.tsx (main component)\n├── hooks/\n│  ├── useArtifacts.ts (fetch/manage artifacts)\n│  └── useArtifactFilters.ts (filter state)\n├── components/\n│  ├── ArtifactList.tsx (main list view)\n│  ├── ArtifactGrid.tsx (grid view alternative)\n│  ├── ArtifactModal.tsx (view/edit modal)\n│  ├── ArtifactFilters.tsx (filter UI)\n│  └── ArtifactActionsToolbar.tsx (bulk actions)\n└── types/\n   └── artifact.types.ts\n```\n\n---\n\n### KEY TAKEAWAYS FOR YOUR IMPLEMENTATION\n\n1. **Use Existing Document/Session Infrastructure:** The codebase already has `knowledge_base_docs` table and session management - leverage this!\n\n2. **Follow Modal Pattern:** Use `SaveToContextLakeModal` as your reference - it's production-grade with proper lifecycle management\n\n3. **Implement Filtering Like DocumentList:** Search + multiple dropdowns + tag buttons work really well\n\n4. **Use Context API + Hooks:** Standard pattern throughout - Provider at app level, custom hooks for consumption\n\n5. **Expandable Sections:** ChevronDown/ChevronRight + useState for toggle, with summary badges when collapsed\n\n6. **Toast Notifications:** Use `useToast()` from context for feedback\n\n7. **Confirmation Dialogs:** Use `useModal().confirm()` for destructive actions\n\n8. **Tab Navigation:** Use border-b underline pattern with active state styling\n\n9. **Bulk Operations:** Checkbox selection with \"select all\" and toolbar appears\n\n10. **Mobile Responsiveness:** Use responsive grid/flex with hidden elements on smaller screens (`hidden sm:flex`)\n\nThis should give you a solid foundation for building the Artifact Browser with consistency to the rest of the codebase!"},{"type":"text","text":"agentId: a1ad87f (for resuming to continue this agent's work if needed)"}]}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"2db08476-4417-49e1-8e74-8d1c4bd486fc","tool_use_result":{"status":"completed","prompt":"Explore the codebase to understand:\n1. The structure of the src/components directory, especially any existing session-related components\n2. How artifacts/data are stored and managed in the session (look for session state, context, or stores)\n3. The existing modal patterns used in the app\n4. How the \"Save to Context Lake\" functionality is implemented\n5. Any existing export functionality (CSV/JSON)\n6. The UI patterns used for tabs/panels and expandable sections\n\nFocus on finding patterns I should follow for the Artifact Browser implementation.","agentId":"a1ad87f","content":[{"type":"text","text":"Perfect! Now I have a comprehensive understanding. Let me create a detailed analysis document:\n\n## Codebase Exploration Summary\n\nI've thoroughly explored your codebase and documented all the key patterns and implementations relevant to building the Artifact Browser. Here's my comprehensive analysis:\n\n---\n\n### 1. SESSION-RELATED COMPONENTS & STATE MANAGEMENT\n\n**Key Files:**\n- `/src/app/api/playbook/sessions/route.ts` - Session API (create, list)\n- `/src/components/playbook/AllSessionsPanel.tsx` - Session history panel\n\n**Patterns to Follow:**\n- Sessions stored in `playbook_sessions` table with fields: `id`, `project_id`, `playbook_type`, `name`, `status`, `current_step`, `created_at`, `updated_at`, `tags`\n- Status values: `'draft' | 'running' | 'paused' | 'completed' | 'failed'`\n- AllSessionsPanel uses:\n  - Debounced search/filter state\n  - Tab-based UI for filtering (status, date range)\n  - Collapsible filters section\n  - Real-time list updates via `useCallback` and `useEffect`\n\n---\n\n### 2. CONTEXT & SESSION DATA STORAGE\n\n**Key Files:**\n- `/src/hooks/useDocuments.ts` - Comprehensive document management hooks\n- `/src/lib/auth-context.tsx` - Authentication context pattern\n\n**Document Types:**\n```typescript\ninterface Document {\n  id: string\n  project_id?: string | null\n  client_id?: string | null\n  filename: string\n  category: string\n  extracted_content: string | null\n  source_type: 'import' | 'scraper' | 'playbook' | 'api'\n  source_metadata?: Record<string, unknown>\n  tags?: string[] | null\n  folder?: string | null\n  is_deleted?: boolean\n  version_count?: number\n  created_at: string\n}\n```\n\n**Key Hooks:**\n- `useDocuments(projectId)` - Project-level docs\n- `useClientDocuments(clientId)` - Client-level shared docs\n- `useContextLake(projectId, clientId?)` - Combined project + client docs\n- `useAllClientDocuments(clientId)` - All docs across all projects for a client\n\n**State Management Pattern:**\n- Context API + custom hooks with local state (`useState`)\n- Supabase client for data fetching\n- Soft delete pattern (preserves audit trail)\n- Document grouping by folder with `groupByFolder()` utility\n\n---\n\n### 3. MODAL PATTERNS\n\n**Files:**\n- `/src/components/ui/Modal/ModalContext.tsx` - Global modal context\n- `/src/components/documents/SaveToContextLakeModal.tsx` - Rich modal example\n- `/src/components/ui/Modal/ConfirmModal.tsx` - Simple confirm modal\n\n**SaveToContextLakeModal Pattern:**\n- Uses `createPortal()` for rendering outside DOM hierarchy\n- Manages mounted state separately from visibility (animation)\n- Form state management with multiple input types (text, select, textarea)\n- Tag management (add/remove dynamically)\n- Traceability section showing metadata\n- Content preview with character limit\n- Error state handling\n- Loading state with spinner\n- Header with icon and close button\n- Sticky header/footer pattern\n\n**ModalContext Pattern:**\n- Promise-based confirmation dialog\n- Returns boolean for async handling\n- Supports custom text, variant (danger/default), and icons\n- Single context for all modals (composable)\n\n---\n\n### 4. EXPANDABLE SECTIONS & TABS\n\n**Files:**\n- `/src/components/playbook/inspection/InputContextSection.tsx` - Expandable section\n- `/src/components/playbook/inspection/OutputSection.tsx` - Status-aware expandable\n- `/src/components/project/ExportDataTab.tsx` - Tab navigation pattern\n\n**InputContextSection Pattern:**\n```typescript\n- [isExpanded, setIsExpanded] = useState(defaultExpanded)\n- ChevronDown/ChevronRight icons for toggle\n- Conditional expansion with smooth reveal\n- Collapsible header with click handler\n- Summary text shown when collapsed (badge counts)\n```\n\n**ExportDataTab Pattern:**\n- Multiple sub-tabs with counts (e.g., \"Find Your Place (45)\")\n- Active tab styling with underline\n- Icon + label + count badge per tab\n- Tab switching updates rendered content\n- Filter dropdowns within tables\n\n---\n\n### 5. \"SAVE TO CONTEXT LAKE\" FUNCTIONALITY\n\n**Files:**\n- `/src/components/documents/SaveToContextLakeModal.tsx` - Main implementation\n- `/src/components/campaign/StepOutputEditor.tsx` - Usage example\n- `/src/app/api/documents/from-step-output/route.ts` - Backend API\n\n**Key Features:**\n1. **Form Fields:**\n   - Filename (required, pre-filled with smart default)\n   - Category dropdown (research, strategy, content, analysis, etc.)\n   - Destination toggle (project vs. client-level)\n   - Description textarea (optional)\n   - Tags (dynamic add/remove with Enter key)\n\n2. **Metadata Capture:**\n   ```typescript\n   interface PlaybookStepSourceMetadata {\n     origin_type: 'flow_step_output'\n     playbook_id, playbook_name\n     campaign_id, campaign_name, campaign_variables\n     step_id, step_name, step_order\n     executed_at, model_used, model_provider\n     input_tokens, output_tokens\n     input_document_ids, input_previous_step_ids\n     converted_at, converted_by\n     was_edited_before_conversion\n   }\n   ```\n\n3. **Traceability Display:**\n   - Info box showing campaign, step, model, creator\n   - Visual indication if output was edited before saving\n   - Character count in content preview\n\n4. **Error Handling:**\n   - Required field validation\n   - API error messages\n   - Loading state with spinner\n\n---\n\n### 6. EXPORT FUNCTIONALITY\n\n**Files:**\n- `/src/components/project/ExportDataTab.tsx` - CSV export with filtering\n\n**Patterns:**\n- CSV download via blob and `URL.createObjectURL()`\n- ZIP file downloads for multiple files\n- Column filtering dropdowns\n- Resizable columns using mouse drag handlers\n- Multi-tab table views (Find Place, Prove Legit, USP & UVP)\n- Toast notifications for success/error\n\n**Key Implementation:**\n```typescript\n// Export CSV\nconst response = await fetch(`/api/projects/${projectId}/export-csv`)\nconst blob = await response.blob()\nconst url = URL.createObjectURL(blob)\nconst a = document.createElement('a')\na.href = url\na.download = 'ecp-export.zip'\ndocument.body.appendChild(a)\na.click()\n```\n\n---\n\n### 7. UI PATTERNS & COMPONENT PATTERNS\n\n**Document List Pattern** (`/src/components/documents/DocumentList.tsx`):\n- Expandable rows with chevron icons\n- Inline search + multiple filter dropdowns\n- Bulk selection with \"select all\" checkbox\n- Hover state actions (edit, delete, more)\n- Tag-based filtering with quick filter buttons\n- Tier badges (T1, T2, T3) with hover tooltips\n- Source type badges with icons\n- Responsive two-tier layout (expanded info on second row for mobile)\n- Inline editing for names and descriptions\n\n**Folder View Pattern** (`/src/components/documents/DocumentFolderView.tsx`):\n- Hierarchical folder structure\n- Expandable folders with counts\n- \"Create new folder\" input\n- Drag-drop (implied but not fully shown)\n- Uncategorized default folder\n- Empty state messaging\n\n**Toast Pattern** (`/src/components/ui/Toast/ToastContext.tsx`):\n- Provider-based context\n- Convenience methods: `toast.success()`, `toast.error()`, `toast.warning()`, `toast.info()`\n- Auto-dismiss with configurable duration\n- Dismissible flag support\n\n---\n\n### 8. FORM & INPUT PATTERNS\n\n**Multi-select Tags:**\n```typescript\nconst [tags, setTags] = useState<string[]>([])\nconst [newTag, setNewTag] = useState('')\n\nconst handleAddTag = () => {\n  const trimmedTag = newTag.trim().toLowerCase()\n  if (trimmedTag && !tags.includes(trimmedTag)) {\n    setTags([...tags, trimmedTag])\n    setNewTag('')\n  }\n}\n\n// In JSX:\n{tags.map(tag => (\n  <span key={tag} className=\"inline-flex items-center\">\n    {tag}\n    <button onClick={() => setTags(tags.filter(t => t !== tag))}>×</button>\n  </span>\n))}\n```\n\n**Inline Editing Pattern:**\n```typescript\nconst [editingId, setEditingId] = useState<string | null>(null)\nconst [editingValue, setEditingValue] = useState('')\n\n// Toggle edit mode\nconst startEdit = (item) => {\n  setEditingId(item.id)\n  setEditingValue(item.value)\n}\n\n// Save with async handler\nconst handleSave = async (id) => {\n  setSaving(true)\n  try {\n    await onSave(id, editingValue)\n    setEditingId(null)\n  } finally {\n    setSaving(false)\n  }\n}\n```\n\n---\n\n### 9. DESIGN SYSTEM & STYLING\n\n**Color Scheme Used:**\n- Primary: `bg-blue-600`, `text-blue-600`\n- Secondary: `bg-indigo-600`, `text-indigo-600`\n- Success: `bg-green-600`, `text-green-600`\n- Danger: `bg-red-600`, `text-red-600`\n- Neutral: `bg-gray-50/100/200`, `text-gray-400/600/900`\n\n**Border Radius:** Consistently `rounded-xl` (large), `rounded-lg` (medium), `rounded` (small)\n\n**Spacing:** Gap system using `gap-2/3/4/6` consistently\n\n**Icons:** lucide-react library used throughout\n\n---\n\n### 10. RECOMMENDED STRUCTURE FOR ARTIFACT BROWSER\n\nBased on patterns observed:\n\n```\nArtifactBrowser/\n├── ArtifactBrowser.tsx (main component)\n├── hooks/\n│  ├── useArtifacts.ts (fetch/manage artifacts)\n│  └── useArtifactFilters.ts (filter state)\n├── components/\n│  ├── ArtifactList.tsx (main list view)\n│  ├── ArtifactGrid.tsx (grid view alternative)\n│  ├── ArtifactModal.tsx (view/edit modal)\n│  ├── ArtifactFilters.tsx (filter UI)\n│  └── ArtifactActionsToolbar.tsx (bulk actions)\n└── types/\n   └── artifact.types.ts\n```\n\n---\n\n### KEY TAKEAWAYS FOR YOUR IMPLEMENTATION\n\n1. **Use Existing Document/Session Infrastructure:** The codebase already has `knowledge_base_docs` table and session management - leverage this!\n\n2. **Follow Modal Pattern:** Use `SaveToContextLakeModal` as your reference - it's production-grade with proper lifecycle management\n\n3. **Implement Filtering Like DocumentList:** Search + multiple dropdowns + tag buttons work really well\n\n4. **Use Context API + Hooks:** Standard pattern throughout - Provider at app level, custom hooks for consumption\n\n5. **Expandable Sections:** ChevronDown/ChevronRight + useState for toggle, with summary badges when collapsed\n\n6. **Toast Notifications:** Use `useToast()` from context for feedback\n\n7. **Confirmation Dialogs:** Use `useModal().confirm()` for destructive actions\n\n8. **Tab Navigation:** Use border-b underline pattern with active state styling\n\n9. **Bulk Operations:** Checkbox selection with \"select all\" and toolbar appears\n\n10. **Mobile Responsiveness:** Use responsive grid/flex with hidden elements on smaller screens (`hidden sm:flex`)\n\nThis should give you a solid foundation for building the Artifact Browser with consistency to the rest of the codebase!"}],"totalDurationMs":62419,"totalTokens":120952,"totalToolUseCount":23,"usage":{"input_tokens":5,"cache_creation_input_tokens":5472,"cache_read_input_tokens":112531,"cache_creation":{"ephemeral_5m_input_tokens":5472,"ephemeral_1h_input_tokens":0},"output_tokens":2944,"service_tier":"standard"}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Wkb27XKbUNPpQxxoAu8NYx","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me look at the specific step execution and session data structure to understand how artifacts are stored."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3223,"cache_read_input_tokens":49590,"cache_creation":{"ephemeral_5m_input_tokens":3223,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"a7ddf885-fe05-4f04-b74f-47cc89030b80"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Wkb27XKbUNPpQxxoAu8NYx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Uvcdpz3iGQxB8qaH4Jp95D","name":"Glob","input":{"pattern":"src/components/playbook/**/*.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3223,"cache_read_input_tokens":49590,"cache_creation":{"ephemeral_5m_input_tokens":3223,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"f91a9e0d-9363-4a5c-916f-47b441635f68"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Wkb27XKbUNPpQxxoAu8NYx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VbbwL7Gyo6vrDHfaeHBe39","name":"Grep","input":{"pattern":"stepOutputs|artifacts|session.*data","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3223,"cache_read_input_tokens":49590,"cache_creation":{"ephemeral_5m_input_tokens":3223,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"adf37faf-5140-4ce7-9ca4-cd45b44c5e0b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VbbwL7Gyo6vrDHfaeHBe39","type":"tool_result","content":"Found 34 files\ntasks/prd-playbook-orchestration-ux.json\n.ralph-tui/progress.md\n.ralph-tui/iterations/a2c55120_2026-01-25_20-27-38_US-010.log\n.ralph-tui/iterations/a2c55120_2026-01-25_20-22-53_US-009.log\n.ralph-tui/iterations/a2c55120_2026-01-25_20-18-48_US-008.log\n.ralph-tui/iterations/a2c55120_2026-01-25_20-12-52_US-007.log\n.ralph-tui/iterations/a2c55120_2026-01-25_20-04-06_US-006.log\n.ralph-tui/iterations/a2c55120_2026-01-25_19-59-28_US-005.log\nsupabase/functions/execute-flow-step/index.ts\n.ralph-tui/iterations/a2c55120_2026-01-25_19-55-24_US-004.log\n.ralph-tui/iterations/a2c55120_2026-01-25_19-47-57_US-003.log\n.ralph-tui/iterations/a2c55120_2026-01-25_19-41-59_US-002.log\n.ralph-tui/iterations/a2c55120_2026-01-25_19-39-46_US-001.log\nsupabase/migrations/20260125000002_update_playbook_session_schema.sql\ntasks/prd-playbook-orchestration-ux.md\n.agents/skills/agent-browser/references/video-recording.md\n.agents/skills/vercel-react-best-practices/rules/rerender-lazy-state-init.md\n.agents/skills/vercel-react-best-practices/AGENTS.md\nsrc/app/api/reports/analyze/route.ts\nsrc/app/api/niche-finder/jobs/[id]/analyze/route.ts\nsrc/app/api/niche-finder/suggest/route.ts\nsrc/lib/inngest/functions/niche-finder.ts\nsrc/components/playbook/SessionHistoryPanel.tsx\nsrc/types/flow.types.ts\nsrc/lib/exporters/export-service.ts\nsrc/components/reports/ReportPreview.tsx\nsrc/components/reports/ReportGenerator.tsx\nsrc/app/api/reports/export/route.ts\nsrc/app/api/niche-finder/results/[jobId]/route.ts\nskills/Vibe-Creative-Pack-Claude-Code-v.01/ai-image-generation/SKILL.md\nskills/Vibe-Creative-Pack-Claude-Code-v.01/ai-product-photo/SKILL.md\nskills/Vibe-Creative-Pack-Claude-Code-v.01/ai-product-video/SKILL.md\nskills/Vibe-Creative-Pack-Claude-Code-v.01/ai-talking-head/SKILL.md\nDEPLOY_THIS_CODE.ts"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"62bc8ab4-c7ca-4466-8de1-aa8050a6bb20","tool_use_result":{"mode":"files_with_matches","filenames":["tasks/prd-playbook-orchestration-ux.json",".ralph-tui/progress.md",".ralph-tui/iterations/a2c55120_2026-01-25_20-27-38_US-010.log",".ralph-tui/iterations/a2c55120_2026-01-25_20-22-53_US-009.log",".ralph-tui/iterations/a2c55120_2026-01-25_20-18-48_US-008.log",".ralph-tui/iterations/a2c55120_2026-01-25_20-12-52_US-007.log",".ralph-tui/iterations/a2c55120_2026-01-25_20-04-06_US-006.log",".ralph-tui/iterations/a2c55120_2026-01-25_19-59-28_US-005.log","supabase/functions/execute-flow-step/index.ts",".ralph-tui/iterations/a2c55120_2026-01-25_19-55-24_US-004.log",".ralph-tui/iterations/a2c55120_2026-01-25_19-47-57_US-003.log",".ralph-tui/iterations/a2c55120_2026-01-25_19-41-59_US-002.log",".ralph-tui/iterations/a2c55120_2026-01-25_19-39-46_US-001.log","supabase/migrations/20260125000002_update_playbook_session_schema.sql","tasks/prd-playbook-orchestration-ux.md",".agents/skills/agent-browser/references/video-recording.md",".agents/skills/vercel-react-best-practices/rules/rerender-lazy-state-init.md",".agents/skills/vercel-react-best-practices/AGENTS.md","src/app/api/reports/analyze/route.ts","src/app/api/niche-finder/jobs/[id]/analyze/route.ts","src/app/api/niche-finder/suggest/route.ts","src/lib/inngest/functions/niche-finder.ts","src/components/playbook/SessionHistoryPanel.tsx","src/types/flow.types.ts","src/lib/exporters/export-service.ts","src/components/reports/ReportPreview.tsx","src/components/reports/ReportGenerator.tsx","src/app/api/reports/export/route.ts","src/app/api/niche-finder/results/[jobId]/route.ts","skills/Vibe-Creative-Pack-Claude-Code-v.01/ai-image-generation/SKILL.md","skills/Vibe-Creative-Pack-Claude-Code-v.01/ai-product-photo/SKILL.md","skills/Vibe-Creative-Pack-Claude-Code-v.01/ai-product-video/SKILL.md","skills/Vibe-Creative-Pack-Claude-Code-v.01/ai-talking-head/SKILL.md","DEPLOY_THIS_CODE.ts"],"numFiles":34}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Uvcdpz3iGQxB8qaH4Jp95D","type":"tool_result","content":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/steps/DeepResearchManualStep.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/CampaignSettings.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ConfigurationMode.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/QueryPreviewPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SearchWithPreviewPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/CampaignWizard.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SerpResultsPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/ErrorAnalyzer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/InputContextSection.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/ExecutionSection.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepInspectionPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/OutputSection.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ScrapeResultsPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SessionHistoryPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/JobControlPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ReviewAndScrapePanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/KeywordConfigPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/NavigationPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/UnifiedSearchExtractPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StartSessionDialog.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/AllSessionsPanel.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookWizardNav.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SavedIndicator.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/NavigationWarningDialog.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookStepContainer.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepRetryDialog.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepExecutionProgress.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/FailedStepActions.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/WorkArea.tsx"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"bd09df7f-34ff-4a96-baab-036b03466f98","tool_use_result":{"filenames":["/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/steps/DeepResearchManualStep.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/CampaignSettings.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ConfigurationMode.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/QueryPreviewPanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SearchWithPreviewPanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/CampaignWizard.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SerpResultsPanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/ErrorAnalyzer.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/InputContextSection.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/ExecutionSection.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepInspectionPanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/inspection/OutputSection.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ScrapeResultsPanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SessionHistoryPanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/JobControlPanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ReviewAndScrapePanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/KeywordConfigPanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/NavigationPanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/UnifiedSearchExtractPanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StartSessionDialog.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/AllSessionsPanel.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookWizardNav.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SavedIndicator.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/NavigationWarningDialog.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookStepContainer.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepRetryDialog.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/StepExecutionProgress.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/FailedStepActions.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/WorkArea.tsx"],"durationMs":371,"numFiles":30,"truncated":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RcooMacJFs3QdidKd9mgfv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01E5N8oKzL7QmMJoWCJXwLvV","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SessionHistoryPanel.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":801,"cache_creation_input_tokens":1284,"cache_read_input_tokens":52813,"cache_creation":{"ephemeral_5m_input_tokens":1284,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"98952298-e299-4282-bf3b-fc3637d65e7e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RcooMacJFs3QdidKd9mgfv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017gwEgfN9RjY3gWqJZzafJX","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/types/flow.types.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":801,"cache_creation_input_tokens":1284,"cache_read_input_tokens":52813,"cache_creation":{"ephemeral_5m_input_tokens":1284,"ephemeral_1h_input_tokens":0},"output_tokens":153,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"bbf5e372-ee3d-4ca2-acbb-78f634996ccd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01E5N8oKzL7QmMJoWCJXwLvV","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useEffect, useCallback } from 'react'\n     4→import { Clock, CheckCircle, XCircle, Loader2, AlertTriangle, ChevronDown, ChevronRight, RefreshCw } from 'lucide-react'\n     5→\n     6→interface SessionStep {\n     7→  id: string\n     8→  step_id: string\n     9→  status: string\n    10→  started_at: string | null\n    11→  completed_at: string | null\n    12→  error_message: string | null\n    13→  output: unknown\n    14→}\n    15→\n    16→interface SessionJob {\n    17→  id: string\n    18→  status: string\n    19→  urls_found: number\n    20→  urls_scraped: number\n    21→  urls_failed: number\n    22→  niches_extracted: number\n    23→  created_at: string\n    24→  updated_at: string\n    25→}\n    26→\n    27→interface TimelineEvent {\n    28→  type: 'step' | 'job'\n    29→  id: string\n    30→  title: string\n    31→  status: string\n    32→  timestamp: string\n    33→  details?: Record<string, unknown>\n    34→}\n    35→\n    36→interface Session {\n    37→  id: string\n    38→  project_id: string\n    39→  playbook_type: string\n    40→  status: string\n    41→  current_phase: string | null\n    42→  current_step: string | null\n    43→  config: Record<string, unknown>\n    44→  variables: Record<string, unknown>\n    45→  created_at: string\n    46→  updated_at: string\n    47→  completed_at: string | null\n    48→  active_job_id: string | null\n    49→}\n    50→\n    51→interface SessionHistoryPanelProps {\n    52→  sessionId: string\n    53→  onClose?: () => void\n    54→}\n    55→\n    56→function getStatusIcon(status: string) {\n    57→  switch (status) {\n    58→    case 'completed':\n    59→      return <CheckCircle size={16} className=\"text-green-500\" />\n    60→    case 'in_progress':\n    61→      return <Loader2 size={16} className=\"text-blue-500 animate-spin\" />\n    62→    case 'error':\n    63→    case 'failed':\n    64→      return <XCircle size={16} className=\"text-red-500\" />\n    65→    case 'pending':\n    66→      return <Clock size={16} className=\"text-gray-400\" />\n    67→    default:\n    68→      return <AlertTriangle size={16} className=\"text-yellow-500\" />\n    69→  }\n    70→}\n    71→\n    72→function formatTimestamp(timestamp: string): string {\n    73→  const date = new Date(timestamp)\n    74→  return date.toLocaleString('es-ES', {\n    75→    day: '2-digit',\n    76→    month: '2-digit',\n    77→    hour: '2-digit',\n    78→    minute: '2-digit',\n    79→  })\n    80→}\n    81→\n    82→export default function SessionHistoryPanel({ sessionId, onClose }: SessionHistoryPanelProps) {\n    83→  const [session, setSession] = useState<Session | null>(null)\n    84→  const [steps, setSteps] = useState<SessionStep[]>([])\n    85→  const [jobs, setJobs] = useState<SessionJob[]>([])\n    86→  const [timeline, setTimeline] = useState<TimelineEvent[]>([])\n    87→  const [loading, setLoading] = useState(true)\n    88→  const [error, setError] = useState<string | null>(null)\n    89→  const [expandedEvents, setExpandedEvents] = useState<Set<string>>(new Set())\n    90→\n    91→  const loadSessionData = useCallback(async () => {\n    92→    try {\n    93→      setLoading(true)\n    94→      setError(null)\n    95→\n    96→      const response = await fetch(`/api/playbook/sessions/${sessionId}`)\n    97→      if (!response.ok) {\n    98→        throw new Error('Error loading session data')\n    99→      }\n   100→\n   101→      const data = await response.json()\n   102→      setSession(data.session)\n   103→      setSteps(data.steps || [])\n   104→      setJobs(data.jobs || [])\n   105→      setTimeline(data.timeline || [])\n   106→    } catch (err) {\n   107→      setError(err instanceof Error ? err.message : 'Unknown error')\n   108→    } finally {\n   109→      setLoading(false)\n   110→    }\n   111→  }, [sessionId])\n   112→\n   113→  useEffect(() => {\n   114→    loadSessionData()\n   115→  }, [loadSessionData])\n   116→\n   117→  const toggleEvent = (eventId: string) => {\n   118→    setExpandedEvents(prev => {\n   119→      const newSet = new Set(prev)\n   120→      if (newSet.has(eventId)) {\n   121→        newSet.delete(eventId)\n   122→      } else {\n   123→        newSet.add(eventId)\n   124→      }\n   125→      return newSet\n   126→    })\n   127→  }\n   128→\n   129→  if (loading) {\n   130→    return (\n   131→      <div className=\"p-4 flex items-center justify-center\">\n   132→        <Loader2 className=\"animate-spin text-gray-400\" size={24} />\n   133→      </div>\n   134→    )\n   135→  }\n   136→\n   137→  if (error) {\n   138→    return (\n   139→      <div className=\"p-4 text-red-600 text-sm\">\n   140→        <AlertTriangle size={16} className=\"inline mr-2\" />\n   141→        {error}\n   142→      </div>\n   143→    )\n   144→  }\n   145→\n   146→  if (!session) {\n   147→    return (\n   148→      <div className=\"p-4 text-gray-500 text-sm\">\n   149→        No session data available\n   150→      </div>\n   151→    )\n   152→  }\n   153→\n   154→  return (\n   155→    <div className=\"bg-white border-l border-gray-200 h-full flex flex-col\">\n   156→      {/* Header */}\n   157→      <div className=\"px-4 py-3 border-b border-gray-200 flex items-center justify-between\">\n   158→        <div>\n   159→          <h3 className=\"font-medium text-gray-900\">Historial de Sesi\\u00f3n</h3>\n   160→          <p className=\"text-xs text-gray-500 mt-0.5\">\n   161→            {session.playbook_type} - {formatTimestamp(session.created_at)}\n   162→          </p>\n   163→        </div>\n   164→        <button\n   165→          onClick={loadSessionData}\n   166→          className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded\"\n   167→          title=\"Actualizar\"\n   168→        >\n   169→          <RefreshCw size={14} />\n   170→        </button>\n   171→      </div>\n   172→\n   173→      {/* Session Status */}\n   174→      <div className=\"px-4 py-3 border-b border-gray-100 bg-gray-50\">\n   175→        <div className=\"flex items-center gap-2\">\n   176→          {getStatusIcon(session.status)}\n   177→          <span className=\"text-sm font-medium capitalize\">{session.status}</span>\n   178→        </div>\n   179→        {session.current_step && (\n   180→          <p className=\"text-xs text-gray-500 mt-1\">\n   181→            Paso actual: {session.current_step}\n   182→          </p>\n   183→        )}\n   184→      </div>\n   185→\n   186→      {/* Timeline */}\n   187→      <div className=\"flex-1 overflow-y-auto\">\n   188→        <div className=\"p-4 space-y-2\">\n   189→          {timeline.length === 0 ? (\n   190→            <p className=\"text-sm text-gray-500 text-center py-4\">\n   191→              No hay eventos registrados\n   192→            </p>\n   193→          ) : (\n   194→            timeline.map((event, index) => (\n   195→              <div\n   196→                key={`${event.type}-${event.id}`}\n   197→                className=\"relative pl-6 pb-4\"\n   198→              >\n   199→                {/* Timeline line */}\n   200→                {index < timeline.length - 1 && (\n   201→                  <div className=\"absolute left-[11px] top-6 bottom-0 w-px bg-gray-200\" />\n   202→                )}\n   203→\n   204→                {/* Status dot */}\n   205→                <div className=\"absolute left-0 top-0.5\">\n   206→                  {getStatusIcon(event.status)}\n   207→                </div>\n   208→\n   209→                {/* Event content */}\n   210→                <div\n   211→                  className=\"bg-gray-50 rounded-lg p-3 cursor-pointer hover:bg-gray-100 transition-colors\"\n   212→                  onClick={() => toggleEvent(event.id)}\n   213→                >\n   214→                  <div className=\"flex items-center justify-between\">\n   215→                    <div className=\"flex items-center gap-2\">\n   216→                      {expandedEvents.has(event.id) ? (\n   217→                        <ChevronDown size={14} className=\"text-gray-400\" />\n   218→                      ) : (\n   219→                        <ChevronRight size={14} className=\"text-gray-400\" />\n   220→                      )}\n   221→                      <span className=\"text-sm font-medium text-gray-900\">\n   222→                        {event.title}\n   223→                      </span>\n   224→                      <span className=\"text-xs px-1.5 py-0.5 rounded bg-gray-200 text-gray-600\">\n   225→                        {event.type}\n   226→                      </span>\n   227→                    </div>\n   228→                    <span className=\"text-xs text-gray-500\">\n   229→                      {formatTimestamp(event.timestamp)}\n   230→                    </span>\n   231→                  </div>\n   232→\n   233→                  {/* Expanded details */}\n   234→                  {expandedEvents.has(event.id) && event.details && (\n   235→                    <div className=\"mt-2 pt-2 border-t border-gray-200\">\n   236→                      <pre className=\"text-xs text-gray-600 overflow-x-auto\">\n   237→                        {JSON.stringify(event.details, null, 2)}\n   238→                      </pre>\n   239→                    </div>\n   240→                  )}\n   241→                </div>\n   242→              </div>\n   243→            ))\n   244→          )}\n   245→        </div>\n   246→      </div>\n   247→\n   248→      {/* Jobs section */}\n   249→      {jobs.length > 0 && (\n   250→        <div className=\"border-t border-gray-200 p-4\">\n   251→          <h4 className=\"text-sm font-medium text-gray-900 mb-2\">Jobs</h4>\n   252→          <div className=\"space-y-2\">\n   253→            {jobs.map(job => (\n   254→              <div\n   255→                key={job.id}\n   256→                className=\"bg-gray-50 rounded-lg p-2 text-xs\"\n   257→              >\n   258→                <div className=\"flex items-center justify-between mb-1\">\n   259→                  <span className=\"font-mono text-gray-600\">\n   260→                    {job.id.slice(0, 8)}...\n   261→                  </span>\n   262→                  <span className={`px-1.5 py-0.5 rounded ${\n   263→                    job.status === 'completed' ? 'bg-green-100 text-green-700' :\n   264→                    job.status === 'failed' ? 'bg-red-100 text-red-700' :\n   265→                    'bg-blue-100 text-blue-700'\n   266→                  }`}>\n   267→                    {job.status}\n   268→                  </span>\n   269→                </div>\n   270→                <div className=\"grid grid-cols-2 gap-1 text-gray-500\">\n   271→                  <span>URLs: {job.urls_found}</span>\n   272→                  <span>Scraped: {job.urls_scraped}</span>\n   273→                  <span>Failed: {job.urls_failed}</span>\n   274→                  <span>Niches: {job.niches_extracted}</span>\n   275→                </div>\n   276→              </div>\n   277→            ))}\n   278→          </div>\n   279→        </div>\n   280→      )}\n   281→    </div>\n   282→  )\n   283→}\n   284→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"36b38517-a934-4e5e-821d-f3b4c38979e0","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SessionHistoryPanel.tsx","content":"'use client'\n\nimport { useState, useEffect, useCallback } from 'react'\nimport { Clock, CheckCircle, XCircle, Loader2, AlertTriangle, ChevronDown, ChevronRight, RefreshCw } from 'lucide-react'\n\ninterface SessionStep {\n  id: string\n  step_id: string\n  status: string\n  started_at: string | null\n  completed_at: string | null\n  error_message: string | null\n  output: unknown\n}\n\ninterface SessionJob {\n  id: string\n  status: string\n  urls_found: number\n  urls_scraped: number\n  urls_failed: number\n  niches_extracted: number\n  created_at: string\n  updated_at: string\n}\n\ninterface TimelineEvent {\n  type: 'step' | 'job'\n  id: string\n  title: string\n  status: string\n  timestamp: string\n  details?: Record<string, unknown>\n}\n\ninterface Session {\n  id: string\n  project_id: string\n  playbook_type: string\n  status: string\n  current_phase: string | null\n  current_step: string | null\n  config: Record<string, unknown>\n  variables: Record<string, unknown>\n  created_at: string\n  updated_at: string\n  completed_at: string | null\n  active_job_id: string | null\n}\n\ninterface SessionHistoryPanelProps {\n  sessionId: string\n  onClose?: () => void\n}\n\nfunction getStatusIcon(status: string) {\n  switch (status) {\n    case 'completed':\n      return <CheckCircle size={16} className=\"text-green-500\" />\n    case 'in_progress':\n      return <Loader2 size={16} className=\"text-blue-500 animate-spin\" />\n    case 'error':\n    case 'failed':\n      return <XCircle size={16} className=\"text-red-500\" />\n    case 'pending':\n      return <Clock size={16} className=\"text-gray-400\" />\n    default:\n      return <AlertTriangle size={16} className=\"text-yellow-500\" />\n  }\n}\n\nfunction formatTimestamp(timestamp: string): string {\n  const date = new Date(timestamp)\n  return date.toLocaleString('es-ES', {\n    day: '2-digit',\n    month: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n  })\n}\n\nexport default function SessionHistoryPanel({ sessionId, onClose }: SessionHistoryPanelProps) {\n  const [session, setSession] = useState<Session | null>(null)\n  const [steps, setSteps] = useState<SessionStep[]>([])\n  const [jobs, setJobs] = useState<SessionJob[]>([])\n  const [timeline, setTimeline] = useState<TimelineEvent[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n  const [expandedEvents, setExpandedEvents] = useState<Set<string>>(new Set())\n\n  const loadSessionData = useCallback(async () => {\n    try {\n      setLoading(true)\n      setError(null)\n\n      const response = await fetch(`/api/playbook/sessions/${sessionId}`)\n      if (!response.ok) {\n        throw new Error('Error loading session data')\n      }\n\n      const data = await response.json()\n      setSession(data.session)\n      setSteps(data.steps || [])\n      setJobs(data.jobs || [])\n      setTimeline(data.timeline || [])\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error')\n    } finally {\n      setLoading(false)\n    }\n  }, [sessionId])\n\n  useEffect(() => {\n    loadSessionData()\n  }, [loadSessionData])\n\n  const toggleEvent = (eventId: string) => {\n    setExpandedEvents(prev => {\n      const newSet = new Set(prev)\n      if (newSet.has(eventId)) {\n        newSet.delete(eventId)\n      } else {\n        newSet.add(eventId)\n      }\n      return newSet\n    })\n  }\n\n  if (loading) {\n    return (\n      <div className=\"p-4 flex items-center justify-center\">\n        <Loader2 className=\"animate-spin text-gray-400\" size={24} />\n      </div>\n    )\n  }\n\n  if (error) {\n    return (\n      <div className=\"p-4 text-red-600 text-sm\">\n        <AlertTriangle size={16} className=\"inline mr-2\" />\n        {error}\n      </div>\n    )\n  }\n\n  if (!session) {\n    return (\n      <div className=\"p-4 text-gray-500 text-sm\">\n        No session data available\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"bg-white border-l border-gray-200 h-full flex flex-col\">\n      {/* Header */}\n      <div className=\"px-4 py-3 border-b border-gray-200 flex items-center justify-between\">\n        <div>\n          <h3 className=\"font-medium text-gray-900\">Historial de Sesi\\u00f3n</h3>\n          <p className=\"text-xs text-gray-500 mt-0.5\">\n            {session.playbook_type} - {formatTimestamp(session.created_at)}\n          </p>\n        </div>\n        <button\n          onClick={loadSessionData}\n          className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded\"\n          title=\"Actualizar\"\n        >\n          <RefreshCw size={14} />\n        </button>\n      </div>\n\n      {/* Session Status */}\n      <div className=\"px-4 py-3 border-b border-gray-100 bg-gray-50\">\n        <div className=\"flex items-center gap-2\">\n          {getStatusIcon(session.status)}\n          <span className=\"text-sm font-medium capitalize\">{session.status}</span>\n        </div>\n        {session.current_step && (\n          <p className=\"text-xs text-gray-500 mt-1\">\n            Paso actual: {session.current_step}\n          </p>\n        )}\n      </div>\n\n      {/* Timeline */}\n      <div className=\"flex-1 overflow-y-auto\">\n        <div className=\"p-4 space-y-2\">\n          {timeline.length === 0 ? (\n            <p className=\"text-sm text-gray-500 text-center py-4\">\n              No hay eventos registrados\n            </p>\n          ) : (\n            timeline.map((event, index) => (\n              <div\n                key={`${event.type}-${event.id}`}\n                className=\"relative pl-6 pb-4\"\n              >\n                {/* Timeline line */}\n                {index < timeline.length - 1 && (\n                  <div className=\"absolute left-[11px] top-6 bottom-0 w-px bg-gray-200\" />\n                )}\n\n                {/* Status dot */}\n                <div className=\"absolute left-0 top-0.5\">\n                  {getStatusIcon(event.status)}\n                </div>\n\n                {/* Event content */}\n                <div\n                  className=\"bg-gray-50 rounded-lg p-3 cursor-pointer hover:bg-gray-100 transition-colors\"\n                  onClick={() => toggleEvent(event.id)}\n                >\n                  <div className=\"flex items-center justify-between\">\n                    <div className=\"flex items-center gap-2\">\n                      {expandedEvents.has(event.id) ? (\n                        <ChevronDown size={14} className=\"text-gray-400\" />\n                      ) : (\n                        <ChevronRight size={14} className=\"text-gray-400\" />\n                      )}\n                      <span className=\"text-sm font-medium text-gray-900\">\n                        {event.title}\n                      </span>\n                      <span className=\"text-xs px-1.5 py-0.5 rounded bg-gray-200 text-gray-600\">\n                        {event.type}\n                      </span>\n                    </div>\n                    <span className=\"text-xs text-gray-500\">\n                      {formatTimestamp(event.timestamp)}\n                    </span>\n                  </div>\n\n                  {/* Expanded details */}\n                  {expandedEvents.has(event.id) && event.details && (\n                    <div className=\"mt-2 pt-2 border-t border-gray-200\">\n                      <pre className=\"text-xs text-gray-600 overflow-x-auto\">\n                        {JSON.stringify(event.details, null, 2)}\n                      </pre>\n                    </div>\n                  )}\n                </div>\n              </div>\n            ))\n          )}\n        </div>\n      </div>\n\n      {/* Jobs section */}\n      {jobs.length > 0 && (\n        <div className=\"border-t border-gray-200 p-4\">\n          <h4 className=\"text-sm font-medium text-gray-900 mb-2\">Jobs</h4>\n          <div className=\"space-y-2\">\n            {jobs.map(job => (\n              <div\n                key={job.id}\n                className=\"bg-gray-50 rounded-lg p-2 text-xs\"\n              >\n                <div className=\"flex items-center justify-between mb-1\">\n                  <span className=\"font-mono text-gray-600\">\n                    {job.id.slice(0, 8)}...\n                  </span>\n                  <span className={`px-1.5 py-0.5 rounded ${\n                    job.status === 'completed' ? 'bg-green-100 text-green-700' :\n                    job.status === 'failed' ? 'bg-red-100 text-red-700' :\n                    'bg-blue-100 text-blue-700'\n                  }`}>\n                    {job.status}\n                  </span>\n                </div>\n                <div className=\"grid grid-cols-2 gap-1 text-gray-500\">\n                  <span>URLs: {job.urls_found}</span>\n                  <span>Scraped: {job.urls_scraped}</span>\n                  <span>Failed: {job.urls_failed}</span>\n                  <span>Niches: {job.niches_extracted}</span>\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n","numLines":284,"startLine":1,"totalLines":284}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017gwEgfN9RjY3gWqJZzafJX","type":"tool_result","content":"     1→/**\n     2→ * Flow Builder Types\n     3→ *\n     4→ * Tipos para el sistema de flow builder dinámico.\n     5→ * Permite configurar procesos de análisis customizables con:\n     6→ * - Steps ordenables\n     7→ * - Documentos base asignables\n     8→ * - Auto-conexión de outputs entre steps\n     9→ * - Prompts editables con variables\n    10→ */\n    11→\n    12→export type OutputFormat = 'text' | 'markdown' | 'json' | 'csv' | 'html' | 'xml'\n    13→\n    14→// Tipo de step: 'llm' para prompts con LLM, 'scraper' para el Step 0 de Niche Finder\n    15→export type FlowStepType = 'llm' | 'scraper'\n    16→\n    17→// Proveedores LLM soportados\n    18→export type LLMProvider = 'gemini' | 'openai' | 'anthropic' | 'groq' | 'deep-research'\n    19→\n    20→// Modelos disponibles por proveedor (IDs reales de API)\n    21→export type GeminiModel = 'gemini-3.0-pro-preview' | 'gemini-2.5-pro' | 'gemini-2.5-flash' | 'gemini-2.5-flash-lite'\n    22→export type OpenAIModel = 'gpt-5.2' | 'gpt-5' | 'gpt-5-mini' | 'gpt-4.1' | 'gpt-4.1-mini' | 'gpt-4o' | 'gpt-4o-mini' | 'o1' | 'o1-mini' | 'o3' | 'o3-mini' | 'o3-pro' | 'o4-mini'\n    23→export type AnthropicModel = 'claude-4.5-opus' | 'claude-4.5-sonnet' | 'claude-4.5-haiku'\n    24→export type GroqModel = 'llama-3.3-70b-versatile' | 'llama-3.1-8b-instant' | 'mixtral-8x7b-32768'\n    25→\n    26→// Google Deep Research - Agente autónomo de investigación (usa Interactions API, no generateContent)\n    27→export type DeepResearchModel = 'deep-research-pro-preview-12-2025'\n    28→\n    29→// LLMModel ahora acepta strings genéricos para soportar IDs de OpenRouter (ej: \"google/gemini-2.5-flash-preview\")\n    30→export type LLMModel = GeminiModel | OpenAIModel | AnthropicModel | GroqModel | DeepResearchModel | string\n    31→\n    32→// Configuración de fallback\n    33→export interface FallbackConfig {\n    34→  enabled: boolean\n    35→  models: LLMModel[]  // Orden de fallback\n    36→  max_retries?: number  // Reintentos por modelo (default: 2)\n    37→}\n    38→\n    39→// Modo de recuperación de documentos\n    40→export type RetrievalMode = 'full' | 'rag'\n    41→\n    42→// Configuración de RAG\n    43→export interface RAGConfig {\n    44→  top_k: number       // Número de chunks a recuperar (default: 10)\n    45→  min_score: number   // Score mínimo de similitud (default: 0.7)\n    46→}\n    47→\n    48→// Precios de modelos para estimación de costos (USD por millón de tokens)\n    49→export const MODEL_PRICING: Record<string, { input: number; output: number }> = {\n    50→  'gemini-2.5-pro': { input: 1.25, output: 10.0 },\n    51→  'gemini-2.5-flash': { input: 0.30, output: 2.50 },\n    52→  'gemini-2.5-flash-lite': { input: 0.10, output: 0.40 },\n    53→  'gemini-3.0-pro-preview': { input: 2.00, output: 12.00 },\n    54→  'google/gemini-2.5-pro': { input: 1.25, output: 10.0 },\n    55→  'google/gemini-2.5-flash': { input: 0.30, output: 2.50 },\n    56→  'google/gemini-3-pro-preview': { input: 2.00, output: 12.00 },\n    57→  'gpt-4o': { input: 2.50, output: 10.0 },\n    58→  'gpt-4o-mini': { input: 0.15, output: 0.60 },\n    59→  'claude-4.5-sonnet': { input: 3.00, output: 15.0 },\n    60→  'claude-4.5-opus': { input: 15.00, output: 75.0 },\n    61→  // Default para modelos desconocidos\n    62→  'default': { input: 1.00, output: 5.00 },\n    63→}\n    64→\n    65→// Documento requerido por un paso (para matching inteligente)\n    66→export interface RequiredDocument {\n    67→  id: string                    // UUID generado\n    68→  name: string                  // Nombre/descripción del documento requerido\n    69→  required: boolean             // true = obligatorio, false = opcional\n    70→  matchedDocId?: string         // ID del documento asignado (si hay match)\n    71→  matchConfidence?: number      // 0-1, confianza del match\n    72→}\n    73→\n    74→export interface FlowStep {\n    75→  id: string\n    76→  name: string\n    77→  description?: string\n    78→  order: number\n    79→\n    80→  // 🆕 Tipo de step: 'llm' (default) o 'scraper' (para Niche Finder Step 0)\n    81→  type?: FlowStepType  // Default: 'llm'\n    82→\n    83→  // ============================================\n    84→  // CONFIGURACIÓN PARA type: 'llm' (existente)\n    85→  // ============================================\n    86→\n    87→  // Prompt con variables: {{ecp_name}}, {{country}}, etc.\n    88→  prompt: string\n    89→\n    90→  // Documentos base (ya subidos) que se usan en este step\n    91→  base_doc_ids: string[]\n    92→\n    93→  // Documentos requeridos por el paso (para matching inteligente)\n    94→  required_documents?: RequiredDocument[]\n    95→\n    96→  // IDs de steps previos cuyos outputs se incluyen automáticamente\n    97→  auto_receive_from: string[]\n    98→\n    99→  // Formato de salida deseado\n   100→  output_format?: OutputFormat\n   101→\n   102→  // Configuración del modelo LLM\n   103→  provider?: LLMProvider  // Default: 'gemini'\n   104→  model?: LLMModel\n   105→  temperature?: number\n   106→  max_tokens?: number\n   107→\n   108→  // Configuración de fallback (opcional)\n   109→  fallback?: FallbackConfig\n   110→\n   111→  // Modo de recuperación de documentos\n   112→  retrieval_mode?: RetrievalMode  // Default: 'full'\n   113→  rag_config?: RAGConfig\n   114→\n   115→  // ============================================\n   116→  // CONFIGURACIÓN PARA type: 'scraper' (nuevo)\n   117→  // Sistema de combinaciones A × B para Niche Finder\n   118→  // ============================================\n   119→\n   120→  // Configuración del scraper (solo si type === 'scraper')\n   121→  // Ver ScraperStepConfig en scraper.types.ts\n   122→  scraper_config?: {\n   123→    // Columna A: Contextos de vida\n   124→    life_contexts: string[]       // familia, hijos, universidad, casamiento...\n   125→\n   126→    // Columna B: Palabras del producto\n   127→    product_words: string[]       // pagos, ahorro, gastos, cuenta...\n   128→\n   129→    // Indicadores de problema (opcional)\n   130→    indicators: string[]          // me frustra, necesito ayuda...\n   131→\n   132→    // Fuentes donde buscar\n   133→    sources: {\n   134→      reddit: boolean             // Búsqueda general en Reddit\n   135→      thematic_forums: boolean    // Foros temáticos según contexto\n   136→      general_forums: string[]    // Dominios de foros generales\n   137→    }\n   138→\n   139→    // Configuración de SERP y scraping\n   140→    serp_pages: number            // Páginas de resultados (default: 5)\n   141→    batch_size: number            // URLs en paralelo (default: 10)\n   142→\n   143→    // Configuración de extracción LLM\n   144→    extraction_prompt: string     // Prompt para extraer nichos\n   145→    extraction_model: string      // Modelo LLM (default: gpt-4o-mini)\n   146→  }\n   147→}\n   148→\n   149→export interface FlowConfig {\n   150→  steps: FlowStep[]\n   151→  version?: string\n   152→  description?: string\n   153→}\n   154→\n   155→export interface StepOutput {\n   156→  step_id: string\n   157→  step_name: string\n   158→  output: string\n   159→  tokens: number\n   160→  status: 'pending' | 'running' | 'completed' | 'error'\n   161→  started_at?: string\n   162→  completed_at?: string\n   163→  error_message?: string\n   164→}\n   165→\n   166→export interface CampaignExecutionState {\n   167→  status: 'draft' | 'running' | 'paused' | 'completed' | 'error'\n   168→  current_step_id: string | null\n   169→  step_outputs: Record<string, StepOutput>\n   170→  started_at: string | null\n   171→  completed_at: string | null\n   172→  error_message?: string\n   173→}\n   174→\n   175→// Variables disponibles en prompts\n   176→export interface PromptVariables {\n   177→  ecp_name: string\n   178→  problem_core: string\n   179→  country: string\n   180→  industry: string\n   181→  client_name: string\n   182→}\n   183→\n   184→// Request para ejecutar un step individual\n   185→export interface ExecuteStepRequest {\n   186→  campaign_id: string\n   187→  step_config: FlowStep\n   188→  variables: PromptVariables\n   189→  documents: Array<{\n   190→    id: string\n   191→    filename: string\n   192→    content: string\n   193→    category: string\n   194→  }>\n   195→  previous_outputs: StepOutput[]\n   196→}\n   197→\n   198→// Request para ejecutar campaña completa\n   199→export interface ExecuteCampaignRequest {\n   200→  campaign_id: string\n   201→}\n   202→\n   203→// Response de ejecución\n   204→export interface ExecutionResponse {\n   205→  success: boolean\n   206→  output?: string\n   207→  tokens?: {\n   208→    input: number\n   209→    output: number\n   210→    total: number\n   211→  }\n   212→  duration_ms?: number\n   213→  error?: string\n   214→}\n   215→\n   216→// ============================================\n   217→// REPORT GENERATION TYPES\n   218→// ============================================\n   219→\n   220→// Resultado de detección de inconsistencias\n   221→export interface InconsistencyResult {\n   222→  id: string\n   223→  type: 'numeric' | 'factual' | 'missing'\n   224→  field: string                    // Ej: \"número de empleados\"\n   225→  description: string              // Descripción legible\n   226→  campaigns: {\n   227→    campaignId: string\n   228→    campaignName: string\n   229→    value: string\n   230→    stepId: string\n   231→    stepName: string\n   232→  }[]\n   233→  severity: 'high' | 'medium' | 'low'\n   234→  suggestedResolution?: string\n   235→  resolved?: boolean\n   236→  resolvedValue?: string\n   237→}\n   238→\n   239→// Configuración de exportación de reporte\n   240→export interface ReportExportConfig {\n   241→  format: 'markdown' | 'pdf' | 'pptx' | 'notion' | 'json'\n   242→  includeExecutiveSummary: boolean\n   243→  includeCampaignDetails: boolean\n   244→  includeInconsistencyReport: boolean\n   245→  includeRecommendations: boolean\n   246→  customTitle?: string\n   247→  notionParentPageId?: string      // Para exportación a Notion\n   248→}\n   249→\n   250→// Datos de reporte generado\n   251→export interface GeneratedReport {\n   252→  id: string\n   253→  projectId: string\n   254→  projectName: string\n   255→  generatedAt: string\n   256→  campaigns: {\n   257→    id: string\n   258→    name: string\n   259→    country: string\n   260→    industry: string\n   261→    customVariables: Record<string, string>\n   262→    stepOutputs: {\n   263→      stepId: string\n   264→      stepName: string\n   265→      output: string\n   266→    }[]\n   267→  }[]\n   268→  selectedStepIds: string[]\n   269→  inconsistencies: InconsistencyResult[]\n   270→  executiveSummary?: string        // Generado por LLM\n   271→  recommendations?: string[]       // Generado por LLM\n   272→}\n   273→\n   274→// Estado del selector de campañas\n   275→export interface CampaignSelectionState {\n   276→  selectedCampaignIds: string[]\n   277→  selectedStepIds: string[]\n   278→  statusFilter: 'all' | 'ready_to_present' | string\n   279→}\n   280→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"1a760038-a42d-431f-a1d1-ce2f4d4e0515","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/types/flow.types.ts","content":"/**\n * Flow Builder Types\n *\n * Tipos para el sistema de flow builder dinámico.\n * Permite configurar procesos de análisis customizables con:\n * - Steps ordenables\n * - Documentos base asignables\n * - Auto-conexión de outputs entre steps\n * - Prompts editables con variables\n */\n\nexport type OutputFormat = 'text' | 'markdown' | 'json' | 'csv' | 'html' | 'xml'\n\n// Tipo de step: 'llm' para prompts con LLM, 'scraper' para el Step 0 de Niche Finder\nexport type FlowStepType = 'llm' | 'scraper'\n\n// Proveedores LLM soportados\nexport type LLMProvider = 'gemini' | 'openai' | 'anthropic' | 'groq' | 'deep-research'\n\n// Modelos disponibles por proveedor (IDs reales de API)\nexport type GeminiModel = 'gemini-3.0-pro-preview' | 'gemini-2.5-pro' | 'gemini-2.5-flash' | 'gemini-2.5-flash-lite'\nexport type OpenAIModel = 'gpt-5.2' | 'gpt-5' | 'gpt-5-mini' | 'gpt-4.1' | 'gpt-4.1-mini' | 'gpt-4o' | 'gpt-4o-mini' | 'o1' | 'o1-mini' | 'o3' | 'o3-mini' | 'o3-pro' | 'o4-mini'\nexport type AnthropicModel = 'claude-4.5-opus' | 'claude-4.5-sonnet' | 'claude-4.5-haiku'\nexport type GroqModel = 'llama-3.3-70b-versatile' | 'llama-3.1-8b-instant' | 'mixtral-8x7b-32768'\n\n// Google Deep Research - Agente autónomo de investigación (usa Interactions API, no generateContent)\nexport type DeepResearchModel = 'deep-research-pro-preview-12-2025'\n\n// LLMModel ahora acepta strings genéricos para soportar IDs de OpenRouter (ej: \"google/gemini-2.5-flash-preview\")\nexport type LLMModel = GeminiModel | OpenAIModel | AnthropicModel | GroqModel | DeepResearchModel | string\n\n// Configuración de fallback\nexport interface FallbackConfig {\n  enabled: boolean\n  models: LLMModel[]  // Orden de fallback\n  max_retries?: number  // Reintentos por modelo (default: 2)\n}\n\n// Modo de recuperación de documentos\nexport type RetrievalMode = 'full' | 'rag'\n\n// Configuración de RAG\nexport interface RAGConfig {\n  top_k: number       // Número de chunks a recuperar (default: 10)\n  min_score: number   // Score mínimo de similitud (default: 0.7)\n}\n\n// Precios de modelos para estimación de costos (USD por millón de tokens)\nexport const MODEL_PRICING: Record<string, { input: number; output: number }> = {\n  'gemini-2.5-pro': { input: 1.25, output: 10.0 },\n  'gemini-2.5-flash': { input: 0.30, output: 2.50 },\n  'gemini-2.5-flash-lite': { input: 0.10, output: 0.40 },\n  'gemini-3.0-pro-preview': { input: 2.00, output: 12.00 },\n  'google/gemini-2.5-pro': { input: 1.25, output: 10.0 },\n  'google/gemini-2.5-flash': { input: 0.30, output: 2.50 },\n  'google/gemini-3-pro-preview': { input: 2.00, output: 12.00 },\n  'gpt-4o': { input: 2.50, output: 10.0 },\n  'gpt-4o-mini': { input: 0.15, output: 0.60 },\n  'claude-4.5-sonnet': { input: 3.00, output: 15.0 },\n  'claude-4.5-opus': { input: 15.00, output: 75.0 },\n  // Default para modelos desconocidos\n  'default': { input: 1.00, output: 5.00 },\n}\n\n// Documento requerido por un paso (para matching inteligente)\nexport interface RequiredDocument {\n  id: string                    // UUID generado\n  name: string                  // Nombre/descripción del documento requerido\n  required: boolean             // true = obligatorio, false = opcional\n  matchedDocId?: string         // ID del documento asignado (si hay match)\n  matchConfidence?: number      // 0-1, confianza del match\n}\n\nexport interface FlowStep {\n  id: string\n  name: string\n  description?: string\n  order: number\n\n  // 🆕 Tipo de step: 'llm' (default) o 'scraper' (para Niche Finder Step 0)\n  type?: FlowStepType  // Default: 'llm'\n\n  // ============================================\n  // CONFIGURACIÓN PARA type: 'llm' (existente)\n  // ============================================\n\n  // Prompt con variables: {{ecp_name}}, {{country}}, etc.\n  prompt: string\n\n  // Documentos base (ya subidos) que se usan en este step\n  base_doc_ids: string[]\n\n  // Documentos requeridos por el paso (para matching inteligente)\n  required_documents?: RequiredDocument[]\n\n  // IDs de steps previos cuyos outputs se incluyen automáticamente\n  auto_receive_from: string[]\n\n  // Formato de salida deseado\n  output_format?: OutputFormat\n\n  // Configuración del modelo LLM\n  provider?: LLMProvider  // Default: 'gemini'\n  model?: LLMModel\n  temperature?: number\n  max_tokens?: number\n\n  // Configuración de fallback (opcional)\n  fallback?: FallbackConfig\n\n  // Modo de recuperación de documentos\n  retrieval_mode?: RetrievalMode  // Default: 'full'\n  rag_config?: RAGConfig\n\n  // ============================================\n  // CONFIGURACIÓN PARA type: 'scraper' (nuevo)\n  // Sistema de combinaciones A × B para Niche Finder\n  // ============================================\n\n  // Configuración del scraper (solo si type === 'scraper')\n  // Ver ScraperStepConfig en scraper.types.ts\n  scraper_config?: {\n    // Columna A: Contextos de vida\n    life_contexts: string[]       // familia, hijos, universidad, casamiento...\n\n    // Columna B: Palabras del producto\n    product_words: string[]       // pagos, ahorro, gastos, cuenta...\n\n    // Indicadores de problema (opcional)\n    indicators: string[]          // me frustra, necesito ayuda...\n\n    // Fuentes donde buscar\n    sources: {\n      reddit: boolean             // Búsqueda general en Reddit\n      thematic_forums: boolean    // Foros temáticos según contexto\n      general_forums: string[]    // Dominios de foros generales\n    }\n\n    // Configuración de SERP y scraping\n    serp_pages: number            // Páginas de resultados (default: 5)\n    batch_size: number            // URLs en paralelo (default: 10)\n\n    // Configuración de extracción LLM\n    extraction_prompt: string     // Prompt para extraer nichos\n    extraction_model: string      // Modelo LLM (default: gpt-4o-mini)\n  }\n}\n\nexport interface FlowConfig {\n  steps: FlowStep[]\n  version?: string\n  description?: string\n}\n\nexport interface StepOutput {\n  step_id: string\n  step_name: string\n  output: string\n  tokens: number\n  status: 'pending' | 'running' | 'completed' | 'error'\n  started_at?: string\n  completed_at?: string\n  error_message?: string\n}\n\nexport interface CampaignExecutionState {\n  status: 'draft' | 'running' | 'paused' | 'completed' | 'error'\n  current_step_id: string | null\n  step_outputs: Record<string, StepOutput>\n  started_at: string | null\n  completed_at: string | null\n  error_message?: string\n}\n\n// Variables disponibles en prompts\nexport interface PromptVariables {\n  ecp_name: string\n  problem_core: string\n  country: string\n  industry: string\n  client_name: string\n}\n\n// Request para ejecutar un step individual\nexport interface ExecuteStepRequest {\n  campaign_id: string\n  step_config: FlowStep\n  variables: PromptVariables\n  documents: Array<{\n    id: string\n    filename: string\n    content: string\n    category: string\n  }>\n  previous_outputs: StepOutput[]\n}\n\n// Request para ejecutar campaña completa\nexport interface ExecuteCampaignRequest {\n  campaign_id: string\n}\n\n// Response de ejecución\nexport interface ExecutionResponse {\n  success: boolean\n  output?: string\n  tokens?: {\n    input: number\n    output: number\n    total: number\n  }\n  duration_ms?: number\n  error?: string\n}\n\n// ============================================\n// REPORT GENERATION TYPES\n// ============================================\n\n// Resultado de detección de inconsistencias\nexport interface InconsistencyResult {\n  id: string\n  type: 'numeric' | 'factual' | 'missing'\n  field: string                    // Ej: \"número de empleados\"\n  description: string              // Descripción legible\n  campaigns: {\n    campaignId: string\n    campaignName: string\n    value: string\n    stepId: string\n    stepName: string\n  }[]\n  severity: 'high' | 'medium' | 'low'\n  suggestedResolution?: string\n  resolved?: boolean\n  resolvedValue?: string\n}\n\n// Configuración de exportación de reporte\nexport interface ReportExportConfig {\n  format: 'markdown' | 'pdf' | 'pptx' | 'notion' | 'json'\n  includeExecutiveSummary: boolean\n  includeCampaignDetails: boolean\n  includeInconsistencyReport: boolean\n  includeRecommendations: boolean\n  customTitle?: string\n  notionParentPageId?: string      // Para exportación a Notion\n}\n\n// Datos de reporte generado\nexport interface GeneratedReport {\n  id: string\n  projectId: string\n  projectName: string\n  generatedAt: string\n  campaigns: {\n    id: string\n    name: string\n    country: string\n    industry: string\n    customVariables: Record<string, string>\n    stepOutputs: {\n      stepId: string\n      stepName: string\n      output: string\n    }[]\n  }[]\n  selectedStepIds: string[]\n  inconsistencies: InconsistencyResult[]\n  executiveSummary?: string        // Generado por LLM\n  recommendations?: string[]       // Generado por LLM\n}\n\n// Estado del selector de campañas\nexport interface CampaignSelectionState {\n  selectedCampaignIds: string[]\n  selectedStepIds: string[]\n  statusFilter: 'all' | 'ready_to_present' | string\n}\n","numLines":280,"startLine":1,"totalLines":280}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KRfp4tz5rtRtC1bRUdKY4W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011TdFrLPgt825o6p7B9dfr8","name":"TodoWrite","input":{"todos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"pending","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"pending","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"pending","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"pending","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"pending","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"pending","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"pending","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Run quality checks","status":"pending","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":8602,"cache_read_input_tokens":54097,"cache_creation":{"ephemeral_5m_input_tokens":8602,"ephemeral_1h_input_tokens":0},"output_tokens":360,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"fe4cf90b-5f29-40ae-ae1e-5ec397a5b0e6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011TdFrLPgt825o6p7B9dfr8","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"934ca4c0-41a3-4175-b8ac-2bff46829d19","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"pending","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"pending","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"pending","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"pending","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"pending","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"pending","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"pending","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Run quality checks","status":"pending","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TPZFBaJ9LjLMumwXoD1ogv","type":"message","role":"assistant","content":[{"type":"text","text":"Let me look at more existing patterns, specifically the SaveToContextLakeModal and existing artifact-related components."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":391,"cache_read_input_tokens":62699,"cache_creation":{"ephemeral_5m_input_tokens":391,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"6088e9d3-8918-4ec3-9d69-e169d8af130b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TPZFBaJ9LjLMumwXoD1ogv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NpWMDsVoPTnEsN84h2KKQw","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/SaveToContextLakeModal.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":391,"cache_read_input_tokens":62699,"cache_creation":{"ephemeral_5m_input_tokens":391,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"0c2c7e5d-9fe0-4792-855e-90c132d9a37c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TPZFBaJ9LjLMumwXoD1ogv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01J8k4tzWBPuLHm3rthbBodA","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SerpResultsPanel.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":391,"cache_read_input_tokens":62699,"cache_creation":{"ephemeral_5m_input_tokens":391,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"203e2cdd-3eba-469f-82a5-aa14b63b6a62"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TPZFBaJ9LjLMumwXoD1ogv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GMMNdPXJmfkg3ZGezZxgWD","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ScrapeResultsPanel.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":391,"cache_read_input_tokens":62699,"cache_creation":{"ephemeral_5m_input_tokens":391,"ephemeral_1h_input_tokens":0},"output_tokens":255,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"75551c85-7a8f-4b3c-9c6c-4b5dcbc1143f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NpWMDsVoPTnEsN84h2KKQw","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useEffect, useRef } from 'react'\n     4→import { createPortal } from 'react-dom'\n     5→import { X, Save, FileText, Tag, Folder, Building2, FolderKanban, User, Clock, Cpu, Sparkles, Loader2, Info } from 'lucide-react'\n     6→import { PlaybookStepSourceMetadata } from '@/hooks/useDocuments'\n     7→\n     8→// ============================================\n     9→// TYPES\n    10→// ============================================\n    11→\n    12→export interface StepOutputContext {\n    13→  // Step info\n    14→  stepId: string\n    15→  stepName: string\n    16→  stepOrder: number\n    17→  // Campaign info\n    18→  campaignId: string\n    19→  campaignName: string\n    20→  campaignVariables?: Record<string, string>\n    21→  // Playbook info\n    22→  playbookId: string\n    23→  playbookName: string\n    24→  // Execution info\n    25→  executedAt?: string\n    26→  modelUsed?: string\n    27→  modelProvider?: string\n    28→  inputTokens?: number\n    29→  outputTokens?: number\n    30→  // Input references\n    31→  inputDocumentIds?: string[]\n    32→  inputPreviousStepIds?: string[]\n    33→  // Was the content edited before saving?\n    34→  wasEditedBeforeConversion: boolean\n    35→}\n    36→\n    37→export interface SaveToContextLakeModalProps {\n    38→  isOpen: boolean\n    39→  content: string\n    40→  projectId: string\n    41→  clientId: string\n    42→  userId: string\n    43→  stepContext: StepOutputContext\n    44→  onSave: (savedDocId: string) => void\n    45→  onClose: () => void\n    46→}\n    47→\n    48→// Document categories\n    49→const DOCUMENT_CATEGORIES = [\n    50→  { value: 'research', label: 'Investigación' },\n    51→  { value: 'strategy', label: 'Estrategia' },\n    52→  { value: 'content', label: 'Contenido' },\n    53→  { value: 'analysis', label: 'Análisis' },\n    54→  { value: 'persona', label: 'Persona/Avatar' },\n    55→  { value: 'brief', label: 'Brief' },\n    56→  { value: 'guidelines', label: 'Guías/Guidelines' },\n    57→  { value: 'other', label: 'Otro' },\n    58→]\n    59→\n    60→// ============================================\n    61→// MODAL COMPONENT\n    62→// ============================================\n    63→\n    64→export default function SaveToContextLakeModal({\n    65→  isOpen,\n    66→  content,\n    67→  projectId,\n    68→  clientId,\n    69→  userId,\n    70→  stepContext,\n    71→  onSave,\n    72→  onClose,\n    73→}: SaveToContextLakeModalProps) {\n    74→  const [mounted, setMounted] = useState(false)\n    75→  const [isVisible, setIsVisible] = useState(false)\n    76→  const [saving, setSaving] = useState(false)\n    77→  const [error, setError] = useState<string | null>(null)\n    78→  const modalRef = useRef<HTMLDivElement>(null)\n    79→\n    80→  // Form state\n    81→  const defaultFilename = `${stepContext.stepName} - ${stepContext.campaignName} - ${new Date().toLocaleDateString('es-ES', { day: 'numeric', month: 'short', year: 'numeric' })}`\n    82→  const [filename, setFilename] = useState(defaultFilename)\n    83→  const [category, setCategory] = useState('content')\n    84→  const [description, setDescription] = useState(`Output del paso \"${stepContext.stepName}\" del playbook ${stepContext.playbookName}.`)\n    85→  const [tags, setTags] = useState<string[]>([stepContext.campaignName.toLowerCase().replace(/\\s+/g, '-')])\n    86→  const [newTag, setNewTag] = useState('')\n    87→  const [destination, setDestination] = useState<'project' | 'client'>('project')\n    88→\n    89→  useEffect(() => {\n    90→    setMounted(true)\n    91→  }, [])\n    92→\n    93→  useEffect(() => {\n    94→    if (isOpen) {\n    95→      requestAnimationFrame(() => setIsVisible(true))\n    96→      // Reset form when opening\n    97→      setFilename(defaultFilename)\n    98→      setError(null)\n    99→    } else {\n   100→      setIsVisible(false)\n   101→    }\n   102→  }, [isOpen, defaultFilename])\n   103→\n   104→  // Handle escape key\n   105→  useEffect(() => {\n   106→    if (!isOpen) return\n   107→\n   108→    const handleKeyDown = (e: KeyboardEvent) => {\n   109→      if (e.key === 'Escape') onClose()\n   110→    }\n   111→\n   112→    document.addEventListener('keydown', handleKeyDown)\n   113→    return () => document.removeEventListener('keydown', handleKeyDown)\n   114→  }, [isOpen, onClose])\n   115→\n   116→  // Prevent body scroll\n   117→  useEffect(() => {\n   118→    if (isOpen) {\n   119→      document.body.style.overflow = 'hidden'\n   120→    } else {\n   121→      document.body.style.overflow = ''\n   122→    }\n   123→    return () => {\n   124→      document.body.style.overflow = ''\n   125→    }\n   126→  }, [isOpen])\n   127→\n   128→  const handleAddTag = () => {\n   129→    const trimmedTag = newTag.trim().toLowerCase().replace(/\\s+/g, '-')\n   130→    if (trimmedTag && !tags.includes(trimmedTag)) {\n   131→      setTags([...tags, trimmedTag])\n   132→      setNewTag('')\n   133→    }\n   134→  }\n   135→\n   136→  const handleRemoveTag = (tagToRemove: string) => {\n   137→    setTags(tags.filter(t => t !== tagToRemove))\n   138→  }\n   139→\n   140→  const handleSave = async () => {\n   141→    if (!filename.trim()) {\n   142→      setError('El nombre del documento es requerido')\n   143→      return\n   144→    }\n   145→\n   146→    setSaving(true)\n   147→    setError(null)\n   148→\n   149→    try {\n   150→      // Build source metadata\n   151→      const sourceMetadata: PlaybookStepSourceMetadata = {\n   152→        origin_type: 'flow_step_output',\n   153→        playbook_id: stepContext.playbookId,\n   154→        playbook_name: stepContext.playbookName,\n   155→        campaign_id: stepContext.campaignId,\n   156→        campaign_name: stepContext.campaignName,\n   157→        campaign_variables: stepContext.campaignVariables || {},\n   158→        step_id: stepContext.stepId,\n   159→        step_name: stepContext.stepName,\n   160→        step_order: stepContext.stepOrder,\n   161→        executed_at: stepContext.executedAt || new Date().toISOString(),\n   162→        model_used: stepContext.modelUsed || 'unknown',\n   163→        model_provider: stepContext.modelProvider || 'unknown',\n   164→        input_tokens: stepContext.inputTokens || 0,\n   165→        output_tokens: stepContext.outputTokens || 0,\n   166→        input_document_ids: stepContext.inputDocumentIds || [],\n   167→        input_previous_step_ids: stepContext.inputPreviousStepIds || [],\n   168→        converted_at: new Date().toISOString(),\n   169→        converted_by: userId,\n   170→        was_edited_before_conversion: stepContext.wasEditedBeforeConversion,\n   171→      }\n   172→\n   173→      const response = await fetch('/api/documents/from-step-output', {\n   174→        method: 'POST',\n   175→        headers: { 'Content-Type': 'application/json' },\n   176→        body: JSON.stringify({\n   177→          projectId: destination === 'project' ? projectId : null,\n   178→          clientId,\n   179→          filename: filename.trim(),\n   180→          category,\n   181→          content,\n   182→          description: description.trim() || null,\n   183→          tags: tags.length > 0 ? tags : null,\n   184→          userId,\n   185→          sourceMetadata,\n   186→          sourceCampaignId: stepContext.campaignId,\n   187→          sourceStepId: stepContext.stepId,\n   188→          sourceStepName: stepContext.stepName,\n   189→          sourcePlaybookId: stepContext.playbookId,\n   190→        }),\n   191→      })\n   192→\n   193→      const data = await response.json()\n   194→\n   195→      if (!response.ok) {\n   196→        throw new Error(data.error || 'Error al guardar el documento')\n   197→      }\n   198→\n   199→      onSave(data.document.id)\n   200→    } catch (err) {\n   201→      setError(err instanceof Error ? err.message : 'Error desconocido')\n   202→    } finally {\n   203→      setSaving(false)\n   204→    }\n   205→  }\n   206→\n   207→  if (!mounted || !isOpen) return null\n   208→\n   209→  return createPortal(\n   210→    <div\n   211→      className={`fixed inset-0 z-[10000] flex items-center justify-center p-4 transition-all duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n   212→      role=\"dialog\"\n   213→      aria-modal=\"true\"\n   214→      aria-labelledby=\"modal-title\"\n   215→    >\n   216→      {/* Backdrop */}\n   217→      <div\n   218→        className={`absolute inset-0 bg-gray-900/60 backdrop-blur-sm transition-opacity duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n   219→        onClick={onClose}\n   220→        aria-hidden=\"true\"\n   221→      />\n   222→\n   223→      {/* Modal */}\n   224→      <div\n   225→        ref={modalRef}\n   226→        className={`relative w-full max-w-2xl max-h-[90vh] overflow-y-auto bg-white dark:bg-gray-900 rounded-2xl shadow-2xl transform transition-all duration-200 ${isVisible ? 'scale-100 opacity-100' : 'scale-95 opacity-0'}`}\n   227→      >\n   228→        {/* Header */}\n   229→        <div className=\"sticky top-0 bg-gradient-to-r from-indigo-600 to-purple-600 px-6 py-5 rounded-t-2xl z-10\">\n   230→          <div className=\"flex items-center justify-between\">\n   231→            <div className=\"flex items-center gap-3\">\n   232→              <div className=\"p-3 bg-white/20 rounded-xl backdrop-blur-sm\">\n   233→                <Save className=\"w-6 h-6 text-white\" />\n   234→              </div>\n   235→              <div>\n   236→                <h2 id=\"modal-title\" className=\"text-xl font-bold text-white\">\n   237→                  Guardar en Context Lake\n   238→                </h2>\n   239→                <p className=\"text-indigo-100 text-sm mt-0.5\">\n   240→                  Crear documento permanente desde este output\n   241→                </p>\n   242→              </div>\n   243→            </div>\n   244→            <button\n   245→              onClick={onClose}\n   246→              className=\"p-2 text-white/70 hover:text-white hover:bg-white/10 rounded-lg transition-colors\"\n   247→            >\n   248→              <X size={20} />\n   249→            </button>\n   250→          </div>\n   251→        </div>\n   252→\n   253→        {/* Content */}\n   254→        <div className=\"p-6 space-y-6\">\n   255→          {/* Error message */}\n   256→          {error && (\n   257→            <div className=\"p-4 bg-red-50 border border-red-200 text-red-700 rounded-xl text-sm\">\n   258→              {error}\n   259→            </div>\n   260→          )}\n   261→\n   262→          {/* Filename */}\n   263→          <div>\n   264→            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   265→              <FileText size={14} className=\"inline mr-1.5\" />\n   266→              Nombre del documento\n   267→            </label>\n   268→            <input\n   269→              type=\"text\"\n   270→              value={filename}\n   271→              onChange={(e) => setFilename(e.target.value)}\n   272→              className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n   273→              placeholder=\"Nombre del documento...\"\n   274→            />\n   275→          </div>\n   276→\n   277→          {/* Category and Destination */}\n   278→          <div className=\"grid grid-cols-2 gap-4\">\n   279→            <div>\n   280→              <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   281→                <Folder size={14} className=\"inline mr-1.5\" />\n   282→                Categoría\n   283→              </label>\n   284→              <select\n   285→                value={category}\n   286→                onChange={(e) => setCategory(e.target.value)}\n   287→                className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n   288→              >\n   289→                {DOCUMENT_CATEGORIES.map((cat) => (\n   290→                  <option key={cat.value} value={cat.value}>\n   291→                    {cat.label}\n   292→                  </option>\n   293→                ))}\n   294→              </select>\n   295→            </div>\n   296→\n   297→            <div>\n   298→              <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   299→                Guardar en\n   300→              </label>\n   301→              <div className=\"flex gap-2\">\n   302→                <button\n   303→                  type=\"button\"\n   304→                  onClick={() => setDestination('project')}\n   305→                  className={`flex-1 px-4 py-3 text-sm rounded-xl border transition-all flex items-center justify-center gap-2 ${\n   306→                    destination === 'project'\n   307→                      ? 'bg-indigo-50 border-indigo-300 text-indigo-700 dark:bg-indigo-900/30 dark:border-indigo-600 dark:text-indigo-300'\n   308→                      : 'border-gray-200 text-gray-600 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800'\n   309→                  }`}\n   310→                >\n   311→                  <FolderKanban size={16} />\n   312→                  Proyecto\n   313→                </button>\n   314→                <button\n   315→                  type=\"button\"\n   316→                  onClick={() => setDestination('client')}\n   317→                  className={`flex-1 px-4 py-3 text-sm rounded-xl border transition-all flex items-center justify-center gap-2 ${\n   318→                    destination === 'client'\n   319→                      ? 'bg-indigo-50 border-indigo-300 text-indigo-700 dark:bg-indigo-900/30 dark:border-indigo-600 dark:text-indigo-300'\n   320→                      : 'border-gray-200 text-gray-600 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800'\n   321→                  }`}\n   322→                >\n   323→                  <Building2 size={16} />\n   324→                  Cliente\n   325→                </button>\n   326→              </div>\n   327→              <p className=\"text-xs text-gray-500 mt-1.5\">\n   328→                {destination === 'project'\n   329→                  ? 'Visible solo en este proyecto'\n   330→                  : 'Compartido con todos los proyectos del cliente'}\n   331→              </p>\n   332→            </div>\n   333→          </div>\n   334→\n   335→          {/* Description */}\n   336→          <div>\n   337→            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   338→              Descripción (opcional)\n   339→            </label>\n   340→            <textarea\n   341→              value={description}\n   342→              onChange={(e) => setDescription(e.target.value)}\n   343→              rows={2}\n   344→              className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 resize-none\"\n   345→              placeholder=\"Descripción del documento...\"\n   346→            />\n   347→          </div>\n   348→\n   349→          {/* Tags */}\n   350→          <div>\n   351→            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   352→              <Tag size={14} className=\"inline mr-1.5\" />\n   353→              Tags\n   354→            </label>\n   355→            <div className=\"flex flex-wrap gap-2 mb-2\">\n   356→              {tags.map((tag) => (\n   357→                <span\n   358→                  key={tag}\n   359→                  className=\"inline-flex items-center gap-1 px-3 py-1.5 bg-indigo-50 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300 rounded-lg text-sm\"\n   360→                >\n   361→                  {tag}\n   362→                  <button\n   363→                    type=\"button\"\n   364→                    onClick={() => handleRemoveTag(tag)}\n   365→                    className=\"ml-1 text-indigo-400 hover:text-indigo-600\"\n   366→                  >\n   367→                    <X size={12} />\n   368→                  </button>\n   369→                </span>\n   370→              ))}\n   371→            </div>\n   372→            <div className=\"flex gap-2\">\n   373→              <input\n   374→                type=\"text\"\n   375→                value={newTag}\n   376→                onChange={(e) => setNewTag(e.target.value)}\n   377→                onKeyDown={(e) => {\n   378→                  if (e.key === 'Enter') {\n   379→                    e.preventDefault()\n   380→                    handleAddTag()\n   381→                  }\n   382→                }}\n   383→                className=\"flex-1 px-4 py-2 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n   384→                placeholder=\"Agregar tag...\"\n   385→              />\n   386→              <button\n   387→                type=\"button\"\n   388→                onClick={handleAddTag}\n   389→                className=\"px-4 py-2 text-sm bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 rounded-xl hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors\"\n   390→              >\n   391→                Agregar\n   392→              </button>\n   393→            </div>\n   394→          </div>\n   395→\n   396→          {/* Traceability Info */}\n   397→          <div className=\"p-4 bg-gray-50 dark:bg-gray-800/50 rounded-xl border border-gray-200 dark:border-gray-700\">\n   398→            <div className=\"flex items-center gap-2 text-gray-700 dark:text-gray-300 font-medium text-sm mb-3\">\n   399→              <Info size={16} />\n   400→              Trazabilidad que se guardará\n   401→            </div>\n   402→            <div className=\"grid grid-cols-2 gap-3 text-sm\">\n   403→              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n   404→                <FolderKanban size={14} />\n   405→                <span className=\"font-medium\">Campaña:</span>\n   406→                <span className=\"truncate\">{stepContext.campaignName}</span>\n   407→              </div>\n   408→              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n   409→                <Sparkles size={14} />\n   410→                <span className=\"font-medium\">Paso:</span>\n   411→                <span className=\"truncate\">{stepContext.stepName} (#{stepContext.stepOrder})</span>\n   412→              </div>\n   413→              {stepContext.modelUsed && (\n   414→                <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n   415→                  <Cpu size={14} />\n   416→                  <span className=\"font-medium\">Modelo:</span>\n   417→                  <span className=\"truncate\">{stepContext.modelUsed}</span>\n   418→                </div>\n   419→              )}\n   420→              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n   421→                <User size={14} />\n   422→                <span className=\"font-medium\">Creado por:</span>\n   423→                <span className=\"truncate\">Usuario actual</span>\n   424→              </div>\n   425→              {stepContext.wasEditedBeforeConversion && (\n   426→                <div className=\"col-span-2 flex items-center gap-2 text-amber-600 dark:text-amber-400\">\n   427→                  <Clock size={14} />\n   428→                  <span>El output fue editado antes de guardarse</span>\n   429→                </div>\n   430→              )}\n   431→            </div>\n   432→          </div>\n   433→\n   434→          {/* Content Preview */}\n   435→          <div>\n   436→            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n   437→              Vista previa del contenido ({content.length.toLocaleString()} caracteres)\n   438→            </label>\n   439→            <div className=\"max-h-40 overflow-y-auto p-4 bg-gray-50 dark:bg-gray-800/50 rounded-xl border border-gray-200 dark:border-gray-700 text-sm text-gray-600 dark:text-gray-400 font-mono whitespace-pre-wrap\">\n   440→              {content.substring(0, 1000)}\n   441→              {content.length > 1000 && (\n   442→                <span className=\"text-gray-400\">... [{(content.length - 1000).toLocaleString()} caracteres más]</span>\n   443→              )}\n   444→            </div>\n   445→          </div>\n   446→        </div>\n   447→\n   448→        {/* Footer */}\n   449→        <div className=\"sticky bottom-0 flex items-center justify-end gap-3 px-6 py-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/50 rounded-b-2xl\">\n   450→          <button\n   451→            type=\"button\"\n   452→            onClick={onClose}\n   453→            className=\"px-5 py-2.5 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-xl hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors\"\n   454→          >\n   455→            Cancelar\n   456→          </button>\n   457→          <button\n   458→            type=\"button\"\n   459→            onClick={handleSave}\n   460→            disabled={saving || !filename.trim()}\n   461→            className=\"px-6 py-2.5 text-sm font-medium text-white bg-gradient-to-r from-indigo-600 to-purple-600 rounded-xl hover:from-indigo-700 hover:to-purple-700 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed transition-all shadow-md hover:shadow-lg inline-flex items-center gap-2\"\n   462→          >\n   463→            {saving ? (\n   464→              <>\n   465→                <Loader2 size={16} className=\"animate-spin\" />\n   466→                Guardando...\n   467→              </>\n   468→            ) : (\n   469→              <>\n   470→                <Save size={16} />\n   471→                Guardar en Context Lake\n   472→              </>\n   473→            )}\n   474→          </button>\n   475→        </div>\n   476→      </div>\n   477→    </div>,\n   478→    document.body\n   479→  )\n   480→}\n   481→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"bee5e5e8-c341-4a10-88c4-d535b5634771","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/documents/SaveToContextLakeModal.tsx","content":"'use client'\n\nimport { useState, useEffect, useRef } from 'react'\nimport { createPortal } from 'react-dom'\nimport { X, Save, FileText, Tag, Folder, Building2, FolderKanban, User, Clock, Cpu, Sparkles, Loader2, Info } from 'lucide-react'\nimport { PlaybookStepSourceMetadata } from '@/hooks/useDocuments'\n\n// ============================================\n// TYPES\n// ============================================\n\nexport interface StepOutputContext {\n  // Step info\n  stepId: string\n  stepName: string\n  stepOrder: number\n  // Campaign info\n  campaignId: string\n  campaignName: string\n  campaignVariables?: Record<string, string>\n  // Playbook info\n  playbookId: string\n  playbookName: string\n  // Execution info\n  executedAt?: string\n  modelUsed?: string\n  modelProvider?: string\n  inputTokens?: number\n  outputTokens?: number\n  // Input references\n  inputDocumentIds?: string[]\n  inputPreviousStepIds?: string[]\n  // Was the content edited before saving?\n  wasEditedBeforeConversion: boolean\n}\n\nexport interface SaveToContextLakeModalProps {\n  isOpen: boolean\n  content: string\n  projectId: string\n  clientId: string\n  userId: string\n  stepContext: StepOutputContext\n  onSave: (savedDocId: string) => void\n  onClose: () => void\n}\n\n// Document categories\nconst DOCUMENT_CATEGORIES = [\n  { value: 'research', label: 'Investigación' },\n  { value: 'strategy', label: 'Estrategia' },\n  { value: 'content', label: 'Contenido' },\n  { value: 'analysis', label: 'Análisis' },\n  { value: 'persona', label: 'Persona/Avatar' },\n  { value: 'brief', label: 'Brief' },\n  { value: 'guidelines', label: 'Guías/Guidelines' },\n  { value: 'other', label: 'Otro' },\n]\n\n// ============================================\n// MODAL COMPONENT\n// ============================================\n\nexport default function SaveToContextLakeModal({\n  isOpen,\n  content,\n  projectId,\n  clientId,\n  userId,\n  stepContext,\n  onSave,\n  onClose,\n}: SaveToContextLakeModalProps) {\n  const [mounted, setMounted] = useState(false)\n  const [isVisible, setIsVisible] = useState(false)\n  const [saving, setSaving] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const modalRef = useRef<HTMLDivElement>(null)\n\n  // Form state\n  const defaultFilename = `${stepContext.stepName} - ${stepContext.campaignName} - ${new Date().toLocaleDateString('es-ES', { day: 'numeric', month: 'short', year: 'numeric' })}`\n  const [filename, setFilename] = useState(defaultFilename)\n  const [category, setCategory] = useState('content')\n  const [description, setDescription] = useState(`Output del paso \"${stepContext.stepName}\" del playbook ${stepContext.playbookName}.`)\n  const [tags, setTags] = useState<string[]>([stepContext.campaignName.toLowerCase().replace(/\\s+/g, '-')])\n  const [newTag, setNewTag] = useState('')\n  const [destination, setDestination] = useState<'project' | 'client'>('project')\n\n  useEffect(() => {\n    setMounted(true)\n  }, [])\n\n  useEffect(() => {\n    if (isOpen) {\n      requestAnimationFrame(() => setIsVisible(true))\n      // Reset form when opening\n      setFilename(defaultFilename)\n      setError(null)\n    } else {\n      setIsVisible(false)\n    }\n  }, [isOpen, defaultFilename])\n\n  // Handle escape key\n  useEffect(() => {\n    if (!isOpen) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') onClose()\n    }\n\n    document.addEventListener('keydown', handleKeyDown)\n    return () => document.removeEventListener('keydown', handleKeyDown)\n  }, [isOpen, onClose])\n\n  // Prevent body scroll\n  useEffect(() => {\n    if (isOpen) {\n      document.body.style.overflow = 'hidden'\n    } else {\n      document.body.style.overflow = ''\n    }\n    return () => {\n      document.body.style.overflow = ''\n    }\n  }, [isOpen])\n\n  const handleAddTag = () => {\n    const trimmedTag = newTag.trim().toLowerCase().replace(/\\s+/g, '-')\n    if (trimmedTag && !tags.includes(trimmedTag)) {\n      setTags([...tags, trimmedTag])\n      setNewTag('')\n    }\n  }\n\n  const handleRemoveTag = (tagToRemove: string) => {\n    setTags(tags.filter(t => t !== tagToRemove))\n  }\n\n  const handleSave = async () => {\n    if (!filename.trim()) {\n      setError('El nombre del documento es requerido')\n      return\n    }\n\n    setSaving(true)\n    setError(null)\n\n    try {\n      // Build source metadata\n      const sourceMetadata: PlaybookStepSourceMetadata = {\n        origin_type: 'flow_step_output',\n        playbook_id: stepContext.playbookId,\n        playbook_name: stepContext.playbookName,\n        campaign_id: stepContext.campaignId,\n        campaign_name: stepContext.campaignName,\n        campaign_variables: stepContext.campaignVariables || {},\n        step_id: stepContext.stepId,\n        step_name: stepContext.stepName,\n        step_order: stepContext.stepOrder,\n        executed_at: stepContext.executedAt || new Date().toISOString(),\n        model_used: stepContext.modelUsed || 'unknown',\n        model_provider: stepContext.modelProvider || 'unknown',\n        input_tokens: stepContext.inputTokens || 0,\n        output_tokens: stepContext.outputTokens || 0,\n        input_document_ids: stepContext.inputDocumentIds || [],\n        input_previous_step_ids: stepContext.inputPreviousStepIds || [],\n        converted_at: new Date().toISOString(),\n        converted_by: userId,\n        was_edited_before_conversion: stepContext.wasEditedBeforeConversion,\n      }\n\n      const response = await fetch('/api/documents/from-step-output', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          projectId: destination === 'project' ? projectId : null,\n          clientId,\n          filename: filename.trim(),\n          category,\n          content,\n          description: description.trim() || null,\n          tags: tags.length > 0 ? tags : null,\n          userId,\n          sourceMetadata,\n          sourceCampaignId: stepContext.campaignId,\n          sourceStepId: stepContext.stepId,\n          sourceStepName: stepContext.stepName,\n          sourcePlaybookId: stepContext.playbookId,\n        }),\n      })\n\n      const data = await response.json()\n\n      if (!response.ok) {\n        throw new Error(data.error || 'Error al guardar el documento')\n      }\n\n      onSave(data.document.id)\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Error desconocido')\n    } finally {\n      setSaving(false)\n    }\n  }\n\n  if (!mounted || !isOpen) return null\n\n  return createPortal(\n    <div\n      className={`fixed inset-0 z-[10000] flex items-center justify-center p-4 transition-all duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-labelledby=\"modal-title\"\n    >\n      {/* Backdrop */}\n      <div\n        className={`absolute inset-0 bg-gray-900/60 backdrop-blur-sm transition-opacity duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n        onClick={onClose}\n        aria-hidden=\"true\"\n      />\n\n      {/* Modal */}\n      <div\n        ref={modalRef}\n        className={`relative w-full max-w-2xl max-h-[90vh] overflow-y-auto bg-white dark:bg-gray-900 rounded-2xl shadow-2xl transform transition-all duration-200 ${isVisible ? 'scale-100 opacity-100' : 'scale-95 opacity-0'}`}\n      >\n        {/* Header */}\n        <div className=\"sticky top-0 bg-gradient-to-r from-indigo-600 to-purple-600 px-6 py-5 rounded-t-2xl z-10\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-3\">\n              <div className=\"p-3 bg-white/20 rounded-xl backdrop-blur-sm\">\n                <Save className=\"w-6 h-6 text-white\" />\n              </div>\n              <div>\n                <h2 id=\"modal-title\" className=\"text-xl font-bold text-white\">\n                  Guardar en Context Lake\n                </h2>\n                <p className=\"text-indigo-100 text-sm mt-0.5\">\n                  Crear documento permanente desde este output\n                </p>\n              </div>\n            </div>\n            <button\n              onClick={onClose}\n              className=\"p-2 text-white/70 hover:text-white hover:bg-white/10 rounded-lg transition-colors\"\n            >\n              <X size={20} />\n            </button>\n          </div>\n        </div>\n\n        {/* Content */}\n        <div className=\"p-6 space-y-6\">\n          {/* Error message */}\n          {error && (\n            <div className=\"p-4 bg-red-50 border border-red-200 text-red-700 rounded-xl text-sm\">\n              {error}\n            </div>\n          )}\n\n          {/* Filename */}\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n              <FileText size={14} className=\"inline mr-1.5\" />\n              Nombre del documento\n            </label>\n            <input\n              type=\"text\"\n              value={filename}\n              onChange={(e) => setFilename(e.target.value)}\n              className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n              placeholder=\"Nombre del documento...\"\n            />\n          </div>\n\n          {/* Category and Destination */}\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                <Folder size={14} className=\"inline mr-1.5\" />\n                Categoría\n              </label>\n              <select\n                value={category}\n                onChange={(e) => setCategory(e.target.value)}\n                className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n              >\n                {DOCUMENT_CATEGORIES.map((cat) => (\n                  <option key={cat.value} value={cat.value}>\n                    {cat.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div>\n              <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                Guardar en\n              </label>\n              <div className=\"flex gap-2\">\n                <button\n                  type=\"button\"\n                  onClick={() => setDestination('project')}\n                  className={`flex-1 px-4 py-3 text-sm rounded-xl border transition-all flex items-center justify-center gap-2 ${\n                    destination === 'project'\n                      ? 'bg-indigo-50 border-indigo-300 text-indigo-700 dark:bg-indigo-900/30 dark:border-indigo-600 dark:text-indigo-300'\n                      : 'border-gray-200 text-gray-600 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800'\n                  }`}\n                >\n                  <FolderKanban size={16} />\n                  Proyecto\n                </button>\n                <button\n                  type=\"button\"\n                  onClick={() => setDestination('client')}\n                  className={`flex-1 px-4 py-3 text-sm rounded-xl border transition-all flex items-center justify-center gap-2 ${\n                    destination === 'client'\n                      ? 'bg-indigo-50 border-indigo-300 text-indigo-700 dark:bg-indigo-900/30 dark:border-indigo-600 dark:text-indigo-300'\n                      : 'border-gray-200 text-gray-600 hover:bg-gray-50 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800'\n                  }`}\n                >\n                  <Building2 size={16} />\n                  Cliente\n                </button>\n              </div>\n              <p className=\"text-xs text-gray-500 mt-1.5\">\n                {destination === 'project'\n                  ? 'Visible solo en este proyecto'\n                  : 'Compartido con todos los proyectos del cliente'}\n              </p>\n            </div>\n          </div>\n\n          {/* Description */}\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n              Descripción (opcional)\n            </label>\n            <textarea\n              value={description}\n              onChange={(e) => setDescription(e.target.value)}\n              rows={2}\n              className=\"w-full px-4 py-3 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 resize-none\"\n              placeholder=\"Descripción del documento...\"\n            />\n          </div>\n\n          {/* Tags */}\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n              <Tag size={14} className=\"inline mr-1.5\" />\n              Tags\n            </label>\n            <div className=\"flex flex-wrap gap-2 mb-2\">\n              {tags.map((tag) => (\n                <span\n                  key={tag}\n                  className=\"inline-flex items-center gap-1 px-3 py-1.5 bg-indigo-50 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300 rounded-lg text-sm\"\n                >\n                  {tag}\n                  <button\n                    type=\"button\"\n                    onClick={() => handleRemoveTag(tag)}\n                    className=\"ml-1 text-indigo-400 hover:text-indigo-600\"\n                  >\n                    <X size={12} />\n                  </button>\n                </span>\n              ))}\n            </div>\n            <div className=\"flex gap-2\">\n              <input\n                type=\"text\"\n                value={newTag}\n                onChange={(e) => setNewTag(e.target.value)}\n                onKeyDown={(e) => {\n                  if (e.key === 'Enter') {\n                    e.preventDefault()\n                    handleAddTag()\n                  }\n                }}\n                className=\"flex-1 px-4 py-2 text-sm border border-gray-200 dark:border-gray-700 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n                placeholder=\"Agregar tag...\"\n              />\n              <button\n                type=\"button\"\n                onClick={handleAddTag}\n                className=\"px-4 py-2 text-sm bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 rounded-xl hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors\"\n              >\n                Agregar\n              </button>\n            </div>\n          </div>\n\n          {/* Traceability Info */}\n          <div className=\"p-4 bg-gray-50 dark:bg-gray-800/50 rounded-xl border border-gray-200 dark:border-gray-700\">\n            <div className=\"flex items-center gap-2 text-gray-700 dark:text-gray-300 font-medium text-sm mb-3\">\n              <Info size={16} />\n              Trazabilidad que se guardará\n            </div>\n            <div className=\"grid grid-cols-2 gap-3 text-sm\">\n              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n                <FolderKanban size={14} />\n                <span className=\"font-medium\">Campaña:</span>\n                <span className=\"truncate\">{stepContext.campaignName}</span>\n              </div>\n              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n                <Sparkles size={14} />\n                <span className=\"font-medium\">Paso:</span>\n                <span className=\"truncate\">{stepContext.stepName} (#{stepContext.stepOrder})</span>\n              </div>\n              {stepContext.modelUsed && (\n                <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n                  <Cpu size={14} />\n                  <span className=\"font-medium\">Modelo:</span>\n                  <span className=\"truncate\">{stepContext.modelUsed}</span>\n                </div>\n              )}\n              <div className=\"flex items-center gap-2 text-gray-600 dark:text-gray-400\">\n                <User size={14} />\n                <span className=\"font-medium\">Creado por:</span>\n                <span className=\"truncate\">Usuario actual</span>\n              </div>\n              {stepContext.wasEditedBeforeConversion && (\n                <div className=\"col-span-2 flex items-center gap-2 text-amber-600 dark:text-amber-400\">\n                  <Clock size={14} />\n                  <span>El output fue editado antes de guardarse</span>\n                </div>\n              )}\n            </div>\n          </div>\n\n          {/* Content Preview */}\n          <div>\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n              Vista previa del contenido ({content.length.toLocaleString()} caracteres)\n            </label>\n            <div className=\"max-h-40 overflow-y-auto p-4 bg-gray-50 dark:bg-gray-800/50 rounded-xl border border-gray-200 dark:border-gray-700 text-sm text-gray-600 dark:text-gray-400 font-mono whitespace-pre-wrap\">\n              {content.substring(0, 1000)}\n              {content.length > 1000 && (\n                <span className=\"text-gray-400\">... [{(content.length - 1000).toLocaleString()} caracteres más]</span>\n              )}\n            </div>\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div className=\"sticky bottom-0 flex items-center justify-end gap-3 px-6 py-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/50 rounded-b-2xl\">\n          <button\n            type=\"button\"\n            onClick={onClose}\n            className=\"px-5 py-2.5 text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-xl hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors\"\n          >\n            Cancelar\n          </button>\n          <button\n            type=\"button\"\n            onClick={handleSave}\n            disabled={saving || !filename.trim()}\n            className=\"px-6 py-2.5 text-sm font-medium text-white bg-gradient-to-r from-indigo-600 to-purple-600 rounded-xl hover:from-indigo-700 hover:to-purple-700 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed transition-all shadow-md hover:shadow-lg inline-flex items-center gap-2\"\n          >\n            {saving ? (\n              <>\n                <Loader2 size={16} className=\"animate-spin\" />\n                Guardando...\n              </>\n            ) : (\n              <>\n                <Save size={16} />\n                Guardar en Context Lake\n              </>\n            )}\n          </button>\n        </div>\n      </div>\n    </div>,\n    document.body\n  )\n}\n","numLines":481,"startLine":1,"totalLines":481}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01J8k4tzWBPuLHm3rthbBodA","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useEffect } from 'react'\n     4→import { Check, ChevronDown, ChevronUp, ExternalLink, Loader2 } from 'lucide-react'\n     5→\n     6→interface SourceGroup {\n     7→  source_type: string\n     8→  count: number\n     9→  selected: boolean\n    10→  sampleUrls: Array<{ id: string; url: string; title: string; life_context: string; product_word: string }>\n    11→}\n    12→\n    13→interface SerpResultsPanelProps {\n    14→  jobId: string\n    15→  onContinue: (selectedSources: string[]) => void\n    16→  onBack: () => void\n    17→}\n    18→\n    19→const FIRECRAWL_COST_PER_URL = 0.001 // Approximate cost\n    20→\n    21→export function SerpResultsPanel({ jobId, onContinue, onBack }: SerpResultsPanelProps) {\n    22→  const [groups, setGroups] = useState<SourceGroup[]>([])\n    23→  const [expandedSource, setExpandedSource] = useState<string | null>(null)\n    24→  const [loading, setLoading] = useState(true)\n    25→  const [error, setError] = useState<string | null>(null)\n    26→\n    27→  // Fetch URL summary from API\n    28→  useEffect(() => {\n    29→    async function loadSummary() {\n    30→      try {\n    31→        setLoading(true)\n    32→        const response = await fetch(`/api/niche-finder/jobs/${jobId}/urls/summary`)\n    33→        if (!response.ok) {\n    34→          throw new Error('Failed to load URL summary')\n    35→        }\n    36→        const data = await response.json()\n    37→\n    38→        // Initialize all sources as selected\n    39→        setGroups(data.sources.map((s: Omit<SourceGroup, 'selected'>) => ({\n    40→          ...s,\n    41→          selected: true\n    42→        })))\n    43→      } catch (err) {\n    44→        setError(err instanceof Error ? err.message : 'Unknown error')\n    45→      } finally {\n    46→        setLoading(false)\n    47→      }\n    48→    }\n    49→    loadSummary()\n    50→  }, [jobId])\n    51→\n    52→  const totalUrls = groups.reduce((sum, g) => sum + g.count, 0)\n    53→  const selectedUrls = groups.filter(g => g.selected).reduce((sum, g) => sum + g.count, 0)\n    54→  const estimatedCost = selectedUrls * FIRECRAWL_COST_PER_URL\n    55→\n    56→  const toggleSource = (sourceType: string) => {\n    57→    setGroups(gs => gs.map(g =>\n    58→      g.source_type === sourceType\n    59→        ? { ...g, selected: !g.selected }\n    60→        : g\n    61→    ))\n    62→  }\n    63→\n    64→  const toggleExpand = (sourceType: string) => {\n    65→    setExpandedSource(prev => prev === sourceType ? null : sourceType)\n    66→  }\n    67→\n    68→  if (loading) {\n    69→    return (\n    70→      <div className=\"flex items-center justify-center py-12\">\n    71→        <Loader2 className=\"w-6 h-6 text-blue-600 animate-spin\" />\n    72→        <span className=\"ml-3 text-gray-600\">Cargando resultados...</span>\n    73→      </div>\n    74→    )\n    75→  }\n    76→\n    77→  if (error) {\n    78→    return (\n    79→      <div className=\"bg-red-50 border border-red-200 rounded-lg p-4\">\n    80→        <p className=\"text-red-800\">{error}</p>\n    81→        <button\n    82→          onClick={() => window.location.reload()}\n    83→          className=\"mt-2 text-sm text-red-600 underline\"\n    84→        >\n    85→          Reintentar\n    86→        </button>\n    87→      </div>\n    88→    )\n    89→  }\n    90→\n    91→  if (groups.length === 0) {\n    92→    return (\n    93→      <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-6 text-center\">\n    94→        <p className=\"text-yellow-800 font-medium\">No se encontraron URLs</p>\n    95→        <p className=\"text-yellow-700 text-sm mt-2\">\n    96→          Las búsquedas no devolvieron resultados relevantes.\n    97→          Intenta ajustar los contextos o palabras de búsqueda.\n    98→        </p>\n    99→        <button\n   100→          onClick={onBack}\n   101→          className=\"mt-4 px-4 py-2 bg-yellow-100 text-yellow-800 rounded-lg hover:bg-yellow-200 transition-colors\"\n   102→        >\n   103→          ← Volver a configurar\n   104→        </button>\n   105→      </div>\n   106→    )\n   107→  }\n   108→\n   109→  return (\n   110→    <div className=\"space-y-6\">\n   111→      {/* Header */}\n   112→      <div className=\"flex items-center gap-2 text-green-700\">\n   113→        <Check className=\"w-5 h-5\" />\n   114→        <span className=\"font-medium\">Búsqueda completada</span>\n   115→      </div>\n   116→\n   117→      <p className=\"text-gray-600\">\n   118→        Se encontraron <strong>{totalUrls.toLocaleString()} URLs</strong> únicas en {groups.length} fuentes\n   119→      </p>\n   120→\n   121→      {/* Source groups */}\n   122→      <div className=\"space-y-3\">\n   123→        {groups.map(group => (\n   124→          <div\n   125→            key={group.source_type}\n   126→            className={`border rounded-lg overflow-hidden transition-colors ${\n   127→              group.selected ? 'border-blue-200 bg-blue-50/30' : 'border-gray-200 bg-gray-50/50'\n   128→            }`}\n   129→          >\n   130→            {/* Header row */}\n   131→            <div className=\"flex items-center justify-between p-4\">\n   132→              <label className=\"flex items-center gap-3 cursor-pointer flex-1\">\n   133→                <input\n   134→                  type=\"checkbox\"\n   135→                  checked={group.selected}\n   136→                  onChange={() => toggleSource(group.source_type)}\n   137→                  className=\"w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500\"\n   138→                />\n   139→                <div>\n   140→                  <span className=\"font-medium text-gray-900\">\n   141→                    {formatSourceName(group.source_type)}\n   142→                  </span>\n   143→                  <span className=\"ml-2 text-gray-500\">\n   144→                    ({group.count.toLocaleString()} URLs)\n   145→                  </span>\n   146→                </div>\n   147→              </label>\n   148→              <button\n   149→                onClick={() => toggleExpand(group.source_type)}\n   150→                className=\"flex items-center gap-1 text-sm text-blue-600 hover:text-blue-800 transition-colors\"\n   151→              >\n   152→                {expandedSource === group.source_type ? (\n   153→                  <>\n   154→                    <span>ocultar</span>\n   155→                    <ChevronUp className=\"w-4 h-4\" />\n   156→                  </>\n   157→                ) : (\n   158→                  <>\n   159→                    <span>ver muestra</span>\n   160→                    <ChevronDown className=\"w-4 h-4\" />\n   161→                  </>\n   162→                )}\n   163→              </button>\n   164→            </div>\n   165→\n   166→            {/* Expanded samples */}\n   167→            {expandedSource === group.source_type && (\n   168→              <div className=\"border-t border-gray-200 bg-white p-4 space-y-3\">\n   169→                {group.sampleUrls.map((url, i) => (\n   170→                  <div key={url.id || i} className=\"flex items-start gap-3\">\n   171→                    <ExternalLink className=\"w-4 h-4 text-gray-400 mt-1 flex-shrink-0\" />\n   172→                    <div className=\"min-w-0 flex-1\">\n   173→                      <a\n   174→                        href={url.url}\n   175→                        target=\"_blank\"\n   176→                        rel=\"noopener noreferrer\"\n   177→                        className=\"text-blue-600 hover:underline text-sm font-medium block truncate\"\n   178→                      >\n   179→                        {url.title || url.url}\n   180→                      </a>\n   181→                      <p className=\"text-xs text-gray-500 mt-0.5 truncate\">\n   182→                        {url.url}\n   183→                      </p>\n   184→                      <div className=\"flex gap-2 mt-1\">\n   185→                        <span className=\"text-xs bg-gray-100 text-gray-600 px-2 py-0.5 rounded\">\n   186→                          {url.life_context}\n   187→                        </span>\n   188→                        <span className=\"text-xs bg-gray-100 text-gray-600 px-2 py-0.5 rounded\">\n   189→                          {url.product_word}\n   190→                        </span>\n   191→                      </div>\n   192→                    </div>\n   193→                  </div>\n   194→                ))}\n   195→                {group.count > group.sampleUrls.length && (\n   196→                  <p className=\"text-xs text-gray-400 pt-2\">\n   197→                    ...y {(group.count - group.sampleUrls.length).toLocaleString()} URLs más\n   198→                  </p>\n   199→                )}\n   200→              </div>\n   201→            )}\n   202→          </div>\n   203→        ))}\n   204→      </div>\n   205→\n   206→      {/* Summary */}\n   207→      <div className=\"bg-gray-50 rounded-lg p-4 space-y-2\">\n   208→        <div className=\"flex justify-between text-sm\">\n   209→          <span className=\"text-gray-600\">URLs seleccionadas</span>\n   210→          <span className=\"font-medium\">{selectedUrls.toLocaleString()} de {totalUrls.toLocaleString()}</span>\n   211→        </div>\n   212→        <div className=\"flex justify-between text-sm\">\n   213→          <span className=\"text-gray-600\">Costo estimado scraping</span>\n   214→          <span className=\"font-medium\">~${estimatedCost.toFixed(2)} USD</span>\n   215→        </div>\n   216→      </div>\n   217→\n   218→      {/* Actions */}\n   219→      <div className=\"flex gap-4 pt-2\">\n   220→        <button\n   221→          onClick={onBack}\n   222→          className=\"px-4 py-2.5 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors\"\n   223→        >\n   224→          ← Volver\n   225→        </button>\n   226→        <button\n   227→          onClick={() => onContinue(groups.filter(g => g.selected).map(g => g.source_type))}\n   228→          disabled={selectedUrls === 0}\n   229→          className={`flex-1 px-4 py-2.5 rounded-lg font-medium transition-colors ${\n   230→            selectedUrls === 0\n   231→              ? 'bg-gray-300 text-gray-500 cursor-not-allowed'\n   232→              : 'bg-blue-600 text-white hover:bg-blue-700'\n   233→          }`}\n   234→        >\n   235→          Continuar con {selectedUrls.toLocaleString()} URLs →\n   236→        </button>\n   237→      </div>\n   238→    </div>\n   239→  )\n   240→}\n   241→\n   242→function formatSourceName(source: string): string {\n   243→  const names: Record<string, string> = {\n   244→    reddit: 'Reddit',\n   245→    thematic_forum: 'Foros Temáticos',\n   246→    general_forum: 'Foros Generales',\n   247→  }\n   248→  return names[source] || source\n   249→}\n   250→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"3fea35a0-1ccb-4b94-a9a3-2992c7410a04","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/SerpResultsPanel.tsx","content":"'use client'\n\nimport { useState, useEffect } from 'react'\nimport { Check, ChevronDown, ChevronUp, ExternalLink, Loader2 } from 'lucide-react'\n\ninterface SourceGroup {\n  source_type: string\n  count: number\n  selected: boolean\n  sampleUrls: Array<{ id: string; url: string; title: string; life_context: string; product_word: string }>\n}\n\ninterface SerpResultsPanelProps {\n  jobId: string\n  onContinue: (selectedSources: string[]) => void\n  onBack: () => void\n}\n\nconst FIRECRAWL_COST_PER_URL = 0.001 // Approximate cost\n\nexport function SerpResultsPanel({ jobId, onContinue, onBack }: SerpResultsPanelProps) {\n  const [groups, setGroups] = useState<SourceGroup[]>([])\n  const [expandedSource, setExpandedSource] = useState<string | null>(null)\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n\n  // Fetch URL summary from API\n  useEffect(() => {\n    async function loadSummary() {\n      try {\n        setLoading(true)\n        const response = await fetch(`/api/niche-finder/jobs/${jobId}/urls/summary`)\n        if (!response.ok) {\n          throw new Error('Failed to load URL summary')\n        }\n        const data = await response.json()\n\n        // Initialize all sources as selected\n        setGroups(data.sources.map((s: Omit<SourceGroup, 'selected'>) => ({\n          ...s,\n          selected: true\n        })))\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Unknown error')\n      } finally {\n        setLoading(false)\n      }\n    }\n    loadSummary()\n  }, [jobId])\n\n  const totalUrls = groups.reduce((sum, g) => sum + g.count, 0)\n  const selectedUrls = groups.filter(g => g.selected).reduce((sum, g) => sum + g.count, 0)\n  const estimatedCost = selectedUrls * FIRECRAWL_COST_PER_URL\n\n  const toggleSource = (sourceType: string) => {\n    setGroups(gs => gs.map(g =>\n      g.source_type === sourceType\n        ? { ...g, selected: !g.selected }\n        : g\n    ))\n  }\n\n  const toggleExpand = (sourceType: string) => {\n    setExpandedSource(prev => prev === sourceType ? null : sourceType)\n  }\n\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center py-12\">\n        <Loader2 className=\"w-6 h-6 text-blue-600 animate-spin\" />\n        <span className=\"ml-3 text-gray-600\">Cargando resultados...</span>\n      </div>\n    )\n  }\n\n  if (error) {\n    return (\n      <div className=\"bg-red-50 border border-red-200 rounded-lg p-4\">\n        <p className=\"text-red-800\">{error}</p>\n        <button\n          onClick={() => window.location.reload()}\n          className=\"mt-2 text-sm text-red-600 underline\"\n        >\n          Reintentar\n        </button>\n      </div>\n    )\n  }\n\n  if (groups.length === 0) {\n    return (\n      <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-6 text-center\">\n        <p className=\"text-yellow-800 font-medium\">No se encontraron URLs</p>\n        <p className=\"text-yellow-700 text-sm mt-2\">\n          Las búsquedas no devolvieron resultados relevantes.\n          Intenta ajustar los contextos o palabras de búsqueda.\n        </p>\n        <button\n          onClick={onBack}\n          className=\"mt-4 px-4 py-2 bg-yellow-100 text-yellow-800 rounded-lg hover:bg-yellow-200 transition-colors\"\n        >\n          ← Volver a configurar\n        </button>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header */}\n      <div className=\"flex items-center gap-2 text-green-700\">\n        <Check className=\"w-5 h-5\" />\n        <span className=\"font-medium\">Búsqueda completada</span>\n      </div>\n\n      <p className=\"text-gray-600\">\n        Se encontraron <strong>{totalUrls.toLocaleString()} URLs</strong> únicas en {groups.length} fuentes\n      </p>\n\n      {/* Source groups */}\n      <div className=\"space-y-3\">\n        {groups.map(group => (\n          <div\n            key={group.source_type}\n            className={`border rounded-lg overflow-hidden transition-colors ${\n              group.selected ? 'border-blue-200 bg-blue-50/30' : 'border-gray-200 bg-gray-50/50'\n            }`}\n          >\n            {/* Header row */}\n            <div className=\"flex items-center justify-between p-4\">\n              <label className=\"flex items-center gap-3 cursor-pointer flex-1\">\n                <input\n                  type=\"checkbox\"\n                  checked={group.selected}\n                  onChange={() => toggleSource(group.source_type)}\n                  className=\"w-5 h-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500\"\n                />\n                <div>\n                  <span className=\"font-medium text-gray-900\">\n                    {formatSourceName(group.source_type)}\n                  </span>\n                  <span className=\"ml-2 text-gray-500\">\n                    ({group.count.toLocaleString()} URLs)\n                  </span>\n                </div>\n              </label>\n              <button\n                onClick={() => toggleExpand(group.source_type)}\n                className=\"flex items-center gap-1 text-sm text-blue-600 hover:text-blue-800 transition-colors\"\n              >\n                {expandedSource === group.source_type ? (\n                  <>\n                    <span>ocultar</span>\n                    <ChevronUp className=\"w-4 h-4\" />\n                  </>\n                ) : (\n                  <>\n                    <span>ver muestra</span>\n                    <ChevronDown className=\"w-4 h-4\" />\n                  </>\n                )}\n              </button>\n            </div>\n\n            {/* Expanded samples */}\n            {expandedSource === group.source_type && (\n              <div className=\"border-t border-gray-200 bg-white p-4 space-y-3\">\n                {group.sampleUrls.map((url, i) => (\n                  <div key={url.id || i} className=\"flex items-start gap-3\">\n                    <ExternalLink className=\"w-4 h-4 text-gray-400 mt-1 flex-shrink-0\" />\n                    <div className=\"min-w-0 flex-1\">\n                      <a\n                        href={url.url}\n                        target=\"_blank\"\n                        rel=\"noopener noreferrer\"\n                        className=\"text-blue-600 hover:underline text-sm font-medium block truncate\"\n                      >\n                        {url.title || url.url}\n                      </a>\n                      <p className=\"text-xs text-gray-500 mt-0.5 truncate\">\n                        {url.url}\n                      </p>\n                      <div className=\"flex gap-2 mt-1\">\n                        <span className=\"text-xs bg-gray-100 text-gray-600 px-2 py-0.5 rounded\">\n                          {url.life_context}\n                        </span>\n                        <span className=\"text-xs bg-gray-100 text-gray-600 px-2 py-0.5 rounded\">\n                          {url.product_word}\n                        </span>\n                      </div>\n                    </div>\n                  </div>\n                ))}\n                {group.count > group.sampleUrls.length && (\n                  <p className=\"text-xs text-gray-400 pt-2\">\n                    ...y {(group.count - group.sampleUrls.length).toLocaleString()} URLs más\n                  </p>\n                )}\n              </div>\n            )}\n          </div>\n        ))}\n      </div>\n\n      {/* Summary */}\n      <div className=\"bg-gray-50 rounded-lg p-4 space-y-2\">\n        <div className=\"flex justify-between text-sm\">\n          <span className=\"text-gray-600\">URLs seleccionadas</span>\n          <span className=\"font-medium\">{selectedUrls.toLocaleString()} de {totalUrls.toLocaleString()}</span>\n        </div>\n        <div className=\"flex justify-between text-sm\">\n          <span className=\"text-gray-600\">Costo estimado scraping</span>\n          <span className=\"font-medium\">~${estimatedCost.toFixed(2)} USD</span>\n        </div>\n      </div>\n\n      {/* Actions */}\n      <div className=\"flex gap-4 pt-2\">\n        <button\n          onClick={onBack}\n          className=\"px-4 py-2.5 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors\"\n        >\n          ← Volver\n        </button>\n        <button\n          onClick={() => onContinue(groups.filter(g => g.selected).map(g => g.source_type))}\n          disabled={selectedUrls === 0}\n          className={`flex-1 px-4 py-2.5 rounded-lg font-medium transition-colors ${\n            selectedUrls === 0\n              ? 'bg-gray-300 text-gray-500 cursor-not-allowed'\n              : 'bg-blue-600 text-white hover:bg-blue-700'\n          }`}\n        >\n          Continuar con {selectedUrls.toLocaleString()} URLs →\n        </button>\n      </div>\n    </div>\n  )\n}\n\nfunction formatSourceName(source: string): string {\n  const names: Record<string, string> = {\n    reddit: 'Reddit',\n    thematic_forum: 'Foros Temáticos',\n    general_forum: 'Foros Generales',\n  }\n  return names[source] || source\n}\n","numLines":250,"startLine":1,"totalLines":250}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GMMNdPXJmfkg3ZGezZxgWD","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useEffect, useCallback, useRef } from 'react'\n     4→import {\n     5→  Check,\n     6→  X,\n     7→  ChevronDown,\n     8→  ChevronUp,\n     9→  Loader2,\n    10→  AlertTriangle,\n    11→  RefreshCw,\n    12→  FileText,\n    13→  ExternalLink,\n    14→  HelpCircle,\n    15→  CheckSquare,\n    16→  Square,\n    17→  DollarSign,\n    18→} from 'lucide-react'\n    19→import MarkdownRenderer from '@/components/common/MarkdownRenderer'\n    20→\n    21→interface ScrapedUrl {\n    22→  id: string\n    23→  url: string\n    24→  title: string\n    25→  source_type: string\n    26→  status: 'scraped' | 'failed'\n    27→  content_markdown: string | null\n    28→  word_count: number\n    29→  error_message: string | null\n    30→  selected: boolean\n    31→  life_context?: string\n    32→  product_word?: string\n    33→}\n    34→\n    35→interface Summary {\n    36→  total: number\n    37→  scraped: number\n    38→  failed: number\n    39→  selected: number\n    40→  totalWords: number\n    41→  selectedWords: number\n    42→  estimatedCost: number\n    43→}\n    44→\n    45→interface ExtractionProgress {\n    46→  current: number\n    47→  total: number\n    48→  extracted: number\n    49→  filtered: number\n    50→  label?: string\n    51→}\n    52→\n    53→interface ScrapeResultsPanelProps {\n    54→  jobId: string\n    55→  onContinue: () => void\n    56→  onBack: () => void\n    57→  onExecuteExtraction?: () => Promise<void>\n    58→  isExtracting?: boolean\n    59→  extractionProgress?: ExtractionProgress\n    60→  onResetExtractionState?: () => void\n    61→}\n    62→\n    63→// Source type display names and colors\n    64→const SOURCE_LABELS: Record<string, { label: string; color: string }> = {\n    65→  reddit: { label: 'Reddit', color: 'bg-orange-100 text-orange-800' },\n    66→  forum: { label: 'Forum', color: 'bg-blue-100 text-blue-800' },\n    67→  quora: { label: 'Quora', color: 'bg-red-100 text-red-800' },\n    68→  general: { label: 'Web', color: 'bg-gray-100 text-gray-800' },\n    69→}\n    70→\n    71→export function ScrapeResultsPanel({\n    72→  jobId,\n    73→  onContinue,\n    74→  onBack,\n    75→  onExecuteExtraction,\n    76→  isExtracting = false,\n    77→  extractionProgress,\n    78→  onResetExtractionState,\n    79→}: ScrapeResultsPanelProps) {\n    80→  const [loading, setLoading] = useState(true)\n    81→  const [error, setError] = useState<string | null>(null)\n    82→  const [urls, setUrls] = useState<ScrapedUrl[]>([])\n    83→  const [failedUrls, setFailedUrls] = useState<ScrapedUrl[]>([])\n    84→  const [summary, setSummary] = useState<Summary | null>(null)\n    85→  const [expandedUrls, setExpandedUrls] = useState<Set<string>>(new Set())\n    86→  const [sourceFilter, setSourceFilter] = useState<string | null>(null)\n    87→  const [showConfirmModal, setShowConfirmModal] = useState(false)\n    88→  const [retrying, setRetrying] = useState(false)\n    89→  const [loadingMore, setLoadingMore] = useState(false)\n    90→  const [hasMore, setHasMore] = useState(false)\n    91→  const [offset, setOffset] = useState(0)\n    92→  const scrollContainerRef = useRef<HTMLDivElement>(null)\n    93→\n    94→  const LIMIT = 20\n    95→\n    96→  // Fetch URLs\n    97→  const fetchUrls = useCallback(async (newOffset = 0, append = false) => {\n    98→    try {\n    99→      if (newOffset === 0) {\n   100→        setLoading(true)\n   101→      } else {\n   102→        setLoadingMore(true)\n   103→      }\n   104→\n   105→      const response = await fetch(\n   106→        `/api/niche-finder/jobs/${jobId}/urls/scraped?limit=${LIMIT}&offset=${newOffset}`\n   107→      )\n   108→\n   109→      if (!response.ok) {\n   110→        throw new Error('Error al cargar URLs scrapeadas')\n   111→      }\n   112→\n   113→      const data = await response.json()\n   114→\n   115→      // Debug: Log response to see what we're getting\n   116→      console.log('[ScrapeResultsPanel] API response:', {\n   117→        urlsCount: data.urls?.length,\n   118→        failedCount: data.failedUrls?.length,\n   119→        summary: data.summary,\n   120→        pagination: data.pagination,\n   121→      })\n   122→\n   123→      if (append) {\n   124→        setUrls(prev => [...prev, ...data.urls])\n   125→      } else {\n   126→        setUrls(data.urls || [])\n   127→        setFailedUrls(data.failedUrls || [])\n   128→      }\n   129→\n   130→      setSummary(data.summary)\n   131→      setHasMore(data.pagination?.hasMore || false)\n   132→      setOffset(newOffset + (data.urls?.length || 0))\n   133→    } catch (err) {\n   134→      setError(err instanceof Error ? err.message : 'Error desconocido')\n   135→    } finally {\n   136→      setLoading(false)\n   137→      setLoadingMore(false)\n   138→    }\n   139→  }, [jobId])\n   140→\n   141→  useEffect(() => {\n   142→    fetchUrls(0, false)\n   143→  }, [fetchUrls])\n   144→\n   145→  // Reset stale extraction state if detected\n   146→  useEffect(() => {\n   147→    if (onResetExtractionState) {\n   148→      console.log('[ScrapeResultsPanel] Resetting stale extraction state')\n   149→      onResetExtractionState()\n   150→    }\n   151→  }, [onResetExtractionState])\n   152→\n   153→  // Scroll infinite loading\n   154→  const handleScroll = useCallback(() => {\n   155→    if (!scrollContainerRef.current || loadingMore || !hasMore) return\n   156→\n   157→    const { scrollTop, scrollHeight, clientHeight } = scrollContainerRef.current\n   158→    if (scrollTop + clientHeight >= scrollHeight - 100) {\n   159→      fetchUrls(offset, true)\n   160→    }\n   161→  }, [loadingMore, hasMore, offset, fetchUrls])\n   162→\n   163→  // Toggle URL selection\n   164→  const toggleSelection = async (urlId: string, selected: boolean) => {\n   165→    // Optimistic update\n   166→    setUrls(prev => prev.map(u => u.id === urlId ? { ...u, selected } : u))\n   167→\n   168→    try {\n   169→      await fetch(`/api/niche-finder/jobs/${jobId}/urls/selection`, {\n   170→        method: 'PATCH',\n   171→        headers: { 'Content-Type': 'application/json' },\n   172→        body: JSON.stringify({ urlIds: [urlId], selected }),\n   173→      })\n   174→\n   175→      // Refresh summary\n   176→      const response = await fetch(`/api/niche-finder/jobs/${jobId}/urls/scraped?limit=1`)\n   177→      const data = await response.json()\n   178→      setSummary(data.summary)\n   179→    } catch (err) {\n   180→      // Revert on error\n   181→      setUrls(prev => prev.map(u => u.id === urlId ? { ...u, selected: !selected } : u))\n   182→    }\n   183→  }\n   184→\n   185→  // Select/deselect all\n   186→  const toggleSelectAll = async (selectAll: boolean) => {\n   187→    // Optimistic update\n   188→    setUrls(prev => prev.map(u => ({ ...u, selected: selectAll })))\n   189→\n   190→    try {\n   191→      await fetch(`/api/niche-finder/jobs/${jobId}/urls/selection`, {\n   192→        method: 'PATCH',\n   193→        headers: { 'Content-Type': 'application/json' },\n   194→        body: JSON.stringify({ selectAll }),\n   195→      })\n   196→\n   197→      // Refresh summary\n   198→      const response = await fetch(`/api/niche-finder/jobs/${jobId}/urls/scraped?limit=1`)\n   199→      const data = await response.json()\n   200→      setSummary(data.summary)\n   201→    } catch (err) {\n   202→      // Revert on error\n   203→      setUrls(prev => prev.map(u => ({ ...u, selected: !selectAll })))\n   204→    }\n   205→  }\n   206→\n   207→  // Retry failed URLs\n   208→  const retryFailed = async () => {\n   209→    setRetrying(true)\n   210→    try {\n   211→      await fetch(`/api/niche-finder/jobs/${jobId}/urls/retry`, {\n   212→        method: 'POST',\n   213→        headers: { 'Content-Type': 'application/json' },\n   214→        body: JSON.stringify({}),\n   215→      })\n   216→\n   217→      // Refresh list\n   218→      await fetchUrls(0, false)\n   219→    } catch (err) {\n   220→      console.error('Error retrying:', err)\n   221→    } finally {\n   222→      setRetrying(false)\n   223→    }\n   224→  }\n   225→\n   226→  // Toggle URL expansion\n   227→  const toggleExpanded = (urlId: string) => {\n   228→    setExpandedUrls(prev => {\n   229→      const next = new Set(prev)\n   230→      if (next.has(urlId)) {\n   231→        next.delete(urlId)\n   232→      } else {\n   233→        next.add(urlId)\n   234→      }\n   235→      return next\n   236→    })\n   237→  }\n   238→\n   239→  // Get unique source types for filter\n   240→  const sourceTypes = [...new Set(urls.map(u => u.source_type))]\n   241→\n   242→  // Filter URLs by source\n   243→  const filteredUrls = sourceFilter\n   244→    ? urls.filter(u => u.source_type === sourceFilter)\n   245→    : urls\n   246→\n   247→  // Calculate selected count for display\n   248→  const selectedCount = summary?.selected || urls.filter(u => u.selected).length\n   249→  const allSelected = urls.length > 0 && urls.every(u => u.selected)\n   250→\n   251→  if (loading) {\n   252→    return (\n   253→      <div className=\"flex items-center justify-center py-12\">\n   254→        <Loader2 className=\"w-8 h-8 animate-spin text-blue-500\" />\n   255→        <span className=\"ml-3 text-gray-600\">Cargando resultados del scraping...</span>\n   256→      </div>\n   257→    )\n   258→  }\n   259→\n   260→  if (error) {\n   261→    return (\n   262→      <div className=\"p-6 bg-red-50 rounded-lg\">\n   263→        <div className=\"flex items-center gap-2 text-red-700\">\n   264→          <AlertTriangle className=\"w-5 h-5\" />\n   265→          <span>{error}</span>\n   266→        </div>\n   267→        <button\n   268→          onClick={onBack}\n   269→          className=\"mt-4 px-4 py-2 bg-gray-200 rounded hover:bg-gray-300\"\n   270→        >\n   271→          Volver\n   272→        </button>\n   273→      </div>\n   274→    )\n   275→  }\n   276→\n   277→  return (\n   278→    <div className=\"flex flex-col h-full\">\n   279→      {/* Stepper */}\n   280→      <div className=\"flex items-center justify-center gap-2 mb-6 text-sm\">\n   281→        <span className=\"px-3 py-1 bg-green-100 text-green-700 rounded-full\">\n   282→          Scraping\n   283→        </span>\n   284→        <span className=\"text-gray-400\">→</span>\n   285→        <span className=\"px-3 py-1 bg-blue-500 text-white rounded-full font-medium\">\n   286→          Revisar\n   287→        </span>\n   288→        <span className=\"text-gray-400\">→</span>\n   289→        <span className=\"px-3 py-1 bg-gray-100 text-gray-500 rounded-full\">\n   290→          Extraer\n   291→        </span>\n   292→      </div>\n   293→\n   294→      {/* Header with explanation */}\n   295→      <div className=\"mb-6 p-4 bg-blue-50 rounded-lg border border-blue-200\">\n   296→        <div className=\"flex items-start gap-3\">\n   297→          <FileText className=\"w-5 h-5 text-blue-600 mt-0.5\" />\n   298→          <div>\n   299→            <h3 className=\"font-medium text-blue-900\">Revisa el contenido scrapeado</h3>\n   300→            <p className=\"text-sm text-blue-700 mt-1\">\n   301→              Selecciona las URLs que quieres analizar. Las no seleccionadas se ignorarán\n   302→              en el paso de extracción.\n   303→            </p>\n   304→          </div>\n   305→          <button className=\"ml-auto text-blue-500 hover:text-blue-700\" title=\"Más información\">\n   306→            <HelpCircle className=\"w-5 h-5\" />\n   307→          </button>\n   308→        </div>\n   309→      </div>\n   310→\n   311→      {/* Stats */}\n   312→      <div className=\"flex gap-4 mb-4\">\n   313→        <div className=\"flex items-center gap-2 px-3 py-2 bg-green-50 rounded-lg\">\n   314→          <Check className=\"w-4 h-4 text-green-600\" />\n   315→          <span className=\"text-green-800 font-medium\">{summary?.scraped || 0}</span>\n   316→          <span className=\"text-green-600 text-sm\">scrapeadas</span>\n   317→        </div>\n   318→        {(summary?.failed || 0) > 0 && (\n   319→          <div className=\"flex items-center gap-2 px-3 py-2 bg-red-50 rounded-lg\">\n   320→            <X className=\"w-4 h-4 text-red-600\" />\n   321→            <span className=\"text-red-800 font-medium\">{summary?.failed || 0}</span>\n   322→            <span className=\"text-red-600 text-sm\">fallidas</span>\n   323→          </div>\n   324→        )}\n   325→        <div className=\"flex items-center gap-2 px-3 py-2 bg-gray-50 rounded-lg\">\n   326→          <FileText className=\"w-4 h-4 text-gray-600\" />\n   327→          <span className=\"text-gray-800 font-medium\">\n   328→            {(summary?.totalWords || 0).toLocaleString()}\n   329→          </span>\n   330→          <span className=\"text-gray-600 text-sm\">palabras</span>\n   331→        </div>\n   332→      </div>\n   333→\n   334→      {/* Source filters */}\n   335→      {sourceTypes.length > 1 && (\n   336→        <div className=\"flex gap-2 mb-4\">\n   337→          <button\n   338→            onClick={() => setSourceFilter(null)}\n   339→            className={`px-3 py-1 rounded-full text-sm transition ${\n   340→              !sourceFilter\n   341→                ? 'bg-gray-800 text-white'\n   342→                : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n   343→            }`}\n   344→          >\n   345→            Todas\n   346→          </button>\n   347→          {sourceTypes.map(source => {\n   348→            const { label, color } = SOURCE_LABELS[source] || { label: source, color: 'bg-gray-100 text-gray-800' }\n   349→            return (\n   350→              <button\n   351→                key={source}\n   352→                onClick={() => setSourceFilter(source)}\n   353→                className={`px-3 py-1 rounded-full text-sm transition ${\n   354→                  sourceFilter === source\n   355→                    ? 'bg-gray-800 text-white'\n   356→                    : `${color} hover:opacity-80`\n   357→                }`}\n   358→              >\n   359→                {label}\n   360→              </button>\n   361→            )\n   362→          })}\n   363→        </div>\n   364→      )}\n   365→\n   366→      {/* Select all */}\n   367→      <div className=\"flex items-center gap-2 mb-4 pb-4 border-b\">\n   368→        <button\n   369→          onClick={() => toggleSelectAll(!allSelected)}\n   370→          className=\"flex items-center gap-2 text-sm text-gray-600 hover:text-gray-900\"\n   371→        >\n   372→          {allSelected ? (\n   373→            <CheckSquare className=\"w-4 h-4 text-blue-600\" />\n   374→          ) : (\n   375→            <Square className=\"w-4 h-4\" />\n   376→          )}\n   377→          <span>{allSelected ? 'Deseleccionar todas' : 'Seleccionar todas'}</span>\n   378→        </button>\n   379→        <span className=\"text-gray-400 text-sm ml-auto\">\n   380→          {selectedCount} de {summary?.scraped || 0} seleccionadas\n   381→        </span>\n   382→      </div>\n   383→\n   384→      {/* URL list with scroll */}\n   385→      <div\n   386→        ref={scrollContainerRef}\n   387→        onScroll={handleScroll}\n   388→        className=\"overflow-y-auto space-y-3 border rounded-lg p-2 bg-gray-50\"\n   389→        style={{ maxHeight: '400px', minHeight: '150px' }}\n   390→      >\n   391→        {/* Debug info for development */}\n   392→        {process.env.NODE_ENV === 'development' && (\n   393→          <div className=\"text-xs text-gray-400 mb-2\">\n   394→            Debug: {filteredUrls.length} URLs cargadas, filter: {sourceFilter || 'ninguno'}\n   395→          </div>\n   396→        )}\n   397→\n   398→        {/* Empty state */}\n   399→        {filteredUrls.length === 0 && !loading && (\n   400→          <div className=\"text-center py-8 text-gray-500\">\n   401→            <FileText className=\"w-8 h-8 mx-auto mb-2 text-gray-300\" />\n   402→            <p>No hay URLs para mostrar.</p>\n   403→            <p className=\"text-sm mt-1\">Verifica que el scraping se completó correctamente.</p>\n   404→          </div>\n   405→        )}\n   406→\n   407→        {filteredUrls.map(url => (\n   408→          <div\n   409→            key={url.id}\n   410→            className={`border rounded-lg transition ${\n   411→              url.selected ? 'border-blue-200 bg-white' : 'border-gray-200 bg-gray-50 opacity-60'\n   412→            }`}\n   413→          >\n   414→            {/* URL header */}\n   415→            <div className=\"flex items-center gap-3 p-3\">\n   416→              <button\n   417→                onClick={() => toggleSelection(url.id, !url.selected)}\n   418→                className=\"flex-shrink-0\"\n   419→              >\n   420→                {url.selected ? (\n   421→                  <CheckSquare className=\"w-5 h-5 text-blue-600\" />\n   422→                ) : (\n   423→                  <Square className=\"w-5 h-5 text-gray-400\" />\n   424→                )}\n   425→              </button>\n   426→\n   427→              <span className={`px-2 py-0.5 rounded text-xs font-medium ${\n   428→                SOURCE_LABELS[url.source_type]?.color || 'bg-gray-100 text-gray-800'\n   429→              }`}>\n   430→                {SOURCE_LABELS[url.source_type]?.label || url.source_type}\n   431→              </span>\n   432→\n   433→              <div className=\"flex-1 min-w-0\">\n   434→                <h4 className=\"font-medium text-gray-900 truncate\">\n   435→                  {url.title || url.url}\n   436→                </h4>\n   437→                <p className=\"text-xs text-gray-500 truncate\">{url.url}</p>\n   438→              </div>\n   439→\n   440→              <span className=\"text-xs text-gray-500 flex-shrink-0\">\n   441→                {url.word_count.toLocaleString()} palabras\n   442→              </span>\n   443→\n   444→              <a\n   445→                href={url.url}\n   446→                target=\"_blank\"\n   447→                rel=\"noopener noreferrer\"\n   448→                className=\"text-gray-400 hover:text-blue-600 flex-shrink-0\"\n   449→                onClick={e => e.stopPropagation()}\n   450→              >\n   451→                <ExternalLink className=\"w-4 h-4\" />\n   452→              </a>\n   453→\n   454→              <button\n   455→                onClick={() => toggleExpanded(url.id)}\n   456→                className=\"text-gray-400 hover:text-gray-600 flex-shrink-0\"\n   457→              >\n   458→                {expandedUrls.has(url.id) ? (\n   459→                  <ChevronUp className=\"w-5 h-5\" />\n   460→                ) : (\n   461→                  <ChevronDown className=\"w-5 h-5\" />\n   462→                )}\n   463→              </button>\n   464→            </div>\n   465→\n   466→            {/* Expanded content */}\n   467→            {expandedUrls.has(url.id) && url.content_markdown && (\n   468→              <div className=\"border-t p-4 bg-gray-50\">\n   469→                <div className=\"max-h-[500px] overflow-y-auto prose prose-sm max-w-none\">\n   470→                  <MarkdownRenderer content={url.content_markdown} />\n   471→                </div>\n   472→              </div>\n   473→            )}\n   474→          </div>\n   475→        ))}\n   476→\n   477→        {loadingMore && (\n   478→          <div className=\"flex items-center justify-center py-4\">\n   479→            <Loader2 className=\"w-5 h-5 animate-spin text-gray-400\" />\n   480→          </div>\n   481→        )}\n   482→      </div>\n   483→\n   484→      {/* Failed URLs section */}\n   485→      {failedUrls.length > 0 && (\n   486→        <div className=\"mt-6 p-4 bg-red-50 rounded-lg border border-red-200\">\n   487→          <div className=\"flex items-center justify-between mb-3\">\n   488→            <div className=\"flex items-center gap-2\">\n   489→              <AlertTriangle className=\"w-5 h-5 text-red-600\" />\n   490→              <h3 className=\"font-medium text-red-900\">\n   491→                URLs Fallidas ({failedUrls.length})\n   492→              </h3>\n   493→            </div>\n   494→            <button\n   495→              onClick={retryFailed}\n   496→              disabled={retrying}\n   497→              className=\"flex items-center gap-2 px-3 py-1.5 bg-red-100 text-red-700 rounded hover:bg-red-200 disabled:opacity-50\"\n   498→            >\n   499→              {retrying ? (\n   500→                <Loader2 className=\"w-4 h-4 animate-spin\" />\n   501→              ) : (\n   502→                <RefreshCw className=\"w-4 h-4\" />\n   503→              )}\n   504→              <span>Reintentar</span>\n   505→            </button>\n   506→          </div>\n   507→          <div className=\"space-y-2 max-h-[150px] overflow-y-auto\">\n   508→            {failedUrls.map(url => (\n   509→              <div key={url.id} className=\"flex items-center gap-2 text-sm\">\n   510→                <X className=\"w-4 h-4 text-red-500 flex-shrink-0\" />\n   511→                <span className=\"text-gray-700 truncate\">{url.url}</span>\n   512→                <span className=\"text-red-600 text-xs flex-shrink-0\">\n   513→                  {url.error_message || 'Error desconocido'}\n   514→                </span>\n   515→              </div>\n   516→            ))}\n   517→          </div>\n   518→        </div>\n   519→      )}\n   520→\n   521→      {/* Summary section */}\n   522→      <div className=\"mt-6 p-4 bg-gray-50 rounded-lg border\">\n   523→        <h3 className=\"font-medium text-gray-900 mb-3\">Resumen</h3>\n   524→        <div className=\"space-y-2 text-sm text-gray-600\">\n   525→          <p>• {selectedCount} URLs seleccionadas de {summary?.scraped || 0}</p>\n   526→          <p>• ~{(summary?.selectedWords || 0).toLocaleString()} palabras a procesar</p>\n   527→          <div className=\"flex items-center gap-1\">\n   528→            <DollarSign className=\"w-4 h-4\" />\n   529→            <span>Costo estimado: ~${summary?.estimatedCost?.toFixed(2) || '0.00'}</span>\n   530→          </div>\n   531→        </div>\n   532→\n   533→        <div className=\"mt-4 p-3 bg-blue-50 rounded border border-blue-100\">\n   534→          <p className=\"text-sm text-blue-800\">\n   535→            <strong>Siguiente paso:</strong> Se analizará cada URL buscando problemas,\n   536→            frustraciones y necesidades. El LLM filtrará conversaciones no relacionadas\n   537→            con tu propuesta de valor y extraerá los pain points relevantes.\n   538→          </p>\n   539→        </div>\n   540→      </div>\n   541→\n   542→      {/* Extraction progress */}\n   543→      {isExtracting && extractionProgress && (\n   544→        <div className=\"mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200\">\n   545→          <div className=\"flex items-center gap-3 mb-3\">\n   546→            <Loader2 className=\"w-5 h-5 text-blue-600 animate-spin\" />\n   547→            <span className=\"font-medium text-blue-800\">Extrayendo problemas...</span>\n   548→          </div>\n   549→          <div className=\"space-y-2\">\n   550→            <div className=\"flex justify-between text-sm text-blue-700\">\n   551→              <span>{extractionProgress.label || 'Procesando URLs...'}</span>\n   552→              <span>{extractionProgress.current}/{extractionProgress.total}</span>\n   553→            </div>\n   554→            <div className=\"w-full bg-blue-200 rounded-full h-2\">\n   555→              <div\n   556→                className=\"bg-blue-600 h-2 rounded-full transition-all duration-300\"\n   557→                style={{\n   558→                  width: extractionProgress.total > 0\n   559→                    ? `${(extractionProgress.current / extractionProgress.total) * 100}%`\n   560→                    : '0%'\n   561→                }}\n   562→              />\n   563→            </div>\n   564→            <div className=\"flex gap-4 text-xs text-blue-600 mt-2\">\n   565→              <span>✓ {extractionProgress.extracted} problemas encontrados</span>\n   566→              <span>⊘ {extractionProgress.filtered} URLs filtradas</span>\n   567→            </div>\n   568→          </div>\n   569→        </div>\n   570→      )}\n   571→\n   572→      {/* Action buttons */}\n   573→      <div className=\"flex justify-between mt-6 pt-4 border-t\">\n   574→        <button\n   575→          onClick={onBack}\n   576→          disabled={isExtracting}\n   577→          className=\"px-4 py-2 text-gray-600 hover:text-gray-900 disabled:opacity-50\"\n   578→        >\n   579→          ← Atrás\n   580→        </button>\n   581→        <button\n   582→          onClick={() => setShowConfirmModal(true)}\n   583→          disabled={selectedCount === 0 || isExtracting}\n   584→          className=\"px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2\"\n   585→        >\n   586→          {isExtracting ? (\n   587→            <>\n   588→              <Loader2 className=\"w-4 h-4 animate-spin\" />\n   589→              Extrayendo...\n   590→            </>\n   591→          ) : (\n   592→            <>Extraer de {selectedCount} URLs (~${summary?.estimatedCost?.toFixed(2) || '0.00'}) →</>\n   593→          )}\n   594→        </button>\n   595→      </div>\n   596→\n   597→      {/* Confirmation Modal */}\n   598→      {showConfirmModal && (\n   599→        <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center z-50\">\n   600→          <div className=\"bg-white rounded-lg shadow-xl max-w-md w-full mx-4 p-6\">\n   601→            <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">\n   602→              Confirmar Extracción\n   603→            </h3>\n   604→            <p className=\"text-gray-600 mb-4\">\n   605→              Vas a analizar {selectedCount} URLs buscando pain points y problemas\n   606→              relevantes para tu propuesta de valor.\n   607→            </p>\n   608→            <div className=\"space-y-2 mb-6 text-sm text-gray-600 bg-gray-50 p-3 rounded\">\n   609→              <p>• URLs a procesar: <strong>{selectedCount}</strong></p>\n   610→              <p>• URLs excluidas: <strong>{(summary?.scraped || 0) - selectedCount}</strong></p>\n   611→              <p>• Costo estimado: <strong>~${summary?.estimatedCost?.toFixed(2) || '0.00'}</strong></p>\n   612→            </div>\n   613→            <p className=\"text-sm text-amber-600 mb-6\">\n   614→              Este proceso puede tomar varios minutos dependiendo de la cantidad de URLs.\n   615→            </p>\n   616→            <div className=\"flex justify-end gap-3\">\n   617→              <button\n   618→                onClick={() => setShowConfirmModal(false)}\n   619→                className=\"px-4 py-2 text-gray-600 hover:bg-gray-100 rounded\"\n   620→              >\n   621→                Cancelar\n   622→              </button>\n   623→              <button\n   624→                onClick={() => {\n   625→                  setShowConfirmModal(false)\n   626→                  if (onExecuteExtraction) {\n   627→                    onExecuteExtraction()\n   628→                  } else {\n   629→                    // Fallback to old behavior if no extraction handler\n   630→                    onContinue()\n   631→                  }\n   632→                }}\n   633→                className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\"\n   634→              >\n   635→                Confirmar y Extraer\n   636→              </button>\n   637→            </div>\n   638→          </div>\n   639→        </div>\n   640→      )}\n   641→    </div>\n   642→  )\n   643→}\n   644→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"5dbbe372-b452-467c-a6c1-e213aab2e635","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ScrapeResultsPanel.tsx","content":"'use client'\n\nimport { useState, useEffect, useCallback, useRef } from 'react'\nimport {\n  Check,\n  X,\n  ChevronDown,\n  ChevronUp,\n  Loader2,\n  AlertTriangle,\n  RefreshCw,\n  FileText,\n  ExternalLink,\n  HelpCircle,\n  CheckSquare,\n  Square,\n  DollarSign,\n} from 'lucide-react'\nimport MarkdownRenderer from '@/components/common/MarkdownRenderer'\n\ninterface ScrapedUrl {\n  id: string\n  url: string\n  title: string\n  source_type: string\n  status: 'scraped' | 'failed'\n  content_markdown: string | null\n  word_count: number\n  error_message: string | null\n  selected: boolean\n  life_context?: string\n  product_word?: string\n}\n\ninterface Summary {\n  total: number\n  scraped: number\n  failed: number\n  selected: number\n  totalWords: number\n  selectedWords: number\n  estimatedCost: number\n}\n\ninterface ExtractionProgress {\n  current: number\n  total: number\n  extracted: number\n  filtered: number\n  label?: string\n}\n\ninterface ScrapeResultsPanelProps {\n  jobId: string\n  onContinue: () => void\n  onBack: () => void\n  onExecuteExtraction?: () => Promise<void>\n  isExtracting?: boolean\n  extractionProgress?: ExtractionProgress\n  onResetExtractionState?: () => void\n}\n\n// Source type display names and colors\nconst SOURCE_LABELS: Record<string, { label: string; color: string }> = {\n  reddit: { label: 'Reddit', color: 'bg-orange-100 text-orange-800' },\n  forum: { label: 'Forum', color: 'bg-blue-100 text-blue-800' },\n  quora: { label: 'Quora', color: 'bg-red-100 text-red-800' },\n  general: { label: 'Web', color: 'bg-gray-100 text-gray-800' },\n}\n\nexport function ScrapeResultsPanel({\n  jobId,\n  onContinue,\n  onBack,\n  onExecuteExtraction,\n  isExtracting = false,\n  extractionProgress,\n  onResetExtractionState,\n}: ScrapeResultsPanelProps) {\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n  const [urls, setUrls] = useState<ScrapedUrl[]>([])\n  const [failedUrls, setFailedUrls] = useState<ScrapedUrl[]>([])\n  const [summary, setSummary] = useState<Summary | null>(null)\n  const [expandedUrls, setExpandedUrls] = useState<Set<string>>(new Set())\n  const [sourceFilter, setSourceFilter] = useState<string | null>(null)\n  const [showConfirmModal, setShowConfirmModal] = useState(false)\n  const [retrying, setRetrying] = useState(false)\n  const [loadingMore, setLoadingMore] = useState(false)\n  const [hasMore, setHasMore] = useState(false)\n  const [offset, setOffset] = useState(0)\n  const scrollContainerRef = useRef<HTMLDivElement>(null)\n\n  const LIMIT = 20\n\n  // Fetch URLs\n  const fetchUrls = useCallback(async (newOffset = 0, append = false) => {\n    try {\n      if (newOffset === 0) {\n        setLoading(true)\n      } else {\n        setLoadingMore(true)\n      }\n\n      const response = await fetch(\n        `/api/niche-finder/jobs/${jobId}/urls/scraped?limit=${LIMIT}&offset=${newOffset}`\n      )\n\n      if (!response.ok) {\n        throw new Error('Error al cargar URLs scrapeadas')\n      }\n\n      const data = await response.json()\n\n      // Debug: Log response to see what we're getting\n      console.log('[ScrapeResultsPanel] API response:', {\n        urlsCount: data.urls?.length,\n        failedCount: data.failedUrls?.length,\n        summary: data.summary,\n        pagination: data.pagination,\n      })\n\n      if (append) {\n        setUrls(prev => [...prev, ...data.urls])\n      } else {\n        setUrls(data.urls || [])\n        setFailedUrls(data.failedUrls || [])\n      }\n\n      setSummary(data.summary)\n      setHasMore(data.pagination?.hasMore || false)\n      setOffset(newOffset + (data.urls?.length || 0))\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Error desconocido')\n    } finally {\n      setLoading(false)\n      setLoadingMore(false)\n    }\n  }, [jobId])\n\n  useEffect(() => {\n    fetchUrls(0, false)\n  }, [fetchUrls])\n\n  // Reset stale extraction state if detected\n  useEffect(() => {\n    if (onResetExtractionState) {\n      console.log('[ScrapeResultsPanel] Resetting stale extraction state')\n      onResetExtractionState()\n    }\n  }, [onResetExtractionState])\n\n  // Scroll infinite loading\n  const handleScroll = useCallback(() => {\n    if (!scrollContainerRef.current || loadingMore || !hasMore) return\n\n    const { scrollTop, scrollHeight, clientHeight } = scrollContainerRef.current\n    if (scrollTop + clientHeight >= scrollHeight - 100) {\n      fetchUrls(offset, true)\n    }\n  }, [loadingMore, hasMore, offset, fetchUrls])\n\n  // Toggle URL selection\n  const toggleSelection = async (urlId: string, selected: boolean) => {\n    // Optimistic update\n    setUrls(prev => prev.map(u => u.id === urlId ? { ...u, selected } : u))\n\n    try {\n      await fetch(`/api/niche-finder/jobs/${jobId}/urls/selection`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ urlIds: [urlId], selected }),\n      })\n\n      // Refresh summary\n      const response = await fetch(`/api/niche-finder/jobs/${jobId}/urls/scraped?limit=1`)\n      const data = await response.json()\n      setSummary(data.summary)\n    } catch (err) {\n      // Revert on error\n      setUrls(prev => prev.map(u => u.id === urlId ? { ...u, selected: !selected } : u))\n    }\n  }\n\n  // Select/deselect all\n  const toggleSelectAll = async (selectAll: boolean) => {\n    // Optimistic update\n    setUrls(prev => prev.map(u => ({ ...u, selected: selectAll })))\n\n    try {\n      await fetch(`/api/niche-finder/jobs/${jobId}/urls/selection`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ selectAll }),\n      })\n\n      // Refresh summary\n      const response = await fetch(`/api/niche-finder/jobs/${jobId}/urls/scraped?limit=1`)\n      const data = await response.json()\n      setSummary(data.summary)\n    } catch (err) {\n      // Revert on error\n      setUrls(prev => prev.map(u => ({ ...u, selected: !selectAll })))\n    }\n  }\n\n  // Retry failed URLs\n  const retryFailed = async () => {\n    setRetrying(true)\n    try {\n      await fetch(`/api/niche-finder/jobs/${jobId}/urls/retry`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({}),\n      })\n\n      // Refresh list\n      await fetchUrls(0, false)\n    } catch (err) {\n      console.error('Error retrying:', err)\n    } finally {\n      setRetrying(false)\n    }\n  }\n\n  // Toggle URL expansion\n  const toggleExpanded = (urlId: string) => {\n    setExpandedUrls(prev => {\n      const next = new Set(prev)\n      if (next.has(urlId)) {\n        next.delete(urlId)\n      } else {\n        next.add(urlId)\n      }\n      return next\n    })\n  }\n\n  // Get unique source types for filter\n  const sourceTypes = [...new Set(urls.map(u => u.source_type))]\n\n  // Filter URLs by source\n  const filteredUrls = sourceFilter\n    ? urls.filter(u => u.source_type === sourceFilter)\n    : urls\n\n  // Calculate selected count for display\n  const selectedCount = summary?.selected || urls.filter(u => u.selected).length\n  const allSelected = urls.length > 0 && urls.every(u => u.selected)\n\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center py-12\">\n        <Loader2 className=\"w-8 h-8 animate-spin text-blue-500\" />\n        <span className=\"ml-3 text-gray-600\">Cargando resultados del scraping...</span>\n      </div>\n    )\n  }\n\n  if (error) {\n    return (\n      <div className=\"p-6 bg-red-50 rounded-lg\">\n        <div className=\"flex items-center gap-2 text-red-700\">\n          <AlertTriangle className=\"w-5 h-5\" />\n          <span>{error}</span>\n        </div>\n        <button\n          onClick={onBack}\n          className=\"mt-4 px-4 py-2 bg-gray-200 rounded hover:bg-gray-300\"\n        >\n          Volver\n        </button>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* Stepper */}\n      <div className=\"flex items-center justify-center gap-2 mb-6 text-sm\">\n        <span className=\"px-3 py-1 bg-green-100 text-green-700 rounded-full\">\n          Scraping\n        </span>\n        <span className=\"text-gray-400\">→</span>\n        <span className=\"px-3 py-1 bg-blue-500 text-white rounded-full font-medium\">\n          Revisar\n        </span>\n        <span className=\"text-gray-400\">→</span>\n        <span className=\"px-3 py-1 bg-gray-100 text-gray-500 rounded-full\">\n          Extraer\n        </span>\n      </div>\n\n      {/* Header with explanation */}\n      <div className=\"mb-6 p-4 bg-blue-50 rounded-lg border border-blue-200\">\n        <div className=\"flex items-start gap-3\">\n          <FileText className=\"w-5 h-5 text-blue-600 mt-0.5\" />\n          <div>\n            <h3 className=\"font-medium text-blue-900\">Revisa el contenido scrapeado</h3>\n            <p className=\"text-sm text-blue-700 mt-1\">\n              Selecciona las URLs que quieres analizar. Las no seleccionadas se ignorarán\n              en el paso de extracción.\n            </p>\n          </div>\n          <button className=\"ml-auto text-blue-500 hover:text-blue-700\" title=\"Más información\">\n            <HelpCircle className=\"w-5 h-5\" />\n          </button>\n        </div>\n      </div>\n\n      {/* Stats */}\n      <div className=\"flex gap-4 mb-4\">\n        <div className=\"flex items-center gap-2 px-3 py-2 bg-green-50 rounded-lg\">\n          <Check className=\"w-4 h-4 text-green-600\" />\n          <span className=\"text-green-800 font-medium\">{summary?.scraped || 0}</span>\n          <span className=\"text-green-600 text-sm\">scrapeadas</span>\n        </div>\n        {(summary?.failed || 0) > 0 && (\n          <div className=\"flex items-center gap-2 px-3 py-2 bg-red-50 rounded-lg\">\n            <X className=\"w-4 h-4 text-red-600\" />\n            <span className=\"text-red-800 font-medium\">{summary?.failed || 0}</span>\n            <span className=\"text-red-600 text-sm\">fallidas</span>\n          </div>\n        )}\n        <div className=\"flex items-center gap-2 px-3 py-2 bg-gray-50 rounded-lg\">\n          <FileText className=\"w-4 h-4 text-gray-600\" />\n          <span className=\"text-gray-800 font-medium\">\n            {(summary?.totalWords || 0).toLocaleString()}\n          </span>\n          <span className=\"text-gray-600 text-sm\">palabras</span>\n        </div>\n      </div>\n\n      {/* Source filters */}\n      {sourceTypes.length > 1 && (\n        <div className=\"flex gap-2 mb-4\">\n          <button\n            onClick={() => setSourceFilter(null)}\n            className={`px-3 py-1 rounded-full text-sm transition ${\n              !sourceFilter\n                ? 'bg-gray-800 text-white'\n                : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n            }`}\n          >\n            Todas\n          </button>\n          {sourceTypes.map(source => {\n            const { label, color } = SOURCE_LABELS[source] || { label: source, color: 'bg-gray-100 text-gray-800' }\n            return (\n              <button\n                key={source}\n                onClick={() => setSourceFilter(source)}\n                className={`px-3 py-1 rounded-full text-sm transition ${\n                  sourceFilter === source\n                    ? 'bg-gray-800 text-white'\n                    : `${color} hover:opacity-80`\n                }`}\n              >\n                {label}\n              </button>\n            )\n          })}\n        </div>\n      )}\n\n      {/* Select all */}\n      <div className=\"flex items-center gap-2 mb-4 pb-4 border-b\">\n        <button\n          onClick={() => toggleSelectAll(!allSelected)}\n          className=\"flex items-center gap-2 text-sm text-gray-600 hover:text-gray-900\"\n        >\n          {allSelected ? (\n            <CheckSquare className=\"w-4 h-4 text-blue-600\" />\n          ) : (\n            <Square className=\"w-4 h-4\" />\n          )}\n          <span>{allSelected ? 'Deseleccionar todas' : 'Seleccionar todas'}</span>\n        </button>\n        <span className=\"text-gray-400 text-sm ml-auto\">\n          {selectedCount} de {summary?.scraped || 0} seleccionadas\n        </span>\n      </div>\n\n      {/* URL list with scroll */}\n      <div\n        ref={scrollContainerRef}\n        onScroll={handleScroll}\n        className=\"overflow-y-auto space-y-3 border rounded-lg p-2 bg-gray-50\"\n        style={{ maxHeight: '400px', minHeight: '150px' }}\n      >\n        {/* Debug info for development */}\n        {process.env.NODE_ENV === 'development' && (\n          <div className=\"text-xs text-gray-400 mb-2\">\n            Debug: {filteredUrls.length} URLs cargadas, filter: {sourceFilter || 'ninguno'}\n          </div>\n        )}\n\n        {/* Empty state */}\n        {filteredUrls.length === 0 && !loading && (\n          <div className=\"text-center py-8 text-gray-500\">\n            <FileText className=\"w-8 h-8 mx-auto mb-2 text-gray-300\" />\n            <p>No hay URLs para mostrar.</p>\n            <p className=\"text-sm mt-1\">Verifica que el scraping se completó correctamente.</p>\n          </div>\n        )}\n\n        {filteredUrls.map(url => (\n          <div\n            key={url.id}\n            className={`border rounded-lg transition ${\n              url.selected ? 'border-blue-200 bg-white' : 'border-gray-200 bg-gray-50 opacity-60'\n            }`}\n          >\n            {/* URL header */}\n            <div className=\"flex items-center gap-3 p-3\">\n              <button\n                onClick={() => toggleSelection(url.id, !url.selected)}\n                className=\"flex-shrink-0\"\n              >\n                {url.selected ? (\n                  <CheckSquare className=\"w-5 h-5 text-blue-600\" />\n                ) : (\n                  <Square className=\"w-5 h-5 text-gray-400\" />\n                )}\n              </button>\n\n              <span className={`px-2 py-0.5 rounded text-xs font-medium ${\n                SOURCE_LABELS[url.source_type]?.color || 'bg-gray-100 text-gray-800'\n              }`}>\n                {SOURCE_LABELS[url.source_type]?.label || url.source_type}\n              </span>\n\n              <div className=\"flex-1 min-w-0\">\n                <h4 className=\"font-medium text-gray-900 truncate\">\n                  {url.title || url.url}\n                </h4>\n                <p className=\"text-xs text-gray-500 truncate\">{url.url}</p>\n              </div>\n\n              <span className=\"text-xs text-gray-500 flex-shrink-0\">\n                {url.word_count.toLocaleString()} palabras\n              </span>\n\n              <a\n                href={url.url}\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n                className=\"text-gray-400 hover:text-blue-600 flex-shrink-0\"\n                onClick={e => e.stopPropagation()}\n              >\n                <ExternalLink className=\"w-4 h-4\" />\n              </a>\n\n              <button\n                onClick={() => toggleExpanded(url.id)}\n                className=\"text-gray-400 hover:text-gray-600 flex-shrink-0\"\n              >\n                {expandedUrls.has(url.id) ? (\n                  <ChevronUp className=\"w-5 h-5\" />\n                ) : (\n                  <ChevronDown className=\"w-5 h-5\" />\n                )}\n              </button>\n            </div>\n\n            {/* Expanded content */}\n            {expandedUrls.has(url.id) && url.content_markdown && (\n              <div className=\"border-t p-4 bg-gray-50\">\n                <div className=\"max-h-[500px] overflow-y-auto prose prose-sm max-w-none\">\n                  <MarkdownRenderer content={url.content_markdown} />\n                </div>\n              </div>\n            )}\n          </div>\n        ))}\n\n        {loadingMore && (\n          <div className=\"flex items-center justify-center py-4\">\n            <Loader2 className=\"w-5 h-5 animate-spin text-gray-400\" />\n          </div>\n        )}\n      </div>\n\n      {/* Failed URLs section */}\n      {failedUrls.length > 0 && (\n        <div className=\"mt-6 p-4 bg-red-50 rounded-lg border border-red-200\">\n          <div className=\"flex items-center justify-between mb-3\">\n            <div className=\"flex items-center gap-2\">\n              <AlertTriangle className=\"w-5 h-5 text-red-600\" />\n              <h3 className=\"font-medium text-red-900\">\n                URLs Fallidas ({failedUrls.length})\n              </h3>\n            </div>\n            <button\n              onClick={retryFailed}\n              disabled={retrying}\n              className=\"flex items-center gap-2 px-3 py-1.5 bg-red-100 text-red-700 rounded hover:bg-red-200 disabled:opacity-50\"\n            >\n              {retrying ? (\n                <Loader2 className=\"w-4 h-4 animate-spin\" />\n              ) : (\n                <RefreshCw className=\"w-4 h-4\" />\n              )}\n              <span>Reintentar</span>\n            </button>\n          </div>\n          <div className=\"space-y-2 max-h-[150px] overflow-y-auto\">\n            {failedUrls.map(url => (\n              <div key={url.id} className=\"flex items-center gap-2 text-sm\">\n                <X className=\"w-4 h-4 text-red-500 flex-shrink-0\" />\n                <span className=\"text-gray-700 truncate\">{url.url}</span>\n                <span className=\"text-red-600 text-xs flex-shrink-0\">\n                  {url.error_message || 'Error desconocido'}\n                </span>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Summary section */}\n      <div className=\"mt-6 p-4 bg-gray-50 rounded-lg border\">\n        <h3 className=\"font-medium text-gray-900 mb-3\">Resumen</h3>\n        <div className=\"space-y-2 text-sm text-gray-600\">\n          <p>• {selectedCount} URLs seleccionadas de {summary?.scraped || 0}</p>\n          <p>• ~{(summary?.selectedWords || 0).toLocaleString()} palabras a procesar</p>\n          <div className=\"flex items-center gap-1\">\n            <DollarSign className=\"w-4 h-4\" />\n            <span>Costo estimado: ~${summary?.estimatedCost?.toFixed(2) || '0.00'}</span>\n          </div>\n        </div>\n\n        <div className=\"mt-4 p-3 bg-blue-50 rounded border border-blue-100\">\n          <p className=\"text-sm text-blue-800\">\n            <strong>Siguiente paso:</strong> Se analizará cada URL buscando problemas,\n            frustraciones y necesidades. El LLM filtrará conversaciones no relacionadas\n            con tu propuesta de valor y extraerá los pain points relevantes.\n          </p>\n        </div>\n      </div>\n\n      {/* Extraction progress */}\n      {isExtracting && extractionProgress && (\n        <div className=\"mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200\">\n          <div className=\"flex items-center gap-3 mb-3\">\n            <Loader2 className=\"w-5 h-5 text-blue-600 animate-spin\" />\n            <span className=\"font-medium text-blue-800\">Extrayendo problemas...</span>\n          </div>\n          <div className=\"space-y-2\">\n            <div className=\"flex justify-between text-sm text-blue-700\">\n              <span>{extractionProgress.label || 'Procesando URLs...'}</span>\n              <span>{extractionProgress.current}/{extractionProgress.total}</span>\n            </div>\n            <div className=\"w-full bg-blue-200 rounded-full h-2\">\n              <div\n                className=\"bg-blue-600 h-2 rounded-full transition-all duration-300\"\n                style={{\n                  width: extractionProgress.total > 0\n                    ? `${(extractionProgress.current / extractionProgress.total) * 100}%`\n                    : '0%'\n                }}\n              />\n            </div>\n            <div className=\"flex gap-4 text-xs text-blue-600 mt-2\">\n              <span>✓ {extractionProgress.extracted} problemas encontrados</span>\n              <span>⊘ {extractionProgress.filtered} URLs filtradas</span>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Action buttons */}\n      <div className=\"flex justify-between mt-6 pt-4 border-t\">\n        <button\n          onClick={onBack}\n          disabled={isExtracting}\n          className=\"px-4 py-2 text-gray-600 hover:text-gray-900 disabled:opacity-50\"\n        >\n          ← Atrás\n        </button>\n        <button\n          onClick={() => setShowConfirmModal(true)}\n          disabled={selectedCount === 0 || isExtracting}\n          className=\"px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2\"\n        >\n          {isExtracting ? (\n            <>\n              <Loader2 className=\"w-4 h-4 animate-spin\" />\n              Extrayendo...\n            </>\n          ) : (\n            <>Extraer de {selectedCount} URLs (~${summary?.estimatedCost?.toFixed(2) || '0.00'}) →</>\n          )}\n        </button>\n      </div>\n\n      {/* Confirmation Modal */}\n      {showConfirmModal && (\n        <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center z-50\">\n          <div className=\"bg-white rounded-lg shadow-xl max-w-md w-full mx-4 p-6\">\n            <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">\n              Confirmar Extracción\n            </h3>\n            <p className=\"text-gray-600 mb-4\">\n              Vas a analizar {selectedCount} URLs buscando pain points y problemas\n              relevantes para tu propuesta de valor.\n            </p>\n            <div className=\"space-y-2 mb-6 text-sm text-gray-600 bg-gray-50 p-3 rounded\">\n              <p>• URLs a procesar: <strong>{selectedCount}</strong></p>\n              <p>• URLs excluidas: <strong>{(summary?.scraped || 0) - selectedCount}</strong></p>\n              <p>• Costo estimado: <strong>~${summary?.estimatedCost?.toFixed(2) || '0.00'}</strong></p>\n            </div>\n            <p className=\"text-sm text-amber-600 mb-6\">\n              Este proceso puede tomar varios minutos dependiendo de la cantidad de URLs.\n            </p>\n            <div className=\"flex justify-end gap-3\">\n              <button\n                onClick={() => setShowConfirmModal(false)}\n                className=\"px-4 py-2 text-gray-600 hover:bg-gray-100 rounded\"\n              >\n                Cancelar\n              </button>\n              <button\n                onClick={() => {\n                  setShowConfirmModal(false)\n                  if (onExecuteExtraction) {\n                    onExecuteExtraction()\n                  } else {\n                    // Fallback to old behavior if no extraction handler\n                    onContinue()\n                  }\n                }}\n                className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\"\n              >\n                Confirmar y Extraer\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n","numLines":644,"startLine":1,"totalLines":644}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014LiLJhn4CxCMMZbJDHU5aq","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the PlaybookShell and WorkArea to understand how to integrate the Artifact Browser tab."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":20253,"cache_read_input_tokens":63090,"cache_creation":{"ephemeral_5m_input_tokens":20253,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"27cfc71d-779f-43bd-8581-3aa54eba7c35"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014LiLJhn4CxCMMZbJDHU5aq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015LMzdZmrnxXMGE162z76eo","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":20253,"cache_read_input_tokens":63090,"cache_creation":{"ephemeral_5m_input_tokens":20253,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"a0f84bf6-dc4a-4c78-89ef-f1e44512a1e6"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014LiLJhn4CxCMMZbJDHU5aq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ktc5q5XNZZQyw8jj9kdpet","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/WorkArea.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":20253,"cache_read_input_tokens":63090,"cache_creation":{"ephemeral_5m_input_tokens":20253,"ephemeral_1h_input_tokens":0},"output_tokens":181,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"e34bd168-6418-4fe0-b6cf-62dafb07c495"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (31841 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_015LMzdZmrnxXMGE162z76eo"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"04cec9b1-d473-4245-b2ff-4992a509d60f","tool_use_result":"Error: File content (31841 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (30402 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01Ktc5q5XNZZQyw8jj9kdpet"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"e94a5013-4d96-4c79-af5b-338c845356e1","tool_use_result":"Error: File content (30402 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018H7iA71jPp6YCLhnfNZ6sr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UoKeyoUVnuENzto7NB3Qgo","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","limit":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":326,"cache_read_input_tokens":83343,"cache_creation":{"ephemeral_5m_input_tokens":326,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"bf2b9922-35b2-4b5b-a462-f6eb37c65c7b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018H7iA71jPp6YCLhnfNZ6sr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011bLu6V3kJSV6TmNGCQg2B4","name":"Grep","input":{"pattern":"Session Data|SessionData|artifact|Artifact","path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":326,"cache_read_input_tokens":83343,"cache_creation":{"ephemeral_5m_input_tokens":326,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"9c84ed38-947e-4bb6-8090-9c8c90e9b7b0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UoKeyoUVnuENzto7NB3Qgo","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useCallback, useEffect, useRef } from 'react'\n     4→import {\n     5→  PlaybookShellProps,\n     6→  PlaybookState,\n     7→  PhaseState,\n     8→  StepState,\n     9→  StepDefinition,\n    10→  PhaseDefinition,\n    11→} from './types'\n    12→import NavigationPanel from './NavigationPanel'\n    13→import { WorkArea } from './WorkArea'\n    14→import ConfigurationMode from './ConfigurationMode'\n    15→import CampaignWizard from './CampaignWizard'\n    16→import CampaignSettings from './CampaignSettings'\n    17→import { Settings, ChevronDown, Plus, Folder, Pencil, Trash2 } from 'lucide-react'\n    18→import { useStepPersistence } from '@/hooks/useStepPersistence'\n    19→import { useStepRetry } from '@/hooks/useStepRetry'\n    20→import { StepAttemptConfig, StepRetryInfo } from './types'\n    21→import StepRetryDialog from './StepRetryDialog'\n    22→import FailedStepActions from './FailedStepActions'\n    23→\n    24→// Mode types for the unified view\n    25→type PlaybookMode = 'config' | 'campaign'\n    26→\n    27→interface Campaign {\n    28→  id: string\n    29→  name: string\n    30→  status: 'draft' | 'in_progress' | 'completed'\n    31→  completedSteps: number\n    32→  totalSteps: number\n    33→  customVariables?: Record<string, unknown> // Includes context_type, product, target, etc.\n    34→  playbookState?: PlaybookState // Saved playbook state for persistence\n    35→}\n    36→\n    37→function initializeState(\n    38→  projectId: string,\n    39→  playbookConfig: PlaybookShellProps['playbookConfig'],\n    40→  initialState?: Partial<PlaybookState>\n    41→): PlaybookState {\n    42→  const phases: PhaseState[] = playbookConfig.phases.map(phase => ({\n    43→    id: phase.id,\n    44→    status: 'pending',\n    45→    steps: phase.steps.map(step => ({\n    46→      id: step.id,\n    47→      status: 'pending',\n    48→    })),\n    49→  }))\n    50→\n    51→  // Apply initial state if provided - match by ID for robustness when config changes\n    52→  if (initialState?.phases) {\n    53→    initialState.phases.forEach((savedPhaseState) => {\n    54→      // Find phase by ID instead of index\n    55→      const phaseIndex = phases.findIndex(p => p.id === savedPhaseState.id)\n    56→      if (phaseIndex === -1) return\n    57→\n    58→      phases[phaseIndex].status = savedPhaseState.status\n    59→      savedPhaseState.steps.forEach((savedStepState) => {\n    60→        // Find step by ID instead of index\n    61→        const stepIndex = phases[phaseIndex].steps.findIndex(s => s.id === savedStepState.id)\n    62→        if (stepIndex === -1) return\n    63→\n    64→        phases[phaseIndex].steps[stepIndex] = {\n    65→          ...phases[phaseIndex].steps[stepIndex],\n    66→          ...savedStepState,\n    67→        }\n    68→      })\n    69→    })\n    70→  }\n    71→\n    72→  const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n    73→  const completedSteps = phases.reduce(\n    74→    (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n    75→    0\n    76→  )\n    77→\n    78→  // Validate currentPhaseIndex and currentStepIndex are within bounds\n    79→  let currentPhaseIndex = initialState?.currentPhaseIndex ?? 0\n    80→  let currentStepIndex = initialState?.currentStepIndex ?? 0\n    81→\n    82→  // Ensure phase index is valid\n    83→  if (currentPhaseIndex >= playbookConfig.phases.length) {\n    84→    currentPhaseIndex = Math.max(0, playbookConfig.phases.length - 1)\n    85→  }\n    86→\n    87→  // Ensure step index is valid for the current phase\n    88→  const currentPhaseSteps = playbookConfig.phases[currentPhaseIndex]?.steps.length ?? 0\n    89→  if (currentStepIndex >= currentPhaseSteps) {\n    90→    currentStepIndex = Math.max(0, currentPhaseSteps - 1)\n    91→  }\n    92→\n    93→  // If the current step doesn't exist, find the first non-completed step\n    94→  if (currentPhaseSteps === 0 || currentStepIndex < 0) {\n    95→    // Find first pending step\n    96→    for (let pi = 0; pi < phases.length; pi++) {\n    97→      for (let si = 0; si < phases[pi].steps.length; si++) {\n    98→        if (phases[pi].steps[si].status !== 'completed') {\n    99→          currentPhaseIndex = pi\n   100→          currentStepIndex = si\n   101→          break\n   102→        }\n   103→      }\n   104→      if (currentStepIndex >= 0) break\n   105→    }\n   106→    // Default to first step if all completed\n   107→    if (currentStepIndex < 0) {\n   108→      currentPhaseIndex = 0\n   109→      currentStepIndex = 0\n   110→    }\n   111→  }\n   112→\n   113→  console.log('[initializeState] Validated indices:', {\n   114→    originalPhase: initialState?.currentPhaseIndex,\n   115→    originalStep: initialState?.currentStepIndex,\n   116→    validatedPhase: currentPhaseIndex,\n   117→    validatedStep: currentStepIndex,\n   118→    maxPhases: playbookConfig.phases.length,\n   119→    maxSteps: currentPhaseSteps,\n   120→  })\n   121→\n   122→  return {\n   123→    projectId,\n   124→    playbookType: playbookConfig.type,\n   125→    phases,\n   126→    currentPhaseIndex,\n   127→    currentStepIndex,\n   128→    config: initialState?.config ?? {},\n   129→    completedSteps,\n   130→    totalSteps,\n   131→    startedAt: initialState?.startedAt,\n   132→    completedAt: initialState?.completedAt,\n   133→  }\n   134→}\n   135→\n   136→export default function PlaybookShell({\n   137→  projectId,\n   138→  playbookConfig,\n   139→  initialState,\n   140→  sessionId,\n   141→}: PlaybookShellProps) {\n   142→  const [state, setState] = useState<PlaybookState>(() =>\n   143→    initializeState(projectId, playbookConfig, initialState)\n   144→  )\n   145→\n   146→  // Step persistence hook for auto-saving step data to database\n   147→  const [stepPersistenceState, stepPersistenceActions] = useStepPersistence({\n   148→    sessionId: sessionId || null,\n   149→    autoSaveInterval: 30000, // Auto-save every 30 seconds\n   150→    enabled: !!sessionId, // Only enable if sessionId is provided\n   151→  })\n   152→\n   153→  // Step retry hook for managing retry attempts\n   154→  const [stepRetryState, stepRetryActions] = useStepRetry(sessionId || null, {\n   155→    enabled: !!sessionId,\n   156→  })\n   157→\n   158→  // State for retry dialog\n   159→  const [retryDialogOpen, setRetryDialogOpen] = useState(false)\n   160→  const [retryDialogStepId, setRetryDialogStepId] = useState<string | null>(null)\n   161→\n   162→  // Flag to distinguish between intentional navigation (Continue button)\n   163→  // vs manual navigation (clicking on a step)\n   164→  const [shouldAutoExecute, setShouldAutoExecute] = useState(false)\n   165→\n   166→  // Mode: 'config' for editing base prompts, 'campaign' for execution\n   167→  const [mode, setMode] = useState<PlaybookMode>('campaign')\n   168→  const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null)\n   169→  const [campaigns, setCampaigns] = useState<Campaign[]>([])\n   170→  const [showCampaignDropdown, setShowCampaignDropdown] = useState(false)\n   171→  const [showWizard, setShowWizard] = useState(false)\n   172→  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n   173→\n   174→  // Load campaigns from database\n   175→  const loadCampaigns = useCallback(async () => {\n   176→    try {\n   177→      const response = await fetch(`/api/campaign/create?projectId=${projectId}`)\n   178→      if (!response.ok) {\n   179→        console.error('Failed to load campaigns')\n   180→        return\n   181→      }\n   182→      const data = await response.json()\n   183→      if (data.campaigns) {\n   184→        const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n   185→        const mappedCampaigns: Campaign[] = data.campaigns.map((c: any) => ({\n   186→          id: c.id,\n   187→          name: c.ecp_name,\n   188→          status: c.status || 'draft',\n   189→          // Calculate completed steps from playbook_state if available\n   190→          completedSteps: c.playbook_state?.completedSteps ?? 0,\n   191→          totalSteps,\n   192→          customVariables: c.custom_variables || {}, // Load campaign variables including context_type\n   193→          playbookState: c.playbook_state || null, // Load saved playbook state\n   194→        }))\n   195→        setCampaigns(mappedCampaigns)\n   196→      }\n   197→    } catch (error) {\n   198→      console.error('Error loading campaigns:', error)\n   199→    }\n   200→  }, [projectId, playbookConfig.phases])\n   201→\n   202→  useEffect(() => {\n   203→    loadCampaigns()\n   204→  }, [loadCampaigns])\n   205→\n   206→  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)\n   207→\n   208→  // Ref to track if we should save (avoid saving on initial load)\n   209→  const shouldSaveRef = useRef(false)\n   210→  // Ref to prevent duplicate saves\n   211→  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n   212→  // Ref to store polling interval for cancellation\n   213→  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)\n   214→\n   215→  // Save playbook state to database (debounced)\n   216→  const savePlaybookState = useCallback(async (stateToSave: PlaybookState) => {\n   217→    if (!selectedCampaignId) return\n   218→\n   219→    try {\n   220→      await fetch(`/api/campaign/${selectedCampaignId}`, {\n   221→        method: 'PATCH',\n   222→        headers: { 'Content-Type': 'application/json' },\n   223→        body: JSON.stringify({ playbook_state: stateToSave }),\n   224→      })\n   225→    } catch (error) {\n   226→      console.error('Error saving playbook state:', error)\n   227→    }\n   228→  }, [selectedCampaignId])\n   229→\n   230→  // Auto-save state when it changes (debounced)\n   231→  useEffect(() => {\n   232→    if (!shouldSaveRef.current || !selectedCampaignId) return\n   233→\n   234→    // Clear any pending save\n   235→    if (saveTimeoutRef.current) {\n   236→      clearTimeout(saveTimeoutRef.current)\n   237→    }\n   238→\n   239→    // Debounce saves by 500ms to avoid too many API calls\n   240→    saveTimeoutRef.current = setTimeout(() => {\n   241→      savePlaybookState(state)\n   242→    }, 500)\n   243→\n   244→    return () => {\n   245→      if (saveTimeoutRef.current) {\n   246→        clearTimeout(saveTimeoutRef.current)\n   247→      }\n   248→    }\n   249→  }, [state, selectedCampaignId, savePlaybookState])\n   250→\n   251→  // Load saved state when selecting a campaign\n   252→  useEffect(() => {\n   253→    if (!selectedCampaignId) {\n   254→      shouldSaveRef.current = false\n   255→      return\n   256→    }\n   257→\n   258→    const campaign = campaigns.find(c => c.id === selectedCampaignId)\n   259→    if (campaign?.playbookState) {\n   260→      // Load saved state\n   261→      shouldSaveRef.current = false // Don't save while loading\n   262→      setState(initializeState(projectId, playbookConfig, campaign.playbookState))\n   263→      // Enable saving after a short delay\n   264→      setTimeout(() => {\n   265→        shouldSaveRef.current = true\n   266→      }, 100)\n   267→    } else {\n   268→      // Fresh state for new campaign\n   269→      shouldSaveRef.current = false\n   270→      setState(initializeState(projectId, playbookConfig))\n   271→      setTimeout(() => {\n   272→        shouldSaveRef.current = true\n   273→      }, 100)\n   274→    }\n   275→  }, [selectedCampaignId, campaigns, projectId, playbookConfig])\n   276→\n   277→  // Load step data from database on session resume (if sessionId is provided)\n   278→  useEffect(() => {\n   279→    if (!sessionId) return\n   280→\n   281→    const loadStepData = async () => {\n   282→      try {\n   283→        const savedSteps = await stepPersistenceActions.loadAllSteps()\n   284→        if (Object.keys(savedSteps).length === 0) return\n   285→\n   286→        console.log('[PlaybookShell] Loaded step data from session:', Object.keys(savedSteps))\n   287→\n   288→        // Merge saved step data into current state\n   289→        setState(prev => {\n   290→          const newPhases = prev.phases.map(phase => ({\n   291→            ...phase,\n   292→            steps: phase.steps.map(step => {\n   293→              const savedStep = savedSteps[step.id]\n   294→              if (savedStep) {\n   295→                return {\n   296→                  ...step,\n   297→                  ...savedStep,\n   298→                }\n   299→              }\n   300→              return step\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"5be6da06-2ba4-490f-81c5-9da61817d5af","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","content":"'use client'\n\nimport { useState, useCallback, useEffect, useRef } from 'react'\nimport {\n  PlaybookShellProps,\n  PlaybookState,\n  PhaseState,\n  StepState,\n  StepDefinition,\n  PhaseDefinition,\n} from './types'\nimport NavigationPanel from './NavigationPanel'\nimport { WorkArea } from './WorkArea'\nimport ConfigurationMode from './ConfigurationMode'\nimport CampaignWizard from './CampaignWizard'\nimport CampaignSettings from './CampaignSettings'\nimport { Settings, ChevronDown, Plus, Folder, Pencil, Trash2 } from 'lucide-react'\nimport { useStepPersistence } from '@/hooks/useStepPersistence'\nimport { useStepRetry } from '@/hooks/useStepRetry'\nimport { StepAttemptConfig, StepRetryInfo } from './types'\nimport StepRetryDialog from './StepRetryDialog'\nimport FailedStepActions from './FailedStepActions'\n\n// Mode types for the unified view\ntype PlaybookMode = 'config' | 'campaign'\n\ninterface Campaign {\n  id: string\n  name: string\n  status: 'draft' | 'in_progress' | 'completed'\n  completedSteps: number\n  totalSteps: number\n  customVariables?: Record<string, unknown> // Includes context_type, product, target, etc.\n  playbookState?: PlaybookState // Saved playbook state for persistence\n}\n\nfunction initializeState(\n  projectId: string,\n  playbookConfig: PlaybookShellProps['playbookConfig'],\n  initialState?: Partial<PlaybookState>\n): PlaybookState {\n  const phases: PhaseState[] = playbookConfig.phases.map(phase => ({\n    id: phase.id,\n    status: 'pending',\n    steps: phase.steps.map(step => ({\n      id: step.id,\n      status: 'pending',\n    })),\n  }))\n\n  // Apply initial state if provided - match by ID for robustness when config changes\n  if (initialState?.phases) {\n    initialState.phases.forEach((savedPhaseState) => {\n      // Find phase by ID instead of index\n      const phaseIndex = phases.findIndex(p => p.id === savedPhaseState.id)\n      if (phaseIndex === -1) return\n\n      phases[phaseIndex].status = savedPhaseState.status\n      savedPhaseState.steps.forEach((savedStepState) => {\n        // Find step by ID instead of index\n        const stepIndex = phases[phaseIndex].steps.findIndex(s => s.id === savedStepState.id)\n        if (stepIndex === -1) return\n\n        phases[phaseIndex].steps[stepIndex] = {\n          ...phases[phaseIndex].steps[stepIndex],\n          ...savedStepState,\n        }\n      })\n    })\n  }\n\n  const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n  const completedSteps = phases.reduce(\n    (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n    0\n  )\n\n  // Validate currentPhaseIndex and currentStepIndex are within bounds\n  let currentPhaseIndex = initialState?.currentPhaseIndex ?? 0\n  let currentStepIndex = initialState?.currentStepIndex ?? 0\n\n  // Ensure phase index is valid\n  if (currentPhaseIndex >= playbookConfig.phases.length) {\n    currentPhaseIndex = Math.max(0, playbookConfig.phases.length - 1)\n  }\n\n  // Ensure step index is valid for the current phase\n  const currentPhaseSteps = playbookConfig.phases[currentPhaseIndex]?.steps.length ?? 0\n  if (currentStepIndex >= currentPhaseSteps) {\n    currentStepIndex = Math.max(0, currentPhaseSteps - 1)\n  }\n\n  // If the current step doesn't exist, find the first non-completed step\n  if (currentPhaseSteps === 0 || currentStepIndex < 0) {\n    // Find first pending step\n    for (let pi = 0; pi < phases.length; pi++) {\n      for (let si = 0; si < phases[pi].steps.length; si++) {\n        if (phases[pi].steps[si].status !== 'completed') {\n          currentPhaseIndex = pi\n          currentStepIndex = si\n          break\n        }\n      }\n      if (currentStepIndex >= 0) break\n    }\n    // Default to first step if all completed\n    if (currentStepIndex < 0) {\n      currentPhaseIndex = 0\n      currentStepIndex = 0\n    }\n  }\n\n  console.log('[initializeState] Validated indices:', {\n    originalPhase: initialState?.currentPhaseIndex,\n    originalStep: initialState?.currentStepIndex,\n    validatedPhase: currentPhaseIndex,\n    validatedStep: currentStepIndex,\n    maxPhases: playbookConfig.phases.length,\n    maxSteps: currentPhaseSteps,\n  })\n\n  return {\n    projectId,\n    playbookType: playbookConfig.type,\n    phases,\n    currentPhaseIndex,\n    currentStepIndex,\n    config: initialState?.config ?? {},\n    completedSteps,\n    totalSteps,\n    startedAt: initialState?.startedAt,\n    completedAt: initialState?.completedAt,\n  }\n}\n\nexport default function PlaybookShell({\n  projectId,\n  playbookConfig,\n  initialState,\n  sessionId,\n}: PlaybookShellProps) {\n  const [state, setState] = useState<PlaybookState>(() =>\n    initializeState(projectId, playbookConfig, initialState)\n  )\n\n  // Step persistence hook for auto-saving step data to database\n  const [stepPersistenceState, stepPersistenceActions] = useStepPersistence({\n    sessionId: sessionId || null,\n    autoSaveInterval: 30000, // Auto-save every 30 seconds\n    enabled: !!sessionId, // Only enable if sessionId is provided\n  })\n\n  // Step retry hook for managing retry attempts\n  const [stepRetryState, stepRetryActions] = useStepRetry(sessionId || null, {\n    enabled: !!sessionId,\n  })\n\n  // State for retry dialog\n  const [retryDialogOpen, setRetryDialogOpen] = useState(false)\n  const [retryDialogStepId, setRetryDialogStepId] = useState<string | null>(null)\n\n  // Flag to distinguish between intentional navigation (Continue button)\n  // vs manual navigation (clicking on a step)\n  const [shouldAutoExecute, setShouldAutoExecute] = useState(false)\n\n  // Mode: 'config' for editing base prompts, 'campaign' for execution\n  const [mode, setMode] = useState<PlaybookMode>('campaign')\n  const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null)\n  const [campaigns, setCampaigns] = useState<Campaign[]>([])\n  const [showCampaignDropdown, setShowCampaignDropdown] = useState(false)\n  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n\n  // Load campaigns from database\n  const loadCampaigns = useCallback(async () => {\n    try {\n      const response = await fetch(`/api/campaign/create?projectId=${projectId}`)\n      if (!response.ok) {\n        console.error('Failed to load campaigns')\n        return\n      }\n      const data = await response.json()\n      if (data.campaigns) {\n        const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n        const mappedCampaigns: Campaign[] = data.campaigns.map((c: any) => ({\n          id: c.id,\n          name: c.ecp_name,\n          status: c.status || 'draft',\n          // Calculate completed steps from playbook_state if available\n          completedSteps: c.playbook_state?.completedSteps ?? 0,\n          totalSteps,\n          customVariables: c.custom_variables || {}, // Load campaign variables including context_type\n          playbookState: c.playbook_state || null, // Load saved playbook state\n        }))\n        setCampaigns(mappedCampaigns)\n      }\n    } catch (error) {\n      console.error('Error loading campaigns:', error)\n    }\n  }, [projectId, playbookConfig.phases])\n\n  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)\n\n  // Ref to track if we should save (avoid saving on initial load)\n  const shouldSaveRef = useRef(false)\n  // Ref to prevent duplicate saves\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  // Ref to store polling interval for cancellation\n  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Save playbook state to database (debounced)\n  const savePlaybookState = useCallback(async (stateToSave: PlaybookState) => {\n    if (!selectedCampaignId) return\n\n    try {\n      await fetch(`/api/campaign/${selectedCampaignId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ playbook_state: stateToSave }),\n      })\n    } catch (error) {\n      console.error('Error saving playbook state:', error)\n    }\n  }, [selectedCampaignId])\n\n  // Auto-save state when it changes (debounced)\n  useEffect(() => {\n    if (!shouldSaveRef.current || !selectedCampaignId) return\n\n    // Clear any pending save\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current)\n    }\n\n    // Debounce saves by 500ms to avoid too many API calls\n    saveTimeoutRef.current = setTimeout(() => {\n      savePlaybookState(state)\n    }, 500)\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n      }\n    }\n  }, [state, selectedCampaignId, savePlaybookState])\n\n  // Load saved state when selecting a campaign\n  useEffect(() => {\n    if (!selectedCampaignId) {\n      shouldSaveRef.current = false\n      return\n    }\n\n    const campaign = campaigns.find(c => c.id === selectedCampaignId)\n    if (campaign?.playbookState) {\n      // Load saved state\n      shouldSaveRef.current = false // Don't save while loading\n      setState(initializeState(projectId, playbookConfig, campaign.playbookState))\n      // Enable saving after a short delay\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    } else {\n      // Fresh state for new campaign\n      shouldSaveRef.current = false\n      setState(initializeState(projectId, playbookConfig))\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    }\n  }, [selectedCampaignId, campaigns, projectId, playbookConfig])\n\n  // Load step data from database on session resume (if sessionId is provided)\n  useEffect(() => {\n    if (!sessionId) return\n\n    const loadStepData = async () => {\n      try {\n        const savedSteps = await stepPersistenceActions.loadAllSteps()\n        if (Object.keys(savedSteps).length === 0) return\n\n        console.log('[PlaybookShell] Loaded step data from session:', Object.keys(savedSteps))\n\n        // Merge saved step data into current state\n        setState(prev => {\n          const newPhases = prev.phases.map(phase => ({\n            ...phase,\n            steps: phase.steps.map(step => {\n              const savedStep = savedSteps[step.id]\n              if (savedStep) {\n                return {\n                  ...step,\n                  ...savedStep,\n                }\n              }\n              return step","numLines":300,"startLine":1,"totalLines":2850}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011bLu6V3kJSV6TmNGCQg2B4","type":"tool_result","content":"src/components/playbook/SessionHistoryPanel.tsx:91:  const loadSessionData = useCallback(async () => {\nsrc/components/playbook/SessionHistoryPanel.tsx:114:    loadSessionData()\nsrc/components/playbook/SessionHistoryPanel.tsx:115:  }, [loadSessionData])\nsrc/components/playbook/SessionHistoryPanel.tsx:165:          onClick={loadSessionData}"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"1ac4b981-2e36-4a7a-b5d4-84996fdccec9","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"src/components/playbook/SessionHistoryPanel.tsx:91:  const loadSessionData = useCallback(async () => {\nsrc/components/playbook/SessionHistoryPanel.tsx:114:    loadSessionData()\nsrc/components/playbook/SessionHistoryPanel.tsx:115:  }, [loadSessionData])\nsrc/components/playbook/SessionHistoryPanel.tsx:165:          onClick={loadSessionData}","numLines":4}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018j2qSSHSAVAVZe4rrsq7Mc","type":"message","role":"assistant","content":[{"type":"text","text":"Let me check what types and interfaces are used in the playbook system and how the session stores artifacts."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4528,"cache_read_input_tokens":83669,"cache_creation":{"ephemeral_5m_input_tokens":4528,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"6d6a10fb-77ab-4e7d-8d7d-140f7923a16d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018j2qSSHSAVAVZe4rrsq7Mc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AX5c2qbMMBeGSrbQPnaoJC","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/types.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4528,"cache_read_input_tokens":83669,"cache_creation":{"ephemeral_5m_input_tokens":4528,"ephemeral_1h_input_tokens":0},"output_tokens":106,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"a75e9d8c-1acc-422c-9492-06e340a11282"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AX5c2qbMMBeGSrbQPnaoJC","type":"tool_result","content":"     1→// Types for the unified playbook architecture with dual panel layout\n     2→\n     3→export type StepStatus = 'pending' | 'in_progress' | 'completed' | 'skipped' | 'error'\n     4→export type PhaseStatus = 'pending' | 'in_progress' | 'completed' | 'error'\n     5→\n     6→/**\n     7→ * Step types determine how the WorkArea renders and behaves:\n     8→ * - input: User must enter data (minimize these)\n     9→ * - suggestion: System suggests, user selects/edits\n    10→ * - auto: Executes without stopping\n    11→ * - auto_with_preview: Shows preview before continuing\n    12→ * - auto_with_review: Executes and shows result for optional review\n    13→ * - decision: User must make a decision (pause here)\n    14→ * - display: Only shows information\n    15→ * - action: User performs an action (e.g., export)\n    16→ * - manual_research: User performs manual research with external tools (e.g., ChatGPT/Perplexity)\n    17→ * - manual_review: User must review and approve before continuing (e.g., preview queries before SERP)\n    18→ * - search_with_preview: Shows search config preview with ability to adjust, then executes search\n    19→ * - review_with_action: Shows results for review/selection, then executes action on selected items\n    20→ */\n    21→export type StepType =\n    22→  | 'input'\n    23→  | 'suggestion'\n    24→  | 'auto'\n    25→  | 'auto_with_preview'\n    26→  | 'auto_with_review'\n    27→  | 'decision'\n    28→  | 'display'\n    29→  | 'display_scrape_results'\n    30→  | 'extract_with_preview' // Shows scraped URLs + extraction button + results table\n    31→  | 'action'\n    32→  | 'manual_research'\n    33→  | 'manual_review'\n    34→  | 'search_with_preview'\n    35→  | 'review_with_action'\n    36→  | 'unified_keyword_config' // Unified panel for keywords, indicators, and sources\n    37→  | 'unified_search_extract' // All-in-one: SERP → show URLs → scrape → extract\n    38→\n    39→/**\n    40→ * Executor type determines how the step is executed:\n    41→ * - llm: Uses /api/playbook/execute-step with LLM\n    42→ * - job: Uses background job system (like Niche Finder scraping)\n    43→ * - api: Calls a specific API endpoint\n    44→ * - custom: Custom logic defined in the playbook\n    45→ * - none: No execution needed (display/input steps)\n    46→ */\n    47→export type ExecutorType = 'llm' | 'job' | 'api' | 'custom' | 'none'\n    48→\n    49→export interface StepDefinition {\n    50→  id: string\n    51→  name: string\n    52→  description?: string\n    53→  type: StepType\n    54→  executor: ExecutorType\n    55→\n    56→  // Required API keys - will show setup modal if not configured\n    57→  // e.g., ['blotato', 'wavespeed'] or ['serper', 'firecrawl']\n    58→  requiredApiKeys?: string[]\n    59→\n    60→  // For LLM executor\n    61→  promptKey?: string\n    62→\n    63→  // For job executor\n    64→  jobType?: string\n    65→\n    66→  // For API executor\n    67→  apiEndpoint?: string\n    68→\n    69→  // Dependencies\n    70→  dependsOn?: string[]\n    71→\n    72→  // For suggestion type\n    73→  suggestionConfig?: {\n    74→    generateFrom: 'project' | 'previous_step' | 'api' | 'llm' | 'fixed'\n    75→    apiEndpoint?: string\n    76→    fixedOptionsKey?: string // For 'fixed' - key to identify which lists to load\n    77→    allowAdd?: boolean\n    78→    allowEdit?: boolean\n    79→    minSelections?: number\n    80→    maxSelections?: number\n    81→  }\n    82→\n    83→  // For decision type\n    84→  decisionConfig?: {\n    85→    question: string\n    86→    optionsFrom: 'previous_step' | 'api' | 'fixed'\n    87→    fixedOptions?: Array<{ id: string; label: string; description?: string }>\n    88→    multiSelect?: boolean\n    89→    minSelections?: number\n    90→    maxSelections?: number\n    91→    defaultSelection?: string | string[]\n    92→  }\n    93→\n    94→  // For action type\n    95→  actionConfig?: {\n    96→    label: string\n    97→    actionType: 'export' | 'save' | 'navigate' | 'custom'\n    98→    customHandler?: string\n    99→  }\n   100→\n   101→  // Explanation shown before executing auto steps\n   102→  // Helps user understand what the step will do\n   103→  executionExplanation?: {\n   104→    title: string\n   105→    steps: string[] // List of what the step will do\n   106→    estimatedTime?: string\n   107→    estimatedCost?: string\n   108→    costService?: string // e.g., \"Serper API\", \"Firecrawl\"\n   109→  }\n   110→\n   111→  // Guidance configuration for the step container\n   112→  // Provides clear instructions to users about what the step does and what they need to do\n   113→  guidance?: StepGuidance\n   114→}\n   115→\n   116→/**\n   117→ * Step guidance configuration\n   118→ * Displayed in the PlaybookStepContainer to help users understand:\n   119→ * - What this step does (description)\n   120→ * - What actions they need to take (userActions)\n   121→ * - What conditions must be met to proceed (completionCriteria)\n   122→ */\n   123→export interface StepGuidance {\n   124→  /** Brief description of what this step accomplishes */\n   125→  description: string\n   126→  /** List of actions the user needs to take in this step */\n   127→  userActions: string[]\n   128→  /**\n   129→   * Completion criteria - defines when the \"Next\" button should be enabled\n   130→   * Can be a simple description or structured criteria\n   131→   */\n   132→  completionCriteria: StepCompletionCriteria\n   133→}\n   134→\n   135→/**\n   136→ * Defines completion criteria for a step\n   137→ */\n   138→export interface StepCompletionCriteria {\n   139→  /** Human-readable description of what needs to be done */\n   140→  description: string\n   141→  /** Type of validation to perform */\n   142→  type: 'manual' | 'input_required' | 'selection_required' | 'auto_complete' | 'custom'\n   143→  /** Minimum number of items/characters required (for input_required or selection_required) */\n   144→  minCount?: number\n   145→  /** Custom validation function name (for custom type) */\n   146→  customValidator?: string\n   147→}\n   148→\n   149→export interface PhaseDefinition {\n   150→  id: string\n   151→  name: string\n   152→  description?: string\n   153→  steps: StepDefinition[]\n   154→}\n   155→\n   156→export interface PlaybookConfig {\n   157→  id: string\n   158→  type: string // playbook_type from database\n   159→  name: string\n   160→  description?: string\n   161→  icon?: string\n   162→  phases: PhaseDefinition[]\n   163→\n   164→  // Variables needed for this playbook\n   165→  variables?: Array<{\n   166→    key: string\n   167→    label: string\n   168→    type: 'text' | 'textarea' | 'select' | 'multiselect' | 'number'\n   169→    required?: boolean\n   170→    defaultValue?: any\n   171→    description?: string\n   172→    placeholder?: string\n   173→    options?: Array<{ value: string; label: string }>\n   174→    // For number type\n   175→    min?: number\n   176→    max?: number\n   177→  }>\n   178→}\n   179→\n   180→// Runtime state types\n   181→\n   182→export interface StepState {\n   183→  id: string\n   184→  status: StepStatus\n   185→  startedAt?: Date\n   186→  completedAt?: Date\n   187→  error?: string\n   188→\n   189→  // Input/output data\n   190→  input?: any\n   191→  output?: any\n   192→\n   193→  // For suggestion steps\n   194→  suggestions?: Array<{ id: string; label: string; selected: boolean; description?: string; category?: string; contextType?: 'b2c' | 'b2b' }>\n   195→\n   196→  // For decision steps\n   197→  decision?: any\n   198→\n   199→  // Progress for auto steps\n   200→  progress?: {\n   201→    current: number\n   202→    total: number\n   203→    label?: string\n   204→    estimatedTimeRemaining?: string\n   205→  }\n   206→\n   207→  // Partial results shown during execution\n   208→  partialResults?: {\n   209→    lastItems?: string[] // Last few items found/processed\n   210→    successCount?: number\n   211→    failedCount?: number\n   212→    lastSnippet?: string // Last content snippet (for scraping)\n   213→    lastUrl?: string // Last URL processed\n   214→    extracted?: number // Count of successfully extracted items (for extraction step)\n   215→    filtered?: number // Count of filtered/ignored items (for extraction step)\n   216→  }\n   217→\n   218→  // Retry tracking for failed steps\n   219→  retryInfo?: StepRetryInfo\n   220→}\n   221→\n   222→/**\n   223→ * Retry information for tracking step execution attempts\n   224→ */\n   225→export interface StepRetryInfo {\n   226→  /** Current attempt number (1-based) */\n   227→  attemptNumber: number\n   228→  /** Maximum allowed attempts before suggesting alternative actions */\n   229→  maxAttempts: number\n   230→  /** History of all attempts for this step */\n   231→  attempts: StepAttempt[]\n   232→}\n   233→\n   234→/**\n   235→ * Individual step execution attempt record\n   236→ */\n   237→export interface StepAttempt {\n   238→  /** Unique identifier for this attempt */\n   239→  attemptId: string\n   240→  /** Attempt number (1-based) */\n   241→  attemptNumber: number\n   242→  /** When this attempt started */\n   243→  startedAt: Date\n   244→  /** When this attempt ended (null if still running) */\n   245→  endedAt?: Date\n   246→  /** Status of this attempt */\n   247→  status: 'running' | 'completed' | 'failed'\n   248→  /** Error message if failed */\n   249→  errorMessage?: string\n   250→  /** Configuration used for this attempt (useful for tracking changes) */\n   251→  configSnapshot?: StepAttemptConfig\n   252→  /** Output data if completed */\n   253→  output?: unknown\n   254→}\n   255→\n   256→/**\n   257→ * Configuration snapshot for a step attempt\n   258→ * Allows users to modify settings before retry\n   259→ */\n   260→export interface StepAttemptConfig {\n   261→  /** Model override (e.g., switch from gpt-4 to gpt-4-turbo) */\n   262→  model?: string\n   263→  /** Temperature override for LLM steps */\n   264→  temperature?: number\n   265→  /** Max tokens override */\n   266→  maxTokens?: number\n   267→  /** Timeout override in milliseconds */\n   268→  timeout?: number\n   269→  /** Custom parameters specific to the step type */\n   270→  customParams?: Record<string, unknown>\n   271→}\n   272→\n   273→/**\n   274→ * Retry configuration for step execution\n   275→ */\n   276→export interface StepRetryConfig {\n   277→  /** Maximum number of retry attempts (default: 3) */\n   278→  maxAttempts?: number\n   279→  /** Whether to allow config modification before retry (default: true) */\n   280→  allowConfigModification?: boolean\n   281→  /** Available models for retry (if different from default) */\n   282→  availableModels?: string[]\n   283→  /** Default retry delay in milliseconds (default: 0 - immediate) */\n   284→  retryDelay?: number\n   285→}\n   286→\n   287→export interface PhaseState {\n   288→  id: string\n   289→  status: PhaseStatus\n   290→  steps: StepState[]\n   291→}\n   292→\n   293→export interface PlaybookState {\n   294→  projectId: string\n   295→  playbookType: string\n   296→  phases: PhaseState[]\n   297→  currentPhaseIndex: number\n   298→  currentStepIndex: number\n   299→\n   300→  // Configuration values\n   301→  config: Record<string, any>\n   302→\n   303→  // Overall progress\n   304→  completedSteps: number\n   305→  totalSteps: number\n   306→\n   307→  // Timestamps\n   308→  startedAt?: Date\n   309→  completedAt?: Date\n   310→}\n   311→\n   312→// Utility types\n   313→\n   314→export interface PlaybookContext {\n   315→  projectId: string\n   316→  playbookConfig: PlaybookConfig\n   317→  state: PlaybookState\n   318→\n   319→  // Actions\n   320→  goToStep: (phaseIndex: number, stepIndex: number) => void\n   321→  executeStep: (stepId: string, input?: any) => Promise<void>\n   322→  updateStepState: (stepId: string, update: Partial<StepState>) => void\n   323→  saveConfig: (config: Record<string, any>) => Promise<void>\n   324→\n   325→  // Status helpers\n   326→  canExecuteStep: (stepId: string) => boolean\n   327→  getStepState: (stepId: string) => StepState | undefined\n   328→  getCurrentStep: () => { phase: PhaseDefinition; step: StepDefinition } | null\n   329→}\n   330→\n   331→// Props types for components\n   332→\n   333→export interface PlaybookShellProps {\n   334→  projectId: string\n   335→  playbookConfig: PlaybookConfig\n   336→  initialState?: Partial<PlaybookState>\n   337→  sessionId?: string\n   338→}\n   339→\n   340→export interface NavigationPanelProps {\n   341→  phases: PhaseDefinition[]\n   342→  phaseStates: PhaseState[]\n   343→  currentPhaseIndex: number\n   344→  currentStepIndex: number\n   345→  onStepClick: (phaseIndex: number, stepIndex: number) => void\n   346→}\n   347→\n   348→export interface WorkAreaProps {\n   349→  step: StepDefinition\n   350→  stepState: StepState\n   351→  onContinue: () => void\n   352→  onBack?: () => void\n   353→  onExecute: (input?: any) => Promise<void>\n   354→  onUpdateState: (update: Partial<StepState>) => void\n   355→  onEdit?: () => void           // Volver a editar un paso completado\n   356→  onCancel?: () => void         // Cancelar ejecución en curso\n   357→  onRerunPrevious?: () => void  // Re-ejecutar el paso anterior (para decisiones de regenerar)\n   358→  onRetry?: () => void          // Quick retry the current step after an error\n   359→  onRetryWithConfig?: () => void // Open retry dialog with config modification\n   360→  onSkipStep?: () => void       // Skip the current step after max retries\n   361→  isFirst: boolean\n   362→  isLast: boolean\n   363→  previousStepOutput?: unknown  // Output from the previous step\n   364→  projectId?: string            // Project ID for API calls\n   365→  playbookContext?: Record<string, unknown>  // Context with all previous step outputs\n   366→  allSteps?: Array<{ definition: StepDefinition; state: StepState }>  // All steps info for inspection panel\n   367→  saveState?: {                 // Auto-save state for showing saved indicator\n   368→    isSaving: boolean\n   369→    lastSavedAt: Date | null\n   370→    saveError: string | null\n   371→    isDirty?: boolean\n   372→  }\n   373→  retryInfo?: StepRetryInfo     // Retry tracking information for the step\n   374→  maxRetriesReached?: boolean   // Whether max retries have been reached\n   375→  sessionId?: string            // Session ID for support reference\n   376→}\n   377→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"a1d22395-c4af-4897-a368-b05c3278c196","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/types.ts","content":"// Types for the unified playbook architecture with dual panel layout\n\nexport type StepStatus = 'pending' | 'in_progress' | 'completed' | 'skipped' | 'error'\nexport type PhaseStatus = 'pending' | 'in_progress' | 'completed' | 'error'\n\n/**\n * Step types determine how the WorkArea renders and behaves:\n * - input: User must enter data (minimize these)\n * - suggestion: System suggests, user selects/edits\n * - auto: Executes without stopping\n * - auto_with_preview: Shows preview before continuing\n * - auto_with_review: Executes and shows result for optional review\n * - decision: User must make a decision (pause here)\n * - display: Only shows information\n * - action: User performs an action (e.g., export)\n * - manual_research: User performs manual research with external tools (e.g., ChatGPT/Perplexity)\n * - manual_review: User must review and approve before continuing (e.g., preview queries before SERP)\n * - search_with_preview: Shows search config preview with ability to adjust, then executes search\n * - review_with_action: Shows results for review/selection, then executes action on selected items\n */\nexport type StepType =\n  | 'input'\n  | 'suggestion'\n  | 'auto'\n  | 'auto_with_preview'\n  | 'auto_with_review'\n  | 'decision'\n  | 'display'\n  | 'display_scrape_results'\n  | 'extract_with_preview' // Shows scraped URLs + extraction button + results table\n  | 'action'\n  | 'manual_research'\n  | 'manual_review'\n  | 'search_with_preview'\n  | 'review_with_action'\n  | 'unified_keyword_config' // Unified panel for keywords, indicators, and sources\n  | 'unified_search_extract' // All-in-one: SERP → show URLs → scrape → extract\n\n/**\n * Executor type determines how the step is executed:\n * - llm: Uses /api/playbook/execute-step with LLM\n * - job: Uses background job system (like Niche Finder scraping)\n * - api: Calls a specific API endpoint\n * - custom: Custom logic defined in the playbook\n * - none: No execution needed (display/input steps)\n */\nexport type ExecutorType = 'llm' | 'job' | 'api' | 'custom' | 'none'\n\nexport interface StepDefinition {\n  id: string\n  name: string\n  description?: string\n  type: StepType\n  executor: ExecutorType\n\n  // Required API keys - will show setup modal if not configured\n  // e.g., ['blotato', 'wavespeed'] or ['serper', 'firecrawl']\n  requiredApiKeys?: string[]\n\n  // For LLM executor\n  promptKey?: string\n\n  // For job executor\n  jobType?: string\n\n  // For API executor\n  apiEndpoint?: string\n\n  // Dependencies\n  dependsOn?: string[]\n\n  // For suggestion type\n  suggestionConfig?: {\n    generateFrom: 'project' | 'previous_step' | 'api' | 'llm' | 'fixed'\n    apiEndpoint?: string\n    fixedOptionsKey?: string // For 'fixed' - key to identify which lists to load\n    allowAdd?: boolean\n    allowEdit?: boolean\n    minSelections?: number\n    maxSelections?: number\n  }\n\n  // For decision type\n  decisionConfig?: {\n    question: string\n    optionsFrom: 'previous_step' | 'api' | 'fixed'\n    fixedOptions?: Array<{ id: string; label: string; description?: string }>\n    multiSelect?: boolean\n    minSelections?: number\n    maxSelections?: number\n    defaultSelection?: string | string[]\n  }\n\n  // For action type\n  actionConfig?: {\n    label: string\n    actionType: 'export' | 'save' | 'navigate' | 'custom'\n    customHandler?: string\n  }\n\n  // Explanation shown before executing auto steps\n  // Helps user understand what the step will do\n  executionExplanation?: {\n    title: string\n    steps: string[] // List of what the step will do\n    estimatedTime?: string\n    estimatedCost?: string\n    costService?: string // e.g., \"Serper API\", \"Firecrawl\"\n  }\n\n  // Guidance configuration for the step container\n  // Provides clear instructions to users about what the step does and what they need to do\n  guidance?: StepGuidance\n}\n\n/**\n * Step guidance configuration\n * Displayed in the PlaybookStepContainer to help users understand:\n * - What this step does (description)\n * - What actions they need to take (userActions)\n * - What conditions must be met to proceed (completionCriteria)\n */\nexport interface StepGuidance {\n  /** Brief description of what this step accomplishes */\n  description: string\n  /** List of actions the user needs to take in this step */\n  userActions: string[]\n  /**\n   * Completion criteria - defines when the \"Next\" button should be enabled\n   * Can be a simple description or structured criteria\n   */\n  completionCriteria: StepCompletionCriteria\n}\n\n/**\n * Defines completion criteria for a step\n */\nexport interface StepCompletionCriteria {\n  /** Human-readable description of what needs to be done */\n  description: string\n  /** Type of validation to perform */\n  type: 'manual' | 'input_required' | 'selection_required' | 'auto_complete' | 'custom'\n  /** Minimum number of items/characters required (for input_required or selection_required) */\n  minCount?: number\n  /** Custom validation function name (for custom type) */\n  customValidator?: string\n}\n\nexport interface PhaseDefinition {\n  id: string\n  name: string\n  description?: string\n  steps: StepDefinition[]\n}\n\nexport interface PlaybookConfig {\n  id: string\n  type: string // playbook_type from database\n  name: string\n  description?: string\n  icon?: string\n  phases: PhaseDefinition[]\n\n  // Variables needed for this playbook\n  variables?: Array<{\n    key: string\n    label: string\n    type: 'text' | 'textarea' | 'select' | 'multiselect' | 'number'\n    required?: boolean\n    defaultValue?: any\n    description?: string\n    placeholder?: string\n    options?: Array<{ value: string; label: string }>\n    // For number type\n    min?: number\n    max?: number\n  }>\n}\n\n// Runtime state types\n\nexport interface StepState {\n  id: string\n  status: StepStatus\n  startedAt?: Date\n  completedAt?: Date\n  error?: string\n\n  // Input/output data\n  input?: any\n  output?: any\n\n  // For suggestion steps\n  suggestions?: Array<{ id: string; label: string; selected: boolean; description?: string; category?: string; contextType?: 'b2c' | 'b2b' }>\n\n  // For decision steps\n  decision?: any\n\n  // Progress for auto steps\n  progress?: {\n    current: number\n    total: number\n    label?: string\n    estimatedTimeRemaining?: string\n  }\n\n  // Partial results shown during execution\n  partialResults?: {\n    lastItems?: string[] // Last few items found/processed\n    successCount?: number\n    failedCount?: number\n    lastSnippet?: string // Last content snippet (for scraping)\n    lastUrl?: string // Last URL processed\n    extracted?: number // Count of successfully extracted items (for extraction step)\n    filtered?: number // Count of filtered/ignored items (for extraction step)\n  }\n\n  // Retry tracking for failed steps\n  retryInfo?: StepRetryInfo\n}\n\n/**\n * Retry information for tracking step execution attempts\n */\nexport interface StepRetryInfo {\n  /** Current attempt number (1-based) */\n  attemptNumber: number\n  /** Maximum allowed attempts before suggesting alternative actions */\n  maxAttempts: number\n  /** History of all attempts for this step */\n  attempts: StepAttempt[]\n}\n\n/**\n * Individual step execution attempt record\n */\nexport interface StepAttempt {\n  /** Unique identifier for this attempt */\n  attemptId: string\n  /** Attempt number (1-based) */\n  attemptNumber: number\n  /** When this attempt started */\n  startedAt: Date\n  /** When this attempt ended (null if still running) */\n  endedAt?: Date\n  /** Status of this attempt */\n  status: 'running' | 'completed' | 'failed'\n  /** Error message if failed */\n  errorMessage?: string\n  /** Configuration used for this attempt (useful for tracking changes) */\n  configSnapshot?: StepAttemptConfig\n  /** Output data if completed */\n  output?: unknown\n}\n\n/**\n * Configuration snapshot for a step attempt\n * Allows users to modify settings before retry\n */\nexport interface StepAttemptConfig {\n  /** Model override (e.g., switch from gpt-4 to gpt-4-turbo) */\n  model?: string\n  /** Temperature override for LLM steps */\n  temperature?: number\n  /** Max tokens override */\n  maxTokens?: number\n  /** Timeout override in milliseconds */\n  timeout?: number\n  /** Custom parameters specific to the step type */\n  customParams?: Record<string, unknown>\n}\n\n/**\n * Retry configuration for step execution\n */\nexport interface StepRetryConfig {\n  /** Maximum number of retry attempts (default: 3) */\n  maxAttempts?: number\n  /** Whether to allow config modification before retry (default: true) */\n  allowConfigModification?: boolean\n  /** Available models for retry (if different from default) */\n  availableModels?: string[]\n  /** Default retry delay in milliseconds (default: 0 - immediate) */\n  retryDelay?: number\n}\n\nexport interface PhaseState {\n  id: string\n  status: PhaseStatus\n  steps: StepState[]\n}\n\nexport interface PlaybookState {\n  projectId: string\n  playbookType: string\n  phases: PhaseState[]\n  currentPhaseIndex: number\n  currentStepIndex: number\n\n  // Configuration values\n  config: Record<string, any>\n\n  // Overall progress\n  completedSteps: number\n  totalSteps: number\n\n  // Timestamps\n  startedAt?: Date\n  completedAt?: Date\n}\n\n// Utility types\n\nexport interface PlaybookContext {\n  projectId: string\n  playbookConfig: PlaybookConfig\n  state: PlaybookState\n\n  // Actions\n  goToStep: (phaseIndex: number, stepIndex: number) => void\n  executeStep: (stepId: string, input?: any) => Promise<void>\n  updateStepState: (stepId: string, update: Partial<StepState>) => void\n  saveConfig: (config: Record<string, any>) => Promise<void>\n\n  // Status helpers\n  canExecuteStep: (stepId: string) => boolean\n  getStepState: (stepId: string) => StepState | undefined\n  getCurrentStep: () => { phase: PhaseDefinition; step: StepDefinition } | null\n}\n\n// Props types for components\n\nexport interface PlaybookShellProps {\n  projectId: string\n  playbookConfig: PlaybookConfig\n  initialState?: Partial<PlaybookState>\n  sessionId?: string\n}\n\nexport interface NavigationPanelProps {\n  phases: PhaseDefinition[]\n  phaseStates: PhaseState[]\n  currentPhaseIndex: number\n  currentStepIndex: number\n  onStepClick: (phaseIndex: number, stepIndex: number) => void\n}\n\nexport interface WorkAreaProps {\n  step: StepDefinition\n  stepState: StepState\n  onContinue: () => void\n  onBack?: () => void\n  onExecute: (input?: any) => Promise<void>\n  onUpdateState: (update: Partial<StepState>) => void\n  onEdit?: () => void           // Volver a editar un paso completado\n  onCancel?: () => void         // Cancelar ejecución en curso\n  onRerunPrevious?: () => void  // Re-ejecutar el paso anterior (para decisiones de regenerar)\n  onRetry?: () => void          // Quick retry the current step after an error\n  onRetryWithConfig?: () => void // Open retry dialog with config modification\n  onSkipStep?: () => void       // Skip the current step after max retries\n  isFirst: boolean\n  isLast: boolean\n  previousStepOutput?: unknown  // Output from the previous step\n  projectId?: string            // Project ID for API calls\n  playbookContext?: Record<string, unknown>  // Context with all previous step outputs\n  allSteps?: Array<{ definition: StepDefinition; state: StepState }>  // All steps info for inspection panel\n  saveState?: {                 // Auto-save state for showing saved indicator\n    isSaving: boolean\n    lastSavedAt: Date | null\n    saveError: string | null\n    isDirty?: boolean\n  }\n  retryInfo?: StepRetryInfo     // Retry tracking information for the step\n  maxRetriesReached?: boolean   // Whether max retries have been reached\n  sessionId?: string            // Session ID for support reference\n}\n","numLines":377,"startLine":1,"totalLines":377}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01B86XejTy4LhNRKCUN2cqu2","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check if there's an API that returns session data with step outputs."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4942,"cache_read_input_tokens":88197,"cache_creation":{"ephemeral_5m_input_tokens":4942,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"6bccd1b7-76cb-40f1-b7e0-a67e7bc95b31"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01B86XejTy4LhNRKCUN2cqu2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0173UhH82eenGMsFEKT4aYUu","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[sessionId]/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4942,"cache_read_input_tokens":88197,"cache_creation":{"ephemeral_5m_input_tokens":4942,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"66b3a38d-e86d-49db-b284-88c3cede56a3"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File does not exist.</tool_use_error>","is_error":true,"tool_use_id":"toolu_0173UhH82eenGMsFEKT4aYUu"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"656132a7-efbb-4a7a-8222-a2fe1e726fc9","tool_use_result":"Error: File does not exist."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016ttjkQYDyNeg8ctFx5EFwM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TKiycVk8qVcvDjtc1pLSYJ","name":"Glob","input":{"pattern":"src/app/api/playbook/**/*.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":146,"cache_read_input_tokens":93139,"cache_creation":{"ephemeral_5m_input_tokens":146,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"49fed8db-6193-43e8-86e5-2461ef07c36a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TKiycVk8qVcvDjtc1pLSYJ","type":"tool_result","content":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/import-data/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/outputs/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/scrape-engagers/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/generate-audio/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/compose-video/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/generate-clips/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/publish/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/execute-step/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/generate-suggestions/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/suggest-creators/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/steps/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/attempts/route.ts\n/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/attempts/[attemptId]/route.ts"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"0f9da9ac-dd32-498d-b18f-ba9f0cec6dee","tool_use_result":{"filenames":["/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/import-data/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/outputs/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/scrape-engagers/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/generate-audio/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/compose-video/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/generate-clips/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/video-viral/publish/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/execute-step/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/generate-suggestions/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/suggest-creators/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/steps/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/attempts/route.ts","/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/attempts/[attemptId]/route.ts"],"durationMs":166,"numFiles":15,"truncated":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01STgvV2ivUvt1uCkZKBaFys","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FtyivvMhURJJuoiC234MKb","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":684,"cache_read_input_tokens":93285,"cache_creation":{"ephemeral_5m_input_tokens":684,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"d643e954-e01a-40a3-adfd-4cfba8234ca0"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01STgvV2ivUvt1uCkZKBaFys","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019A5v9ZDNqYFoMAL76LmRJi","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/steps/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":684,"cache_read_input_tokens":93285,"cache_creation":{"ephemeral_5m_input_tokens":684,"ephemeral_1h_input_tokens":0},"output_tokens":167,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"9f65c75d-6e55-47a0-bf5d-89c16d7c579d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FtyivvMhURJJuoiC234MKb","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from 'next/server'\n     2→import { createClient } from '@supabase/supabase-js'\n     3→\n     4→export const dynamic = 'force-dynamic'\n     5→\n     6→type Params = { params: Promise<{ id: string }> }\n     7→\n     8→// GET: Get session details with steps and jobs\n     9→export async function GET(request: NextRequest, { params }: Params) {\n    10→  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n    11→  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n    12→\n    13→  if (!supabaseUrl || !supabaseServiceKey) {\n    14→    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n    15→  }\n    16→\n    17→  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n    18→  const { id: sessionId } = await params\n    19→\n    20→  try {\n    21→    // Get session\n    22→    const { data: session, error: sessionError } = await supabase\n    23→      .from('playbook_sessions')\n    24→      .select('*')\n    25→      .eq('id', sessionId)\n    26→      .single()\n    27→\n    28→    if (sessionError || !session) {\n    29→      return NextResponse.json({ error: 'Session not found' }, { status: 404 })\n    30→    }\n    31→\n    32→    // Get session steps\n    33→    const { data: steps } = await supabase\n    34→      .from('playbook_session_steps')\n    35→      .select('*')\n    36→      .eq('session_id', sessionId)\n    37→      .order('created_at', { ascending: true })\n    38→\n    39→    // Get related jobs (for niche_finder)\n    40→    const { data: jobs } = await supabase\n    41→      .from('niche_finder_jobs')\n    42→      .select('id, status, urls_found, urls_scraped, urls_failed, niches_extracted, created_at, updated_at')\n    43→      .eq('session_id', sessionId)\n    44→      .order('created_at', { ascending: false })\n    45→\n    46→    // Build timeline\n    47→    const timeline = buildTimeline(steps || [], jobs || [])\n    48→\n    49→    return NextResponse.json({\n    50→      session,\n    51→      steps: steps || [],\n    52→      jobs: jobs || [],\n    53→      timeline,\n    54→    })\n    55→  } catch (error) {\n    56→    console.error('Error getting session:', error)\n    57→    return NextResponse.json(\n    58→      { error: error instanceof Error ? error.message : 'Unknown error' },\n    59→      { status: 500 }\n    60→    )\n    61→  }\n    62→}\n    63→\n    64→// PATCH: Update session\n    65→export async function PATCH(request: NextRequest, { params }: Params) {\n    66→  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n    67→  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n    68→\n    69→  if (!supabaseUrl || !supabaseServiceKey) {\n    70→    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n    71→  }\n    72→\n    73→  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n    74→  const { id: sessionId } = await params\n    75→\n    76→  try {\n    77→    const body = await request.json()\n    78→    const allowedFields = ['status', 'current_phase', 'current_step', 'config', 'variables', 'active_job_id', 'completed_at']\n    79→\n    80→    const updateData: Record<string, unknown> = {}\n    81→    for (const field of allowedFields) {\n    82→      if (body[field] !== undefined) {\n    83→        updateData[field] = body[field]\n    84→      }\n    85→    }\n    86→\n    87→    if (Object.keys(updateData).length === 0) {\n    88→      return NextResponse.json({ error: 'No valid fields to update' }, { status: 400 })\n    89→    }\n    90→\n    91→    const { data: session, error } = await supabase\n    92→      .from('playbook_sessions')\n    93→      .update(updateData)\n    94→      .eq('id', sessionId)\n    95→      .select()\n    96→      .single()\n    97→\n    98→    if (error) {\n    99→      return NextResponse.json({ error: error.message }, { status: 500 })\n   100→    }\n   101→\n   102→    return NextResponse.json({ session })\n   103→  } catch (error) {\n   104→    console.error('Error updating session:', error)\n   105→    return NextResponse.json(\n   106→      { error: error instanceof Error ? error.message : 'Unknown error' },\n   107→      { status: 500 }\n   108→    )\n   109→  }\n   110→}\n   111→\n   112→interface TimelineEvent {\n   113→  type: 'step' | 'job'\n   114→  id: string\n   115→  title: string\n   116→  status: string\n   117→  timestamp: string\n   118→  details?: Record<string, unknown>\n   119→}\n   120→\n   121→function buildTimeline(\n   122→  steps: Array<{\n   123→    id: string\n   124→    step_id: string\n   125→    status: string\n   126→    started_at: string | null\n   127→    completed_at: string | null\n   128→    output: unknown\n   129→  }>,\n   130→  jobs: Array<{\n   131→    id: string\n   132→    status: string\n   133→    urls_found: number\n   134→    urls_scraped: number\n   135→    urls_failed: number\n   136→    niches_extracted: number\n   137→    created_at: string\n   138→    updated_at: string\n   139→  }>\n   140→): TimelineEvent[] {\n   141→  const events: TimelineEvent[] = []\n   142→\n   143→  // Add step events\n   144→  for (const step of steps) {\n   145→    if (step.started_at) {\n   146→      events.push({\n   147→        type: 'step',\n   148→        id: step.id,\n   149→        title: step.step_id,\n   150→        status: step.status,\n   151→        timestamp: step.completed_at || step.started_at,\n   152→        details: step.output as Record<string, unknown> | undefined,\n   153→      })\n   154→    }\n   155→  }\n   156→\n   157→  // Add job events\n   158→  for (const job of jobs) {\n   159→    events.push({\n   160→      type: 'job',\n   161→      id: job.id,\n   162→      title: `Job ${job.id.slice(0, 8)}`,\n   163→      status: job.status,\n   164→      timestamp: job.updated_at,\n   165→      details: {\n   166→        urls_found: job.urls_found,\n   167→        urls_scraped: job.urls_scraped,\n   168→        urls_failed: job.urls_failed,\n   169→        niches_extracted: job.niches_extracted,\n   170→      },\n   171→    })\n   172→  }\n   173→\n   174→  // Sort by timestamp\n   175→  events.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())\n   176→\n   177→  return events\n   178→}\n   179→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"4b8352fb-e890-4a0d-93bd-4714bd79a52d","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@supabase/supabase-js'\n\nexport const dynamic = 'force-dynamic'\n\ntype Params = { params: Promise<{ id: string }> }\n\n// GET: Get session details with steps and jobs\nexport async function GET(request: NextRequest, { params }: Params) {\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n\n  if (!supabaseUrl || !supabaseServiceKey) {\n    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n  }\n\n  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n  const { id: sessionId } = await params\n\n  try {\n    // Get session\n    const { data: session, error: sessionError } = await supabase\n      .from('playbook_sessions')\n      .select('*')\n      .eq('id', sessionId)\n      .single()\n\n    if (sessionError || !session) {\n      return NextResponse.json({ error: 'Session not found' }, { status: 404 })\n    }\n\n    // Get session steps\n    const { data: steps } = await supabase\n      .from('playbook_session_steps')\n      .select('*')\n      .eq('session_id', sessionId)\n      .order('created_at', { ascending: true })\n\n    // Get related jobs (for niche_finder)\n    const { data: jobs } = await supabase\n      .from('niche_finder_jobs')\n      .select('id, status, urls_found, urls_scraped, urls_failed, niches_extracted, created_at, updated_at')\n      .eq('session_id', sessionId)\n      .order('created_at', { ascending: false })\n\n    // Build timeline\n    const timeline = buildTimeline(steps || [], jobs || [])\n\n    return NextResponse.json({\n      session,\n      steps: steps || [],\n      jobs: jobs || [],\n      timeline,\n    })\n  } catch (error) {\n    console.error('Error getting session:', error)\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    )\n  }\n}\n\n// PATCH: Update session\nexport async function PATCH(request: NextRequest, { params }: Params) {\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n\n  if (!supabaseUrl || !supabaseServiceKey) {\n    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n  }\n\n  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n  const { id: sessionId } = await params\n\n  try {\n    const body = await request.json()\n    const allowedFields = ['status', 'current_phase', 'current_step', 'config', 'variables', 'active_job_id', 'completed_at']\n\n    const updateData: Record<string, unknown> = {}\n    for (const field of allowedFields) {\n      if (body[field] !== undefined) {\n        updateData[field] = body[field]\n      }\n    }\n\n    if (Object.keys(updateData).length === 0) {\n      return NextResponse.json({ error: 'No valid fields to update' }, { status: 400 })\n    }\n\n    const { data: session, error } = await supabase\n      .from('playbook_sessions')\n      .update(updateData)\n      .eq('id', sessionId)\n      .select()\n      .single()\n\n    if (error) {\n      return NextResponse.json({ error: error.message }, { status: 500 })\n    }\n\n    return NextResponse.json({ session })\n  } catch (error) {\n    console.error('Error updating session:', error)\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    )\n  }\n}\n\ninterface TimelineEvent {\n  type: 'step' | 'job'\n  id: string\n  title: string\n  status: string\n  timestamp: string\n  details?: Record<string, unknown>\n}\n\nfunction buildTimeline(\n  steps: Array<{\n    id: string\n    step_id: string\n    status: string\n    started_at: string | null\n    completed_at: string | null\n    output: unknown\n  }>,\n  jobs: Array<{\n    id: string\n    status: string\n    urls_found: number\n    urls_scraped: number\n    urls_failed: number\n    niches_extracted: number\n    created_at: string\n    updated_at: string\n  }>\n): TimelineEvent[] {\n  const events: TimelineEvent[] = []\n\n  // Add step events\n  for (const step of steps) {\n    if (step.started_at) {\n      events.push({\n        type: 'step',\n        id: step.id,\n        title: step.step_id,\n        status: step.status,\n        timestamp: step.completed_at || step.started_at,\n        details: step.output as Record<string, unknown> | undefined,\n      })\n    }\n  }\n\n  // Add job events\n  for (const job of jobs) {\n    events.push({\n      type: 'job',\n      id: job.id,\n      title: `Job ${job.id.slice(0, 8)}`,\n      status: job.status,\n      timestamp: job.updated_at,\n      details: {\n        urls_found: job.urls_found,\n        urls_scraped: job.urls_scraped,\n        urls_failed: job.urls_failed,\n        niches_extracted: job.niches_extracted,\n      },\n    })\n  }\n\n  // Sort by timestamp\n  events.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())\n\n  return events\n}\n","numLines":179,"startLine":1,"totalLines":179}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019A5v9ZDNqYFoMAL76LmRJi","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from 'next/server'\n     2→import { createClient } from '@supabase/supabase-js'\n     3→\n     4→export const dynamic = 'force-dynamic'\n     5→\n     6→type Params = { params: Promise<{ id: string }> }\n     7→\n     8→interface StepUpdate {\n     9→  step_id: string\n    10→  status?: 'pending' | 'in_progress' | 'completed' | 'error' | 'skipped'\n    11→  started_at?: string\n    12→  completed_at?: string\n    13→  input?: unknown\n    14→  output?: unknown\n    15→  error_message?: string\n    16→  job_id?: string\n    17→  job_type?: string\n    18→}\n    19→\n    20→// Map API field names to database column names\n    21→// The database uses input_data/output_data, but API accepts input/output for convenience\n    22→function mapToDbFields(fields: Omit<StepUpdate, 'step_id'>): Record<string, unknown> {\n    23→  const dbFields: Record<string, unknown> = {}\n    24→\n    25→  // Map input -> input_data\n    26→  if (fields.input !== undefined) {\n    27→    dbFields.input_data = fields.input\n    28→  }\n    29→\n    30→  // Map output -> output_data\n    31→  if (fields.output !== undefined) {\n    32→    dbFields.output_data = fields.output\n    33→  }\n    34→\n    35→  // Copy other fields directly\n    36→  if (fields.status !== undefined) dbFields.status = fields.status\n    37→  if (fields.started_at !== undefined) dbFields.started_at = fields.started_at\n    38→  if (fields.completed_at !== undefined) dbFields.completed_at = fields.completed_at\n    39→  if (fields.error_message !== undefined) dbFields.error_message = fields.error_message\n    40→  if (fields.job_id !== undefined) dbFields.job_id = fields.job_id\n    41→  if (fields.job_type !== undefined) dbFields.job_type = fields.job_type\n    42→\n    43→  return dbFields\n    44→}\n    45→\n    46→// GET: List steps for a session\n    47→export async function GET(request: NextRequest, { params }: Params) {\n    48→  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n    49→  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n    50→\n    51→  if (!supabaseUrl || !supabaseServiceKey) {\n    52→    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n    53→  }\n    54→\n    55→  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n    56→  const { id: sessionId } = await params\n    57→\n    58→  try {\n    59→    const { data: steps, error } = await supabase\n    60→      .from('playbook_session_steps')\n    61→      .select('*')\n    62→      .eq('session_id', sessionId)\n    63→      .order('created_at', { ascending: true })\n    64→\n    65→    if (error) {\n    66→      return NextResponse.json({ error: error.message }, { status: 500 })\n    67→    }\n    68→\n    69→    return NextResponse.json({ steps })\n    70→  } catch (error) {\n    71→    console.error('Error listing steps:', error)\n    72→    return NextResponse.json(\n    73→      { error: error instanceof Error ? error.message : 'Unknown error' },\n    74→      { status: 500 }\n    75→    )\n    76→  }\n    77→}\n    78→\n    79→// POST/PUT: Upsert a step (create or update)\n    80→export async function POST(request: NextRequest, { params }: Params) {\n    81→  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n    82→  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n    83→\n    84→  if (!supabaseUrl || !supabaseServiceKey) {\n    85→    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n    86→  }\n    87→\n    88→  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n    89→  const { id: sessionId } = await params\n    90→\n    91→  try {\n    92→    const body: StepUpdate = await request.json()\n    93→    const { step_id, ...updateFields } = body\n    94→\n    95→    if (!step_id) {\n    96→      return NextResponse.json({ error: 'step_id is required' }, { status: 400 })\n    97→    }\n    98→\n    99→    // Map API fields to database column names\n   100→    const dbFields = mapToDbFields(updateFields)\n   101→\n   102→    // Upsert step\n   103→    const { data: step, error } = await supabase\n   104→      .from('playbook_session_steps')\n   105→      .upsert(\n   106→        {\n   107→          session_id: sessionId,\n   108→          step_id,\n   109→          ...dbFields,\n   110→        },\n   111→        { onConflict: 'session_id,step_id' }\n   112→      )\n   113→      .select()\n   114→      .single()\n   115→\n   116→    if (error) {\n   117→      console.error('Error upserting step:', error)\n   118→      return NextResponse.json({ error: error.message }, { status: 500 })\n   119→    }\n   120→\n   121→    // Also update session's current_step if starting a new step\n   122→    if (updateFields.status === 'in_progress') {\n   123→      await supabase\n   124→        .from('playbook_sessions')\n   125→        .update({ current_step: step_id })\n   126→        .eq('id', sessionId)\n   127→    }\n   128→\n   129→    return NextResponse.json({ step })\n   130→  } catch (error) {\n   131→    console.error('Error in steps endpoint:', error)\n   132→    return NextResponse.json(\n   133→      { error: error instanceof Error ? error.message : 'Unknown error' },\n   134→      { status: 500 }\n   135→    )\n   136→  }\n   137→}\n   138→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"bd2e4d0f-66af-4743-b5a6-f85f8e3a7180","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/app/api/playbook/sessions/[id]/steps/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@supabase/supabase-js'\n\nexport const dynamic = 'force-dynamic'\n\ntype Params = { params: Promise<{ id: string }> }\n\ninterface StepUpdate {\n  step_id: string\n  status?: 'pending' | 'in_progress' | 'completed' | 'error' | 'skipped'\n  started_at?: string\n  completed_at?: string\n  input?: unknown\n  output?: unknown\n  error_message?: string\n  job_id?: string\n  job_type?: string\n}\n\n// Map API field names to database column names\n// The database uses input_data/output_data, but API accepts input/output for convenience\nfunction mapToDbFields(fields: Omit<StepUpdate, 'step_id'>): Record<string, unknown> {\n  const dbFields: Record<string, unknown> = {}\n\n  // Map input -> input_data\n  if (fields.input !== undefined) {\n    dbFields.input_data = fields.input\n  }\n\n  // Map output -> output_data\n  if (fields.output !== undefined) {\n    dbFields.output_data = fields.output\n  }\n\n  // Copy other fields directly\n  if (fields.status !== undefined) dbFields.status = fields.status\n  if (fields.started_at !== undefined) dbFields.started_at = fields.started_at\n  if (fields.completed_at !== undefined) dbFields.completed_at = fields.completed_at\n  if (fields.error_message !== undefined) dbFields.error_message = fields.error_message\n  if (fields.job_id !== undefined) dbFields.job_id = fields.job_id\n  if (fields.job_type !== undefined) dbFields.job_type = fields.job_type\n\n  return dbFields\n}\n\n// GET: List steps for a session\nexport async function GET(request: NextRequest, { params }: Params) {\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n\n  if (!supabaseUrl || !supabaseServiceKey) {\n    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n  }\n\n  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n  const { id: sessionId } = await params\n\n  try {\n    const { data: steps, error } = await supabase\n      .from('playbook_session_steps')\n      .select('*')\n      .eq('session_id', sessionId)\n      .order('created_at', { ascending: true })\n\n    if (error) {\n      return NextResponse.json({ error: error.message }, { status: 500 })\n    }\n\n    return NextResponse.json({ steps })\n  } catch (error) {\n    console.error('Error listing steps:', error)\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    )\n  }\n}\n\n// POST/PUT: Upsert a step (create or update)\nexport async function POST(request: NextRequest, { params }: Params) {\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n\n  if (!supabaseUrl || !supabaseServiceKey) {\n    return NextResponse.json({ error: 'Database configuration missing' }, { status: 500 })\n  }\n\n  const supabase = createClient(supabaseUrl, supabaseServiceKey)\n  const { id: sessionId } = await params\n\n  try {\n    const body: StepUpdate = await request.json()\n    const { step_id, ...updateFields } = body\n\n    if (!step_id) {\n      return NextResponse.json({ error: 'step_id is required' }, { status: 400 })\n    }\n\n    // Map API fields to database column names\n    const dbFields = mapToDbFields(updateFields)\n\n    // Upsert step\n    const { data: step, error } = await supabase\n      .from('playbook_session_steps')\n      .upsert(\n        {\n          session_id: sessionId,\n          step_id,\n          ...dbFields,\n        },\n        { onConflict: 'session_id,step_id' }\n      )\n      .select()\n      .single()\n\n    if (error) {\n      console.error('Error upserting step:', error)\n      return NextResponse.json({ error: error.message }, { status: 500 })\n    }\n\n    // Also update session's current_step if starting a new step\n    if (updateFields.status === 'in_progress') {\n      await supabase\n        .from('playbook_sessions')\n        .update({ current_step: step_id })\n        .eq('id', sessionId)\n    }\n\n    return NextResponse.json({ step })\n  } catch (error) {\n    console.error('Error in steps endpoint:', error)\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    )\n  }\n}\n","numLines":138,"startLine":1,"totalLines":138}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AfPFmhYCkcDqqqefn1kPgK","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding of the codebase. Let me start implementing the Artifact Browser. I'll create the component with all the required functionality."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4255,"cache_read_input_tokens":93969,"cache_creation":{"ephemeral_5m_input_tokens":4255,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"21cafdc6-784b-4099-93c9-ba32e22d67a1"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AfPFmhYCkcDqqqefn1kPgK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018AmzEir5Ca9EVXCwe1gmTo","name":"TodoWrite","input":{"todos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"in_progress","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"pending","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"pending","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"pending","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"pending","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"pending","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"pending","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Run quality checks","status":"pending","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4255,"cache_read_input_tokens":93969,"cache_creation":{"ephemeral_5m_input_tokens":4255,"ephemeral_1h_input_tokens":0},"output_tokens":384,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"fad740a7-f946-430f-b2f5-7bd13ce6ef5f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018AmzEir5Ca9EVXCwe1gmTo","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"f25f712f-ec78-4fb9-a319-1d6bab650bb8","tool_use_result":{"oldTodos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"pending","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"pending","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"pending","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"pending","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"pending","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"pending","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"pending","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Run quality checks","status":"pending","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"in_progress","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"pending","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"pending","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"pending","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"pending","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"pending","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"pending","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Run quality checks","status":"pending","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VfegBHAiPFyr1Nm6zj79cE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A2ZhjUhEi7vk8xFY1CLE84","name":"Write","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/types.ts","content":"/**\n * Artifact Browser Types\n *\n * Types for the session data browser that allows users to explore\n * all artifacts generated during a playbook session.\n */\n\nexport type ArtifactType =\n  | 'serp_results'      // SERP search results (URLs)\n  | 'scraped_content'   // Scraped page content\n  | 'extracted_data'    // LLM-extracted structured data\n  | 'step_output'       // Regular step output (text/markdown)\n  | 'generated_content' // AI-generated content\n  | 'analysis'          // Analysis results\n  | 'suggestions'       // Generated suggestions\n  | 'decision'          // User decisions\n  | 'custom'            // Custom data type\n\nexport interface Artifact {\n  id: string\n  type: ArtifactType\n  name: string\n  description?: string\n\n  // Source information\n  stepId: string\n  stepName: string\n  stepOrder: number\n\n  // Content\n  content: unknown  // Can be string, array, or object\n  contentType: 'text' | 'markdown' | 'json' | 'table' | 'list'\n\n  // Metadata\n  createdAt: string\n  itemCount?: number    // For arrays/tables\n  wordCount?: number    // For text content\n  size?: number         // Content size in bytes\n\n  // Status\n  savedToContextLake?: boolean\n  contextLakeDocId?: string\n}\n\nexport interface ArtifactGroup {\n  type: ArtifactType\n  label: string\n  icon: string  // Lucide icon name\n  count: number\n  artifacts: Artifact[]\n  stepId?: string\n  stepName?: string\n}\n\nexport interface SessionArtifacts {\n  sessionId: string\n  projectId: string\n  campaignId?: string\n  campaignName?: string\n  playbookType: string\n\n  // Grouped by type\n  groups: ArtifactGroup[]\n\n  // Total counts\n  totalArtifacts: number\n  totalSteps: number\n\n  // Timestamps\n  sessionStartedAt: string\n  lastUpdatedAt: string\n}\n\nexport interface ArtifactFilter {\n  searchQuery: string\n  types: ArtifactType[]\n  stepIds: string[]\n  dateRange?: {\n    from: string\n    to: string\n  }\n  savedOnly?: boolean\n}\n\nexport interface ArtifactViewerState {\n  isOpen: boolean\n  artifact: Artifact | null\n  viewMode: 'preview' | 'full' | 'raw'\n}\n\nexport interface ExportOptions {\n  format: 'csv' | 'json'\n  includeMetadata: boolean\n  selectedArtifactIds?: string[]\n}\n\n// Label mapping for artifact types\nexport const ARTIFACT_TYPE_LABELS: Record<ArtifactType, { label: string; icon: string; color: string }> = {\n  serp_results: { label: 'SERP Results', icon: 'Search', color: 'text-blue-600 bg-blue-50' },\n  scraped_content: { label: 'Scraped Content', icon: 'FileText', color: 'text-green-600 bg-green-50' },\n  extracted_data: { label: 'Extracted Data', icon: 'Database', color: 'text-purple-600 bg-purple-50' },\n  step_output: { label: 'Step Output', icon: 'Sparkles', color: 'text-indigo-600 bg-indigo-50' },\n  generated_content: { label: 'Generated Content', icon: 'Wand2', color: 'text-pink-600 bg-pink-50' },\n  analysis: { label: 'Analysis', icon: 'BarChart3', color: 'text-orange-600 bg-orange-50' },\n  suggestions: { label: 'Suggestions', icon: 'Lightbulb', color: 'text-yellow-600 bg-yellow-50' },\n  decision: { label: 'Decisions', icon: 'GitBranch', color: 'text-teal-600 bg-teal-50' },\n  custom: { label: 'Other', icon: 'Package', color: 'text-gray-600 bg-gray-50' },\n}\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":426,"cache_read_input_tokens":98224,"cache_creation":{"ephemeral_5m_input_tokens":426,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"5ff21ed0-3dc7-43f5-a672-6c171c24a4de"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A2ZhjUhEi7vk8xFY1CLE84","type":"tool_result","content":"File created successfully at: /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/types.ts"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"363d51f8-0eb2-49d4-9068-bea3704fd838","tool_use_result":{"type":"create","filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/types.ts","content":"/**\n * Artifact Browser Types\n *\n * Types for the session data browser that allows users to explore\n * all artifacts generated during a playbook session.\n */\n\nexport type ArtifactType =\n  | 'serp_results'      // SERP search results (URLs)\n  | 'scraped_content'   // Scraped page content\n  | 'extracted_data'    // LLM-extracted structured data\n  | 'step_output'       // Regular step output (text/markdown)\n  | 'generated_content' // AI-generated content\n  | 'analysis'          // Analysis results\n  | 'suggestions'       // Generated suggestions\n  | 'decision'          // User decisions\n  | 'custom'            // Custom data type\n\nexport interface Artifact {\n  id: string\n  type: ArtifactType\n  name: string\n  description?: string\n\n  // Source information\n  stepId: string\n  stepName: string\n  stepOrder: number\n\n  // Content\n  content: unknown  // Can be string, array, or object\n  contentType: 'text' | 'markdown' | 'json' | 'table' | 'list'\n\n  // Metadata\n  createdAt: string\n  itemCount?: number    // For arrays/tables\n  wordCount?: number    // For text content\n  size?: number         // Content size in bytes\n\n  // Status\n  savedToContextLake?: boolean\n  contextLakeDocId?: string\n}\n\nexport interface ArtifactGroup {\n  type: ArtifactType\n  label: string\n  icon: string  // Lucide icon name\n  count: number\n  artifacts: Artifact[]\n  stepId?: string\n  stepName?: string\n}\n\nexport interface SessionArtifacts {\n  sessionId: string\n  projectId: string\n  campaignId?: string\n  campaignName?: string\n  playbookType: string\n\n  // Grouped by type\n  groups: ArtifactGroup[]\n\n  // Total counts\n  totalArtifacts: number\n  totalSteps: number\n\n  // Timestamps\n  sessionStartedAt: string\n  lastUpdatedAt: string\n}\n\nexport interface ArtifactFilter {\n  searchQuery: string\n  types: ArtifactType[]\n  stepIds: string[]\n  dateRange?: {\n    from: string\n    to: string\n  }\n  savedOnly?: boolean\n}\n\nexport interface ArtifactViewerState {\n  isOpen: boolean\n  artifact: Artifact | null\n  viewMode: 'preview' | 'full' | 'raw'\n}\n\nexport interface ExportOptions {\n  format: 'csv' | 'json'\n  includeMetadata: boolean\n  selectedArtifactIds?: string[]\n}\n\n// Label mapping for artifact types\nexport const ARTIFACT_TYPE_LABELS: Record<ArtifactType, { label: string; icon: string; color: string }> = {\n  serp_results: { label: 'SERP Results', icon: 'Search', color: 'text-blue-600 bg-blue-50' },\n  scraped_content: { label: 'Scraped Content', icon: 'FileText', color: 'text-green-600 bg-green-50' },\n  extracted_data: { label: 'Extracted Data', icon: 'Database', color: 'text-purple-600 bg-purple-50' },\n  step_output: { label: 'Step Output', icon: 'Sparkles', color: 'text-indigo-600 bg-indigo-50' },\n  generated_content: { label: 'Generated Content', icon: 'Wand2', color: 'text-pink-600 bg-pink-50' },\n  analysis: { label: 'Analysis', icon: 'BarChart3', color: 'text-orange-600 bg-orange-50' },\n  suggestions: { label: 'Suggestions', icon: 'Lightbulb', color: 'text-yellow-600 bg-yellow-50' },\n  decision: { label: 'Decisions', icon: 'GitBranch', color: 'text-teal-600 bg-teal-50' },\n  custom: { label: 'Other', icon: 'Package', color: 'text-gray-600 bg-gray-50' },\n}\n","structuredPatch":[],"originalFile":null}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CrNGepPp8avDfCRKeBqd67","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0169Q5k7aB6x58GntEqXa5eY","name":"Write","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/useArtifacts.ts","content":"'use client'\n\nimport { useState, useCallback, useEffect, useMemo } from 'react'\nimport {\n  Artifact,\n  ArtifactGroup,\n  ArtifactType,\n  ArtifactFilter,\n  SessionArtifacts,\n  ARTIFACT_TYPE_LABELS,\n} from './types'\n\ninterface UseArtifactsOptions {\n  sessionId?: string\n  projectId: string\n  campaignId?: string\n  playbookType: string\n  stepOutputs?: Record<string, unknown>\n  allSteps?: Array<{\n    definition: { id: string; name: string }\n    state: { id: string; status: string; output?: unknown; input?: unknown }\n  }>\n}\n\ninterface UseArtifactsReturn {\n  artifacts: SessionArtifacts | null\n  loading: boolean\n  error: string | null\n  filter: ArtifactFilter\n  setFilter: (filter: Partial<ArtifactFilter>) => void\n  filteredGroups: ArtifactGroup[]\n  refreshArtifacts: () => Promise<void>\n  getArtifactById: (id: string) => Artifact | undefined\n}\n\nexport function useArtifacts({\n  sessionId,\n  projectId,\n  campaignId,\n  playbookType,\n  stepOutputs = {},\n  allSteps = [],\n}: UseArtifactsOptions): UseArtifactsReturn {\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [sessionData, setSessionData] = useState<{\n    steps: Array<{\n      id: string\n      step_id: string\n      status: string\n      input_data?: unknown\n      output_data?: unknown\n      started_at?: string\n      completed_at?: string\n    }>\n    jobs: Array<{\n      id: string\n      status: string\n      urls_found: number\n      urls_scraped: number\n      niches_extracted: number\n    }>\n  } | null>(null)\n\n  const [filter, setFilterState] = useState<ArtifactFilter>({\n    searchQuery: '',\n    types: [],\n    stepIds: [],\n  })\n\n  const setFilter = useCallback((update: Partial<ArtifactFilter>) => {\n    setFilterState(prev => ({ ...prev, ...update }))\n  }, [])\n\n  // Load session data from API\n  const refreshArtifacts = useCallback(async () => {\n    if (!sessionId) return\n\n    setLoading(true)\n    setError(null)\n\n    try {\n      const response = await fetch(`/api/playbook/sessions/${sessionId}`)\n      if (!response.ok) {\n        throw new Error('Failed to load session data')\n      }\n\n      const data = await response.json()\n      setSessionData({\n        steps: data.steps || [],\n        jobs: data.jobs || [],\n      })\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error')\n    } finally {\n      setLoading(false)\n    }\n  }, [sessionId])\n\n  useEffect(() => {\n    if (sessionId) {\n      refreshArtifacts()\n    }\n  }, [sessionId, refreshArtifacts])\n\n  // Build artifacts from step outputs and session data\n  const artifacts: SessionArtifacts | null = useMemo(() => {\n    const allArtifacts: Artifact[] = []\n    let artifactIndex = 0\n\n    // Process step outputs from props (live data)\n    allSteps.forEach((step, index) => {\n      const stepDef = step.definition\n      const stepState = step.state\n\n      if (!stepState.output && !stepState.input) return\n\n      // Process output\n      if (stepState.output) {\n        const output = stepState.output\n        const artifact = createArtifactFromOutput(\n          `artifact-${artifactIndex++}`,\n          stepDef.id,\n          stepDef.name,\n          index + 1,\n          output\n        )\n        if (artifact) {\n          allArtifacts.push(artifact)\n        }\n      }\n\n      // Process input if it's a complex object (like suggestions)\n      if (stepState.input && typeof stepState.input === 'object') {\n        const input = stepState.input as Record<string, unknown>\n        if (input.suggestions || input.selected || input.items) {\n          const artifact = createArtifactFromInput(\n            `artifact-input-${artifactIndex++}`,\n            stepDef.id,\n            stepDef.name,\n            index + 1,\n            input\n          )\n          if (artifact) {\n            allArtifacts.push(artifact)\n          }\n        }\n      }\n    })\n\n    // Process session data from API\n    if (sessionData?.steps) {\n      sessionData.steps.forEach((step, index) => {\n        if (!step.output_data) return\n\n        // Skip if we already have this step from allSteps\n        const existingArtifact = allArtifacts.find(a => a.stepId === step.step_id)\n        if (existingArtifact) return\n\n        const artifact = createArtifactFromOutput(\n          `artifact-session-${artifactIndex++}`,\n          step.step_id,\n          step.step_id, // Use step_id as name since we don't have the definition\n          index + 1,\n          step.output_data\n        )\n        if (artifact) {\n          artifact.createdAt = step.completed_at || step.started_at || new Date().toISOString()\n          allArtifacts.push(artifact)\n        }\n      })\n    }\n\n    // Process jobs (SERP results, scraped content)\n    if (sessionData?.jobs) {\n      sessionData.jobs.forEach((job, index) => {\n        if (job.urls_found > 0) {\n          allArtifacts.push({\n            id: `serp-${job.id}`,\n            type: 'serp_results',\n            name: `SERP Results - Job ${index + 1}`,\n            stepId: 'serp-search',\n            stepName: 'Search Results',\n            stepOrder: 0,\n            content: { jobId: job.id, count: job.urls_found },\n            contentType: 'json',\n            createdAt: new Date().toISOString(),\n            itemCount: job.urls_found,\n          })\n        }\n\n        if (job.urls_scraped > 0) {\n          allArtifacts.push({\n            id: `scraped-${job.id}`,\n            type: 'scraped_content',\n            name: `Scraped Content - Job ${index + 1}`,\n            stepId: 'scraping',\n            stepName: 'Scraped Pages',\n            stepOrder: 1,\n            content: { jobId: job.id, count: job.urls_scraped },\n            contentType: 'json',\n            createdAt: new Date().toISOString(),\n            itemCount: job.urls_scraped,\n          })\n        }\n\n        if (job.niches_extracted > 0) {\n          allArtifacts.push({\n            id: `extracted-${job.id}`,\n            type: 'extracted_data',\n            name: `Extracted Niches - Job ${index + 1}`,\n            stepId: 'extraction',\n            stepName: 'Extracted Data',\n            stepOrder: 2,\n            content: { jobId: job.id, count: job.niches_extracted },\n            contentType: 'json',\n            createdAt: new Date().toISOString(),\n            itemCount: job.niches_extracted,\n          })\n        }\n      })\n    }\n\n    // Group artifacts by type\n    const groupsMap = new Map<ArtifactType, ArtifactGroup>()\n\n    allArtifacts.forEach(artifact => {\n      const existing = groupsMap.get(artifact.type)\n      if (existing) {\n        existing.artifacts.push(artifact)\n        existing.count++\n      } else {\n        const typeInfo = ARTIFACT_TYPE_LABELS[artifact.type]\n        groupsMap.set(artifact.type, {\n          type: artifact.type,\n          label: typeInfo.label,\n          icon: typeInfo.icon,\n          count: 1,\n          artifacts: [artifact],\n        })\n      }\n    })\n\n    const groups = Array.from(groupsMap.values())\n\n    return {\n      sessionId: sessionId || '',\n      projectId,\n      campaignId,\n      playbookType,\n      groups,\n      totalArtifacts: allArtifacts.length,\n      totalSteps: allSteps.length,\n      sessionStartedAt: new Date().toISOString(),\n      lastUpdatedAt: new Date().toISOString(),\n    }\n  }, [allSteps, sessionData, sessionId, projectId, campaignId, playbookType])\n\n  // Filter groups\n  const filteredGroups = useMemo(() => {\n    if (!artifacts) return []\n\n    return artifacts.groups\n      .map(group => {\n        // Filter by type\n        if (filter.types.length > 0 && !filter.types.includes(group.type)) {\n          return null\n        }\n\n        // Filter artifacts within group\n        let filteredArtifacts = group.artifacts\n\n        // Filter by step\n        if (filter.stepIds.length > 0) {\n          filteredArtifacts = filteredArtifacts.filter(a =>\n            filter.stepIds.includes(a.stepId)\n          )\n        }\n\n        // Filter by search query\n        if (filter.searchQuery) {\n          const query = filter.searchQuery.toLowerCase()\n          filteredArtifacts = filteredArtifacts.filter(a =>\n            a.name.toLowerCase().includes(query) ||\n            a.stepName.toLowerCase().includes(query) ||\n            (typeof a.content === 'string' && a.content.toLowerCase().includes(query))\n          )\n        }\n\n        // Filter by saved only\n        if (filter.savedOnly) {\n          filteredArtifacts = filteredArtifacts.filter(a => a.savedToContextLake)\n        }\n\n        if (filteredArtifacts.length === 0) return null\n\n        return {\n          ...group,\n          artifacts: filteredArtifacts,\n          count: filteredArtifacts.length,\n        }\n      })\n      .filter((g): g is ArtifactGroup => g !== null)\n  }, [artifacts, filter])\n\n  const getArtifactById = useCallback((id: string): Artifact | undefined => {\n    if (!artifacts) return undefined\n\n    for (const group of artifacts.groups) {\n      const artifact = group.artifacts.find(a => a.id === id)\n      if (artifact) return artifact\n    }\n\n    return undefined\n  }, [artifacts])\n\n  return {\n    artifacts,\n    loading,\n    error,\n    filter,\n    setFilter,\n    filteredGroups,\n    refreshArtifacts,\n    getArtifactById,\n  }\n}\n\n// Helper functions\n\nfunction createArtifactFromOutput(\n  id: string,\n  stepId: string,\n  stepName: string,\n  stepOrder: number,\n  output: unknown\n): Artifact | null {\n  if (!output) return null\n\n  const artifact: Artifact = {\n    id,\n    type: 'step_output',\n    name: `${stepName} Output`,\n    stepId,\n    stepName,\n    stepOrder,\n    content: output,\n    contentType: 'text',\n    createdAt: new Date().toISOString(),\n  }\n\n  // Determine content type and artifact type\n  if (typeof output === 'string') {\n    artifact.contentType = output.includes('#') || output.includes('**') ? 'markdown' : 'text'\n    artifact.wordCount = output.split(/\\s+/).length\n  } else if (Array.isArray(output)) {\n    artifact.contentType = 'list'\n    artifact.itemCount = output.length\n\n    // Detect artifact type from array content\n    if (output.length > 0) {\n      const first = output[0]\n      if (typeof first === 'object' && first !== null) {\n        if ('url' in first) {\n          artifact.type = 'serp_results'\n          artifact.name = `${stepName} - URLs`\n        } else if ('content' in first || 'text' in first) {\n          artifact.type = 'scraped_content'\n          artifact.name = `${stepName} - Content`\n        } else if ('niche' in first || 'problem' in first || 'pain_point' in first) {\n          artifact.type = 'extracted_data'\n          artifact.name = `${stepName} - Extracted`\n        }\n        artifact.contentType = 'table'\n      }\n    }\n  } else if (typeof output === 'object' && output !== null) {\n    artifact.contentType = 'json'\n    const obj = output as Record<string, unknown>\n\n    // Detect artifact type from object keys\n    if ('analysis' in obj || 'summary' in obj) {\n      artifact.type = 'analysis'\n      artifact.name = `${stepName} - Analysis`\n    } else if ('suggestions' in obj || 'recommendations' in obj) {\n      artifact.type = 'suggestions'\n      artifact.name = `${stepName} - Suggestions`\n    } else if ('generated' in obj || 'content' in obj) {\n      artifact.type = 'generated_content'\n      artifact.name = `${stepName} - Generated`\n    }\n  }\n\n  return artifact\n}\n\nfunction createArtifactFromInput(\n  id: string,\n  stepId: string,\n  stepName: string,\n  stepOrder: number,\n  input: Record<string, unknown>\n): Artifact | null {\n  if (!input) return null\n\n  const artifact: Artifact = {\n    id,\n    type: 'decision',\n    name: `${stepName} - Selection`,\n    stepId,\n    stepName,\n    stepOrder,\n    content: input,\n    contentType: 'json',\n    createdAt: new Date().toISOString(),\n  }\n\n  if (input.suggestions && Array.isArray(input.suggestions)) {\n    artifact.type = 'suggestions'\n    artifact.name = `${stepName} - Suggestions`\n    artifact.itemCount = (input.suggestions as unknown[]).length\n    artifact.contentType = 'list'\n  } else if (input.selected && Array.isArray(input.selected)) {\n    artifact.type = 'decision'\n    artifact.name = `${stepName} - Selected Items`\n    artifact.itemCount = (input.selected as unknown[]).length\n    artifact.contentType = 'list'\n  }\n\n  return artifact\n}\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1222,"cache_read_input_tokens":98650,"cache_creation":{"ephemeral_5m_input_tokens":1222,"ephemeral_1h_input_tokens":0},"output_tokens":3822,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"07755541-df8a-4a40-af78-7fe400442be2"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0169Q5k7aB6x58GntEqXa5eY","type":"tool_result","content":"File created successfully at: /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/useArtifacts.ts"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"8bce072c-5122-4202-ad52-aae388e4d9b1","tool_use_result":{"type":"create","filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/useArtifacts.ts","content":"'use client'\n\nimport { useState, useCallback, useEffect, useMemo } from 'react'\nimport {\n  Artifact,\n  ArtifactGroup,\n  ArtifactType,\n  ArtifactFilter,\n  SessionArtifacts,\n  ARTIFACT_TYPE_LABELS,\n} from './types'\n\ninterface UseArtifactsOptions {\n  sessionId?: string\n  projectId: string\n  campaignId?: string\n  playbookType: string\n  stepOutputs?: Record<string, unknown>\n  allSteps?: Array<{\n    definition: { id: string; name: string }\n    state: { id: string; status: string; output?: unknown; input?: unknown }\n  }>\n}\n\ninterface UseArtifactsReturn {\n  artifacts: SessionArtifacts | null\n  loading: boolean\n  error: string | null\n  filter: ArtifactFilter\n  setFilter: (filter: Partial<ArtifactFilter>) => void\n  filteredGroups: ArtifactGroup[]\n  refreshArtifacts: () => Promise<void>\n  getArtifactById: (id: string) => Artifact | undefined\n}\n\nexport function useArtifacts({\n  sessionId,\n  projectId,\n  campaignId,\n  playbookType,\n  stepOutputs = {},\n  allSteps = [],\n}: UseArtifactsOptions): UseArtifactsReturn {\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [sessionData, setSessionData] = useState<{\n    steps: Array<{\n      id: string\n      step_id: string\n      status: string\n      input_data?: unknown\n      output_data?: unknown\n      started_at?: string\n      completed_at?: string\n    }>\n    jobs: Array<{\n      id: string\n      status: string\n      urls_found: number\n      urls_scraped: number\n      niches_extracted: number\n    }>\n  } | null>(null)\n\n  const [filter, setFilterState] = useState<ArtifactFilter>({\n    searchQuery: '',\n    types: [],\n    stepIds: [],\n  })\n\n  const setFilter = useCallback((update: Partial<ArtifactFilter>) => {\n    setFilterState(prev => ({ ...prev, ...update }))\n  }, [])\n\n  // Load session data from API\n  const refreshArtifacts = useCallback(async () => {\n    if (!sessionId) return\n\n    setLoading(true)\n    setError(null)\n\n    try {\n      const response = await fetch(`/api/playbook/sessions/${sessionId}`)\n      if (!response.ok) {\n        throw new Error('Failed to load session data')\n      }\n\n      const data = await response.json()\n      setSessionData({\n        steps: data.steps || [],\n        jobs: data.jobs || [],\n      })\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Unknown error')\n    } finally {\n      setLoading(false)\n    }\n  }, [sessionId])\n\n  useEffect(() => {\n    if (sessionId) {\n      refreshArtifacts()\n    }\n  }, [sessionId, refreshArtifacts])\n\n  // Build artifacts from step outputs and session data\n  const artifacts: SessionArtifacts | null = useMemo(() => {\n    const allArtifacts: Artifact[] = []\n    let artifactIndex = 0\n\n    // Process step outputs from props (live data)\n    allSteps.forEach((step, index) => {\n      const stepDef = step.definition\n      const stepState = step.state\n\n      if (!stepState.output && !stepState.input) return\n\n      // Process output\n      if (stepState.output) {\n        const output = stepState.output\n        const artifact = createArtifactFromOutput(\n          `artifact-${artifactIndex++}`,\n          stepDef.id,\n          stepDef.name,\n          index + 1,\n          output\n        )\n        if (artifact) {\n          allArtifacts.push(artifact)\n        }\n      }\n\n      // Process input if it's a complex object (like suggestions)\n      if (stepState.input && typeof stepState.input === 'object') {\n        const input = stepState.input as Record<string, unknown>\n        if (input.suggestions || input.selected || input.items) {\n          const artifact = createArtifactFromInput(\n            `artifact-input-${artifactIndex++}`,\n            stepDef.id,\n            stepDef.name,\n            index + 1,\n            input\n          )\n          if (artifact) {\n            allArtifacts.push(artifact)\n          }\n        }\n      }\n    })\n\n    // Process session data from API\n    if (sessionData?.steps) {\n      sessionData.steps.forEach((step, index) => {\n        if (!step.output_data) return\n\n        // Skip if we already have this step from allSteps\n        const existingArtifact = allArtifacts.find(a => a.stepId === step.step_id)\n        if (existingArtifact) return\n\n        const artifact = createArtifactFromOutput(\n          `artifact-session-${artifactIndex++}`,\n          step.step_id,\n          step.step_id, // Use step_id as name since we don't have the definition\n          index + 1,\n          step.output_data\n        )\n        if (artifact) {\n          artifact.createdAt = step.completed_at || step.started_at || new Date().toISOString()\n          allArtifacts.push(artifact)\n        }\n      })\n    }\n\n    // Process jobs (SERP results, scraped content)\n    if (sessionData?.jobs) {\n      sessionData.jobs.forEach((job, index) => {\n        if (job.urls_found > 0) {\n          allArtifacts.push({\n            id: `serp-${job.id}`,\n            type: 'serp_results',\n            name: `SERP Results - Job ${index + 1}`,\n            stepId: 'serp-search',\n            stepName: 'Search Results',\n            stepOrder: 0,\n            content: { jobId: job.id, count: job.urls_found },\n            contentType: 'json',\n            createdAt: new Date().toISOString(),\n            itemCount: job.urls_found,\n          })\n        }\n\n        if (job.urls_scraped > 0) {\n          allArtifacts.push({\n            id: `scraped-${job.id}`,\n            type: 'scraped_content',\n            name: `Scraped Content - Job ${index + 1}`,\n            stepId: 'scraping',\n            stepName: 'Scraped Pages',\n            stepOrder: 1,\n            content: { jobId: job.id, count: job.urls_scraped },\n            contentType: 'json',\n            createdAt: new Date().toISOString(),\n            itemCount: job.urls_scraped,\n          })\n        }\n\n        if (job.niches_extracted > 0) {\n          allArtifacts.push({\n            id: `extracted-${job.id}`,\n            type: 'extracted_data',\n            name: `Extracted Niches - Job ${index + 1}`,\n            stepId: 'extraction',\n            stepName: 'Extracted Data',\n            stepOrder: 2,\n            content: { jobId: job.id, count: job.niches_extracted },\n            contentType: 'json',\n            createdAt: new Date().toISOString(),\n            itemCount: job.niches_extracted,\n          })\n        }\n      })\n    }\n\n    // Group artifacts by type\n    const groupsMap = new Map<ArtifactType, ArtifactGroup>()\n\n    allArtifacts.forEach(artifact => {\n      const existing = groupsMap.get(artifact.type)\n      if (existing) {\n        existing.artifacts.push(artifact)\n        existing.count++\n      } else {\n        const typeInfo = ARTIFACT_TYPE_LABELS[artifact.type]\n        groupsMap.set(artifact.type, {\n          type: artifact.type,\n          label: typeInfo.label,\n          icon: typeInfo.icon,\n          count: 1,\n          artifacts: [artifact],\n        })\n      }\n    })\n\n    const groups = Array.from(groupsMap.values())\n\n    return {\n      sessionId: sessionId || '',\n      projectId,\n      campaignId,\n      playbookType,\n      groups,\n      totalArtifacts: allArtifacts.length,\n      totalSteps: allSteps.length,\n      sessionStartedAt: new Date().toISOString(),\n      lastUpdatedAt: new Date().toISOString(),\n    }\n  }, [allSteps, sessionData, sessionId, projectId, campaignId, playbookType])\n\n  // Filter groups\n  const filteredGroups = useMemo(() => {\n    if (!artifacts) return []\n\n    return artifacts.groups\n      .map(group => {\n        // Filter by type\n        if (filter.types.length > 0 && !filter.types.includes(group.type)) {\n          return null\n        }\n\n        // Filter artifacts within group\n        let filteredArtifacts = group.artifacts\n\n        // Filter by step\n        if (filter.stepIds.length > 0) {\n          filteredArtifacts = filteredArtifacts.filter(a =>\n            filter.stepIds.includes(a.stepId)\n          )\n        }\n\n        // Filter by search query\n        if (filter.searchQuery) {\n          const query = filter.searchQuery.toLowerCase()\n          filteredArtifacts = filteredArtifacts.filter(a =>\n            a.name.toLowerCase().includes(query) ||\n            a.stepName.toLowerCase().includes(query) ||\n            (typeof a.content === 'string' && a.content.toLowerCase().includes(query))\n          )\n        }\n\n        // Filter by saved only\n        if (filter.savedOnly) {\n          filteredArtifacts = filteredArtifacts.filter(a => a.savedToContextLake)\n        }\n\n        if (filteredArtifacts.length === 0) return null\n\n        return {\n          ...group,\n          artifacts: filteredArtifacts,\n          count: filteredArtifacts.length,\n        }\n      })\n      .filter((g): g is ArtifactGroup => g !== null)\n  }, [artifacts, filter])\n\n  const getArtifactById = useCallback((id: string): Artifact | undefined => {\n    if (!artifacts) return undefined\n\n    for (const group of artifacts.groups) {\n      const artifact = group.artifacts.find(a => a.id === id)\n      if (artifact) return artifact\n    }\n\n    return undefined\n  }, [artifacts])\n\n  return {\n    artifacts,\n    loading,\n    error,\n    filter,\n    setFilter,\n    filteredGroups,\n    refreshArtifacts,\n    getArtifactById,\n  }\n}\n\n// Helper functions\n\nfunction createArtifactFromOutput(\n  id: string,\n  stepId: string,\n  stepName: string,\n  stepOrder: number,\n  output: unknown\n): Artifact | null {\n  if (!output) return null\n\n  const artifact: Artifact = {\n    id,\n    type: 'step_output',\n    name: `${stepName} Output`,\n    stepId,\n    stepName,\n    stepOrder,\n    content: output,\n    contentType: 'text',\n    createdAt: new Date().toISOString(),\n  }\n\n  // Determine content type and artifact type\n  if (typeof output === 'string') {\n    artifact.contentType = output.includes('#') || output.includes('**') ? 'markdown' : 'text'\n    artifact.wordCount = output.split(/\\s+/).length\n  } else if (Array.isArray(output)) {\n    artifact.contentType = 'list'\n    artifact.itemCount = output.length\n\n    // Detect artifact type from array content\n    if (output.length > 0) {\n      const first = output[0]\n      if (typeof first === 'object' && first !== null) {\n        if ('url' in first) {\n          artifact.type = 'serp_results'\n          artifact.name = `${stepName} - URLs`\n        } else if ('content' in first || 'text' in first) {\n          artifact.type = 'scraped_content'\n          artifact.name = `${stepName} - Content`\n        } else if ('niche' in first || 'problem' in first || 'pain_point' in first) {\n          artifact.type = 'extracted_data'\n          artifact.name = `${stepName} - Extracted`\n        }\n        artifact.contentType = 'table'\n      }\n    }\n  } else if (typeof output === 'object' && output !== null) {\n    artifact.contentType = 'json'\n    const obj = output as Record<string, unknown>\n\n    // Detect artifact type from object keys\n    if ('analysis' in obj || 'summary' in obj) {\n      artifact.type = 'analysis'\n      artifact.name = `${stepName} - Analysis`\n    } else if ('suggestions' in obj || 'recommendations' in obj) {\n      artifact.type = 'suggestions'\n      artifact.name = `${stepName} - Suggestions`\n    } else if ('generated' in obj || 'content' in obj) {\n      artifact.type = 'generated_content'\n      artifact.name = `${stepName} - Generated`\n    }\n  }\n\n  return artifact\n}\n\nfunction createArtifactFromInput(\n  id: string,\n  stepId: string,\n  stepName: string,\n  stepOrder: number,\n  input: Record<string, unknown>\n): Artifact | null {\n  if (!input) return null\n\n  const artifact: Artifact = {\n    id,\n    type: 'decision',\n    name: `${stepName} - Selection`,\n    stepId,\n    stepName,\n    stepOrder,\n    content: input,\n    contentType: 'json',\n    createdAt: new Date().toISOString(),\n  }\n\n  if (input.suggestions && Array.isArray(input.suggestions)) {\n    artifact.type = 'suggestions'\n    artifact.name = `${stepName} - Suggestions`\n    artifact.itemCount = (input.suggestions as unknown[]).length\n    artifact.contentType = 'list'\n  } else if (input.selected && Array.isArray(input.selected)) {\n    artifact.type = 'decision'\n    artifact.name = `${stepName} - Selected Items`\n    artifact.itemCount = (input.selected as unknown[]).length\n    artifact.contentType = 'list'\n  }\n\n  return artifact\n}\n","structuredPatch":[],"originalFile":null}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VDEeuQKdXnjbvsyBdF6jsF","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me create the ArtifactViewerModal component:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3882,"cache_read_input_tokens":99872,"cache_creation":{"ephemeral_5m_input_tokens":3882,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"fcdd30cd-f1a5-4736-a4ec-b98ca7530de8"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VDEeuQKdXnjbvsyBdF6jsF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CFxmM8hsuuS9aByqN85Lix","name":"Write","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/ArtifactViewerModal.tsx","content":"'use client'\n\nimport { useState, useEffect, useRef } from 'react'\nimport { createPortal } from 'react-dom'\nimport {\n  X,\n  Download,\n  Save,\n  Copy,\n  Check,\n  Code,\n  FileText,\n  Table,\n  Eye,\n  ChevronDown,\n  Maximize2,\n  Minimize2,\n  ExternalLink,\n} from 'lucide-react'\nimport MarkdownRenderer from '@/components/common/MarkdownRenderer'\nimport { Artifact, ARTIFACT_TYPE_LABELS } from './types'\n\ninterface ArtifactViewerModalProps {\n  isOpen: boolean\n  artifact: Artifact | null\n  onClose: () => void\n  onSaveToContextLake?: (artifact: Artifact) => void\n  onExport?: (artifact: Artifact, format: 'csv' | 'json') => void\n}\n\ntype ViewMode = 'preview' | 'raw' | 'table'\n\nexport default function ArtifactViewerModal({\n  isOpen,\n  artifact,\n  onClose,\n  onSaveToContextLake,\n  onExport,\n}: ArtifactViewerModalProps) {\n  const [mounted, setMounted] = useState(false)\n  const [isVisible, setIsVisible] = useState(false)\n  const [viewMode, setViewMode] = useState<ViewMode>('preview')\n  const [copied, setCopied] = useState(false)\n  const [isFullscreen, setIsFullscreen] = useState(false)\n  const modalRef = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    setMounted(true)\n  }, [])\n\n  useEffect(() => {\n    if (isOpen) {\n      requestAnimationFrame(() => setIsVisible(true))\n      setViewMode('preview')\n      setCopied(false)\n    } else {\n      setIsVisible(false)\n    }\n  }, [isOpen])\n\n  // Handle escape key\n  useEffect(() => {\n    if (!isOpen) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        if (isFullscreen) {\n          setIsFullscreen(false)\n        } else {\n          onClose()\n        }\n      }\n    }\n\n    document.addEventListener('keydown', handleKeyDown)\n    return () => document.removeEventListener('keydown', handleKeyDown)\n  }, [isOpen, isFullscreen, onClose])\n\n  // Prevent body scroll\n  useEffect(() => {\n    if (isOpen) {\n      document.body.style.overflow = 'hidden'\n    } else {\n      document.body.style.overflow = ''\n    }\n    return () => {\n      document.body.style.overflow = ''\n    }\n  }, [isOpen])\n\n  const handleCopy = async () => {\n    if (!artifact) return\n\n    let textToCopy: string\n    if (typeof artifact.content === 'string') {\n      textToCopy = artifact.content\n    } else {\n      textToCopy = JSON.stringify(artifact.content, null, 2)\n    }\n\n    await navigator.clipboard.writeText(textToCopy)\n    setCopied(true)\n    setTimeout(() => setCopied(false), 2000)\n  }\n\n  if (!mounted || !isOpen || !artifact) return null\n\n  const typeInfo = ARTIFACT_TYPE_LABELS[artifact.type]\n\n  const renderContent = () => {\n    const content = artifact.content\n\n    if (viewMode === 'raw') {\n      return (\n        <pre className=\"text-sm text-gray-700 whitespace-pre-wrap font-mono bg-gray-50 p-4 rounded-lg overflow-auto max-h-[60vh]\">\n          {typeof content === 'string' ? content : JSON.stringify(content, null, 2)}\n        </pre>\n      )\n    }\n\n    if (viewMode === 'table' && (Array.isArray(content) || typeof content === 'object')) {\n      return renderTableView(content)\n    }\n\n    // Preview mode\n    if (typeof content === 'string') {\n      if (artifact.contentType === 'markdown') {\n        return (\n          <div className=\"prose prose-sm max-w-none overflow-auto max-h-[60vh]\">\n            <MarkdownRenderer content={content} />\n          </div>\n        )\n      }\n      return (\n        <div className=\"text-gray-700 whitespace-pre-wrap overflow-auto max-h-[60vh]\">\n          {content}\n        </div>\n      )\n    }\n\n    if (Array.isArray(content)) {\n      return renderListView(content)\n    }\n\n    if (typeof content === 'object' && content !== null) {\n      return renderObjectView(content as Record<string, unknown>)\n    }\n\n    return <p className=\"text-gray-500\">No content to display</p>\n  }\n\n  const renderTableView = (data: unknown) => {\n    if (!Array.isArray(data) || data.length === 0) {\n      if (typeof data === 'object' && data !== null) {\n        return renderObjectView(data as Record<string, unknown>)\n      }\n      return <p className=\"text-gray-500\">No table data available</p>\n    }\n\n    const firstItem = data[0]\n    if (typeof firstItem !== 'object' || firstItem === null) {\n      return renderListView(data)\n    }\n\n    const columns = Object.keys(firstItem as Record<string, unknown>)\n\n    return (\n      <div className=\"overflow-auto max-h-[60vh]\">\n        <table className=\"min-w-full divide-y divide-gray-200\">\n          <thead className=\"bg-gray-50 sticky top-0\">\n            <tr>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase\">#</th>\n              {columns.map(col => (\n                <th key={col} className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase\">\n                  {col.replace(/_/g, ' ')}\n                </th>\n              ))}\n            </tr>\n          </thead>\n          <tbody className=\"bg-white divide-y divide-gray-200\">\n            {data.slice(0, 100).map((row, index) => (\n              <tr key={index} className=\"hover:bg-gray-50\">\n                <td className=\"px-3 py-2 text-sm text-gray-400\">{index + 1}</td>\n                {columns.map(col => (\n                  <td key={col} className=\"px-3 py-2 text-sm text-gray-700\">\n                    {renderCellValue((row as Record<string, unknown>)[col])}\n                  </td>\n                ))}\n              </tr>\n            ))}\n          </tbody>\n        </table>\n        {data.length > 100 && (\n          <p className=\"text-sm text-gray-500 text-center py-2\">\n            Showing 100 of {data.length} items\n          </p>\n        )}\n      </div>\n    )\n  }\n\n  const renderCellValue = (value: unknown): React.ReactNode => {\n    if (value === null || value === undefined) return <span className=\"text-gray-400\">-</span>\n    if (typeof value === 'boolean') return value ? 'Yes' : 'No'\n    if (typeof value === 'string') {\n      if (value.startsWith('http')) {\n        return (\n          <a\n            href={value}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            className=\"text-blue-600 hover:underline inline-flex items-center gap-1 max-w-[200px] truncate\"\n          >\n            {new URL(value).hostname}\n            <ExternalLink size={12} />\n          </a>\n        )\n      }\n      return <span className=\"max-w-[300px] truncate block\">{value}</span>\n    }\n    if (typeof value === 'number') return value.toLocaleString()\n    if (Array.isArray(value)) return `[${value.length} items]`\n    if (typeof value === 'object') return JSON.stringify(value).slice(0, 50) + '...'\n    return String(value)\n  }\n\n  const renderListView = (data: unknown[]) => {\n    return (\n      <div className=\"space-y-2 max-h-[60vh] overflow-auto\">\n        {data.slice(0, 50).map((item, index) => (\n          <div key={index} className=\"p-3 bg-gray-50 rounded-lg\">\n            <span className=\"text-gray-400 text-sm mr-2\">#{index + 1}</span>\n            {typeof item === 'object' ? (\n              <pre className=\"text-sm text-gray-700 mt-1\">{JSON.stringify(item, null, 2)}</pre>\n            ) : (\n              <span className=\"text-gray-700\">{String(item)}</span>\n            )}\n          </div>\n        ))}\n        {data.length > 50 && (\n          <p className=\"text-sm text-gray-500 text-center py-2\">\n            Showing 50 of {data.length} items\n          </p>\n        )}\n      </div>\n    )\n  }\n\n  const renderObjectView = (data: Record<string, unknown>) => {\n    return (\n      <div className=\"space-y-3 max-h-[60vh] overflow-auto\">\n        {Object.entries(data).map(([key, value]) => (\n          <div key={key} className=\"border-b border-gray-100 pb-2\">\n            <span className=\"text-sm font-medium text-gray-600\">{key.replace(/_/g, ' ')}</span>\n            <div className=\"mt-1 text-gray-700\">\n              {typeof value === 'string' ? (\n                value.includes('\\n') ? (\n                  <pre className=\"text-sm whitespace-pre-wrap bg-gray-50 p-2 rounded\">{value}</pre>\n                ) : (\n                  <span>{value}</span>\n                )\n              ) : Array.isArray(value) ? (\n                <span className=\"text-sm text-gray-500\">[{value.length} items]</span>\n              ) : typeof value === 'object' && value !== null ? (\n                <pre className=\"text-sm bg-gray-50 p-2 rounded\">{JSON.stringify(value, null, 2)}</pre>\n              ) : (\n                <span>{String(value)}</span>\n              )}\n            </div>\n          </div>\n        ))}\n      </div>\n    )\n  }\n\n  const canShowTable = Array.isArray(artifact.content) ||\n    (typeof artifact.content === 'object' && artifact.content !== null)\n\n  return createPortal(\n    <div\n      className={`fixed inset-0 z-[10000] flex items-center justify-center p-4 transition-all duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-labelledby=\"artifact-modal-title\"\n    >\n      {/* Backdrop */}\n      <div\n        className={`absolute inset-0 bg-gray-900/60 backdrop-blur-sm transition-opacity duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n        onClick={onClose}\n        aria-hidden=\"true\"\n      />\n\n      {/* Modal */}\n      <div\n        ref={modalRef}\n        className={`relative ${isFullscreen ? 'w-full h-full' : 'w-full max-w-4xl max-h-[90vh]'} overflow-hidden bg-white dark:bg-gray-900 rounded-2xl shadow-2xl transform transition-all duration-200 ${isVisible ? 'scale-100 opacity-100' : 'scale-95 opacity-0'} flex flex-col`}\n      >\n        {/* Header */}\n        <div className=\"sticky top-0 bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700 px-6 py-4 z-10\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-3\">\n              <span className={`px-2 py-1 rounded text-xs font-medium ${typeInfo.color}`}>\n                {typeInfo.label}\n              </span>\n              <div>\n                <h2 id=\"artifact-modal-title\" className=\"text-lg font-semibold text-gray-900 dark:text-gray-100\">\n                  {artifact.name}\n                </h2>\n                <p className=\"text-sm text-gray-500 mt-0.5\">\n                  From: {artifact.stepName}\n                  {artifact.itemCount && ` | ${artifact.itemCount} items`}\n                  {artifact.wordCount && ` | ${artifact.wordCount} words`}\n                </p>\n              </div>\n            </div>\n            <div className=\"flex items-center gap-2\">\n              <button\n                onClick={() => setIsFullscreen(!isFullscreen)}\n                className=\"p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors\"\n                title={isFullscreen ? 'Exit fullscreen' : 'Fullscreen'}\n              >\n                {isFullscreen ? <Minimize2 size={18} /> : <Maximize2 size={18} />}\n              </button>\n              <button\n                onClick={onClose}\n                className=\"p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors\"\n              >\n                <X size={20} />\n              </button>\n            </div>\n          </div>\n\n          {/* View mode tabs */}\n          <div className=\"flex items-center gap-2 mt-4\">\n            <button\n              onClick={() => setViewMode('preview')}\n              className={`flex items-center gap-1.5 px-3 py-1.5 text-sm rounded-lg transition-colors ${\n                viewMode === 'preview'\n                  ? 'bg-indigo-100 text-indigo-700 font-medium'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Eye size={14} />\n              Preview\n            </button>\n            {canShowTable && (\n              <button\n                onClick={() => setViewMode('table')}\n                className={`flex items-center gap-1.5 px-3 py-1.5 text-sm rounded-lg transition-colors ${\n                  viewMode === 'table'\n                    ? 'bg-indigo-100 text-indigo-700 font-medium'\n                    : 'text-gray-600 hover:bg-gray-100'\n                }`}\n              >\n                <Table size={14} />\n                Table\n              </button>\n            )}\n            <button\n              onClick={() => setViewMode('raw')}\n              className={`flex items-center gap-1.5 px-3 py-1.5 text-sm rounded-lg transition-colors ${\n                viewMode === 'raw'\n                  ? 'bg-indigo-100 text-indigo-700 font-medium'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Code size={14} />\n              Raw\n            </button>\n          </div>\n        </div>\n\n        {/* Content */}\n        <div className=\"flex-1 overflow-auto p-6\">\n          {renderContent()}\n        </div>\n\n        {/* Footer */}\n        <div className=\"sticky bottom-0 flex items-center justify-between gap-3 px-6 py-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/50\">\n          <div className=\"flex items-center gap-2\">\n            <button\n              onClick={handleCopy}\n              className=\"inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors\"\n            >\n              {copied ? (\n                <>\n                  <Check size={16} className=\"text-green-500\" />\n                  Copied!\n                </>\n              ) : (\n                <>\n                  <Copy size={16} />\n                  Copy\n                </>\n              )}\n            </button>\n          </div>\n\n          <div className=\"flex items-center gap-2\">\n            {onExport && canShowTable && (\n              <div className=\"relative group\">\n                <button className=\"inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors\">\n                  <Download size={16} />\n                  Export\n                  <ChevronDown size={14} />\n                </button>\n                <div className=\"absolute right-0 bottom-full mb-1 hidden group-hover:block bg-white border border-gray-200 rounded-lg shadow-lg py-1 min-w-[120px]\">\n                  <button\n                    onClick={() => onExport(artifact, 'csv')}\n                    className=\"w-full px-4 py-2 text-sm text-left text-gray-700 hover:bg-gray-100\"\n                  >\n                    Export as CSV\n                  </button>\n                  <button\n                    onClick={() => onExport(artifact, 'json')}\n                    className=\"w-full px-4 py-2 text-sm text-left text-gray-700 hover:bg-gray-100\"\n                  >\n                    Export as JSON\n                  </button>\n                </div>\n              </div>\n            )}\n\n            {onSaveToContextLake && (\n              <button\n                onClick={() => onSaveToContextLake(artifact)}\n                className=\"inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-gradient-to-r from-indigo-600 to-purple-600 rounded-lg hover:from-indigo-700 hover:to-purple-700 transition-all shadow-md\"\n              >\n                <Save size={16} />\n                Save to Context Lake\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>,\n    document.body\n  )\n}\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3882,"cache_read_input_tokens":99872,"cache_creation":{"ephemeral_5m_input_tokens":3882,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"696aa260-d8aa-4981-970b-18d9b471bd2d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CFxmM8hsuuS9aByqN85Lix","type":"tool_result","content":"File created successfully at: /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/ArtifactViewerModal.tsx"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"abb2132f-da56-435b-8f57-80430138b7a1","tool_use_result":{"type":"create","filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/ArtifactViewerModal.tsx","content":"'use client'\n\nimport { useState, useEffect, useRef } from 'react'\nimport { createPortal } from 'react-dom'\nimport {\n  X,\n  Download,\n  Save,\n  Copy,\n  Check,\n  Code,\n  FileText,\n  Table,\n  Eye,\n  ChevronDown,\n  Maximize2,\n  Minimize2,\n  ExternalLink,\n} from 'lucide-react'\nimport MarkdownRenderer from '@/components/common/MarkdownRenderer'\nimport { Artifact, ARTIFACT_TYPE_LABELS } from './types'\n\ninterface ArtifactViewerModalProps {\n  isOpen: boolean\n  artifact: Artifact | null\n  onClose: () => void\n  onSaveToContextLake?: (artifact: Artifact) => void\n  onExport?: (artifact: Artifact, format: 'csv' | 'json') => void\n}\n\ntype ViewMode = 'preview' | 'raw' | 'table'\n\nexport default function ArtifactViewerModal({\n  isOpen,\n  artifact,\n  onClose,\n  onSaveToContextLake,\n  onExport,\n}: ArtifactViewerModalProps) {\n  const [mounted, setMounted] = useState(false)\n  const [isVisible, setIsVisible] = useState(false)\n  const [viewMode, setViewMode] = useState<ViewMode>('preview')\n  const [copied, setCopied] = useState(false)\n  const [isFullscreen, setIsFullscreen] = useState(false)\n  const modalRef = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    setMounted(true)\n  }, [])\n\n  useEffect(() => {\n    if (isOpen) {\n      requestAnimationFrame(() => setIsVisible(true))\n      setViewMode('preview')\n      setCopied(false)\n    } else {\n      setIsVisible(false)\n    }\n  }, [isOpen])\n\n  // Handle escape key\n  useEffect(() => {\n    if (!isOpen) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        if (isFullscreen) {\n          setIsFullscreen(false)\n        } else {\n          onClose()\n        }\n      }\n    }\n\n    document.addEventListener('keydown', handleKeyDown)\n    return () => document.removeEventListener('keydown', handleKeyDown)\n  }, [isOpen, isFullscreen, onClose])\n\n  // Prevent body scroll\n  useEffect(() => {\n    if (isOpen) {\n      document.body.style.overflow = 'hidden'\n    } else {\n      document.body.style.overflow = ''\n    }\n    return () => {\n      document.body.style.overflow = ''\n    }\n  }, [isOpen])\n\n  const handleCopy = async () => {\n    if (!artifact) return\n\n    let textToCopy: string\n    if (typeof artifact.content === 'string') {\n      textToCopy = artifact.content\n    } else {\n      textToCopy = JSON.stringify(artifact.content, null, 2)\n    }\n\n    await navigator.clipboard.writeText(textToCopy)\n    setCopied(true)\n    setTimeout(() => setCopied(false), 2000)\n  }\n\n  if (!mounted || !isOpen || !artifact) return null\n\n  const typeInfo = ARTIFACT_TYPE_LABELS[artifact.type]\n\n  const renderContent = () => {\n    const content = artifact.content\n\n    if (viewMode === 'raw') {\n      return (\n        <pre className=\"text-sm text-gray-700 whitespace-pre-wrap font-mono bg-gray-50 p-4 rounded-lg overflow-auto max-h-[60vh]\">\n          {typeof content === 'string' ? content : JSON.stringify(content, null, 2)}\n        </pre>\n      )\n    }\n\n    if (viewMode === 'table' && (Array.isArray(content) || typeof content === 'object')) {\n      return renderTableView(content)\n    }\n\n    // Preview mode\n    if (typeof content === 'string') {\n      if (artifact.contentType === 'markdown') {\n        return (\n          <div className=\"prose prose-sm max-w-none overflow-auto max-h-[60vh]\">\n            <MarkdownRenderer content={content} />\n          </div>\n        )\n      }\n      return (\n        <div className=\"text-gray-700 whitespace-pre-wrap overflow-auto max-h-[60vh]\">\n          {content}\n        </div>\n      )\n    }\n\n    if (Array.isArray(content)) {\n      return renderListView(content)\n    }\n\n    if (typeof content === 'object' && content !== null) {\n      return renderObjectView(content as Record<string, unknown>)\n    }\n\n    return <p className=\"text-gray-500\">No content to display</p>\n  }\n\n  const renderTableView = (data: unknown) => {\n    if (!Array.isArray(data) || data.length === 0) {\n      if (typeof data === 'object' && data !== null) {\n        return renderObjectView(data as Record<string, unknown>)\n      }\n      return <p className=\"text-gray-500\">No table data available</p>\n    }\n\n    const firstItem = data[0]\n    if (typeof firstItem !== 'object' || firstItem === null) {\n      return renderListView(data)\n    }\n\n    const columns = Object.keys(firstItem as Record<string, unknown>)\n\n    return (\n      <div className=\"overflow-auto max-h-[60vh]\">\n        <table className=\"min-w-full divide-y divide-gray-200\">\n          <thead className=\"bg-gray-50 sticky top-0\">\n            <tr>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase\">#</th>\n              {columns.map(col => (\n                <th key={col} className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase\">\n                  {col.replace(/_/g, ' ')}\n                </th>\n              ))}\n            </tr>\n          </thead>\n          <tbody className=\"bg-white divide-y divide-gray-200\">\n            {data.slice(0, 100).map((row, index) => (\n              <tr key={index} className=\"hover:bg-gray-50\">\n                <td className=\"px-3 py-2 text-sm text-gray-400\">{index + 1}</td>\n                {columns.map(col => (\n                  <td key={col} className=\"px-3 py-2 text-sm text-gray-700\">\n                    {renderCellValue((row as Record<string, unknown>)[col])}\n                  </td>\n                ))}\n              </tr>\n            ))}\n          </tbody>\n        </table>\n        {data.length > 100 && (\n          <p className=\"text-sm text-gray-500 text-center py-2\">\n            Showing 100 of {data.length} items\n          </p>\n        )}\n      </div>\n    )\n  }\n\n  const renderCellValue = (value: unknown): React.ReactNode => {\n    if (value === null || value === undefined) return <span className=\"text-gray-400\">-</span>\n    if (typeof value === 'boolean') return value ? 'Yes' : 'No'\n    if (typeof value === 'string') {\n      if (value.startsWith('http')) {\n        return (\n          <a\n            href={value}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            className=\"text-blue-600 hover:underline inline-flex items-center gap-1 max-w-[200px] truncate\"\n          >\n            {new URL(value).hostname}\n            <ExternalLink size={12} />\n          </a>\n        )\n      }\n      return <span className=\"max-w-[300px] truncate block\">{value}</span>\n    }\n    if (typeof value === 'number') return value.toLocaleString()\n    if (Array.isArray(value)) return `[${value.length} items]`\n    if (typeof value === 'object') return JSON.stringify(value).slice(0, 50) + '...'\n    return String(value)\n  }\n\n  const renderListView = (data: unknown[]) => {\n    return (\n      <div className=\"space-y-2 max-h-[60vh] overflow-auto\">\n        {data.slice(0, 50).map((item, index) => (\n          <div key={index} className=\"p-3 bg-gray-50 rounded-lg\">\n            <span className=\"text-gray-400 text-sm mr-2\">#{index + 1}</span>\n            {typeof item === 'object' ? (\n              <pre className=\"text-sm text-gray-700 mt-1\">{JSON.stringify(item, null, 2)}</pre>\n            ) : (\n              <span className=\"text-gray-700\">{String(item)}</span>\n            )}\n          </div>\n        ))}\n        {data.length > 50 && (\n          <p className=\"text-sm text-gray-500 text-center py-2\">\n            Showing 50 of {data.length} items\n          </p>\n        )}\n      </div>\n    )\n  }\n\n  const renderObjectView = (data: Record<string, unknown>) => {\n    return (\n      <div className=\"space-y-3 max-h-[60vh] overflow-auto\">\n        {Object.entries(data).map(([key, value]) => (\n          <div key={key} className=\"border-b border-gray-100 pb-2\">\n            <span className=\"text-sm font-medium text-gray-600\">{key.replace(/_/g, ' ')}</span>\n            <div className=\"mt-1 text-gray-700\">\n              {typeof value === 'string' ? (\n                value.includes('\\n') ? (\n                  <pre className=\"text-sm whitespace-pre-wrap bg-gray-50 p-2 rounded\">{value}</pre>\n                ) : (\n                  <span>{value}</span>\n                )\n              ) : Array.isArray(value) ? (\n                <span className=\"text-sm text-gray-500\">[{value.length} items]</span>\n              ) : typeof value === 'object' && value !== null ? (\n                <pre className=\"text-sm bg-gray-50 p-2 rounded\">{JSON.stringify(value, null, 2)}</pre>\n              ) : (\n                <span>{String(value)}</span>\n              )}\n            </div>\n          </div>\n        ))}\n      </div>\n    )\n  }\n\n  const canShowTable = Array.isArray(artifact.content) ||\n    (typeof artifact.content === 'object' && artifact.content !== null)\n\n  return createPortal(\n    <div\n      className={`fixed inset-0 z-[10000] flex items-center justify-center p-4 transition-all duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-labelledby=\"artifact-modal-title\"\n    >\n      {/* Backdrop */}\n      <div\n        className={`absolute inset-0 bg-gray-900/60 backdrop-blur-sm transition-opacity duration-200 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n        onClick={onClose}\n        aria-hidden=\"true\"\n      />\n\n      {/* Modal */}\n      <div\n        ref={modalRef}\n        className={`relative ${isFullscreen ? 'w-full h-full' : 'w-full max-w-4xl max-h-[90vh]'} overflow-hidden bg-white dark:bg-gray-900 rounded-2xl shadow-2xl transform transition-all duration-200 ${isVisible ? 'scale-100 opacity-100' : 'scale-95 opacity-0'} flex flex-col`}\n      >\n        {/* Header */}\n        <div className=\"sticky top-0 bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700 px-6 py-4 z-10\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-3\">\n              <span className={`px-2 py-1 rounded text-xs font-medium ${typeInfo.color}`}>\n                {typeInfo.label}\n              </span>\n              <div>\n                <h2 id=\"artifact-modal-title\" className=\"text-lg font-semibold text-gray-900 dark:text-gray-100\">\n                  {artifact.name}\n                </h2>\n                <p className=\"text-sm text-gray-500 mt-0.5\">\n                  From: {artifact.stepName}\n                  {artifact.itemCount && ` | ${artifact.itemCount} items`}\n                  {artifact.wordCount && ` | ${artifact.wordCount} words`}\n                </p>\n              </div>\n            </div>\n            <div className=\"flex items-center gap-2\">\n              <button\n                onClick={() => setIsFullscreen(!isFullscreen)}\n                className=\"p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors\"\n                title={isFullscreen ? 'Exit fullscreen' : 'Fullscreen'}\n              >\n                {isFullscreen ? <Minimize2 size={18} /> : <Maximize2 size={18} />}\n              </button>\n              <button\n                onClick={onClose}\n                className=\"p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors\"\n              >\n                <X size={20} />\n              </button>\n            </div>\n          </div>\n\n          {/* View mode tabs */}\n          <div className=\"flex items-center gap-2 mt-4\">\n            <button\n              onClick={() => setViewMode('preview')}\n              className={`flex items-center gap-1.5 px-3 py-1.5 text-sm rounded-lg transition-colors ${\n                viewMode === 'preview'\n                  ? 'bg-indigo-100 text-indigo-700 font-medium'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Eye size={14} />\n              Preview\n            </button>\n            {canShowTable && (\n              <button\n                onClick={() => setViewMode('table')}\n                className={`flex items-center gap-1.5 px-3 py-1.5 text-sm rounded-lg transition-colors ${\n                  viewMode === 'table'\n                    ? 'bg-indigo-100 text-indigo-700 font-medium'\n                    : 'text-gray-600 hover:bg-gray-100'\n                }`}\n              >\n                <Table size={14} />\n                Table\n              </button>\n            )}\n            <button\n              onClick={() => setViewMode('raw')}\n              className={`flex items-center gap-1.5 px-3 py-1.5 text-sm rounded-lg transition-colors ${\n                viewMode === 'raw'\n                  ? 'bg-indigo-100 text-indigo-700 font-medium'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Code size={14} />\n              Raw\n            </button>\n          </div>\n        </div>\n\n        {/* Content */}\n        <div className=\"flex-1 overflow-auto p-6\">\n          {renderContent()}\n        </div>\n\n        {/* Footer */}\n        <div className=\"sticky bottom-0 flex items-center justify-between gap-3 px-6 py-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/50\">\n          <div className=\"flex items-center gap-2\">\n            <button\n              onClick={handleCopy}\n              className=\"inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors\"\n            >\n              {copied ? (\n                <>\n                  <Check size={16} className=\"text-green-500\" />\n                  Copied!\n                </>\n              ) : (\n                <>\n                  <Copy size={16} />\n                  Copy\n                </>\n              )}\n            </button>\n          </div>\n\n          <div className=\"flex items-center gap-2\">\n            {onExport && canShowTable && (\n              <div className=\"relative group\">\n                <button className=\"inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors\">\n                  <Download size={16} />\n                  Export\n                  <ChevronDown size={14} />\n                </button>\n                <div className=\"absolute right-0 bottom-full mb-1 hidden group-hover:block bg-white border border-gray-200 rounded-lg shadow-lg py-1 min-w-[120px]\">\n                  <button\n                    onClick={() => onExport(artifact, 'csv')}\n                    className=\"w-full px-4 py-2 text-sm text-left text-gray-700 hover:bg-gray-100\"\n                  >\n                    Export as CSV\n                  </button>\n                  <button\n                    onClick={() => onExport(artifact, 'json')}\n                    className=\"w-full px-4 py-2 text-sm text-left text-gray-700 hover:bg-gray-100\"\n                  >\n                    Export as JSON\n                  </button>\n                </div>\n              </div>\n            )}\n\n            {onSaveToContextLake && (\n              <button\n                onClick={() => onSaveToContextLake(artifact)}\n                className=\"inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-gradient-to-r from-indigo-600 to-purple-600 rounded-lg hover:from-indigo-700 hover:to-purple-700 transition-all shadow-md\"\n              >\n                <Save size={16} />\n                Save to Context Lake\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>,\n    document.body\n  )\n}\n","structuredPatch":[],"originalFile":null}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LGfkpPJJ4rHi69gMwFkuTZ","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me create the main ArtifactBrowser component:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4927,"cache_read_input_tokens":103754,"cache_creation":{"ephemeral_5m_input_tokens":4927,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"9730960e-ea76-4d4b-a025-e8830362e869"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LGfkpPJJ4rHi69gMwFkuTZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q5z7d5L7uNiwBJAv8YTtbW","name":"Write","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx","content":"'use client'\n\nimport { useState, useCallback, useMemo } from 'react'\nimport {\n  Search,\n  ChevronDown,\n  ChevronRight,\n  Database,\n  FileText,\n  Download,\n  Save,\n  Filter,\n  X,\n  ExternalLink,\n  Loader2,\n  Package,\n  RefreshCw,\n  BarChart3,\n  Sparkles,\n  Lightbulb,\n  GitBranch,\n  Wand2,\n} from 'lucide-react'\nimport { Artifact, ArtifactGroup, ArtifactType, ARTIFACT_TYPE_LABELS } from './types'\nimport { useArtifacts } from './useArtifacts'\nimport ArtifactViewerModal from './ArtifactViewerModal'\nimport SaveToContextLakeModal, { StepOutputContext } from '@/components/documents/SaveToContextLakeModal'\nimport { useToast } from '@/components/ui/Toast/ToastContext'\n\n// Icon mapping for artifact types\nconst ICON_MAP: Record<string, React.ComponentType<{ size?: number; className?: string }>> = {\n  Search: Search,\n  FileText: FileText,\n  Database: Database,\n  Sparkles: Sparkles,\n  Wand2: Wand2,\n  BarChart3: BarChart3,\n  Lightbulb: Lightbulb,\n  GitBranch: GitBranch,\n  Package: Package,\n}\n\ninterface ArtifactBrowserProps {\n  sessionId?: string\n  projectId: string\n  clientId: string\n  userId: string\n  campaignId?: string\n  campaignName?: string\n  playbookId: string\n  playbookName: string\n  playbookType: string\n  allSteps?: Array<{\n    definition: { id: string; name: string }\n    state: { id: string; status: string; output?: unknown; input?: unknown }\n  }>\n  isVisible?: boolean\n  onClose?: () => void\n}\n\nexport default function ArtifactBrowser({\n  sessionId,\n  projectId,\n  clientId,\n  userId,\n  campaignId,\n  campaignName,\n  playbookId,\n  playbookName,\n  playbookType,\n  allSteps = [],\n  isVisible = true,\n  onClose,\n}: ArtifactBrowserProps) {\n  const toast = useToast()\n\n  const {\n    artifacts,\n    loading,\n    error,\n    filter,\n    setFilter,\n    filteredGroups,\n    refreshArtifacts,\n    getArtifactById,\n  } = useArtifacts({\n    sessionId,\n    projectId,\n    campaignId,\n    playbookType,\n    allSteps,\n  })\n\n  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set())\n  const [expandedArtifacts, setExpandedArtifacts] = useState<Set<string>>(new Set())\n  const [viewerOpen, setViewerOpen] = useState(false)\n  const [selectedArtifact, setSelectedArtifact] = useState<Artifact | null>(null)\n  const [saveModalOpen, setSaveModalOpen] = useState(false)\n  const [saveArtifact, setSaveArtifact] = useState<Artifact | null>(null)\n  const [showFilters, setShowFilters] = useState(false)\n\n  // Toggle group expansion\n  const toggleGroup = useCallback((groupType: string) => {\n    setExpandedGroups(prev => {\n      const next = new Set(prev)\n      if (next.has(groupType)) {\n        next.delete(groupType)\n      } else {\n        next.add(groupType)\n      }\n      return next\n    })\n  }, [])\n\n  // Toggle artifact expansion\n  const toggleArtifact = useCallback((artifactId: string) => {\n    setExpandedArtifacts(prev => {\n      const next = new Set(prev)\n      if (next.has(artifactId)) {\n        next.delete(artifactId)\n      } else {\n        next.add(artifactId)\n      }\n      return next\n    })\n  }, [])\n\n  // Open viewer modal\n  const handleViewArtifact = useCallback((artifact: Artifact) => {\n    setSelectedArtifact(artifact)\n    setViewerOpen(true)\n  }, [])\n\n  // Open save modal\n  const handleSaveToContextLake = useCallback((artifact: Artifact) => {\n    setSaveArtifact(artifact)\n    setSaveModalOpen(true)\n    setViewerOpen(false)\n  }, [])\n\n  // Handle save completion\n  const handleSaveComplete = useCallback((docId: string) => {\n    toast.success('Artifact saved to Context Lake')\n    setSaveModalOpen(false)\n    setSaveArtifact(null)\n\n    // Mark artifact as saved (in future, could update state)\n  }, [toast])\n\n  // Export artifact\n  const handleExport = useCallback((artifact: Artifact, format: 'csv' | 'json') => {\n    const content = artifact.content\n\n    let data: string\n    let filename: string\n    let mimeType: string\n\n    if (format === 'json') {\n      data = JSON.stringify(content, null, 2)\n      filename = `${artifact.name.replace(/\\s+/g, '_')}.json`\n      mimeType = 'application/json'\n    } else {\n      // CSV export\n      if (Array.isArray(content) && content.length > 0 && typeof content[0] === 'object') {\n        const headers = Object.keys(content[0] as Record<string, unknown>)\n        const rows = [\n          headers.join(','),\n          ...content.map(row => {\n            const r = row as Record<string, unknown>\n            return headers.map(h => {\n              const val = r[h]\n              if (val === null || val === undefined) return ''\n              if (typeof val === 'string') return `\"${val.replace(/\"/g, '\"\"')}\"`\n              return String(val)\n            }).join(',')\n          })\n        ]\n        data = rows.join('\\n')\n      } else {\n        data = typeof content === 'string' ? content : JSON.stringify(content)\n      }\n      filename = `${artifact.name.replace(/\\s+/g, '_')}.csv`\n      mimeType = 'text/csv'\n    }\n\n    const blob = new Blob([data], { type: mimeType })\n    const url = URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = filename\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    URL.revokeObjectURL(url)\n\n    toast.success(`Exported as ${format.toUpperCase()}`)\n  }, [toast])\n\n  // Get available step names for filter\n  const availableSteps = useMemo(() => {\n    const steps = new Map<string, string>()\n    filteredGroups.forEach(group => {\n      group.artifacts.forEach(artifact => {\n        steps.set(artifact.stepId, artifact.stepName)\n      })\n    })\n    return Array.from(steps.entries()).map(([id, name]) => ({ id, name }))\n  }, [filteredGroups])\n\n  // Get total count\n  const totalArtifacts = useMemo(() => {\n    return filteredGroups.reduce((sum, group) => sum + group.count, 0)\n  }, [filteredGroups])\n\n  if (!isVisible) return null\n\n  return (\n    <div className=\"flex flex-col h-full bg-white border-l border-gray-200\">\n      {/* Header */}\n      <div className=\"px-4 py-3 border-b border-gray-200 bg-gradient-to-r from-indigo-50 to-purple-50\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"p-2 bg-white rounded-lg shadow-sm\">\n              <Database size={18} className=\"text-indigo-600\" />\n            </div>\n            <div>\n              <h3 className=\"font-semibold text-gray-900\">Session Data</h3>\n              <p className=\"text-xs text-gray-500 mt-0.5\">\n                {totalArtifacts} artifacts from {artifacts?.totalSteps || 0} steps\n              </p>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <button\n              onClick={refreshArtifacts}\n              disabled={loading}\n              className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-white/50 rounded transition-colors\"\n              title=\"Refresh\"\n            >\n              <RefreshCw size={14} className={loading ? 'animate-spin' : ''} />\n            </button>\n            {onClose && (\n              <button\n                onClick={onClose}\n                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-white/50 rounded transition-colors\"\n              >\n                <X size={16} />\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Search and Filters */}\n      <div className=\"p-3 border-b border-gray-100 space-y-3\">\n        {/* Search */}\n        <div className=\"relative\">\n          <Search size={16} className=\"absolute left-3 top-1/2 -translate-y-1/2 text-gray-400\" />\n          <input\n            type=\"text\"\n            value={filter.searchQuery}\n            onChange={(e) => setFilter({ searchQuery: e.target.value })}\n            placeholder=\"Search artifacts...\"\n            className=\"w-full pl-9 pr-4 py-2 text-sm border border-gray-200 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500\"\n          />\n          {filter.searchQuery && (\n            <button\n              onClick={() => setFilter({ searchQuery: '' })}\n              className=\"absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600\"\n            >\n              <X size={14} />\n            </button>\n          )}\n        </div>\n\n        {/* Filter toggle */}\n        <button\n          onClick={() => setShowFilters(!showFilters)}\n          className={`flex items-center gap-2 text-sm ${\n            showFilters || filter.types.length > 0 || filter.stepIds.length > 0\n              ? 'text-indigo-600'\n              : 'text-gray-500'\n          } hover:text-indigo-700`}\n        >\n          <Filter size={14} />\n          Filters\n          {(filter.types.length > 0 || filter.stepIds.length > 0) && (\n            <span className=\"px-1.5 py-0.5 text-xs bg-indigo-100 text-indigo-700 rounded\">\n              {filter.types.length + filter.stepIds.length}\n            </span>\n          )}\n          {showFilters ? <ChevronDown size={14} /> : <ChevronRight size={14} />}\n        </button>\n\n        {/* Expanded filters */}\n        {showFilters && (\n          <div className=\"space-y-3 pt-2\">\n            {/* Type filter */}\n            <div>\n              <p className=\"text-xs font-medium text-gray-500 mb-2\">Artifact Type</p>\n              <div className=\"flex flex-wrap gap-1\">\n                {Object.entries(ARTIFACT_TYPE_LABELS).map(([type, info]) => (\n                  <button\n                    key={type}\n                    onClick={() => {\n                      const types = filter.types.includes(type as ArtifactType)\n                        ? filter.types.filter(t => t !== type)\n                        : [...filter.types, type as ArtifactType]\n                      setFilter({ types })\n                    }}\n                    className={`px-2 py-1 text-xs rounded transition-colors ${\n                      filter.types.includes(type as ArtifactType)\n                        ? 'bg-indigo-100 text-indigo-700'\n                        : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n                    }`}\n                  >\n                    {info.label}\n                  </button>\n                ))}\n              </div>\n            </div>\n\n            {/* Step filter */}\n            {availableSteps.length > 1 && (\n              <div>\n                <p className=\"text-xs font-medium text-gray-500 mb-2\">Step</p>\n                <div className=\"flex flex-wrap gap-1\">\n                  {availableSteps.map(step => (\n                    <button\n                      key={step.id}\n                      onClick={() => {\n                        const stepIds = filter.stepIds.includes(step.id)\n                          ? filter.stepIds.filter(id => id !== step.id)\n                          : [...filter.stepIds, step.id]\n                        setFilter({ stepIds })\n                      }}\n                      className={`px-2 py-1 text-xs rounded transition-colors ${\n                        filter.stepIds.includes(step.id)\n                          ? 'bg-indigo-100 text-indigo-700'\n                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n                      }`}\n                    >\n                      {step.name}\n                    </button>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {/* Clear filters */}\n            {(filter.types.length > 0 || filter.stepIds.length > 0) && (\n              <button\n                onClick={() => setFilter({ types: [], stepIds: [] })}\n                className=\"text-xs text-red-600 hover:text-red-700\"\n              >\n                Clear filters\n              </button>\n            )}\n          </div>\n        )}\n      </div>\n\n      {/* Content */}\n      <div className=\"flex-1 overflow-y-auto\">\n        {loading ? (\n          <div className=\"flex items-center justify-center py-12\">\n            <Loader2 className=\"w-6 h-6 text-indigo-500 animate-spin\" />\n          </div>\n        ) : error ? (\n          <div className=\"p-4 text-red-600 text-sm\">\n            <p>{error}</p>\n            <button\n              onClick={refreshArtifacts}\n              className=\"mt-2 text-indigo-600 hover:underline\"\n            >\n              Retry\n            </button>\n          </div>\n        ) : filteredGroups.length === 0 ? (\n          <div className=\"flex flex-col items-center justify-center py-12 text-gray-500\">\n            <Package size={40} className=\"text-gray-300 mb-3\" />\n            <p className=\"text-sm font-medium\">No artifacts found</p>\n            <p className=\"text-xs mt-1\">\n              {filter.searchQuery || filter.types.length > 0 || filter.stepIds.length > 0\n                ? 'Try adjusting your filters'\n                : 'Execute steps to generate data'}\n            </p>\n          </div>\n        ) : (\n          <div className=\"divide-y divide-gray-100\">\n            {filteredGroups.map(group => (\n              <ArtifactGroupComponent\n                key={group.type}\n                group={group}\n                isExpanded={expandedGroups.has(group.type)}\n                expandedArtifacts={expandedArtifacts}\n                onToggle={() => toggleGroup(group.type)}\n                onToggleArtifact={toggleArtifact}\n                onView={handleViewArtifact}\n                onSave={handleSaveToContextLake}\n                onExport={handleExport}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Artifact Viewer Modal */}\n      <ArtifactViewerModal\n        isOpen={viewerOpen}\n        artifact={selectedArtifact}\n        onClose={() => setViewerOpen(false)}\n        onSaveToContextLake={handleSaveToContextLake}\n        onExport={handleExport}\n      />\n\n      {/* Save to Context Lake Modal */}\n      {saveArtifact && (\n        <SaveToContextLakeModal\n          isOpen={saveModalOpen}\n          content={typeof saveArtifact.content === 'string'\n            ? saveArtifact.content\n            : JSON.stringify(saveArtifact.content, null, 2)}\n          projectId={projectId}\n          clientId={clientId}\n          userId={userId}\n          stepContext={{\n            stepId: saveArtifact.stepId,\n            stepName: saveArtifact.stepName,\n            stepOrder: saveArtifact.stepOrder,\n            campaignId: campaignId || '',\n            campaignName: campaignName || '',\n            playbookId,\n            playbookName,\n            wasEditedBeforeConversion: false,\n          }}\n          onSave={handleSaveComplete}\n          onClose={() => {\n            setSaveModalOpen(false)\n            setSaveArtifact(null)\n          }}\n        />\n      )}\n    </div>\n  )\n}\n\n// Artifact Group Component\ninterface ArtifactGroupComponentProps {\n  group: ArtifactGroup\n  isExpanded: boolean\n  expandedArtifacts: Set<string>\n  onToggle: () => void\n  onToggleArtifact: (id: string) => void\n  onView: (artifact: Artifact) => void\n  onSave: (artifact: Artifact) => void\n  onExport: (artifact: Artifact, format: 'csv' | 'json') => void\n}\n\nfunction ArtifactGroupComponent({\n  group,\n  isExpanded,\n  expandedArtifacts,\n  onToggle,\n  onToggleArtifact,\n  onView,\n  onSave,\n  onExport,\n}: ArtifactGroupComponentProps) {\n  const typeInfo = ARTIFACT_TYPE_LABELS[group.type]\n  const IconComponent = ICON_MAP[typeInfo.icon] || Package\n\n  return (\n    <div>\n      {/* Group Header */}\n      <button\n        onClick={onToggle}\n        className=\"w-full flex items-center gap-3 px-4 py-3 hover:bg-gray-50 transition-colors\"\n      >\n        {isExpanded ? (\n          <ChevronDown size={16} className=\"text-gray-400\" />\n        ) : (\n          <ChevronRight size={16} className=\"text-gray-400\" />\n        )}\n        <span className={`p-1.5 rounded ${typeInfo.color}`}>\n          <IconComponent size={14} />\n        </span>\n        <span className=\"font-medium text-gray-900 flex-1 text-left\">\n          {group.label}\n        </span>\n        <span className=\"text-sm text-gray-500\">{group.count}</span>\n      </button>\n\n      {/* Expanded Artifacts */}\n      {isExpanded && (\n        <div className=\"bg-gray-50 border-y border-gray-100\">\n          {group.artifacts.map(artifact => (\n            <ArtifactItem\n              key={artifact.id}\n              artifact={artifact}\n              isExpanded={expandedArtifacts.has(artifact.id)}\n              onToggle={() => onToggleArtifact(artifact.id)}\n              onView={() => onView(artifact)}\n              onSave={() => onSave(artifact)}\n              onExport={(format) => onExport(artifact, format)}\n            />\n          ))}\n        </div>\n      )}\n    </div>\n  )\n}\n\n// Individual Artifact Item\ninterface ArtifactItemProps {\n  artifact: Artifact\n  isExpanded: boolean\n  onToggle: () => void\n  onView: () => void\n  onSave: () => void\n  onExport: (format: 'csv' | 'json') => void\n}\n\nfunction ArtifactItem({\n  artifact,\n  isExpanded,\n  onToggle,\n  onView,\n  onSave,\n  onExport,\n}: ArtifactItemProps) {\n  const preview = useMemo(() => {\n    if (typeof artifact.content === 'string') {\n      return artifact.content.slice(0, 150) + (artifact.content.length > 150 ? '...' : '')\n    }\n    if (Array.isArray(artifact.content)) {\n      return `${artifact.content.length} items`\n    }\n    return 'Object data'\n  }, [artifact.content])\n\n  const canExportCsv = Array.isArray(artifact.content) && artifact.content.length > 0\n\n  return (\n    <div className=\"border-b border-gray-100 last:border-0\">\n      {/* Item Header */}\n      <div className=\"flex items-center gap-2 px-4 py-2.5 hover:bg-white/50\">\n        <button\n          onClick={onToggle}\n          className=\"p-1 text-gray-400 hover:text-gray-600\"\n        >\n          {isExpanded ? (\n            <ChevronDown size={14} />\n          ) : (\n            <ChevronRight size={14} />\n          )}\n        </button>\n        <div className=\"flex-1 min-w-0\">\n          <p className=\"text-sm font-medium text-gray-800 truncate\">\n            {artifact.name}\n          </p>\n          <p className=\"text-xs text-gray-500 truncate\">\n            {artifact.stepName}\n            {artifact.itemCount && ` · ${artifact.itemCount} items`}\n            {artifact.wordCount && ` · ${artifact.wordCount} words`}\n          </p>\n        </div>\n        <div className=\"flex items-center gap-1\">\n          <button\n            onClick={onView}\n            className=\"p-1.5 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 rounded transition-colors\"\n            title=\"View\"\n          >\n            <ExternalLink size={14} />\n          </button>\n          <button\n            onClick={onSave}\n            className=\"p-1.5 text-gray-400 hover:text-purple-600 hover:bg-purple-50 rounded transition-colors\"\n            title=\"Save to Context Lake\"\n          >\n            <Save size={14} />\n          </button>\n          <button\n            onClick={() => onExport(canExportCsv ? 'csv' : 'json')}\n            className=\"p-1.5 text-gray-400 hover:text-green-600 hover:bg-green-50 rounded transition-colors\"\n            title={`Export as ${canExportCsv ? 'CSV' : 'JSON'}`}\n          >\n            <Download size={14} />\n          </button>\n        </div>\n      </div>\n\n      {/* Expanded Preview */}\n      {isExpanded && (\n        <div className=\"px-4 py-3 bg-white border-t border-gray-100\">\n          <div className=\"text-xs text-gray-600 font-mono bg-gray-50 p-3 rounded max-h-32 overflow-auto\">\n            {typeof artifact.content === 'string' ? (\n              artifact.content.slice(0, 500)\n            ) : (\n              <pre>{JSON.stringify(artifact.content, null, 2).slice(0, 500)}</pre>\n            )}\n            {(typeof artifact.content === 'string' ? artifact.content.length : JSON.stringify(artifact.content).length) > 500 && (\n              <span className=\"text-gray-400\">... [more]</span>\n            )}\n          </div>\n          <div className=\"flex justify-end mt-2\">\n            <button\n              onClick={onView}\n              className=\"text-xs text-indigo-600 hover:text-indigo-700 hover:underline\"\n            >\n              View full content\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4927,"cache_read_input_tokens":103754,"cache_creation":{"ephemeral_5m_input_tokens":4927,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"83760d6a-9acc-4800-8f62-2703ebd6c9f0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q5z7d5L7uNiwBJAv8YTtbW","type":"tool_result","content":"File created successfully at: /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"4b4b169e-35a0-46a5-9bee-83c6b6b01d41","tool_use_result":{"type":"create","filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx","content":"'use client'\n\nimport { useState, useCallback, useMemo } from 'react'\nimport {\n  Search,\n  ChevronDown,\n  ChevronRight,\n  Database,\n  FileText,\n  Download,\n  Save,\n  Filter,\n  X,\n  ExternalLink,\n  Loader2,\n  Package,\n  RefreshCw,\n  BarChart3,\n  Sparkles,\n  Lightbulb,\n  GitBranch,\n  Wand2,\n} from 'lucide-react'\nimport { Artifact, ArtifactGroup, ArtifactType, ARTIFACT_TYPE_LABELS } from './types'\nimport { useArtifacts } from './useArtifacts'\nimport ArtifactViewerModal from './ArtifactViewerModal'\nimport SaveToContextLakeModal, { StepOutputContext } from '@/components/documents/SaveToContextLakeModal'\nimport { useToast } from '@/components/ui/Toast/ToastContext'\n\n// Icon mapping for artifact types\nconst ICON_MAP: Record<string, React.ComponentType<{ size?: number; className?: string }>> = {\n  Search: Search,\n  FileText: FileText,\n  Database: Database,\n  Sparkles: Sparkles,\n  Wand2: Wand2,\n  BarChart3: BarChart3,\n  Lightbulb: Lightbulb,\n  GitBranch: GitBranch,\n  Package: Package,\n}\n\ninterface ArtifactBrowserProps {\n  sessionId?: string\n  projectId: string\n  clientId: string\n  userId: string\n  campaignId?: string\n  campaignName?: string\n  playbookId: string\n  playbookName: string\n  playbookType: string\n  allSteps?: Array<{\n    definition: { id: string; name: string }\n    state: { id: string; status: string; output?: unknown; input?: unknown }\n  }>\n  isVisible?: boolean\n  onClose?: () => void\n}\n\nexport default function ArtifactBrowser({\n  sessionId,\n  projectId,\n  clientId,\n  userId,\n  campaignId,\n  campaignName,\n  playbookId,\n  playbookName,\n  playbookType,\n  allSteps = [],\n  isVisible = true,\n  onClose,\n}: ArtifactBrowserProps) {\n  const toast = useToast()\n\n  const {\n    artifacts,\n    loading,\n    error,\n    filter,\n    setFilter,\n    filteredGroups,\n    refreshArtifacts,\n    getArtifactById,\n  } = useArtifacts({\n    sessionId,\n    projectId,\n    campaignId,\n    playbookType,\n    allSteps,\n  })\n\n  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set())\n  const [expandedArtifacts, setExpandedArtifacts] = useState<Set<string>>(new Set())\n  const [viewerOpen, setViewerOpen] = useState(false)\n  const [selectedArtifact, setSelectedArtifact] = useState<Artifact | null>(null)\n  const [saveModalOpen, setSaveModalOpen] = useState(false)\n  const [saveArtifact, setSaveArtifact] = useState<Artifact | null>(null)\n  const [showFilters, setShowFilters] = useState(false)\n\n  // Toggle group expansion\n  const toggleGroup = useCallback((groupType: string) => {\n    setExpandedGroups(prev => {\n      const next = new Set(prev)\n      if (next.has(groupType)) {\n        next.delete(groupType)\n      } else {\n        next.add(groupType)\n      }\n      return next\n    })\n  }, [])\n\n  // Toggle artifact expansion\n  const toggleArtifact = useCallback((artifactId: string) => {\n    setExpandedArtifacts(prev => {\n      const next = new Set(prev)\n      if (next.has(artifactId)) {\n        next.delete(artifactId)\n      } else {\n        next.add(artifactId)\n      }\n      return next\n    })\n  }, [])\n\n  // Open viewer modal\n  const handleViewArtifact = useCallback((artifact: Artifact) => {\n    setSelectedArtifact(artifact)\n    setViewerOpen(true)\n  }, [])\n\n  // Open save modal\n  const handleSaveToContextLake = useCallback((artifact: Artifact) => {\n    setSaveArtifact(artifact)\n    setSaveModalOpen(true)\n    setViewerOpen(false)\n  }, [])\n\n  // Handle save completion\n  const handleSaveComplete = useCallback((docId: string) => {\n    toast.success('Artifact saved to Context Lake')\n    setSaveModalOpen(false)\n    setSaveArtifact(null)\n\n    // Mark artifact as saved (in future, could update state)\n  }, [toast])\n\n  // Export artifact\n  const handleExport = useCallback((artifact: Artifact, format: 'csv' | 'json') => {\n    const content = artifact.content\n\n    let data: string\n    let filename: string\n    let mimeType: string\n\n    if (format === 'json') {\n      data = JSON.stringify(content, null, 2)\n      filename = `${artifact.name.replace(/\\s+/g, '_')}.json`\n      mimeType = 'application/json'\n    } else {\n      // CSV export\n      if (Array.isArray(content) && content.length > 0 && typeof content[0] === 'object') {\n        const headers = Object.keys(content[0] as Record<string, unknown>)\n        const rows = [\n          headers.join(','),\n          ...content.map(row => {\n            const r = row as Record<string, unknown>\n            return headers.map(h => {\n              const val = r[h]\n              if (val === null || val === undefined) return ''\n              if (typeof val === 'string') return `\"${val.replace(/\"/g, '\"\"')}\"`\n              return String(val)\n            }).join(',')\n          })\n        ]\n        data = rows.join('\\n')\n      } else {\n        data = typeof content === 'string' ? content : JSON.stringify(content)\n      }\n      filename = `${artifact.name.replace(/\\s+/g, '_')}.csv`\n      mimeType = 'text/csv'\n    }\n\n    const blob = new Blob([data], { type: mimeType })\n    const url = URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = filename\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    URL.revokeObjectURL(url)\n\n    toast.success(`Exported as ${format.toUpperCase()}`)\n  }, [toast])\n\n  // Get available step names for filter\n  const availableSteps = useMemo(() => {\n    const steps = new Map<string, string>()\n    filteredGroups.forEach(group => {\n      group.artifacts.forEach(artifact => {\n        steps.set(artifact.stepId, artifact.stepName)\n      })\n    })\n    return Array.from(steps.entries()).map(([id, name]) => ({ id, name }))\n  }, [filteredGroups])\n\n  // Get total count\n  const totalArtifacts = useMemo(() => {\n    return filteredGroups.reduce((sum, group) => sum + group.count, 0)\n  }, [filteredGroups])\n\n  if (!isVisible) return null\n\n  return (\n    <div className=\"flex flex-col h-full bg-white border-l border-gray-200\">\n      {/* Header */}\n      <div className=\"px-4 py-3 border-b border-gray-200 bg-gradient-to-r from-indigo-50 to-purple-50\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"p-2 bg-white rounded-lg shadow-sm\">\n              <Database size={18} className=\"text-indigo-600\" />\n            </div>\n            <div>\n              <h3 className=\"font-semibold text-gray-900\">Session Data</h3>\n              <p className=\"text-xs text-gray-500 mt-0.5\">\n                {totalArtifacts} artifacts from {artifacts?.totalSteps || 0} steps\n              </p>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <button\n              onClick={refreshArtifacts}\n              disabled={loading}\n              className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-white/50 rounded transition-colors\"\n              title=\"Refresh\"\n            >\n              <RefreshCw size={14} className={loading ? 'animate-spin' : ''} />\n            </button>\n            {onClose && (\n              <button\n                onClick={onClose}\n                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-white/50 rounded transition-colors\"\n              >\n                <X size={16} />\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Search and Filters */}\n      <div className=\"p-3 border-b border-gray-100 space-y-3\">\n        {/* Search */}\n        <div className=\"relative\">\n          <Search size={16} className=\"absolute left-3 top-1/2 -translate-y-1/2 text-gray-400\" />\n          <input\n            type=\"text\"\n            value={filter.searchQuery}\n            onChange={(e) => setFilter({ searchQuery: e.target.value })}\n            placeholder=\"Search artifacts...\"\n            className=\"w-full pl-9 pr-4 py-2 text-sm border border-gray-200 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500\"\n          />\n          {filter.searchQuery && (\n            <button\n              onClick={() => setFilter({ searchQuery: '' })}\n              className=\"absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600\"\n            >\n              <X size={14} />\n            </button>\n          )}\n        </div>\n\n        {/* Filter toggle */}\n        <button\n          onClick={() => setShowFilters(!showFilters)}\n          className={`flex items-center gap-2 text-sm ${\n            showFilters || filter.types.length > 0 || filter.stepIds.length > 0\n              ? 'text-indigo-600'\n              : 'text-gray-500'\n          } hover:text-indigo-700`}\n        >\n          <Filter size={14} />\n          Filters\n          {(filter.types.length > 0 || filter.stepIds.length > 0) && (\n            <span className=\"px-1.5 py-0.5 text-xs bg-indigo-100 text-indigo-700 rounded\">\n              {filter.types.length + filter.stepIds.length}\n            </span>\n          )}\n          {showFilters ? <ChevronDown size={14} /> : <ChevronRight size={14} />}\n        </button>\n\n        {/* Expanded filters */}\n        {showFilters && (\n          <div className=\"space-y-3 pt-2\">\n            {/* Type filter */}\n            <div>\n              <p className=\"text-xs font-medium text-gray-500 mb-2\">Artifact Type</p>\n              <div className=\"flex flex-wrap gap-1\">\n                {Object.entries(ARTIFACT_TYPE_LABELS).map(([type, info]) => (\n                  <button\n                    key={type}\n                    onClick={() => {\n                      const types = filter.types.includes(type as ArtifactType)\n                        ? filter.types.filter(t => t !== type)\n                        : [...filter.types, type as ArtifactType]\n                      setFilter({ types })\n                    }}\n                    className={`px-2 py-1 text-xs rounded transition-colors ${\n                      filter.types.includes(type as ArtifactType)\n                        ? 'bg-indigo-100 text-indigo-700'\n                        : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n                    }`}\n                  >\n                    {info.label}\n                  </button>\n                ))}\n              </div>\n            </div>\n\n            {/* Step filter */}\n            {availableSteps.length > 1 && (\n              <div>\n                <p className=\"text-xs font-medium text-gray-500 mb-2\">Step</p>\n                <div className=\"flex flex-wrap gap-1\">\n                  {availableSteps.map(step => (\n                    <button\n                      key={step.id}\n                      onClick={() => {\n                        const stepIds = filter.stepIds.includes(step.id)\n                          ? filter.stepIds.filter(id => id !== step.id)\n                          : [...filter.stepIds, step.id]\n                        setFilter({ stepIds })\n                      }}\n                      className={`px-2 py-1 text-xs rounded transition-colors ${\n                        filter.stepIds.includes(step.id)\n                          ? 'bg-indigo-100 text-indigo-700'\n                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n                      }`}\n                    >\n                      {step.name}\n                    </button>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {/* Clear filters */}\n            {(filter.types.length > 0 || filter.stepIds.length > 0) && (\n              <button\n                onClick={() => setFilter({ types: [], stepIds: [] })}\n                className=\"text-xs text-red-600 hover:text-red-700\"\n              >\n                Clear filters\n              </button>\n            )}\n          </div>\n        )}\n      </div>\n\n      {/* Content */}\n      <div className=\"flex-1 overflow-y-auto\">\n        {loading ? (\n          <div className=\"flex items-center justify-center py-12\">\n            <Loader2 className=\"w-6 h-6 text-indigo-500 animate-spin\" />\n          </div>\n        ) : error ? (\n          <div className=\"p-4 text-red-600 text-sm\">\n            <p>{error}</p>\n            <button\n              onClick={refreshArtifacts}\n              className=\"mt-2 text-indigo-600 hover:underline\"\n            >\n              Retry\n            </button>\n          </div>\n        ) : filteredGroups.length === 0 ? (\n          <div className=\"flex flex-col items-center justify-center py-12 text-gray-500\">\n            <Package size={40} className=\"text-gray-300 mb-3\" />\n            <p className=\"text-sm font-medium\">No artifacts found</p>\n            <p className=\"text-xs mt-1\">\n              {filter.searchQuery || filter.types.length > 0 || filter.stepIds.length > 0\n                ? 'Try adjusting your filters'\n                : 'Execute steps to generate data'}\n            </p>\n          </div>\n        ) : (\n          <div className=\"divide-y divide-gray-100\">\n            {filteredGroups.map(group => (\n              <ArtifactGroupComponent\n                key={group.type}\n                group={group}\n                isExpanded={expandedGroups.has(group.type)}\n                expandedArtifacts={expandedArtifacts}\n                onToggle={() => toggleGroup(group.type)}\n                onToggleArtifact={toggleArtifact}\n                onView={handleViewArtifact}\n                onSave={handleSaveToContextLake}\n                onExport={handleExport}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Artifact Viewer Modal */}\n      <ArtifactViewerModal\n        isOpen={viewerOpen}\n        artifact={selectedArtifact}\n        onClose={() => setViewerOpen(false)}\n        onSaveToContextLake={handleSaveToContextLake}\n        onExport={handleExport}\n      />\n\n      {/* Save to Context Lake Modal */}\n      {saveArtifact && (\n        <SaveToContextLakeModal\n          isOpen={saveModalOpen}\n          content={typeof saveArtifact.content === 'string'\n            ? saveArtifact.content\n            : JSON.stringify(saveArtifact.content, null, 2)}\n          projectId={projectId}\n          clientId={clientId}\n          userId={userId}\n          stepContext={{\n            stepId: saveArtifact.stepId,\n            stepName: saveArtifact.stepName,\n            stepOrder: saveArtifact.stepOrder,\n            campaignId: campaignId || '',\n            campaignName: campaignName || '',\n            playbookId,\n            playbookName,\n            wasEditedBeforeConversion: false,\n          }}\n          onSave={handleSaveComplete}\n          onClose={() => {\n            setSaveModalOpen(false)\n            setSaveArtifact(null)\n          }}\n        />\n      )}\n    </div>\n  )\n}\n\n// Artifact Group Component\ninterface ArtifactGroupComponentProps {\n  group: ArtifactGroup\n  isExpanded: boolean\n  expandedArtifacts: Set<string>\n  onToggle: () => void\n  onToggleArtifact: (id: string) => void\n  onView: (artifact: Artifact) => void\n  onSave: (artifact: Artifact) => void\n  onExport: (artifact: Artifact, format: 'csv' | 'json') => void\n}\n\nfunction ArtifactGroupComponent({\n  group,\n  isExpanded,\n  expandedArtifacts,\n  onToggle,\n  onToggleArtifact,\n  onView,\n  onSave,\n  onExport,\n}: ArtifactGroupComponentProps) {\n  const typeInfo = ARTIFACT_TYPE_LABELS[group.type]\n  const IconComponent = ICON_MAP[typeInfo.icon] || Package\n\n  return (\n    <div>\n      {/* Group Header */}\n      <button\n        onClick={onToggle}\n        className=\"w-full flex items-center gap-3 px-4 py-3 hover:bg-gray-50 transition-colors\"\n      >\n        {isExpanded ? (\n          <ChevronDown size={16} className=\"text-gray-400\" />\n        ) : (\n          <ChevronRight size={16} className=\"text-gray-400\" />\n        )}\n        <span className={`p-1.5 rounded ${typeInfo.color}`}>\n          <IconComponent size={14} />\n        </span>\n        <span className=\"font-medium text-gray-900 flex-1 text-left\">\n          {group.label}\n        </span>\n        <span className=\"text-sm text-gray-500\">{group.count}</span>\n      </button>\n\n      {/* Expanded Artifacts */}\n      {isExpanded && (\n        <div className=\"bg-gray-50 border-y border-gray-100\">\n          {group.artifacts.map(artifact => (\n            <ArtifactItem\n              key={artifact.id}\n              artifact={artifact}\n              isExpanded={expandedArtifacts.has(artifact.id)}\n              onToggle={() => onToggleArtifact(artifact.id)}\n              onView={() => onView(artifact)}\n              onSave={() => onSave(artifact)}\n              onExport={(format) => onExport(artifact, format)}\n            />\n          ))}\n        </div>\n      )}\n    </div>\n  )\n}\n\n// Individual Artifact Item\ninterface ArtifactItemProps {\n  artifact: Artifact\n  isExpanded: boolean\n  onToggle: () => void\n  onView: () => void\n  onSave: () => void\n  onExport: (format: 'csv' | 'json') => void\n}\n\nfunction ArtifactItem({\n  artifact,\n  isExpanded,\n  onToggle,\n  onView,\n  onSave,\n  onExport,\n}: ArtifactItemProps) {\n  const preview = useMemo(() => {\n    if (typeof artifact.content === 'string') {\n      return artifact.content.slice(0, 150) + (artifact.content.length > 150 ? '...' : '')\n    }\n    if (Array.isArray(artifact.content)) {\n      return `${artifact.content.length} items`\n    }\n    return 'Object data'\n  }, [artifact.content])\n\n  const canExportCsv = Array.isArray(artifact.content) && artifact.content.length > 0\n\n  return (\n    <div className=\"border-b border-gray-100 last:border-0\">\n      {/* Item Header */}\n      <div className=\"flex items-center gap-2 px-4 py-2.5 hover:bg-white/50\">\n        <button\n          onClick={onToggle}\n          className=\"p-1 text-gray-400 hover:text-gray-600\"\n        >\n          {isExpanded ? (\n            <ChevronDown size={14} />\n          ) : (\n            <ChevronRight size={14} />\n          )}\n        </button>\n        <div className=\"flex-1 min-w-0\">\n          <p className=\"text-sm font-medium text-gray-800 truncate\">\n            {artifact.name}\n          </p>\n          <p className=\"text-xs text-gray-500 truncate\">\n            {artifact.stepName}\n            {artifact.itemCount && ` · ${artifact.itemCount} items`}\n            {artifact.wordCount && ` · ${artifact.wordCount} words`}\n          </p>\n        </div>\n        <div className=\"flex items-center gap-1\">\n          <button\n            onClick={onView}\n            className=\"p-1.5 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 rounded transition-colors\"\n            title=\"View\"\n          >\n            <ExternalLink size={14} />\n          </button>\n          <button\n            onClick={onSave}\n            className=\"p-1.5 text-gray-400 hover:text-purple-600 hover:bg-purple-50 rounded transition-colors\"\n            title=\"Save to Context Lake\"\n          >\n            <Save size={14} />\n          </button>\n          <button\n            onClick={() => onExport(canExportCsv ? 'csv' : 'json')}\n            className=\"p-1.5 text-gray-400 hover:text-green-600 hover:bg-green-50 rounded transition-colors\"\n            title={`Export as ${canExportCsv ? 'CSV' : 'JSON'}`}\n          >\n            <Download size={14} />\n          </button>\n        </div>\n      </div>\n\n      {/* Expanded Preview */}\n      {isExpanded && (\n        <div className=\"px-4 py-3 bg-white border-t border-gray-100\">\n          <div className=\"text-xs text-gray-600 font-mono bg-gray-50 p-3 rounded max-h-32 overflow-auto\">\n            {typeof artifact.content === 'string' ? (\n              artifact.content.slice(0, 500)\n            ) : (\n              <pre>{JSON.stringify(artifact.content, null, 2).slice(0, 500)}</pre>\n            )}\n            {(typeof artifact.content === 'string' ? artifact.content.length : JSON.stringify(artifact.content).length) > 500 && (\n              <span className=\"text-gray-400\">... [more]</span>\n            )}\n          </div>\n          <div className=\"flex justify-end mt-2\">\n            <button\n              onClick={onView}\n              className=\"text-xs text-indigo-600 hover:text-indigo-700 hover:underline\"\n            >\n              View full content\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n","structuredPatch":[],"originalFile":null}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KBXuA3NVE4Tf1KhtrXEfwg","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me create the index file to export the components:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":6372,"cache_read_input_tokens":108681,"cache_creation":{"ephemeral_5m_input_tokens":6372,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"cb565874-0d61-464d-bcef-a90a147cedff"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KBXuA3NVE4Tf1KhtrXEfwg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GBcw9HW31Ri71AqFMBG8tv","name":"Write","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/index.ts","content":"export { default as ArtifactBrowser } from './ArtifactBrowser'\nexport { default as ArtifactViewerModal } from './ArtifactViewerModal'\nexport { useArtifacts } from './useArtifacts'\nexport * from './types'\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":6372,"cache_read_input_tokens":108681,"cache_creation":{"ephemeral_5m_input_tokens":6372,"ephemeral_1h_input_tokens":0},"output_tokens":188,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"7a15eb48-4eaa-48c1-8b18-e44167162b91"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GBcw9HW31Ri71AqFMBG8tv","type":"tool_result","content":"File created successfully at: /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/index.ts"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"a453764a-9dd8-4633-a8f2-610aadb53ed7","tool_use_result":{"type":"create","filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/index.ts","content":"export { default as ArtifactBrowser } from './ArtifactBrowser'\nexport { default as ArtifactViewerModal } from './ArtifactViewerModal'\nexport { useArtifacts } from './useArtifacts'\nexport * from './types'\n","structuredPatch":[],"originalFile":null}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RfdzChyxbyYJez6mXX4kXu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NAE3oHMYD4qKSbzJEi5cUg","name":"TodoWrite","input":{"todos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"completed","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"completed","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"completed","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"completed","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"completed","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"completed","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"completed","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Integrate ArtifactBrowser into PlaybookShell","status":"in_progress","activeForm":"Integrating ArtifactBrowser into PlaybookShell"},{"content":"Run quality checks","status":"pending","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":244,"cache_read_input_tokens":115053,"cache_creation":{"ephemeral_5m_input_tokens":244,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"561dba97-d524-427a-b498-07858d5f1a8f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NAE3oHMYD4qKSbzJEi5cUg","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"b5e3de74-7340-42f9-80da-ffe92d9e8698","tool_use_result":{"oldTodos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"in_progress","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"pending","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"pending","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"pending","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"pending","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"pending","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"pending","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Run quality checks","status":"pending","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"completed","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"completed","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"completed","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"completed","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"completed","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"completed","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"completed","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Integrate ArtifactBrowser into PlaybookShell","status":"in_progress","activeForm":"Integrating ArtifactBrowser into PlaybookShell"},{"content":"Run quality checks","status":"pending","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014DcQiaz7nWN8vGvhzv2mPe","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to integrate the ArtifactBrowser into the PlaybookShell. Let me read more of the PlaybookShell to understand the UI structure:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":440,"cache_read_input_tokens":115297,"cache_creation":{"ephemeral_5m_input_tokens":440,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"a042b427-c5ba-4811-adfd-f592af37d668"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014DcQiaz7nWN8vGvhzv2mPe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WPqr34o2rpfuvZBkJvZxgj","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","offset":700,"limit":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":440,"cache_read_input_tokens":115297,"cache_creation":{"ephemeral_5m_input_tokens":440,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"2b9abe7b-db25-4262-850a-da286bcf071f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WPqr34o2rpfuvZBkJvZxgj","type":"tool_result","content":"   700→  }, [selectedCampaignId, state, savePlaybookState])\n   701→\n   702→  // Go to next step\n   703→  const goToNextStep = useCallback(() => {\n   704→    setState(prev => {\n   705→      const currentPhase = playbookConfig.phases[prev.currentPhaseIndex]\n   706→\n   707→      // Check if there's a next step in current phase\n   708→      if (prev.currentStepIndex < currentPhase.steps.length - 1) {\n   709→        return {\n   710→          ...prev,\n   711→          currentStepIndex: prev.currentStepIndex + 1,\n   712→        }\n   713→      }\n   714→\n   715→      // Check if there's a next phase\n   716→      if (prev.currentPhaseIndex < playbookConfig.phases.length - 1) {\n   717→        return {\n   718→          ...prev,\n   719→          currentPhaseIndex: prev.currentPhaseIndex + 1,\n   720→          currentStepIndex: 0,\n   721→        }\n   722→      }\n   723→\n   724→      // Already at the end\n   725→      return prev\n   726→    })\n   727→  }, [playbookConfig.phases])\n   728→\n   729→  // Go to previous step\n   730→  const goToPreviousStep = useCallback(() => {\n   731→    setState(prev => {\n   732→      // Check if there's a previous step in current phase\n   733→      if (prev.currentStepIndex > 0) {\n   734→        return {\n   735→          ...prev,\n   736→          currentStepIndex: prev.currentStepIndex - 1,\n   737→        }\n   738→      }\n   739→\n   740→      // Check if there's a previous phase\n   741→      if (prev.currentPhaseIndex > 0) {\n   742→        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n   743→        return {\n   744→          ...prev,\n   745→          currentPhaseIndex: prev.currentPhaseIndex - 1,\n   746→          currentStepIndex: prevPhase.steps.length - 1,\n   747→        }\n   748→      }\n   749→\n   750→      // Already at the beginning\n   751→      return prev\n   752→    })\n   753→  }, [playbookConfig.phases])\n   754→\n   755→  // Re-run the previous step (go back and reset its state to pending)\n   756→  const rerunPreviousStep = useCallback(() => {\n   757→    setState(prev => {\n   758→      let newPhaseIndex = prev.currentPhaseIndex\n   759→      let newStepIndex = prev.currentStepIndex\n   760→\n   761→      // Find previous step\n   762→      if (prev.currentStepIndex > 0) {\n   763→        newStepIndex = prev.currentStepIndex - 1\n   764→      } else if (prev.currentPhaseIndex > 0) {\n   765→        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n   766→        newPhaseIndex = prev.currentPhaseIndex - 1\n   767→        newStepIndex = prevPhase.steps.length - 1\n   768→      } else {\n   769→        // Already at the beginning, nothing to rerun\n   770→        return prev\n   771→      }\n   772→\n   773→      // Get the previous step ID\n   774→      const prevStepId = playbookConfig.phases[newPhaseIndex].steps[newStepIndex].id\n   775→\n   776→      // Reset the previous step state to pending and navigate to it\n   777→      const newPhases = prev.phases.map((phase, pi) => ({\n   778→        ...phase,\n   779→        steps: phase.steps.map((step, si) => {\n   780→          if (pi === newPhaseIndex && si === newStepIndex) {\n   781→            return {\n   782→              ...step,\n   783→              status: 'pending' as const,\n   784→              output: undefined,\n   785→              error: undefined,\n   786→            }\n   787→          }\n   788→          return step\n   789→        }),\n   790→      }))\n   791→\n   792→      return {\n   793→        ...prev,\n   794→        phases: newPhases,\n   795→        currentPhaseIndex: newPhaseIndex,\n   796→        currentStepIndex: newStepIndex,\n   797→      }\n   798→    })\n   799→    // Trigger auto-execute after navigating\n   800→    setShouldAutoExecute(true)\n   801→  }, [playbookConfig.phases])\n   802→\n   803→  // Update step state\n   804→  const updateStepState = useCallback(\n   805→    (stepId: string, update: Partial<StepState>) => {\n   806→      console.log('[updateStepState] Updating step:', stepId, 'with:', {\n   807→        ...update,\n   808→        output: update.output ? `[output with keys: ${Object.keys(update.output as object).join(', ')}]` : undefined,\n   809→      })\n   810→\n   811→      // Persist step changes to database (if sessionId is provided)\n   812→      if (sessionId) {\n   813→        // Handle status-specific persistence\n   814→        if (update.status === 'in_progress') {\n   815→          stepPersistenceActions.markStepRunning(stepId, update.input)\n   816→        } else if (update.status === 'completed') {\n   817→          stepPersistenceActions.markStepCompleted(stepId, update.output)\n   818→        } else if (update.status === 'error') {\n   819→          stepPersistenceActions.markStepFailed(stepId, update.error || 'Unknown error')\n   820→        } else if (update.output !== undefined) {\n   821→          // For output-only updates (during execution), schedule auto-save\n   822→          stepPersistenceActions.scheduleAutoSave(stepId, update.output)\n   823→        }\n   824→      }\n   825→\n   826→      setState(prev => {\n   827→        // Find the current step to log what we're merging\n   828→        const currentStep = prev.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n   829→        if (stepId === 'keyword_config') {\n   830→          console.log('[updateStepState] keyword_config before merge:', {\n   831→            status: currentStep?.status,\n   832→            hasOutput: !!currentStep?.output,\n   833→            outputKeys: currentStep?.output ? Object.keys(currentStep.output as object) : [],\n   834→          })\n   835→        }\n   836→\n   837→        const newPhases = prev.phases.map(phase => ({\n   838→          ...phase,\n   839→          steps: phase.steps.map(step =>\n   840→            step.id === stepId ? { ...step, ...update } : step\n   841→          ),\n   842→        }))\n   843→\n   844→        // Log the merged result for keyword_config\n   845→        if (stepId === 'keyword_config') {\n   846→          const mergedStep = newPhases.flatMap(p => p.steps).find(s => s.id === stepId)\n   847→          console.log('[updateStepState] keyword_config after merge:', {\n   848→            status: mergedStep?.status,\n   849→            hasOutput: !!mergedStep?.output,\n   850→            outputKeys: mergedStep?.output ? Object.keys(mergedStep.output as object) : [],\n   851→          })\n   852→        }\n   853→\n   854→        // Recalculate phase status\n   855→        newPhases.forEach(phase => {\n   856→          const hasError = phase.steps.some(s => s.status === 'error')\n   857→          const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n   858→          const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n   859→\n   860→          if (hasError) {\n   861→            phase.status = 'error'\n   862→          } else if (allCompleted) {\n   863→            phase.status = 'completed'\n   864→          } else if (hasInProgress) {\n   865→            phase.status = 'in_progress'\n   866→          } else {\n   867→            phase.status = 'pending'\n   868→          }\n   869→        })\n   870→\n   871→        // Recalculate completed steps\n   872→        const completedSteps = newPhases.reduce(\n   873→          (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n   874→          0\n   875→        )\n   876→\n   877→        return {\n   878→          ...prev,\n   879→          phases: newPhases,\n   880→          completedSteps,\n   881→        }\n   882→      })\n   883→    },\n   884→    [sessionId, stepPersistenceActions]\n   885→  )\n   886→\n   887→  // Execute a step\n   888→  const executeStep = useCallback(\n   889→    async (stepId: string, input?: any) => {\n   890→      console.log('[executeStep] Starting execution for step:', stepId, 'with input:', input)\n   891→\n   892→      const step = playbookConfig.phases\n   893→        .flatMap(p => p.steps)\n   894→        .find(s => s.id === stepId)\n   895→\n   896→      if (!step) {\n   897→        console.error('[executeStep] Step not found:', stepId)\n   898→        return\n   899→      }\n   900→\n   901→      console.log('[executeStep] Found step:', step.id, 'type:', step.type, 'executor:', step.executor, 'jobType:', step.jobType)\n   902→\n   903→      // Mark as in progress\n   904→      updateStepState(stepId, {\n   905→        status: 'in_progress',\n   906→        startedAt: new Date(),\n   907→        input,\n   908→      })\n   909→\n   910→      try {\n   911→        let result: any\n   912→\n   913→        // Special case: Execute extraction from scrape_results step\n   914→        if (step.id === 'scrape_results' && input?.action === 'extract' && input?.jobId) {\n   915→          console.log('[EXTRACT from scrape_results] Starting extraction for job:', input.jobId)\n   916→          const jobId = input.jobId\n   917→\n   918→          updateStepState(stepId, {\n   919→            output: { jobId },\n   920→            progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' },\n   921→            partialResults: { extracted: 0, filtered: 0 },\n   922→          })\n   923→\n   924→          // Get total URLs to extract from job status\n   925→          const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n   926→          const statusData = await statusResponse.json()\n   927→          const scrapedUrlCount = statusData.url_counts?.scraped || 0\n   928→          const totalUrls = scrapedUrlCount || statusData.job?.urls_scraped || 0\n   929→          const existingExtractedCount = statusData.job?.niches_extracted || 0\n   930→          const existingFilteredCount = statusData.url_counts?.filtered || 0\n   931→\n   932→          console.log('[EXTRACT] Status check:', {\n   933→            scrapedUrlCount,\n   934→            totalUrls,\n   935→            existingExtractedCount,\n   936→            existingFilteredCount,\n   937→            jobStatus: statusData.job?.status,\n   938→            urlsFailed: statusData.url_counts?.failed || 0,\n   939→          })\n   940→\n   941→          // Check if there's nothing to extract (all URLs failed or filtered)\n   942→          if (scrapedUrlCount === 0 && existingExtractedCount === 0) {\n   943→            const failedCount = statusData.url_counts?.failed || 0\n   944→            console.log('[EXTRACT] No URLs to extract and no existing results. Failed:', failedCount, 'Filtered:', existingFilteredCount)\n   945→\n   946→            // Show error state - nothing to extract\n   947→            updateStepState(stepId, {\n   948→              status: 'error',\n   949→              completedAt: new Date(),\n   950→              output: {\n   951→                jobId,\n   952→                extractedCount: 0,\n   953→                filteredCount: existingFilteredCount,\n   954→                error: failedCount > 0\n   955→                  ? `El scraping falló para ${failedCount} URLs (posible bloqueo de Reddit API). No hay contenido disponible para extraer.`\n   956→                  : 'No hay URLs disponibles para extraer. Verifica que el scraping se completó correctamente.',\n   957→              },\n   958→              progress: undefined,\n   959→            })\n   960→\n   961→            return // Stop - nothing to do\n   962→          }\n   963→\n   964→          // Check if extraction was already done (no URLs to process but results exist)\n   965→          if (scrapedUrlCount === 0 && existingExtractedCount > 0) {\n   966→            console.log('[EXTRACT] Extraction already completed, using existing results')\n   967→            updateStepState(stepId, {\n   968→              progress: { current: 100, total: 100, label: `Usando resultados existentes: ${existingExtractedCount} problemas encontrados` },\n   969→            })\n   970→\n   971→            // Skip extraction loop and jump to results fetching\n   972→            // Get extracted niches for CSV content\n   973→            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n   974→            const resultsData = await resultsResponse.json()\n   975→            const niches = resultsData.niches || []\n   976→\n   977→            // Build CSV content\n   978→            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n   979→            for (const niche of niches) {\n   980→              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n   981→              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n   982→              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n   983→              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n   984→              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n   985→              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n   986→              const url = niche.source_url || ''\n   987→              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n   988→            }\n   989→\n   990→            // Mark scrape_results as completed\n   991→            updateStepState(stepId, {\n   992→              status: 'completed',\n   993→              completedAt: new Date(),\n   994→              output: {\n   995→                jobId,\n   996→                extractedCount: existingExtractedCount,\n   997→                filteredCount: existingFilteredCount,\n   998→              },\n   999→              progress: undefined,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"a50adb23-b4c6-436d-8a96-1c75fe95a69a","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","content":"  }, [selectedCampaignId, state, savePlaybookState])\n\n  // Go to next step\n  const goToNextStep = useCallback(() => {\n    setState(prev => {\n      const currentPhase = playbookConfig.phases[prev.currentPhaseIndex]\n\n      // Check if there's a next step in current phase\n      if (prev.currentStepIndex < currentPhase.steps.length - 1) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex + 1,\n        }\n      }\n\n      // Check if there's a next phase\n      if (prev.currentPhaseIndex < playbookConfig.phases.length - 1) {\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex + 1,\n          currentStepIndex: 0,\n        }\n      }\n\n      // Already at the end\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Go to previous step\n  const goToPreviousStep = useCallback(() => {\n    setState(prev => {\n      // Check if there's a previous step in current phase\n      if (prev.currentStepIndex > 0) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex - 1,\n        }\n      }\n\n      // Check if there's a previous phase\n      if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex - 1,\n          currentStepIndex: prevPhase.steps.length - 1,\n        }\n      }\n\n      // Already at the beginning\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Re-run the previous step (go back and reset its state to pending)\n  const rerunPreviousStep = useCallback(() => {\n    setState(prev => {\n      let newPhaseIndex = prev.currentPhaseIndex\n      let newStepIndex = prev.currentStepIndex\n\n      // Find previous step\n      if (prev.currentStepIndex > 0) {\n        newStepIndex = prev.currentStepIndex - 1\n      } else if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        newPhaseIndex = prev.currentPhaseIndex - 1\n        newStepIndex = prevPhase.steps.length - 1\n      } else {\n        // Already at the beginning, nothing to rerun\n        return prev\n      }\n\n      // Get the previous step ID\n      const prevStepId = playbookConfig.phases[newPhaseIndex].steps[newStepIndex].id\n\n      // Reset the previous step state to pending and navigate to it\n      const newPhases = prev.phases.map((phase, pi) => ({\n        ...phase,\n        steps: phase.steps.map((step, si) => {\n          if (pi === newPhaseIndex && si === newStepIndex) {\n            return {\n              ...step,\n              status: 'pending' as const,\n              output: undefined,\n              error: undefined,\n            }\n          }\n          return step\n        }),\n      }))\n\n      return {\n        ...prev,\n        phases: newPhases,\n        currentPhaseIndex: newPhaseIndex,\n        currentStepIndex: newStepIndex,\n      }\n    })\n    // Trigger auto-execute after navigating\n    setShouldAutoExecute(true)\n  }, [playbookConfig.phases])\n\n  // Update step state\n  const updateStepState = useCallback(\n    (stepId: string, update: Partial<StepState>) => {\n      console.log('[updateStepState] Updating step:', stepId, 'with:', {\n        ...update,\n        output: update.output ? `[output with keys: ${Object.keys(update.output as object).join(', ')}]` : undefined,\n      })\n\n      // Persist step changes to database (if sessionId is provided)\n      if (sessionId) {\n        // Handle status-specific persistence\n        if (update.status === 'in_progress') {\n          stepPersistenceActions.markStepRunning(stepId, update.input)\n        } else if (update.status === 'completed') {\n          stepPersistenceActions.markStepCompleted(stepId, update.output)\n        } else if (update.status === 'error') {\n          stepPersistenceActions.markStepFailed(stepId, update.error || 'Unknown error')\n        } else if (update.output !== undefined) {\n          // For output-only updates (during execution), schedule auto-save\n          stepPersistenceActions.scheduleAutoSave(stepId, update.output)\n        }\n      }\n\n      setState(prev => {\n        // Find the current step to log what we're merging\n        const currentStep = prev.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n        if (stepId === 'keyword_config') {\n          console.log('[updateStepState] keyword_config before merge:', {\n            status: currentStep?.status,\n            hasOutput: !!currentStep?.output,\n            outputKeys: currentStep?.output ? Object.keys(currentStep.output as object) : [],\n          })\n        }\n\n        const newPhases = prev.phases.map(phase => ({\n          ...phase,\n          steps: phase.steps.map(step =>\n            step.id === stepId ? { ...step, ...update } : step\n          ),\n        }))\n\n        // Log the merged result for keyword_config\n        if (stepId === 'keyword_config') {\n          const mergedStep = newPhases.flatMap(p => p.steps).find(s => s.id === stepId)\n          console.log('[updateStepState] keyword_config after merge:', {\n            status: mergedStep?.status,\n            hasOutput: !!mergedStep?.output,\n            outputKeys: mergedStep?.output ? Object.keys(mergedStep.output as object) : [],\n          })\n        }\n\n        // Recalculate phase status\n        newPhases.forEach(phase => {\n          const hasError = phase.steps.some(s => s.status === 'error')\n          const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n          const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n          if (hasError) {\n            phase.status = 'error'\n          } else if (allCompleted) {\n            phase.status = 'completed'\n          } else if (hasInProgress) {\n            phase.status = 'in_progress'\n          } else {\n            phase.status = 'pending'\n          }\n        })\n\n        // Recalculate completed steps\n        const completedSteps = newPhases.reduce(\n          (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n          0\n        )\n\n        return {\n          ...prev,\n          phases: newPhases,\n          completedSteps,\n        }\n      })\n    },\n    [sessionId, stepPersistenceActions]\n  )\n\n  // Execute a step\n  const executeStep = useCallback(\n    async (stepId: string, input?: any) => {\n      console.log('[executeStep] Starting execution for step:', stepId, 'with input:', input)\n\n      const step = playbookConfig.phases\n        .flatMap(p => p.steps)\n        .find(s => s.id === stepId)\n\n      if (!step) {\n        console.error('[executeStep] Step not found:', stepId)\n        return\n      }\n\n      console.log('[executeStep] Found step:', step.id, 'type:', step.type, 'executor:', step.executor, 'jobType:', step.jobType)\n\n      // Mark as in progress\n      updateStepState(stepId, {\n        status: 'in_progress',\n        startedAt: new Date(),\n        input,\n      })\n\n      try {\n        let result: any\n\n        // Special case: Execute extraction from scrape_results step\n        if (step.id === 'scrape_results' && input?.action === 'extract' && input?.jobId) {\n          console.log('[EXTRACT from scrape_results] Starting extraction for job:', input.jobId)\n          const jobId = input.jobId\n\n          updateStepState(stepId, {\n            output: { jobId },\n            progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' },\n            partialResults: { extracted: 0, filtered: 0 },\n          })\n\n          // Get total URLs to extract from job status\n          const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          const statusData = await statusResponse.json()\n          const scrapedUrlCount = statusData.url_counts?.scraped || 0\n          const totalUrls = scrapedUrlCount || statusData.job?.urls_scraped || 0\n          const existingExtractedCount = statusData.job?.niches_extracted || 0\n          const existingFilteredCount = statusData.url_counts?.filtered || 0\n\n          console.log('[EXTRACT] Status check:', {\n            scrapedUrlCount,\n            totalUrls,\n            existingExtractedCount,\n            existingFilteredCount,\n            jobStatus: statusData.job?.status,\n            urlsFailed: statusData.url_counts?.failed || 0,\n          })\n\n          // Check if there's nothing to extract (all URLs failed or filtered)\n          if (scrapedUrlCount === 0 && existingExtractedCount === 0) {\n            const failedCount = statusData.url_counts?.failed || 0\n            console.log('[EXTRACT] No URLs to extract and no existing results. Failed:', failedCount, 'Filtered:', existingFilteredCount)\n\n            // Show error state - nothing to extract\n            updateStepState(stepId, {\n              status: 'error',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: 0,\n                filteredCount: existingFilteredCount,\n                error: failedCount > 0\n                  ? `El scraping falló para ${failedCount} URLs (posible bloqueo de Reddit API). No hay contenido disponible para extraer.`\n                  : 'No hay URLs disponibles para extraer. Verifica que el scraping se completó correctamente.',\n              },\n              progress: undefined,\n            })\n\n            return // Stop - nothing to do\n          }\n\n          // Check if extraction was already done (no URLs to process but results exist)\n          if (scrapedUrlCount === 0 && existingExtractedCount > 0) {\n            console.log('[EXTRACT] Extraction already completed, using existing results')\n            updateStepState(stepId, {\n              progress: { current: 100, total: 100, label: `Usando resultados existentes: ${existingExtractedCount} problemas encontrados` },\n            })\n\n            // Skip extraction loop and jump to results fetching\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // Mark scrape_results as completed\n            updateStepState(stepId, {\n              status: 'completed',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: existingExtractedCount,\n                filteredCount: existingFilteredCount,\n              },\n              progress: undefined,","numLines":300,"startLine":700,"totalLines":2850}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019UNaYRfHshHysrLmiKWwi1","type":"message","role":"assistant","content":[{"type":"text","text":"Let me search for where the UI layout/panels are defined in PlaybookShell:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4357,"cache_read_input_tokens":115737,"cache_creation":{"ephemeral_5m_input_tokens":4357,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"029265f9-9866-47f0-a0e6-c3059d710940"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019UNaYRfHshHysrLmiKWwi1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JaWSBYdVbKDRfc2pzNY2RD","name":"Grep","input":{"pattern":"return \\(|<div className.*flex|NavigationPanel|WorkArea|className.*grid","path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4357,"cache_read_input_tokens":115737,"cache_creation":{"ephemeral_5m_input_tokens":4357,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"bc6e0ff9-092b-4425-a05a-637b7a621f62"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JaWSBYdVbKDRfc2pzNY2RD","type":"tool_result","content":"12:import NavigationPanel from './NavigationPanel'\n13:import { WorkArea } from './WorkArea'\n244:    return () => {\n2292:    // Note: Don't update step state here if the caller (WorkArea) already updated it.\n2450:      return () => clearTimeout(timer)\n2596:        return () => {\n2607:    return (\n2608:      <div className=\"flex items-center justify-center h-64 text-gray-500\">\n2614:  return (\n2615:    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n2617:      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n2618:        <div className=\"flex items-center gap-3\">\n2623:        <div className=\"flex items-center gap-2\">\n2638:          <div className=\"relative flex items-center gap-1\">\n2725:        <div className=\"flex-1 overflow-hidden\">\n2736:        <div className=\"flex flex-1 overflow-hidden\">\n2738:          <div className=\"w-80 flex-shrink-0\">\n2739:            <NavigationPanel\n2749:          <div className=\"flex-1 overflow-y-auto\">\n2752:              <div className=\"flex flex-col items-center justify-center h-full bg-white p-8 text-center\">\n2770:                <WorkArea"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"b42d81f6-d3bf-4887-b6e2-0b2248824920","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"12:import NavigationPanel from './NavigationPanel'\n13:import { WorkArea } from './WorkArea'\n244:    return () => {\n2292:    // Note: Don't update step state here if the caller (WorkArea) already updated it.\n2450:      return () => clearTimeout(timer)\n2596:        return () => {\n2607:    return (\n2608:      <div className=\"flex items-center justify-center h-64 text-gray-500\">\n2614:  return (\n2615:    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n2617:      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n2618:        <div className=\"flex items-center gap-3\">\n2623:        <div className=\"flex items-center gap-2\">\n2638:          <div className=\"relative flex items-center gap-1\">\n2725:        <div className=\"flex-1 overflow-hidden\">\n2736:        <div className=\"flex flex-1 overflow-hidden\">\n2738:          <div className=\"w-80 flex-shrink-0\">\n2739:            <NavigationPanel\n2749:          <div className=\"flex-1 overflow-y-auto\">\n2752:              <div className=\"flex flex-col items-center justify-center h-full bg-white p-8 text-center\">\n2770:                <WorkArea","numLines":21}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PKyVmBSfeMirAoPmHsfFM1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VXBZaHgxEPxLEw7AkJ8cX6","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","offset":2600,"limit":250}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":120094,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"93f66fea-0219-413e-b4be-8d9b2c120ba7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VXBZaHgxEPxLEw7AkJ8cX6","type":"tool_result","content":"  2600→          }\n  2601→        }\n  2602→      }\n  2603→    }\n  2604→  }, [currentStep?.id, currentStep?.type, currentStepState?.status, currentStepState?.output, updateStepState, goToNextStep])\n  2605→\n  2606→  if (!currentPhase || !currentStep || !currentStepState) {\n  2607→    return (\n  2608→      <div className=\"flex items-center justify-center h-64 text-gray-500\">\n  2609→        Error: Configuración de playbook inválida\n  2610→      </div>\n  2611→    )\n  2612→  }\n  2613→\n  2614→  return (\n  2615→    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n  2616→      {/* Header with mode selector */}\n  2617→      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n  2618→        <div className=\"flex items-center gap-3\">\n  2619→          <span className=\"text-xl\">{playbookConfig.icon}</span>\n  2620→          <h2 className=\"text-lg font-semibold text-gray-900\">{playbookConfig.name}</h2>\n  2621→        </div>\n  2622→\n  2623→        <div className=\"flex items-center gap-2\">\n  2624→          {/* Config Base button */}\n  2625→          <button\n  2626→            onClick={() => setMode('config')}\n  2627→            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n  2628→              mode === 'config'\n  2629→                ? 'bg-blue-100 text-blue-700'\n  2630→                : 'text-gray-600 hover:bg-gray-100'\n  2631→            }`}\n  2632→          >\n  2633→            <Settings size={16} />\n  2634→            Configuración Base\n  2635→          </button>\n  2636→\n  2637→          {/* Campaign selector */}\n  2638→          <div className=\"relative flex items-center gap-1\">\n  2639→            <button\n  2640→              onClick={() => {\n  2641→                setMode('campaign')\n  2642→                setShowCampaignDropdown(!showCampaignDropdown)\n  2643→              }}\n  2644→              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n  2645→                mode === 'campaign'\n  2646→                  ? 'bg-blue-100 text-blue-700'\n  2647→                  : 'text-gray-600 hover:bg-gray-100'\n  2648→              }`}\n  2649→            >\n  2650→              <Folder size={16} />\n  2651→              {selectedCampaign ? selectedCampaign.name : 'Seleccionar Campaña'}\n  2652→              <ChevronDown size={16} />\n  2653→            </button>\n  2654→\n  2655→            {/* Edit campaign settings button */}\n  2656→            {selectedCampaignId && (\n  2657→              <button\n  2658→                onClick={() => setShowCampaignSettings(true)}\n  2659→                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg\"\n  2660→                title=\"Editar configuración de campaña\"\n  2661→              >\n  2662→                <Pencil size={14} />\n  2663→              </button>\n  2664→            )}\n  2665→\n  2666→            {/* Dropdown */}\n  2667→            {showCampaignDropdown && (\n  2668→              <div className=\"absolute right-0 top-full mt-1 w-64 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50\">\n  2669→                {campaigns.length === 0 ? (\n  2670→                  <div className=\"px-3 py-2 text-sm text-gray-500\">No hay campañas</div>\n  2671→                ) : (\n  2672→                  campaigns.map(campaign => (\n  2673→                    <div\n  2674→                      key={campaign.id}\n  2675→                      className={`flex items-center justify-between px-3 py-2 text-sm hover:bg-gray-50 ${\n  2676→                        selectedCampaignId === campaign.id ? 'bg-blue-50' : ''\n  2677→                      }`}\n  2678→                    >\n  2679→                      <button\n  2680→                        onClick={() => {\n  2681→                          setSelectedCampaignId(campaign.id)\n  2682→                          setShowCampaignDropdown(false)\n  2683→                        }}\n  2684→                        className=\"flex-1 flex items-center justify-between text-left\"\n  2685→                      >\n  2686→                        <span className=\"font-medium text-gray-900\">{campaign.name}</span>\n  2687→                        <span className=\"text-gray-500 mr-2\">\n  2688→                          {campaign.completedSteps}/{campaign.totalSteps}\n  2689→                        </span>\n  2690→                      </button>\n  2691→                      <button\n  2692→                        onClick={(e) => {\n  2693→                          e.stopPropagation()\n  2694→                          deleteCampaign(campaign.id)\n  2695→                        }}\n  2696→                        className=\"p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded\"\n  2697→                        title=\"Eliminar campaña\"\n  2698→                      >\n  2699→                        <Trash2 size={14} />\n  2700→                      </button>\n  2701→                    </div>\n  2702→                  ))\n  2703→                )}\n  2704→                <div className=\"border-t border-gray-100 mt-1 pt-1\">\n  2705→                  <button\n  2706→                    onClick={() => {\n  2707→                      setShowWizard(true)\n  2708→                      setShowCampaignDropdown(false)\n  2709→                    }}\n  2710→                    className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-blue-600 hover:bg-blue-50\"\n  2711→                  >\n  2712→                    <Plus size={16} />\n  2713→                    Nueva Campaña\n  2714→                  </button>\n  2715→                </div>\n  2716→              </div>\n  2717→            )}\n  2718→          </div>\n  2719→        </div>\n  2720→      </div>\n  2721→\n  2722→      {/* Main content */}\n  2723→      {mode === 'config' ? (\n  2724→        /* Configuration Mode - Full width */\n  2725→        <div className=\"flex-1 overflow-hidden\">\n  2726→          <ConfigurationMode\n  2727→            projectId={projectId}\n  2728→            playbookConfig={playbookConfig}\n  2729→            onSave={() => {\n  2730→              // Optionally refresh something after save\n  2731→            }}\n  2732→          />\n  2733→        </div>\n  2734→      ) : (\n  2735→        /* Campaign Mode - Dual panel */\n  2736→        <div className=\"flex flex-1 overflow-hidden\">\n  2737→          {/* Navigation Panel - Left side */}\n  2738→          <div className=\"w-80 flex-shrink-0\">\n  2739→            <NavigationPanel\n  2740→              phases={playbookConfig.phases}\n  2741→              phaseStates={state.phases}\n  2742→              currentPhaseIndex={state.currentPhaseIndex}\n  2743→              currentStepIndex={state.currentStepIndex}\n  2744→              onStepClick={goToStep}\n  2745→            />\n  2746→          </div>\n  2747→\n  2748→          {/* Work Area - Right side */}\n  2749→          <div className=\"flex-1 overflow-y-auto\">\n  2750→            {!selectedCampaignId ? (\n  2751→              /* No campaign selected - prompt to select or create */\n  2752→              <div className=\"flex flex-col items-center justify-center h-full bg-white p-8 text-center\">\n  2753→                <Folder className=\"text-gray-300 mb-4\" size={64} />\n  2754→                <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n  2755→                  Selecciona o crea una campaña\n  2756→                </h3>\n  2757→                <p className=\"text-gray-500 mb-6 max-w-md\">\n  2758→                  Para ejecutar el playbook, primero debes seleccionar una campaña existente o crear una nueva.\n  2759→                </p>\n  2760→                <button\n  2761→                  onClick={() => setShowWizard(true)}\n  2762→                  className=\"flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n  2763→                >\n  2764→                  <Plus size={16} />\n  2765→                  Nueva Campaña\n  2766→                </button>\n  2767→              </div>\n  2768→            ) : (\n  2769→              <>\n  2770→                <WorkArea\n  2771→                  step={currentStep}\n  2772→                  stepState={currentStepState}\n  2773→                  onContinue={handleContinue}\n  2774→                  onBack={goToPreviousStep}\n  2775→                  onExecute={(input) => executeStep(currentStep.id, input)}\n  2776→                  onUpdateState={(update) => updateStepState(currentStep.id, update)}\n  2777→                  onEdit={handleEdit}\n  2778→                  onCancel={handleCancel}\n  2779→                  onRerunPrevious={rerunPreviousStep}\n  2780→                  onRetry={handleQuickRetry}\n  2781→                  onRetryWithConfig={handleRetryWithConfig}\n  2782→                  onSkipStep={handleSkipStep}\n  2783→                  isFirst={isFirstStep}\n  2784→                  isLast={isLastStep}\n  2785→                  previousStepOutput={getPreviousStepOutput()}\n  2786→                  projectId={projectId}\n  2787→                  playbookContext={buildPlaybookContext()}\n  2788→                  allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n  2789→                    phase.steps.map((stepDef, stepIdx) => ({\n  2790→                      definition: stepDef,\n  2791→                      state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n  2792→                    }))\n  2793→                  )}\n  2794→                  saveState={sessionId ? stepPersistenceState : undefined}\n  2795→                  retryInfo={currentStepRetryInfo || undefined}\n  2796→                  maxRetriesReached={maxRetriesReached}\n  2797→                  sessionId={sessionId}\n  2798→                />\n  2799→\n  2800→                {/* Retry Dialog */}\n  2801→                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n  2802→                  <StepRetryDialog\n  2803→                    isOpen={retryDialogOpen}\n  2804→                    stepName={currentStep.name}\n  2805→                    errorMessage={currentStepState.error || 'Unknown error'}\n  2806→                    retryInfo={currentStepRetryInfo}\n  2807→                    onRetry={handleRetryFromDialog}\n  2808→                    onClose={() => {\n  2809→                      setRetryDialogOpen(false)\n  2810→                      setRetryDialogStepId(null)\n  2811→                    }}\n  2812→                    isRetrying={stepRetryState.isRetrying}\n  2813→                  />\n  2814→                )}\n  2815→              </>\n  2816→            )}\n  2817→          </div>\n  2818→        </div>\n  2819→      )}\n  2820→\n  2821→      {/* Campaign Wizard Modal */}\n  2822→      {showWizard && (\n  2823→        <CampaignWizard\n  2824→          projectId={projectId}\n  2825→          playbookConfig={playbookConfig}\n  2826→          onClose={() => setShowWizard(false)}\n  2827→          onCreated={(campaignId) => {\n  2828→            setSelectedCampaignId(campaignId)\n  2829→            setShowWizard(false)\n  2830→            // Reload campaigns\n  2831→            loadCampaigns()\n  2832→          }}\n  2833→        />\n  2834→      )}\n  2835→\n  2836→      {/* Campaign Settings Modal */}\n  2837→      {showCampaignSettings && selectedCampaignId && (\n  2838→        <CampaignSettings\n  2839→          campaignId={selectedCampaignId}\n  2840→          playbookConfig={playbookConfig}\n  2841→          onClose={() => setShowCampaignSettings(false)}\n  2842→          onSaved={() => {\n  2843→            loadCampaigns()\n  2844→          }}\n  2845→        />\n  2846→      )}\n  2847→    </div>\n  2848→  )\n  2849→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"d65fe9d3-22b3-483b-ba71-568674c5a67b","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","content":"          }\n        }\n      }\n    }\n  }, [currentStep?.id, currentStep?.type, currentStepState?.status, currentStepState?.output, updateStepState, goToNextStep])\n\n  if (!currentPhase || !currentStep || !currentStepState) {\n    return (\n      <div className=\"flex items-center justify-center h-64 text-gray-500\">\n        Error: Configuración de playbook inválida\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n      {/* Header with mode selector */}\n      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3\">\n          <span className=\"text-xl\">{playbookConfig.icon}</span>\n          <h2 className=\"text-lg font-semibold text-gray-900\">{playbookConfig.name}</h2>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}\n          <div className=\"relative flex items-center gap-1\">\n            <button\n              onClick={() => {\n                setMode('campaign')\n                setShowCampaignDropdown(!showCampaignDropdown)\n              }}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                mode === 'campaign'\n                  ? 'bg-blue-100 text-blue-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Folder size={16} />\n              {selectedCampaign ? selectedCampaign.name : 'Seleccionar Campaña'}\n              <ChevronDown size={16} />\n            </button>\n\n            {/* Edit campaign settings button */}\n            {selectedCampaignId && (\n              <button\n                onClick={() => setShowCampaignSettings(true)}\n                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg\"\n                title=\"Editar configuración de campaña\"\n              >\n                <Pencil size={14} />\n              </button>\n            )}\n\n            {/* Dropdown */}\n            {showCampaignDropdown && (\n              <div className=\"absolute right-0 top-full mt-1 w-64 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50\">\n                {campaigns.length === 0 ? (\n                  <div className=\"px-3 py-2 text-sm text-gray-500\">No hay campañas</div>\n                ) : (\n                  campaigns.map(campaign => (\n                    <div\n                      key={campaign.id}\n                      className={`flex items-center justify-between px-3 py-2 text-sm hover:bg-gray-50 ${\n                        selectedCampaignId === campaign.id ? 'bg-blue-50' : ''\n                      }`}\n                    >\n                      <button\n                        onClick={() => {\n                          setSelectedCampaignId(campaign.id)\n                          setShowCampaignDropdown(false)\n                        }}\n                        className=\"flex-1 flex items-center justify-between text-left\"\n                      >\n                        <span className=\"font-medium text-gray-900\">{campaign.name}</span>\n                        <span className=\"text-gray-500 mr-2\">\n                          {campaign.completedSteps}/{campaign.totalSteps}\n                        </span>\n                      </button>\n                      <button\n                        onClick={(e) => {\n                          e.stopPropagation()\n                          deleteCampaign(campaign.id)\n                        }}\n                        className=\"p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded\"\n                        title=\"Eliminar campaña\"\n                      >\n                        <Trash2 size={14} />\n                      </button>\n                    </div>\n                  ))\n                )}\n                <div className=\"border-t border-gray-100 mt-1 pt-1\">\n                  <button\n                    onClick={() => {\n                      setShowWizard(true)\n                      setShowCampaignDropdown(false)\n                    }}\n                    className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-blue-600 hover:bg-blue-50\"\n                  >\n                    <Plus size={16} />\n                    Nueva Campaña\n                  </button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Main content */}\n      {mode === 'config' ? (\n        /* Configuration Mode - Full width */\n        <div className=\"flex-1 overflow-hidden\">\n          <ConfigurationMode\n            projectId={projectId}\n            playbookConfig={playbookConfig}\n            onSave={() => {\n              // Optionally refresh something after save\n            }}\n          />\n        </div>\n      ) : (\n        /* Campaign Mode - Dual panel */\n        <div className=\"flex flex-1 overflow-hidden\">\n          {/* Navigation Panel - Left side */}\n          <div className=\"w-80 flex-shrink-0\">\n            <NavigationPanel\n              phases={playbookConfig.phases}\n              phaseStates={state.phases}\n              currentPhaseIndex={state.currentPhaseIndex}\n              currentStepIndex={state.currentStepIndex}\n              onStepClick={goToStep}\n            />\n          </div>\n\n          {/* Work Area - Right side */}\n          <div className=\"flex-1 overflow-y-auto\">\n            {!selectedCampaignId ? (\n              /* No campaign selected - prompt to select or create */\n              <div className=\"flex flex-col items-center justify-center h-full bg-white p-8 text-center\">\n                <Folder className=\"text-gray-300 mb-4\" size={64} />\n                <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                  Selecciona o crea una campaña\n                </h3>\n                <p className=\"text-gray-500 mb-6 max-w-md\">\n                  Para ejecutar el playbook, primero debes seleccionar una campaña existente o crear una nueva.\n                </p>\n                <button\n                  onClick={() => setShowWizard(true)}\n                  className=\"flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n                >\n                  <Plus size={16} />\n                  Nueva Campaña\n                </button>\n              </div>\n            ) : (\n              <>\n                <WorkArea\n                  step={currentStep}\n                  stepState={currentStepState}\n                  onContinue={handleContinue}\n                  onBack={goToPreviousStep}\n                  onExecute={(input) => executeStep(currentStep.id, input)}\n                  onUpdateState={(update) => updateStepState(currentStep.id, update)}\n                  onEdit={handleEdit}\n                  onCancel={handleCancel}\n                  onRerunPrevious={rerunPreviousStep}\n                  onRetry={handleQuickRetry}\n                  onRetryWithConfig={handleRetryWithConfig}\n                  onSkipStep={handleSkipStep}\n                  isFirst={isFirstStep}\n                  isLast={isLastStep}\n                  previousStepOutput={getPreviousStepOutput()}\n                  projectId={projectId}\n                  playbookContext={buildPlaybookContext()}\n                  allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                    phase.steps.map((stepDef, stepIdx) => ({\n                      definition: stepDef,\n                      state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                    }))\n                  )}\n                  saveState={sessionId ? stepPersistenceState : undefined}\n                  retryInfo={currentStepRetryInfo || undefined}\n                  maxRetriesReached={maxRetriesReached}\n                  sessionId={sessionId}\n                />\n\n                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Campaign Wizard Modal */}\n      {showWizard && (\n        <CampaignWizard\n          projectId={projectId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowWizard(false)}\n          onCreated={(campaignId) => {\n            setSelectedCampaignId(campaignId)\n            setShowWizard(false)\n            // Reload campaigns\n            loadCampaigns()\n          }}\n        />\n      )}\n\n      {/* Campaign Settings Modal */}\n      {showCampaignSettings && selectedCampaignId && (\n        <CampaignSettings\n          campaignId={selectedCampaignId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowCampaignSettings(false)}\n          onSaved={() => {\n            loadCampaigns()\n          }}\n        />\n      )}\n    </div>\n  )\n}","numLines":250,"startLine":2600,"totalLines":2850}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Xia29GKegCoXQpV3UZNG7v","type":"message","role":"assistant","content":[{"type":"text","text":"Now I can see the layout. I need to add a \"Session Data\" tab/button in the header and integrate the ArtifactBrowser panel. Let me look at what props are available (clientId, userId, etc.):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3942,"cache_read_input_tokens":120669,"cache_creation":{"ephemeral_5m_input_tokens":3942,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"338ad96c-1a60-4959-88c6-68eca831f584"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Xia29GKegCoXQpV3UZNG7v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RzGXQrUwMwdxfP96zGP2yi","name":"Grep","input":{"pattern":"clientId|userId|campaignName","path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3942,"cache_read_input_tokens":120669,"cache_creation":{"ephemeral_5m_input_tokens":3942,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"99889649-2501-483e-840e-489ad2dcbb00"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RzGXQrUwMwdxfP96zGP2yi","type":"tool_result","content":"1149:              clientId: projectData.client_id,\n1163:              userId: 'system', // TODO: Get actual user ID from session"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"a5d4e4bf-b564-4144-a1c4-79842c1aa56e","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"1149:              clientId: projectData.client_id,\n1163:              userId: 'system', // TODO: Get actual user ID from session","numLines":2}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011TsKCanQX1itHGgD3n5KcU","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand. The clientId and userId are obtained from projectData. Let me modify the PlaybookShell to add the Session Data tab. First, let me check the imports section:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":245,"cache_read_input_tokens":124611,"cache_creation":{"ephemeral_5m_input_tokens":245,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"68bb9ed4-d07c-472a-ba9f-aaacaa0f599f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011TsKCanQX1itHGgD3n5KcU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SdSqFU2JZzVKScHjm3zKkQ","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":245,"cache_read_input_tokens":124611,"cache_creation":{"ephemeral_5m_input_tokens":245,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"befda697-3fd1-4a9d-975a-945a6397de1f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SdSqFU2JZzVKScHjm3zKkQ","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useCallback, useEffect, useRef } from 'react'\n     4→import {\n     5→  PlaybookShellProps,\n     6→  PlaybookState,\n     7→  PhaseState,\n     8→  StepState,\n     9→  StepDefinition,\n    10→  PhaseDefinition,\n    11→} from './types'\n    12→import NavigationPanel from './NavigationPanel'\n    13→import { WorkArea } from './WorkArea'\n    14→import ConfigurationMode from './ConfigurationMode'\n    15→import CampaignWizard from './CampaignWizard'\n    16→import CampaignSettings from './CampaignSettings'\n    17→import { Settings, ChevronDown, Plus, Folder, Pencil, Trash2 } from 'lucide-react'\n    18→import { useStepPersistence } from '@/hooks/useStepPersistence'\n    19→import { useStepRetry } from '@/hooks/useStepRetry'\n    20→import { StepAttemptConfig, StepRetryInfo } from './types'\n    21→import StepRetryDialog from './StepRetryDialog'\n    22→import FailedStepActions from './FailedStepActions'\n    23→\n    24→// Mode types for the unified view\n    25→type PlaybookMode = 'config' | 'campaign'\n    26→\n    27→interface Campaign {\n    28→  id: string\n    29→  name: string\n    30→  status: 'draft' | 'in_progress' | 'completed'\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"08a350e4-d6b6-40b3-b474-548bf5adbdb2","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","content":"'use client'\n\nimport { useState, useCallback, useEffect, useRef } from 'react'\nimport {\n  PlaybookShellProps,\n  PlaybookState,\n  PhaseState,\n  StepState,\n  StepDefinition,\n  PhaseDefinition,\n} from './types'\nimport NavigationPanel from './NavigationPanel'\nimport { WorkArea } from './WorkArea'\nimport ConfigurationMode from './ConfigurationMode'\nimport CampaignWizard from './CampaignWizard'\nimport CampaignSettings from './CampaignSettings'\nimport { Settings, ChevronDown, Plus, Folder, Pencil, Trash2 } from 'lucide-react'\nimport { useStepPersistence } from '@/hooks/useStepPersistence'\nimport { useStepRetry } from '@/hooks/useStepRetry'\nimport { StepAttemptConfig, StepRetryInfo } from './types'\nimport StepRetryDialog from './StepRetryDialog'\nimport FailedStepActions from './FailedStepActions'\n\n// Mode types for the unified view\ntype PlaybookMode = 'config' | 'campaign'\n\ninterface Campaign {\n  id: string\n  name: string\n  status: 'draft' | 'in_progress' | 'completed'","numLines":30,"startLine":1,"totalLines":2850}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019bADAK7H4C9baLhYSomdS6","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll add the ArtifactBrowser integration to PlaybookShell. I'll add the import, state for showing the panel, and the UI elements:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":656,"cache_read_input_tokens":124856,"cache_creation":{"ephemeral_5m_input_tokens":656,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"376c5435-2568-47d5-ada6-af6fa8077da5"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019bADAK7H4C9baLhYSomdS6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011daH8rYaRtGcQdcb7EajZZ","name":"Edit","input":{"replace_all":false,"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","old_string":"import { Settings, ChevronDown, Plus, Folder, Pencil, Trash2 } from 'lucide-react'","new_string":"import { Settings, ChevronDown, Plus, Folder, Pencil, Trash2, Database } from 'lucide-react'\nimport { ArtifactBrowser } from './ArtifactBrowser'"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":656,"cache_read_input_tokens":124856,"cache_creation":{"ephemeral_5m_input_tokens":656,"ephemeral_1h_input_tokens":0},"output_tokens":243,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"05d4e875-4d3a-4836-82d8-84f7ff98409d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011daH8rYaRtGcQdcb7EajZZ","type":"tool_result","content":"The file /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"e058e41b-a9a1-4822-8a73-00a49e9c7fb0","tool_use_result":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","oldString":"import { Settings, ChevronDown, Plus, Folder, Pencil, Trash2 } from 'lucide-react'","newString":"import { Settings, ChevronDown, Plus, Folder, Pencil, Trash2, Database } from 'lucide-react'\nimport { ArtifactBrowser } from './ArtifactBrowser'","originalFile":"'use client'\n\nimport { useState, useCallback, useEffect, useRef } from 'react'\nimport {\n  PlaybookShellProps,\n  PlaybookState,\n  PhaseState,\n  StepState,\n  StepDefinition,\n  PhaseDefinition,\n} from './types'\nimport NavigationPanel from './NavigationPanel'\nimport { WorkArea } from './WorkArea'\nimport ConfigurationMode from './ConfigurationMode'\nimport CampaignWizard from './CampaignWizard'\nimport CampaignSettings from './CampaignSettings'\nimport { Settings, ChevronDown, Plus, Folder, Pencil, Trash2 } from 'lucide-react'\nimport { useStepPersistence } from '@/hooks/useStepPersistence'\nimport { useStepRetry } from '@/hooks/useStepRetry'\nimport { StepAttemptConfig, StepRetryInfo } from './types'\nimport StepRetryDialog from './StepRetryDialog'\nimport FailedStepActions from './FailedStepActions'\n\n// Mode types for the unified view\ntype PlaybookMode = 'config' | 'campaign'\n\ninterface Campaign {\n  id: string\n  name: string\n  status: 'draft' | 'in_progress' | 'completed'\n  completedSteps: number\n  totalSteps: number\n  customVariables?: Record<string, unknown> // Includes context_type, product, target, etc.\n  playbookState?: PlaybookState // Saved playbook state for persistence\n}\n\nfunction initializeState(\n  projectId: string,\n  playbookConfig: PlaybookShellProps['playbookConfig'],\n  initialState?: Partial<PlaybookState>\n): PlaybookState {\n  const phases: PhaseState[] = playbookConfig.phases.map(phase => ({\n    id: phase.id,\n    status: 'pending',\n    steps: phase.steps.map(step => ({\n      id: step.id,\n      status: 'pending',\n    })),\n  }))\n\n  // Apply initial state if provided - match by ID for robustness when config changes\n  if (initialState?.phases) {\n    initialState.phases.forEach((savedPhaseState) => {\n      // Find phase by ID instead of index\n      const phaseIndex = phases.findIndex(p => p.id === savedPhaseState.id)\n      if (phaseIndex === -1) return\n\n      phases[phaseIndex].status = savedPhaseState.status\n      savedPhaseState.steps.forEach((savedStepState) => {\n        // Find step by ID instead of index\n        const stepIndex = phases[phaseIndex].steps.findIndex(s => s.id === savedStepState.id)\n        if (stepIndex === -1) return\n\n        phases[phaseIndex].steps[stepIndex] = {\n          ...phases[phaseIndex].steps[stepIndex],\n          ...savedStepState,\n        }\n      })\n    })\n  }\n\n  const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n  const completedSteps = phases.reduce(\n    (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n    0\n  )\n\n  // Validate currentPhaseIndex and currentStepIndex are within bounds\n  let currentPhaseIndex = initialState?.currentPhaseIndex ?? 0\n  let currentStepIndex = initialState?.currentStepIndex ?? 0\n\n  // Ensure phase index is valid\n  if (currentPhaseIndex >= playbookConfig.phases.length) {\n    currentPhaseIndex = Math.max(0, playbookConfig.phases.length - 1)\n  }\n\n  // Ensure step index is valid for the current phase\n  const currentPhaseSteps = playbookConfig.phases[currentPhaseIndex]?.steps.length ?? 0\n  if (currentStepIndex >= currentPhaseSteps) {\n    currentStepIndex = Math.max(0, currentPhaseSteps - 1)\n  }\n\n  // If the current step doesn't exist, find the first non-completed step\n  if (currentPhaseSteps === 0 || currentStepIndex < 0) {\n    // Find first pending step\n    for (let pi = 0; pi < phases.length; pi++) {\n      for (let si = 0; si < phases[pi].steps.length; si++) {\n        if (phases[pi].steps[si].status !== 'completed') {\n          currentPhaseIndex = pi\n          currentStepIndex = si\n          break\n        }\n      }\n      if (currentStepIndex >= 0) break\n    }\n    // Default to first step if all completed\n    if (currentStepIndex < 0) {\n      currentPhaseIndex = 0\n      currentStepIndex = 0\n    }\n  }\n\n  console.log('[initializeState] Validated indices:', {\n    originalPhase: initialState?.currentPhaseIndex,\n    originalStep: initialState?.currentStepIndex,\n    validatedPhase: currentPhaseIndex,\n    validatedStep: currentStepIndex,\n    maxPhases: playbookConfig.phases.length,\n    maxSteps: currentPhaseSteps,\n  })\n\n  return {\n    projectId,\n    playbookType: playbookConfig.type,\n    phases,\n    currentPhaseIndex,\n    currentStepIndex,\n    config: initialState?.config ?? {},\n    completedSteps,\n    totalSteps,\n    startedAt: initialState?.startedAt,\n    completedAt: initialState?.completedAt,\n  }\n}\n\nexport default function PlaybookShell({\n  projectId,\n  playbookConfig,\n  initialState,\n  sessionId,\n}: PlaybookShellProps) {\n  const [state, setState] = useState<PlaybookState>(() =>\n    initializeState(projectId, playbookConfig, initialState)\n  )\n\n  // Step persistence hook for auto-saving step data to database\n  const [stepPersistenceState, stepPersistenceActions] = useStepPersistence({\n    sessionId: sessionId || null,\n    autoSaveInterval: 30000, // Auto-save every 30 seconds\n    enabled: !!sessionId, // Only enable if sessionId is provided\n  })\n\n  // Step retry hook for managing retry attempts\n  const [stepRetryState, stepRetryActions] = useStepRetry(sessionId || null, {\n    enabled: !!sessionId,\n  })\n\n  // State for retry dialog\n  const [retryDialogOpen, setRetryDialogOpen] = useState(false)\n  const [retryDialogStepId, setRetryDialogStepId] = useState<string | null>(null)\n\n  // Flag to distinguish between intentional navigation (Continue button)\n  // vs manual navigation (clicking on a step)\n  const [shouldAutoExecute, setShouldAutoExecute] = useState(false)\n\n  // Mode: 'config' for editing base prompts, 'campaign' for execution\n  const [mode, setMode] = useState<PlaybookMode>('campaign')\n  const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null)\n  const [campaigns, setCampaigns] = useState<Campaign[]>([])\n  const [showCampaignDropdown, setShowCampaignDropdown] = useState(false)\n  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n\n  // Load campaigns from database\n  const loadCampaigns = useCallback(async () => {\n    try {\n      const response = await fetch(`/api/campaign/create?projectId=${projectId}`)\n      if (!response.ok) {\n        console.error('Failed to load campaigns')\n        return\n      }\n      const data = await response.json()\n      if (data.campaigns) {\n        const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n        const mappedCampaigns: Campaign[] = data.campaigns.map((c: any) => ({\n          id: c.id,\n          name: c.ecp_name,\n          status: c.status || 'draft',\n          // Calculate completed steps from playbook_state if available\n          completedSteps: c.playbook_state?.completedSteps ?? 0,\n          totalSteps,\n          customVariables: c.custom_variables || {}, // Load campaign variables including context_type\n          playbookState: c.playbook_state || null, // Load saved playbook state\n        }))\n        setCampaigns(mappedCampaigns)\n      }\n    } catch (error) {\n      console.error('Error loading campaigns:', error)\n    }\n  }, [projectId, playbookConfig.phases])\n\n  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)\n\n  // Ref to track if we should save (avoid saving on initial load)\n  const shouldSaveRef = useRef(false)\n  // Ref to prevent duplicate saves\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  // Ref to store polling interval for cancellation\n  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Save playbook state to database (debounced)\n  const savePlaybookState = useCallback(async (stateToSave: PlaybookState) => {\n    if (!selectedCampaignId) return\n\n    try {\n      await fetch(`/api/campaign/${selectedCampaignId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ playbook_state: stateToSave }),\n      })\n    } catch (error) {\n      console.error('Error saving playbook state:', error)\n    }\n  }, [selectedCampaignId])\n\n  // Auto-save state when it changes (debounced)\n  useEffect(() => {\n    if (!shouldSaveRef.current || !selectedCampaignId) return\n\n    // Clear any pending save\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current)\n    }\n\n    // Debounce saves by 500ms to avoid too many API calls\n    saveTimeoutRef.current = setTimeout(() => {\n      savePlaybookState(state)\n    }, 500)\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n      }\n    }\n  }, [state, selectedCampaignId, savePlaybookState])\n\n  // Load saved state when selecting a campaign\n  useEffect(() => {\n    if (!selectedCampaignId) {\n      shouldSaveRef.current = false\n      return\n    }\n\n    const campaign = campaigns.find(c => c.id === selectedCampaignId)\n    if (campaign?.playbookState) {\n      // Load saved state\n      shouldSaveRef.current = false // Don't save while loading\n      setState(initializeState(projectId, playbookConfig, campaign.playbookState))\n      // Enable saving after a short delay\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    } else {\n      // Fresh state for new campaign\n      shouldSaveRef.current = false\n      setState(initializeState(projectId, playbookConfig))\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    }\n  }, [selectedCampaignId, campaigns, projectId, playbookConfig])\n\n  // Load step data from database on session resume (if sessionId is provided)\n  useEffect(() => {\n    if (!sessionId) return\n\n    const loadStepData = async () => {\n      try {\n        const savedSteps = await stepPersistenceActions.loadAllSteps()\n        if (Object.keys(savedSteps).length === 0) return\n\n        console.log('[PlaybookShell] Loaded step data from session:', Object.keys(savedSteps))\n\n        // Merge saved step data into current state\n        setState(prev => {\n          const newPhases = prev.phases.map(phase => ({\n            ...phase,\n            steps: phase.steps.map(step => {\n              const savedStep = savedSteps[step.id]\n              if (savedStep) {\n                return {\n                  ...step,\n                  ...savedStep,\n                }\n              }\n              return step\n            }),\n          }))\n\n          // Recalculate phase status\n          newPhases.forEach(phase => {\n            const hasError = phase.steps.some(s => s.status === 'error')\n            const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n            const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n            if (hasError) {\n              phase.status = 'error'\n            } else if (allCompleted) {\n              phase.status = 'completed'\n            } else if (hasInProgress) {\n              phase.status = 'in_progress'\n            } else {\n              phase.status = 'pending'\n            }\n          })\n\n          // Recalculate completed steps\n          const completedSteps = newPhases.reduce(\n            (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n            0\n          )\n\n          // Find the first non-completed step to set as current\n          let currentPhaseIndex = 0\n          let currentStepIndex = 0\n          outer: for (let pi = 0; pi < newPhases.length; pi++) {\n            for (let si = 0; si < newPhases[pi].steps.length; si++) {\n              if (newPhases[pi].steps[si].status !== 'completed') {\n                currentPhaseIndex = pi\n                currentStepIndex = si\n                break outer\n              }\n            }\n          }\n\n          return {\n            ...prev,\n            phases: newPhases,\n            completedSteps,\n            currentPhaseIndex,\n            currentStepIndex,\n          }\n        })\n      } catch (error) {\n        console.error('[PlaybookShell] Error loading step data:', error)\n      }\n    }\n\n    loadStepData()\n  }, [sessionId, stepPersistenceActions])\n\n  // Delete a campaign\n  const deleteCampaign = useCallback(async (campaignId: string) => {\n    if (!confirm('¿Estás seguro de que quieres eliminar esta campaña? Esta acción no se puede deshacer.')) {\n      return\n    }\n\n    try {\n      const response = await fetch(`/api/campaign/${campaignId}`, {\n        method: 'DELETE',\n      })\n\n      if (!response.ok) {\n        throw new Error('Error al eliminar campaña')\n      }\n\n      // If we deleted the selected campaign, clear selection\n      if (selectedCampaignId === campaignId) {\n        setSelectedCampaignId(null)\n      }\n\n      // Reload campaigns\n      loadCampaigns()\n    } catch (error) {\n      console.error('Error deleting campaign:', error)\n      alert('Error al eliminar la campaña')\n    }\n  }, [selectedCampaignId, loadCampaigns])\n\n  // Helper function to get the output from the previous step\n  const getPreviousStepOutput = (): string | undefined => {\n    // Find the current step's dependencies\n    if (!currentStep?.dependsOn?.length) return undefined\n\n    // Get the first dependency's output\n    const dependencyId = currentStep.dependsOn[0]\n\n    // Search for this step across all phases\n    for (const phase of state.phases) {\n      const stepState = phase.steps.find(s => s.id === dependencyId)\n      if (stepState?.output) {\n        return typeof stepState.output === 'string'\n          ? stepState.output\n          : JSON.stringify(stepState.output, null, 2)\n      }\n    }\n\n    return undefined\n  }\n\n  // Build context for LLM-based suggestion generation\n  const buildPlaybookContext = (): Record<string, unknown> => {\n    // Start with campaign's custom_variables (includes context_type, product, target, etc.)\n    const campaignVars = selectedCampaign?.customVariables || {}\n\n    const context: Record<string, unknown> = {\n      ...campaignVars, // Include all campaign variables\n      product: campaignVars.product || state.config?.product || '',\n      target: campaignVars.target || state.config?.target || '',\n      context_type: campaignVars.context_type || 'both', // Explicitly include context_type\n    }\n\n    // DEBUG: Log all steps to see their state\n    console.log('[buildPlaybookContext] All steps:', state.phases.flatMap(p =>\n      p.steps.map(s => ({ id: s.id, status: s.status, hasOutput: !!s.output }))\n    ))\n\n    // Collect values from completed steps\n    for (const phase of state.phases) {\n      for (const stepState of phase.steps) {\n        // DEBUG: Log keyword_config step specifically\n        if (stepState.id === 'keyword_config') {\n          console.log('[buildPlaybookContext] keyword_config step:', {\n            status: stepState.status,\n            hasOutput: !!stepState.output,\n            outputKeys: stepState.output ? Object.keys(stepState.output as object) : [],\n            output: stepState.output,\n          })\n        }\n\n        if (stepState.status === 'completed' || stepState.decision || stepState.suggestions) {\n          // Get decision value\n          if (stepState.decision) {\n            context[stepState.id] = stepState.decision\n          }\n\n          // Get selected suggestions as array of labels\n          if (stepState.suggestions?.length) {\n            const selectedLabels = stepState.suggestions\n              .filter(s => s.selected)\n              .map(s => s.label)\n            if (selectedLabels.length > 0) {\n              context[stepState.id] = selectedLabels\n            }\n          }\n\n          // Get output if available\n          if (stepState.output) {\n            context[`${stepState.id}_output`] = stepState.output\n          }\n\n          // Special case: Extract serpJobId from serp_search or search_and_preview step output\n          // This is needed for review_urls/review_and_scrape step to display SERP results\n          // Note: We check this inside the completed block, but also outside below\n          if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Also extract serpJobId from review_and_scrape step (the scrape step)\n          // This ensures scrape_results step can find the jobId after scraping completes\n          if (stepState.id === 'review_and_scrape' && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId && !context.serpJobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Special case: Parse sources step output for QueryPreviewPanel\n          // The LLM returns a JSON string that needs to be parsed\n          if (stepState.id === 'sources' && stepState.output) {\n            try {\n              let parsedSources = stepState.output\n              if (typeof stepState.output === 'string') {\n                // Try to extract JSON from the LLM response\n                const jsonMatch = stepState.output.match(/\\{[\\s\\S]*\\}/)\n                if (jsonMatch) {\n                  parsedSources = JSON.parse(jsonMatch[0])\n                }\n              }\n              // Only set if it's a valid sources config object\n              if (parsedSources && typeof parsedSources === 'object' &&\n                  ('reddit' in parsedSources || 'thematic_forums' in parsedSources || 'general_forums' in parsedSources)) {\n                context.sources = parsedSources\n              }\n            } catch (e) {\n              console.error('[buildPlaybookContext] Error parsing sources output:', e)\n              // Don't set context.sources - let it use default values\n            }\n          }\n\n          // Special case: Extract keyword_config unified output for SearchWithPreviewStep\n          // The unified panel saves data in two formats:\n          // 1. lifeContexts, needWords, indicators as arrays of objects (for UI)\n          // 2. life_contexts, product_words, indicators as arrays of strings (for SERP job)\n          if (stepState.id === 'keyword_config' && stepState.output) {\n            const output = stepState.output as {\n              // Object arrays (for UI state)\n              lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n              needWords?: Array<{ id: string; label: string; selected: boolean }>\n              indicators?: Array<{ id: string; label: string; selected: boolean }>\n              // String arrays (pre-extracted for SERP job)\n              life_contexts?: string[]\n              product_words?: string[]\n              sources?: {\n                reddit_general?: { enabled: boolean }\n                reddit?: { enabled: boolean; subreddits?: string[] }\n                thematic_forums?: { enabled: boolean; forums?: string[] }\n                general_forums?: { enabled: boolean; forums?: string[] }\n              }\n            }\n\n            // First try to use pre-extracted string arrays (set on completion)\n            if (output.life_contexts && Array.isArray(output.life_contexts)) {\n              context.life_contexts = output.life_contexts\n            } else if (output.lifeContexts) {\n              // Fall back to extracting from object array\n              context.life_contexts = output.lifeContexts\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            // Check multiple possible keys for need words\n            if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n              context.need_words = output.product_words\n              console.log('[buildPlaybookContext] Got need_words from product_words:', output.product_words)\n            } else if ((output as any).need_words && Array.isArray((output as any).need_words) && (output as any).need_words.length > 0) {\n              // Also check for 'need_words' key (alternative naming)\n              context.need_words = (output as any).need_words\n              console.log('[buildPlaybookContext] Got need_words from need_words key:', (output as any).need_words)\n            } else if (output.needWords && Array.isArray(output.needWords)) {\n              const extracted = output.needWords\n                .filter(item => item.selected)\n                .map(item => item.label)\n              if (extracted.length > 0) {\n                context.need_words = extracted\n                console.log('[buildPlaybookContext] Got need_words from needWords (selected):', extracted)\n              } else {\n                console.warn('[buildPlaybookContext] needWords array exists but no items selected:', output.needWords)\n              }\n            } else {\n              console.warn('[buildPlaybookContext] Could not find need_words in output:', {\n                hasProductWords: !!output.product_words,\n                productWordsLength: output.product_words?.length,\n                hasNeedWords: !!(output as any).need_words,\n                hasNeedWordsArray: !!output.needWords,\n                outputKeys: Object.keys(output),\n              })\n            }\n\n            if (output.indicators && Array.isArray(output.indicators) && typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else if (output.indicators && Array.isArray(output.indicators)) {\n              context.indicators = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            if (output.sources) {\n              context.sources = output.sources\n            }\n\n            // DEBUG: Log what we extracted from keyword_config\n            console.log('[buildPlaybookContext] Extracted from keyword_config:', {\n              life_contexts: context.life_contexts,\n              need_words: context.need_words,\n              indicators: context.indicators,\n              sources: context.sources,\n            })\n          }\n        }\n\n        // IMPORTANT: Extract serpJobId even from non-completed steps (e.g., after cancel)\n        // This allows review_and_scrape to show URLs from a cancelled SERP job\n        if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also check review_and_scrape for non-completed steps (e.g., in progress or cancelled)\n        if (stepState.id === 'review_and_scrape' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also extract serpJobId from scrape_results step (for extraction step)\n        if (stepState.id === 'scrape_results' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // IMPORTANT: Also extract keyword_config data even if step is not 'completed'\n        // This ensures retry/navigation doesn't lose the config\n        if (stepState.id === 'keyword_config' && stepState.output && !context.life_contexts) {\n          console.log('[buildPlaybookContext] Extracting keyword_config from non-completed step')\n          const output = stepState.output as {\n            lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n            needWords?: Array<{ id: string; label: string; selected: boolean }>\n            indicators?: Array<{ id: string; label: string; selected: boolean }>\n            life_contexts?: string[]\n            product_words?: string[]\n            sources?: Record<string, unknown>\n          }\n\n          if (output.life_contexts && Array.isArray(output.life_contexts) && output.life_contexts.length > 0) {\n            context.life_contexts = output.life_contexts\n          } else if (output.lifeContexts) {\n            const extracted = output.lifeContexts.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.life_contexts = extracted\n            }\n          }\n\n          if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n            context.need_words = output.product_words\n          } else if (output.needWords) {\n            const extracted = output.needWords.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.need_words = extracted\n            }\n          }\n\n          if (output.indicators && Array.isArray(output.indicators) && output.indicators.length > 0) {\n            if (typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else {\n              const extracted = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected).map(item => item.label)\n              if (extracted.length > 0) {\n                context.indicators = extracted\n              }\n            }\n          }\n\n          if (output.sources && !context.sources) {\n            context.sources = output.sources\n          }\n\n          console.log('[buildPlaybookContext] Extracted from non-completed keyword_config:', {\n            life_contexts: context.life_contexts,\n            need_words: context.need_words,\n          })\n        }\n      }\n    }\n\n    // DEBUG: Log final context\n    console.log('[buildPlaybookContext] Final context:', {\n      life_contexts: context.life_contexts,\n      need_words: context.need_words,\n      indicators: context.indicators,\n      sources: context.sources,\n      serpJobId: context.serpJobId,\n    })\n\n    return context\n  }\n\n  // Get current phase and step definitions\n  const currentPhase = playbookConfig.phases[state.currentPhaseIndex]\n  const currentStep = currentPhase?.steps[state.currentStepIndex]\n  const currentStepState = state.phases[state.currentPhaseIndex]?.steps[state.currentStepIndex]\n\n  // Calculate navigation bounds\n  const isFirstStep = state.currentPhaseIndex === 0 && state.currentStepIndex === 0\n  const isLastStep =\n    state.currentPhaseIndex === playbookConfig.phases.length - 1 &&\n    state.currentStepIndex === currentPhase.steps.length - 1\n\n  // Navigate to a specific step\n  const goToStep = useCallback((phaseIndex: number, stepIndex: number) => {\n    // Save current state immediately before navigating (don't wait for debounce)\n    if (shouldSaveRef.current && selectedCampaignId) {\n      // Clear pending debounced save\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n        saveTimeoutRef.current = null\n      }\n      // Save current state synchronously\n      savePlaybookState(state)\n    }\n\n    setState(prev => ({\n      ...prev,\n      currentPhaseIndex: phaseIndex,\n      currentStepIndex: stepIndex,\n    }))\n  }, [selectedCampaignId, state, savePlaybookState])\n\n  // Go to next step\n  const goToNextStep = useCallback(() => {\n    setState(prev => {\n      const currentPhase = playbookConfig.phases[prev.currentPhaseIndex]\n\n      // Check if there's a next step in current phase\n      if (prev.currentStepIndex < currentPhase.steps.length - 1) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex + 1,\n        }\n      }\n\n      // Check if there's a next phase\n      if (prev.currentPhaseIndex < playbookConfig.phases.length - 1) {\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex + 1,\n          currentStepIndex: 0,\n        }\n      }\n\n      // Already at the end\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Go to previous step\n  const goToPreviousStep = useCallback(() => {\n    setState(prev => {\n      // Check if there's a previous step in current phase\n      if (prev.currentStepIndex > 0) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex - 1,\n        }\n      }\n\n      // Check if there's a previous phase\n      if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex - 1,\n          currentStepIndex: prevPhase.steps.length - 1,\n        }\n      }\n\n      // Already at the beginning\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Re-run the previous step (go back and reset its state to pending)\n  const rerunPreviousStep = useCallback(() => {\n    setState(prev => {\n      let newPhaseIndex = prev.currentPhaseIndex\n      let newStepIndex = prev.currentStepIndex\n\n      // Find previous step\n      if (prev.currentStepIndex > 0) {\n        newStepIndex = prev.currentStepIndex - 1\n      } else if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        newPhaseIndex = prev.currentPhaseIndex - 1\n        newStepIndex = prevPhase.steps.length - 1\n      } else {\n        // Already at the beginning, nothing to rerun\n        return prev\n      }\n\n      // Get the previous step ID\n      const prevStepId = playbookConfig.phases[newPhaseIndex].steps[newStepIndex].id\n\n      // Reset the previous step state to pending and navigate to it\n      const newPhases = prev.phases.map((phase, pi) => ({\n        ...phase,\n        steps: phase.steps.map((step, si) => {\n          if (pi === newPhaseIndex && si === newStepIndex) {\n            return {\n              ...step,\n              status: 'pending' as const,\n              output: undefined,\n              error: undefined,\n            }\n          }\n          return step\n        }),\n      }))\n\n      return {\n        ...prev,\n        phases: newPhases,\n        currentPhaseIndex: newPhaseIndex,\n        currentStepIndex: newStepIndex,\n      }\n    })\n    // Trigger auto-execute after navigating\n    setShouldAutoExecute(true)\n  }, [playbookConfig.phases])\n\n  // Update step state\n  const updateStepState = useCallback(\n    (stepId: string, update: Partial<StepState>) => {\n      console.log('[updateStepState] Updating step:', stepId, 'with:', {\n        ...update,\n        output: update.output ? `[output with keys: ${Object.keys(update.output as object).join(', ')}]` : undefined,\n      })\n\n      // Persist step changes to database (if sessionId is provided)\n      if (sessionId) {\n        // Handle status-specific persistence\n        if (update.status === 'in_progress') {\n          stepPersistenceActions.markStepRunning(stepId, update.input)\n        } else if (update.status === 'completed') {\n          stepPersistenceActions.markStepCompleted(stepId, update.output)\n        } else if (update.status === 'error') {\n          stepPersistenceActions.markStepFailed(stepId, update.error || 'Unknown error')\n        } else if (update.output !== undefined) {\n          // For output-only updates (during execution), schedule auto-save\n          stepPersistenceActions.scheduleAutoSave(stepId, update.output)\n        }\n      }\n\n      setState(prev => {\n        // Find the current step to log what we're merging\n        const currentStep = prev.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n        if (stepId === 'keyword_config') {\n          console.log('[updateStepState] keyword_config before merge:', {\n            status: currentStep?.status,\n            hasOutput: !!currentStep?.output,\n            outputKeys: currentStep?.output ? Object.keys(currentStep.output as object) : [],\n          })\n        }\n\n        const newPhases = prev.phases.map(phase => ({\n          ...phase,\n          steps: phase.steps.map(step =>\n            step.id === stepId ? { ...step, ...update } : step\n          ),\n        }))\n\n        // Log the merged result for keyword_config\n        if (stepId === 'keyword_config') {\n          const mergedStep = newPhases.flatMap(p => p.steps).find(s => s.id === stepId)\n          console.log('[updateStepState] keyword_config after merge:', {\n            status: mergedStep?.status,\n            hasOutput: !!mergedStep?.output,\n            outputKeys: mergedStep?.output ? Object.keys(mergedStep.output as object) : [],\n          })\n        }\n\n        // Recalculate phase status\n        newPhases.forEach(phase => {\n          const hasError = phase.steps.some(s => s.status === 'error')\n          const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n          const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n          if (hasError) {\n            phase.status = 'error'\n          } else if (allCompleted) {\n            phase.status = 'completed'\n          } else if (hasInProgress) {\n            phase.status = 'in_progress'\n          } else {\n            phase.status = 'pending'\n          }\n        })\n\n        // Recalculate completed steps\n        const completedSteps = newPhases.reduce(\n          (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n          0\n        )\n\n        return {\n          ...prev,\n          phases: newPhases,\n          completedSteps,\n        }\n      })\n    },\n    [sessionId, stepPersistenceActions]\n  )\n\n  // Execute a step\n  const executeStep = useCallback(\n    async (stepId: string, input?: any) => {\n      console.log('[executeStep] Starting execution for step:', stepId, 'with input:', input)\n\n      const step = playbookConfig.phases\n        .flatMap(p => p.steps)\n        .find(s => s.id === stepId)\n\n      if (!step) {\n        console.error('[executeStep] Step not found:', stepId)\n        return\n      }\n\n      console.log('[executeStep] Found step:', step.id, 'type:', step.type, 'executor:', step.executor, 'jobType:', step.jobType)\n\n      // Mark as in progress\n      updateStepState(stepId, {\n        status: 'in_progress',\n        startedAt: new Date(),\n        input,\n      })\n\n      try {\n        let result: any\n\n        // Special case: Execute extraction from scrape_results step\n        if (step.id === 'scrape_results' && input?.action === 'extract' && input?.jobId) {\n          console.log('[EXTRACT from scrape_results] Starting extraction for job:', input.jobId)\n          const jobId = input.jobId\n\n          updateStepState(stepId, {\n            output: { jobId },\n            progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' },\n            partialResults: { extracted: 0, filtered: 0 },\n          })\n\n          // Get total URLs to extract from job status\n          const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          const statusData = await statusResponse.json()\n          const scrapedUrlCount = statusData.url_counts?.scraped || 0\n          const totalUrls = scrapedUrlCount || statusData.job?.urls_scraped || 0\n          const existingExtractedCount = statusData.job?.niches_extracted || 0\n          const existingFilteredCount = statusData.url_counts?.filtered || 0\n\n          console.log('[EXTRACT] Status check:', {\n            scrapedUrlCount,\n            totalUrls,\n            existingExtractedCount,\n            existingFilteredCount,\n            jobStatus: statusData.job?.status,\n            urlsFailed: statusData.url_counts?.failed || 0,\n          })\n\n          // Check if there's nothing to extract (all URLs failed or filtered)\n          if (scrapedUrlCount === 0 && existingExtractedCount === 0) {\n            const failedCount = statusData.url_counts?.failed || 0\n            console.log('[EXTRACT] No URLs to extract and no existing results. Failed:', failedCount, 'Filtered:', existingFilteredCount)\n\n            // Show error state - nothing to extract\n            updateStepState(stepId, {\n              status: 'error',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: 0,\n                filteredCount: existingFilteredCount,\n                error: failedCount > 0\n                  ? `El scraping falló para ${failedCount} URLs (posible bloqueo de Reddit API). No hay contenido disponible para extraer.`\n                  : 'No hay URLs disponibles para extraer. Verifica que el scraping se completó correctamente.',\n              },\n              progress: undefined,\n            })\n\n            return // Stop - nothing to do\n          }\n\n          // Check if extraction was already done (no URLs to process but results exist)\n          if (scrapedUrlCount === 0 && existingExtractedCount > 0) {\n            console.log('[EXTRACT] Extraction already completed, using existing results')\n            updateStepState(stepId, {\n              progress: { current: 100, total: 100, label: `Usando resultados existentes: ${existingExtractedCount} problemas encontrados` },\n            })\n\n            // Skip extraction loop and jump to results fetching\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // Mark scrape_results as completed\n            updateStepState(stepId, {\n              status: 'completed',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: existingExtractedCount,\n                filteredCount: existingFilteredCount,\n              },\n              progress: undefined,\n            })\n\n            // Also update extract_problems step for clean_filter to use\n            console.log('[EXTRACT] Updating extract_problems step with existing CSV results')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,\n              partialResults: {\n                extracted: existingExtractedCount,\n                filtered: existingFilteredCount,\n                successCount: niches.length,\n              }\n            })\n\n            console.log('[EXTRACT] Using existing results:', niches.length, 'problems')\n            return // Don't proceed with new extraction\n          }\n\n          updateStepState(stepId, {\n            progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` },\n          })\n\n          // Call extract endpoint in batches until has_more=false\n          let hasMore = true\n          let extractedTotal = 0\n          let filteredTotal = 0\n          let processedTotal = 0\n\n          while (hasMore) {\n            try {\n              const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout)\n              const contentType = extractResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                console.error('[EXTRACT] Non-JSON response, polling status...')\n                await new Promise(resolve => setTimeout(resolve, 2000))\n\n                // Check current status\n                const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                const checkData = await checkResponse.json()\n\n                if (checkData.status === 'completed') {\n                  hasMore = false\n                  extractedTotal = checkData.job?.niches_extracted || 0\n                }\n                continue\n              }\n\n              const extractData = await extractResponse.json()\n              console.log('[EXTRACT] Batch response:', extractData)\n\n              if (extractData.error) {\n                throw new Error(extractData.error)\n              }\n\n              extractedTotal += extractData.extracted || 0\n              filteredTotal += extractData.filtered || 0\n              processedTotal = extractedTotal + filteredTotal\n              hasMore = extractData.has_more || false\n\n              updateStepState(stepId, {\n                progress: {\n                  current: processedTotal,\n                  total: totalUrls,\n                  label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                },\n                partialResults: {\n                  extracted: extractedTotal,\n                  filtered: filteredTotal,\n                },\n              })\n            } catch (extractError) {\n              console.error('[EXTRACT] Batch error:', extractError)\n              await new Promise(resolve => setTimeout(resolve, 2000))\n\n              // Check if we should stop\n              const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const checkData = await checkResponse.json()\n              if (checkData.status === 'completed' || checkData.status === 'failed') {\n                hasMore = false\n                if (checkData.status === 'failed') {\n                  throw new Error(checkData.job?.error_message || 'Extraction failed')\n                }\n              }\n            }\n          }\n\n          // Mark as completed\n          updateStepState(stepId, {\n            status: 'completed',\n            completedAt: new Date(),\n            output: {\n              jobId,\n              extractedCount: extractedTotal,\n              filteredCount: filteredTotal,\n            },\n            progress: undefined, // Clear progress\n          })\n\n          console.log('[EXTRACT] Completed! Extracted:', extractedTotal, 'Filtered:', filteredTotal)\n\n          // Save results to Context Lake automatically\n          try {\n            // Get project data (includes client_id)\n            const projectResponse = await fetch(`/api/projects/${projectId}`)\n            const projectData = await projectResponse.json()\n\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // IMPORTANT: Also update extract_problems step so clean_filter can use the results\n            // clean_filter depends on extract_problems, not scrape_results\n            console.log('[EXTRACT] Updating extract_problems step with CSV results for clean_filter')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,  // CSV string that clean_filter will use\n              partialResults: {\n                extracted: extractedTotal,\n                filtered: filteredTotal,\n                successCount: niches.length,\n              }\n            })\n\n            const dateStr = new Date().toISOString().split('T')[0]\n            const campaignSlug = selectedCampaign?.name?.toLowerCase().replace(/\\s+/g, '-') || 'sin-nombre'\n            const projectSlug = projectData.name?.toLowerCase().replace(/\\s+/g, '-') || 'proyecto'\n\n            const documentData = {\n              projectId: projectId,\n              clientId: projectData.client_id,\n              filename: `Niche Finder - ${selectedCampaign?.name || 'Sin nombre'} - ${dateStr}`,\n              category: 'research',\n              content: csvContent,\n              description: `${extractedTotal} problemas extraídos del Niche Finder. ${filteredTotal} URLs filtradas de ${totalUrls} procesadas.`,\n              tags: [\n                `fecha:${dateStr}`,\n                `proyecto:${projectSlug}`,\n                `campaña:${campaignSlug}`,\n                `job:${jobId}`,\n                'niche-finder',\n                'problemas-extraidos'\n              ],\n              folder: `niche-finder/${campaignSlug}`,\n              userId: 'system', // TODO: Get actual user ID from session\n              sourceMetadata: {\n                origin_type: 'flow_step_output',\n                playbook_id: playbookConfig.type || 'niche-finder',\n                playbook_name: playbookConfig.name,\n                campaign_id: selectedCampaignId || '',\n                campaign_name: selectedCampaign?.name || '',\n                campaign_variables: selectedCampaign?.customVariables || {},\n                step_id: 'scrape_results',\n                step_name: 'Extracción de Problemas',\n                step_order: 3,\n                executed_at: new Date().toISOString(),\n                model_used: 'openai/gpt-4o-mini',\n                model_provider: 'openrouter',\n                input_tokens: 0,\n                output_tokens: 0,\n                input_document_ids: [],\n                input_previous_step_ids: ['search_and_preview', 'review_and_scrape'],\n                converted_at: new Date().toISOString(),\n                converted_by: 'system',\n                was_edited_before_conversion: false\n              },\n              sourceCampaignId: selectedCampaignId || '',\n              sourceStepId: 'scrape_results',\n              sourceStepName: 'Extracción de Problemas',\n              sourcePlaybookId: playbookConfig.type\n            }\n\n            const saveResponse = await fetch('/api/documents/from-step-output', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify(documentData)\n            })\n\n            if (saveResponse.ok) {\n              const savedDoc = await saveResponse.json()\n              console.log('[EXTRACT] Results saved to Context Lake:', savedDoc.document?.id)\n            } else {\n              console.error('[EXTRACT] Failed to save to Context Lake:', await saveResponse.text())\n            }\n          } catch (saveError) {\n            console.error('[EXTRACT] Error saving to Context Lake:', saveError)\n            // Don't fail the extraction if saving to Context Lake fails\n          }\n\n          return // Don't fall through to the switch\n        }\n\n        switch (step.executor) {\n          case 'llm':\n            // Build variables including campaign custom_variables (product, target, industry, etc.)\n            const campaignVars = selectedCampaign?.customVariables || {}\n            const stepVariables = {\n              ...Object.fromEntries(\n                Object.entries(campaignVars).map(([k, v]) => [k, String(v ?? '')])\n              ),\n              ...(input || {}),\n            }\n            // Call LLM API\n            const response = await fetch('/api/playbook/execute-step', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({\n                projectId,\n                stepId,\n                playbookType: playbookConfig.type,\n                promptKey: step.promptKey,\n                variables: stepVariables,\n              }),\n            })\n            const data = await response.json()\n            if (!data.success) throw new Error(data.error || 'Error ejecutando paso')\n            result = data.output\n            break\n\n          case 'api':\n            // Call custom API endpoint\n            if (step.apiEndpoint) {\n              // Build payload with previous step outputs and campaign variables\n              const campaignVarsForApi = selectedCampaign?.customVariables || {}\n\n              // Get outputs from previous steps (dependsOn)\n              const previousOutputs: Record<string, unknown> = {}\n              if (step.dependsOn?.length) {\n                for (const depId of step.dependsOn) {\n                  for (const phase of state.phases) {\n                    const depStep = phase.steps.find(s => s.id === depId)\n                    if (depStep?.output) {\n                      previousOutputs[depId] = depStep.output\n                    }\n                  }\n                }\n              }\n\n              // Build scenes array from generate_scenes output (for video-viral generate-clips)\n              let scenes: string[] | undefined\n              if (previousOutputs.generate_scenes) {\n                let scenesOutput = previousOutputs.generate_scenes\n\n                // Parse JSON if output is a string (LLM outputs often come as strings)\n                if (typeof scenesOutput === 'string') {\n                  try {\n                    // Try to extract JSON from the string (might be wrapped in markdown code blocks)\n                    const jsonMatch = scenesOutput.match(/```(?:json)?\\s*(\\{[\\s\\S]*?\\})\\s*```/) ||\n                                     scenesOutput.match(/(\\{[\\s\\S]*\\})/)\n                    if (jsonMatch) {\n                      scenesOutput = JSON.parse(jsonMatch[1])\n                    }\n                  } catch (e) {\n                    console.error('[executeStep] Failed to parse generate_scenes output:', e)\n                  }\n                }\n\n                // Extract scene_1, scene_2, scene_3, etc. from the output\n                if (typeof scenesOutput === 'object' && scenesOutput !== null) {\n                  const scenesRecord = scenesOutput as Record<string, string>\n                  scenes = Object.entries(scenesRecord)\n                    .filter(([key]) => key.startsWith('scene_'))\n                    .sort(([a], [b]) => a.localeCompare(b))\n                    .map(([, value]) => value)\n                  console.log('[executeStep] Extracted scenes:', scenes)\n                }\n              }\n\n              const apiResponse = await fetch(step.apiEndpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                  projectId,\n                  stepId,\n                  input,\n                  ...campaignVarsForApi,\n                  previousOutputs,\n                  scenes, // For generate-clips endpoint\n                }),\n              })\n              const apiData = await apiResponse.json()\n              if (!apiData.success && apiData.error) throw new Error(apiData.error)\n              result = apiData\n            }\n            break\n\n          case 'job':\n            // Job-based execution: create job, execute, poll for status\n            console.log('[executeStep] Executor is JOB, jobType:', step.jobType)\n\n            if (step.jobType === 'niche_finder_serp') {\n              // Check if we have an existing job to resume (from cancelled execution)\n              const currentStepForJob = state.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n              const existingJobId = (currentStepForJob?.output as { jobId?: string })?.jobId\n\n              let jobId: string\n\n              if (existingJobId) {\n                // Resume existing job\n                console.log('[SERP] Resuming existing job:', existingJobId)\n                jobId = existingJobId\n                updateStepState(stepId, { progress: { current: 0, total: 0, label: 'Retomando búsqueda SERP...' } })\n              } else {\n                // Build job config from completed steps OR from input (for search_with_preview)\n                let jobConfig: {\n                  life_contexts: string[]\n                  product_words: string[]\n                  indicators: string[]\n                  sources: { reddit: boolean | { enabled?: boolean; subreddits?: string[] }; thematic_forums: boolean | { enabled?: boolean; forums?: string[] }; general_forums: string[] | { enabled?: boolean; forums?: string[] } }\n                  serp_pages: number\n                  // Campaign metadata for extraction to use correct variables\n                  campaign_id?: string | null\n                  ecp_name?: string\n                  ecp_product?: string\n                  ecp_target?: string\n                  ecp_industry?: string\n                  ecp_category?: string\n                  ecp_country?: string\n                }\n\n                // If input is provided (from SearchWithPreviewPanel), use it directly\n                console.log('[SERP] Input received:', JSON.stringify(input, null, 2))\n\n                if (input && input.life_contexts && input.product_words) {\n                  // Warn if arrays are empty\n                  if (input.life_contexts.length === 0 || input.product_words.length === 0) {\n                    console.warn('[SERP] WARNING: life_contexts or product_words is empty!', {\n                      life_contexts: input.life_contexts,\n                      product_words: input.product_words\n                    })\n                  }\n\n                  jobConfig = {\n                    life_contexts: input.life_contexts,\n                    product_words: input.product_words,\n                    indicators: input.indicators || [],\n                    sources: input.sources || { reddit: true, thematic_forums: false, general_forums: [] },\n                    serp_pages: input.serp_pages || 5,\n                  }\n                } else {\n                  console.log('[SERP] No valid input, falling back to completed steps...')\n                  // Fall back to building from completed steps (legacy flow)\n                  const lifeContextsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'life_contexts')\n                  const needWordsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'need_words')\n                  const indicatorsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'indicators')\n                  const sourcesStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'sources')\n\n                  const selectedContexts = lifeContextsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedNeedWords = needWordsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedIndicators = indicatorsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n\n                  // Parse sources output (can be JSON string from LLM or already parsed object)\n                  let sourcesConfig: { reddit: { enabled: boolean; subreddits: string[] }; thematic_forums: { enabled: boolean; forums: string[] }; general_forums: { enabled: boolean; forums: string[] } } = { reddit: { enabled: true, subreddits: [] }, thematic_forums: { enabled: false, forums: [] }, general_forums: { enabled: false, forums: [] } }\n                  try {\n                    if (sourcesStep?.output) {\n                      // Check if output is already an object (parsed)\n                      if (typeof sourcesStep.output === 'object' && sourcesStep.output !== null) {\n                        sourcesConfig = sourcesStep.output as typeof sourcesConfig\n                      } else if (typeof sourcesStep.output === 'string') {\n                        // Try to extract JSON from string\n                        const jsonMatch = sourcesStep.output.match(/\\{[\\s\\S]*\\}/)\n                        if (jsonMatch) {\n                          sourcesConfig = JSON.parse(jsonMatch[0])\n                        }\n                      }\n                    }\n                  } catch (e) {\n                    console.error('Error parsing sources config:', e)\n                  }\n\n                  // Get campaign variables with proper typing\n                  const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                  jobConfig = {\n                    campaign_id: selectedCampaignId, // CRITICAL: Pass campaign_id so extract uses correct variables\n                    life_contexts: selectedContexts,\n                    product_words: selectedNeedWords,\n                    indicators: selectedIndicators,\n                    sources: sourcesConfig,\n                    serp_pages: (campaignVars?.serp_pages as number) || 5,\n                    // Also pass campaign variables directly in config for reliability\n                    ecp_name: (campaignVars?.company_name as string) || selectedCampaign?.name,\n                    ecp_product: campaignVars?.product as string | undefined,\n                    ecp_target: campaignVars?.target as string | undefined,\n                    ecp_industry: campaignVars?.industry as string | undefined,\n                    ecp_category: campaignVars?.category as string | undefined,\n                    ecp_country: campaignVars?.country as string | undefined,\n                  }\n                }\n\n                console.log('[SERP] Starting job with config:', JSON.stringify(jobConfig, null, 2))\n\n                // 1. Create job\n                const createResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: jobConfig,\n                  }),\n                })\n                const createData = await createResponse.json()\n                console.log('[SERP] Create job response:', createData)\n\n                if (!createData.success) {\n                  throw new Error(createData.error || 'Error creando job')\n                }\n\n                jobId = createData.job_id\n                console.log('[SERP] Job created with ID:', jobId)\n                updateStepState(stepId, { output: { jobId }, progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' } })\n              }\n\n              // 2. Execute SERP job (this will resume from where it left off if job was interrupted)\n              console.log('[SERP] Executing SERP search...')\n              const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout HTML pages)\n              const contentType = serpResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                const text = await serpResponse.text()\n                console.error('[SERP] Non-JSON response:', text.slice(0, 500))\n                // If we got a non-JSON response, the job might still be running in the background\n                // Continue to polling to check status\n                console.log('[SERP] Continuing to poll for job status despite non-JSON response...')\n              } else {\n                const serpData = await serpResponse.json()\n                console.log('[SERP] SERP response:', serpData)\n\n                if (serpData.error) {\n                  // Check if it's a missing API key error\n                  if (serpData.code === 'MISSING_API_KEY') {\n                    throw new Error(`API Key faltante: ${serpData.service}. Configura tu API key en Ajustes > APIs.`)\n                  }\n                  throw new Error(serpData.error)\n                }\n              }\n\n              // 3. Poll for status and auto-resume if needed\n              let isResuming = false\n              let lastCompletedCount = -1 // Track previous poll value\n              let stallCount = 0 // Count consecutive stalls\n              let initialCompleted = -1 // Track initial value when polling started\n\n              // Clear any existing poll interval\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n              }\n\n              pollIntervalRef.current = setInterval(async () => {\n                try {\n                  const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const statusData = await statusResponse.json()\n\n                  const completed = statusData.progress?.serp?.completed || 0\n                  const total = statusData.progress?.serp?.total || 0\n                  const remaining = total - completed\n                  const label = total > 0\n                    ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n                    : 'Iniciando búsqueda SERP...'\n                  updateStepState(stepId, {\n                    progress: {\n                      current: completed,\n                      total: total,\n                      label,\n                    },\n                  })\n\n                  // Track initial value on first poll\n                  if (initialCompleted === -1) {\n                    initialCompleted = completed\n                  }\n\n                  // Auto-resume if job was interrupted (still serp_running but not progressing)\n                  // This handles Vercel timeout scenarios\n                  if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n                    // Check if progress has stalled (same value as PREVIOUS poll)\n                    if (lastCompletedCount === completed && remaining > 0) {\n                      stallCount++\n                      // After 2 consecutive stalls (4+ seconds), OR if no progress since we started polling\n                      const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                      if (stallCount >= 2 || noProgressSinceStart) {\n                        console.log(`[SERP] Job stalled at ${completed}/${total} (stallCount=${stallCount}, initialCompleted=${initialCompleted}), auto-resuming...`)\n                        isResuming = true\n                        stallCount = 0\n                        // Resume the job by calling SERP endpoint again\n                        fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                          .then(res => res.json())\n                          .then(data => {\n                            console.log('[SERP] Resume response:', data)\n                            isResuming = false\n                          })\n                          .catch(err => {\n                            console.error('[SERP] Resume error:', err)\n                            isResuming = false\n                          })\n                      }\n                    } else {\n                      stallCount = 0 // Reset stall count if progress is being made\n                    }\n                  }\n\n                  // Update last completed for next poll comparison\n                  lastCompletedCount = completed\n\n                  // Check if SERP phase is done (includes later states that imply SERP finished)\n                  const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n                  if (serpDone) {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    updateStepState(stepId, {\n                      status: 'completed',\n                      completedAt: new Date(),\n                      output: {\n                        jobId,\n                        urlsFound: statusData.job?.urls_found || 0,\n                        costs: statusData.costs,\n                      },\n                      progress: undefined, // Clear progress to stop spinner\n                    })\n                    setTimeout(goToNextStep, 500)\n                  } else if (statusData.status === 'failed' || statusData.status === 'error') {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    throw new Error(statusData.job?.error_message || 'Job failed')\n                  }\n                } catch (pollError) {\n                  if (pollIntervalRef.current) {\n                    clearInterval(pollIntervalRef.current)\n                    pollIntervalRef.current = null\n                  }\n                  updateStepState(stepId, {\n                    status: 'error',\n                    error: pollError instanceof Error ? pollError.message : 'Error checking job status',\n                  })\n                }\n              }, 2000) // Poll every 2 seconds\n\n              // Don't fall through to the completion logic below\n              return\n            }\n\n            // SCRAPE JOB: Scrape URLs from the SERP results\n            if (step.jobType === 'niche_finder_scrape') {\n              // Get the jobId from the previous step (search_and_preview)\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n              console.log('[SCRAPE] Looking for search_and_preview step:', searchStep)\n              console.log('[SCRAPE] search_and_preview output:', searchStep?.output)\n\n              // Also check for serp_search (legacy step name)\n              const serpStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'serp_search')\n              console.log('[SCRAPE] Looking for serp_search step:', serpStep)\n              console.log('[SCRAPE] serp_search output:', serpStep?.output)\n\n              // Try to get jobId from either step\n              let jobId = (searchStep?.output as { jobId?: string })?.jobId ||\n                          (serpStep?.output as { jobId?: string })?.jobId\n\n              // If still no jobId, try from input (might be passed from ReviewAndScrapePanel)\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n                console.log('[SCRAPE] Got jobId from input:', jobId)\n              }\n\n              if (!jobId) {\n                console.error('[SCRAPE] No jobId found. All steps:', state.phases.flatMap(p => p.steps).map(s => ({ id: s.id, output: s.output })))\n                throw new Error('No se encontró el Job ID del paso de búsqueda')\n              }\n\n              console.log('[SCRAPE] Starting scrape for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando scraping...' }\n              })\n\n              // Get total URLs to scrape\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.urls_found || 0\n\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Scrapeando 0/${totalUrls} URLs...` }\n              })\n\n              // Start scraping - this will scrape in batches\n              let scrapedCount = 0\n              let failedCount = 0\n              let hasMore = true\n\n              while (hasMore) {\n                try {\n                  const scrapeResponse = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = scrapeResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[SCRAPE] Non-JSON response, continuing...')\n                    // Wait a bit and continue polling\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'scrape_done') {\n                      hasMore = false\n                      scrapedCount = checkData.job?.scrape_success_count || 0\n                      failedCount = checkData.job?.scrape_failed_count || 0\n                    }\n                    continue\n                  }\n\n                  const scrapeData = await scrapeResponse.json()\n                  console.log('[SCRAPE] Batch response:', scrapeData)\n\n                  if (scrapeData.error) {\n                    throw new Error(scrapeData.error)\n                  }\n\n                  scrapedCount += scrapeData.scraped || 0\n                  failedCount += scrapeData.failed || 0\n                  hasMore = scrapeData.has_more || false\n\n                  // Update progress with real-time feedback\n                  updateStepState(stepId, {\n                    progress: {\n                      current: scrapedCount + failedCount,\n                      total: totalUrls,\n                      label: `Scrapeando ${scrapedCount + failedCount}/${totalUrls} URLs...`,\n                    },\n                    partialResults: {\n                      successCount: scrapedCount,\n                      failedCount: failedCount,\n                      lastUrl: scrapeData.last_scraped_url,\n                      lastSnippet: scrapeData.last_scraped_snippet,\n                    },\n                  })\n\n                } catch (scrapeError) {\n                  console.error('[SCRAPE] Batch error:', scrapeError)\n                  // Don't throw - try to continue with next batch\n                  // The endpoint will mark failed URLs and continue\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'scrape_done' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Scraping failed')\n                    }\n                  }\n                }\n              }\n\n              // Mark as completed\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  scrapedCount,\n                  failedCount,\n                },\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            if (step.jobType === 'niche_finder_extract') {\n              // Get jobId from previous steps (review_and_scrape or scrape_results)\n              const scrapeResultsStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'scrape_results')\n              const reviewAndScrapeStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'review_and_scrape')\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n\n              console.log('[EXTRACT] Looking for jobId from steps:', {\n                scrape_results: scrapeResultsStep?.output,\n                review_and_scrape: reviewAndScrapeStep?.output,\n                search_and_preview: searchStep?.output,\n              })\n\n              let jobId = (scrapeResultsStep?.output as { jobId?: string })?.jobId ||\n                          (reviewAndScrapeStep?.output as { jobId?: string })?.jobId ||\n                          (searchStep?.output as { jobId?: string })?.jobId\n\n              // Also try from input\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n              }\n\n              if (!jobId) {\n                console.error('[EXTRACT] No jobId found')\n                throw new Error('No se encontró el Job ID. Por favor ejecuta los pasos anteriores primero.')\n              }\n\n              console.log('[EXTRACT] Starting extraction for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' }\n              })\n\n              // Get total URLs to extract from job status\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.scrape_success_count || 0\n\n              console.log('[EXTRACT] Total URLs to process:', totalUrls)\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` }\n              })\n\n              // Call extract endpoint in batches until has_more=false\n              let hasMore = true\n              let extractedTotal = 0\n              let filteredTotal = 0\n              let processedTotal = 0\n\n              while (hasMore) {\n                try {\n                  const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = extractResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[EXTRACT] Non-JSON response, polling status...')\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'completed') {\n                      hasMore = false\n                      extractedTotal = checkData.job?.niches_extracted || 0\n                    }\n                    continue\n                  }\n\n                  const extractData = await extractResponse.json()\n                  console.log('[EXTRACT] Batch response:', extractData)\n\n                  if (extractData.error) {\n                    throw new Error(extractData.error)\n                  }\n\n                  extractedTotal += extractData.extracted || 0\n                  filteredTotal += extractData.filtered || 0\n                  processedTotal = extractedTotal + filteredTotal\n                  hasMore = extractData.has_more || false\n\n                  updateStepState(stepId, {\n                    progress: {\n                      current: processedTotal,\n                      total: totalUrls,\n                      label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                    },\n                    partialResults: {\n                      successCount: extractedTotal,\n                      failedCount: filteredTotal,\n                    },\n                  })\n                } catch (extractError) {\n                  console.error('[EXTRACT] Batch error:', extractError)\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'completed' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Extraction failed')\n                    }\n                  }\n                }\n              }\n\n              // Get extracted problems and format as CSV\n              console.log('[EXTRACT] Getting results from /api/niche-finder/results/', jobId)\n              const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n\n              if (!resultsResponse.ok) {\n                console.error('[EXTRACT] Failed to get results:', resultsResponse.status, resultsResponse.statusText)\n                throw new Error(`Error obteniendo resultados: ${resultsResponse.status}`)\n              }\n\n              const resultsData = await resultsResponse.json()\n              console.log('[EXTRACT] Results data:', {\n                hasNiches: !!resultsData.niches,\n                nichesCount: resultsData.niches?.length || 0,\n                status: resultsData.status,\n                urls: resultsData.urls,\n              })\n\n              // Format niches as CSV string with all relevant columns\n              const niches = resultsData.niches || []\n              let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n              for (const niche of niches) {\n                const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                const url = niche.source_url || ''\n                csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n              }\n\n              console.log('[EXTRACT] Completed. Total problems:', niches.length, 'CSV preview:', csvOutput.substring(0, 200))\n\n              // Mark as completed with CSV output\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: csvOutput,\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            // UNIFIED SEARCH + EXTRACT: Handles both SERP and analysis in one step\n            if (step.jobType === 'niche_finder_unified') {\n              const action = (input as { action?: string })?.action\n\n              // ============ ACTION: SERP ============\n              if (action === 'serp') {\n                const config = (input as { config?: { life_contexts: string[]; product_words: string[]; indicators: string[]; sources: { reddit: boolean; thematic_forums: boolean; general_forums: string[] }; serp_pages: number } }).config\n                if (!config) {\n                  throw new Error('No se recibió configuración para la búsqueda')\n                }\n\n                console.log('[UNIFIED] Starting SERP with config:', config)\n\n                // Get campaign variables\n                const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                // Create the SERP job\n                const jobResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: {\n                      ...config,\n                      campaign_id: selectedCampaignId,\n                      ecp_name: campaignVars?.['ECP Name'] || campaignVars?.ecp_name,\n                      ecp_product: campaignVars?.['ECP Product'] || campaignVars?.ecp_product,\n                      ecp_target: campaignVars?.['ECP Target'] || campaignVars?.ecp_target,\n                      ecp_industry: campaignVars?.['ECP Industry'] || campaignVars?.ecp_industry,\n                      ecp_category: campaignVars?.['ECP Category'] || campaignVars?.ecp_category,\n                      ecp_country: campaignVars?.['ECP Country'] || campaignVars?.ecp_country,\n                    }\n                  }),\n                })\n\n                if (!jobResponse.ok) {\n                  const errorText = await jobResponse.text()\n                  throw new Error(`Error al crear job: ${jobResponse.status} - ${errorText || 'Sin respuesta'}`)\n                }\n\n                const jobText = await jobResponse.text()\n                if (!jobText || jobText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al crear el job')\n                }\n\n                const jobData = JSON.parse(jobText)\n                const jobId = jobData.job_id\n\n                if (!jobId) {\n                  throw new Error('No se pudo crear el job de búsqueda')\n                }\n\n                console.log('[UNIFIED] SERP Job created:', jobId)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'serp_executing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' },\n                })\n\n                // Start SERP execution\n                const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n\n                if (!serpResponse.ok) {\n                  const serpErrorText = await serpResponse.text()\n                  let errorMessage = `Error al iniciar búsqueda SERP: ${serpResponse.status}`\n                  try {\n                    const serpError = JSON.parse(serpErrorText)\n                    if (serpError.code === 'MISSING_API_KEY') {\n                      errorMessage = `${serpError.error}`\n                    } else if (serpError.error) {\n                      errorMessage = serpError.error\n                    }\n                  } catch {\n                    if (serpErrorText) errorMessage += ` - ${serpErrorText}`\n                  }\n                  throw new Error(errorMessage)\n                }\n\n                console.log('[UNIFIED] SERP execution started successfully')\n\n                // Poll for SERP completion\n                let serpComplete = false\n                let pollRetries = 0\n                const MAX_POLL_RETRIES = 3\n                while (!serpComplete) {\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n                  try {\n                    const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n\n                    if (!statusRes.ok) {\n                      console.warn(`[UNIFIED] Status poll failed with ${statusRes.status}`)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error(`Error al consultar estado del job: ${statusRes.status}`)\n                      }\n                      continue\n                    }\n\n                    const text = await statusRes.text()\n                    if (!text || text.trim() === '') {\n                      console.warn('[UNIFIED] Empty response from status endpoint, retrying...')\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('El servidor no está respondiendo correctamente')\n                      }\n                      continue\n                    }\n\n                    const statusData = JSON.parse(text)\n                    pollRetries = 0 // Reset retries on success\n\n                    const urlsFound = statusData.job?.urls_found || 0\n                    // Status API returns serp_total and serp_completed (not total_queries/completed_queries)\n                    const totalSearches = statusData.job?.serp_total || statusData.progress?.serp?.total || 0\n                    const completedSearches = statusData.job?.serp_completed || statusData.progress?.serp?.completed || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: completedSearches,\n                        total: totalSearches,\n                        label: `Buscando... ${urlsFound} URLs encontradas`,\n                      },\n                    })\n\n                    if (['serp_done', 'serp_completed', 'scrape_done', 'completed'].includes(statusData.status)) {\n                      serpComplete = true\n                      console.log('[UNIFIED] SERP completed. URLs found:', urlsFound)\n                      updateStepState(stepId, {\n                        output: { jobId, phase: 'serp_complete', urlsFound },\n                        progress: undefined,\n                      })\n                    } else if (statusData.status === 'failed') {\n                      throw new Error(statusData.job?.error_message || 'SERP falló')\n                    }\n                  } catch (pollError) {\n                    if (pollError instanceof SyntaxError) {\n                      console.warn('[UNIFIED] JSON parse error in poll, retrying...', pollError)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('Error al procesar respuesta del servidor')\n                      }\n                    } else {\n                      throw pollError\n                    }\n                  }\n                }\n                return // Don't mark as completed - wait for analyze action\n              }\n\n              // ============ ACTION: ANALYZE (Scrape + Extract) ============\n              if (action === 'analyze') {\n                const jobId = (input as { jobId?: string }).jobId\n                const selectedSources = (input as { selectedSources?: string[] }).selectedSources || []\n                const extractionPrompt = (input as { extractionPrompt?: string }).extractionPrompt\n\n                if (!jobId) {\n                  throw new Error('No se encontró el Job ID')\n                }\n\n                console.log('[UNIFIED] Starting analysis for job:', jobId, 'sources:', selectedSources, 'custom prompt:', !!extractionPrompt)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'analyzing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando análisis...' },\n                })\n\n                // If a custom extraction prompt was provided, update the job config\n                if (extractionPrompt) {\n                  console.log('[UNIFIED] Updating job with custom extraction prompt')\n                  const updateRes = await fetch(`/api/niche-finder/jobs/${jobId}`, {\n                    method: 'PATCH',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ extraction_prompt: extractionPrompt }),\n                  })\n                  if (!updateRes.ok) {\n                    console.warn('[UNIFIED] Failed to update job with custom prompt:', updateRes.status)\n                  }\n                }\n\n                // Get total URLs to process\n                const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                if (!statusRes.ok) {\n                  throw new Error(`Error al obtener estado del job: ${statusRes.status}`)\n                }\n                const statusText = await statusRes.text()\n                if (!statusText || statusText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al consultar estado')\n                }\n                const statusData = JSON.parse(statusText)\n                const totalUrls = statusData.job?.urls_found || 0\n\n                // Start scraping - call API repeatedly until all URLs are processed\n                console.log('[UNIFIED] Starting scrape for', totalUrls, 'URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: totalUrls, label: 'Descargando contenido...' },\n                })\n\n                let scrapeComplete = false\n                let scrapeRetries = 0\n                let totalScraped = 0\n                let totalFailed = 0\n                const MAX_SCRAPE_RETRIES = 5 // More retries for transient failures\n\n                while (!scrapeComplete) {\n                  try {\n                    console.log(`[UNIFIED] Scrape batch starting, totalScraped=${totalScraped}, retries=${scrapeRetries}`)\n\n                    // Call scrape API with timeout (120s to allow for slow scrapes)\n                    const controller = new AbortController()\n                    const timeout = setTimeout(() => controller.abort(), 120000)\n\n                    const scrapeRes = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                      method: 'POST',\n                      headers: { 'Content-Type': 'application/json' },\n                      body: JSON.stringify({ sources: selectedSources }),\n                      signal: controller.signal,\n                    })\n                    clearTimeout(timeout)\n\n                    if (!scrapeRes.ok) {\n                      const errorText = await scrapeRes.text().catch(() => '')\n                      console.error(`[UNIFIED] Scrape response not ok: ${scrapeRes.status}`, errorText)\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(`Error en scraping: ${scrapeRes.status} - ${errorText || 'Unknown error'}`)\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeText = await scrapeRes.text()\n                    if (!scrapeText) {\n                      console.warn('[UNIFIED] Empty scrape response, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Respuesta vacía del servidor después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeData = JSON.parse(scrapeText)\n                    scrapeRetries = 0 // Reset on successful response\n\n                    if (scrapeData.error) {\n                      // Check if it's a retryable error\n                      if (scrapeData.error.includes('Rate limit') || scrapeData.error.includes('timeout')) {\n                        console.warn(`[UNIFIED] Retryable scrape error: ${scrapeData.error}`)\n                        scrapeRetries++\n                        if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(scrapeData.error)\n                        await new Promise(r => setTimeout(r, 5000))\n                        continue\n                      }\n                      throw new Error(scrapeData.error)\n                    }\n\n                    // Update progress with scraped count from this batch\n                    totalScraped += scrapeData.scraped || 0\n                    totalFailed += scrapeData.failed || 0\n                    const remaining = scrapeData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: totalScraped,\n                        total: totalUrls,\n                        label: `Descargando... ${totalScraped}/${totalUrls} URLs${totalFailed > 0 ? ` (${totalFailed} fallidas)` : ''}`,\n                      },\n                      partialResults: {\n                        successCount: totalScraped,\n                        failedCount: totalFailed,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Scrape batch complete: +${scrapeData.scraped} scraped, ${remaining} remaining, has_more: ${scrapeData.has_more}`)\n\n                    // Check if scraping is complete\n                    if (!scrapeData.has_more || remaining === 0) {\n                      scrapeComplete = true\n                    }\n                  } catch (e) {\n                    console.error('[UNIFIED] Scrape error:', e)\n                    if (e instanceof SyntaxError) {\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 3000))\n                    } else if (e instanceof Error && e.name === 'AbortError') {\n                      // Timeout - retry with longer wait\n                      console.warn('[UNIFIED] Scrape request timed out, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Timeout en scraping después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 5000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Scraping complete, total scraped:', totalScraped)\n\n                // Start extraction - use totalScraped as the base since only scraped URLs can be extracted\n                const extractionTotal = totalScraped || totalUrls // Fallback to totalUrls if scraping tracked differently\n                console.log('[UNIFIED] Starting extraction for', extractionTotal, 'scraped URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: extractionTotal, label: 'Extrayendo problemas...' },\n                })\n\n                let extractComplete = false\n                let extractedTotal = 0\n                let filteredTotal = 0\n                let extractRetries = 0\n\n                while (!extractComplete) {\n                  try {\n                    const extractRes = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, { method: 'POST' })\n                    if (!extractRes.ok) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error(`Error en extracción: ${extractRes.status}`)\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const text = await extractRes.text()\n                    if (!text) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Respuesta vacía del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const extractData = JSON.parse(text)\n                    extractRetries = 0\n\n                    if (extractData.error) {\n                      throw new Error(extractData.error)\n                    }\n\n                    extractedTotal += extractData.extracted || 0\n                    filteredTotal += extractData.filtered || 0\n                    const processed = extractedTotal + filteredTotal\n                    const remaining = extractData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: processed,\n                        total: extractionTotal,\n                        label: `Extrayendo... ${extractedTotal} problemas de ${processed}/${extractionTotal} URLs${filteredTotal > 0 ? ` (${filteredTotal} filtradas)` : ''}`,\n                      },\n                      partialResults: {\n                        extracted: extractedTotal,\n                        filtered: filteredTotal,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Extract batch: ${extractData.extracted} extracted, ${extractData.filtered} filtered, ${remaining} remaining, has_more: ${extractData.has_more}`)\n\n                    if (!extractData.has_more || remaining === 0) {\n                      extractComplete = true\n                    }\n                  } catch (e) {\n                    if (e instanceof SyntaxError) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Extraction complete. Problems:', extractedTotal, 'Filtered:', filteredTotal)\n\n                // Get results and format as CSV\n                console.log('[UNIFIED] Getting results')\n                const resultsRes = await fetch(`/api/niche-finder/results/${jobId}`)\n                if (!resultsRes.ok) {\n                  throw new Error(`Error al obtener resultados: ${resultsRes.status}`)\n                }\n                const resultsText = await resultsRes.text()\n                const resultsData = resultsText ? JSON.parse(resultsText) : { niches: [] }\n                const niches = resultsData.niches || []\n\n                let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n                for (const niche of niches) {\n                  const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                  const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                  const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                  const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                  const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                  const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                  const url = niche.source_url || ''\n                  csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n                }\n\n                console.log('[UNIFIED] Complete. Problems:', niches.length)\n                updateStepState(stepId, {\n                  status: 'completed',\n                  completedAt: new Date(),\n                  output: { jobId, extractedCount: niches.length, csv: csvOutput },\n                })\n                setTimeout(goToNextStep, 500)\n                return\n              }\n\n              // Unknown action\n              console.warn('[UNIFIED] Unknown action:', action)\n            }\n\n            // For other job types, just mark as pending\n            result = input\n            break\n\n          case 'none':\n          default:\n            // No execution needed, just proceed\n            result = input\n            break\n        }\n\n        // Mark as completed\n        updateStepState(stepId, {\n          status: 'completed',\n          completedAt: new Date(),\n          output: result,\n        })\n\n        // Auto-advance for auto steps\n        if (['auto', 'auto_with_review'].includes(step.type)) {\n          setTimeout(goToNextStep, 500)\n        }\n      } catch (error) {\n        updateStepState(stepId, {\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Error desconocido',\n        })\n      }\n    },\n    [projectId, playbookConfig.type, playbookConfig.phases, updateStepState, goToNextStep, selectedCampaign, state.phases]\n  )\n\n  // Handle continue from current step\n  const handleContinue = useCallback(() => {\n    console.log('[handleContinue] Called for step:', currentStep?.id, 'current status:', currentStepState?.status)\n    // Note: Don't update step state here if the caller (WorkArea) already updated it.\n    // The caller is responsible for setting status and output correctly before calling onContinue.\n    // We only set completedAt if not already completed, and we do it in a way that preserves output.\n    if (currentStepState?.status !== 'completed') {\n      console.log('[handleContinue] Status is not completed, updating step state (without output)')\n      // Mark as completed, but preserve any existing output that might have been set\n      // by the caller in the same tick (before React re-renders)\n      updateStepState(currentStep.id, {\n        status: 'completed',\n        completedAt: new Date(),\n        // Don't set output - it should already be set by the caller\n      })\n    } else {\n      console.log('[handleContinue] Status is already completed, not updating')\n    }\n    // Enable auto-execution for the next step (if it's an auto step)\n    setShouldAutoExecute(true)\n    goToNextStep()\n  }, [currentStep?.id, currentStepState?.status, updateStepState, goToNextStep])\n\n  // Handle edit - volver a editar un paso completado\n  const handleEdit = useCallback(() => {\n    if (!currentStep) return\n    // Cambiar status a pending sin perder los datos (suggestions, output, etc.)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      completedAt: undefined,\n      error: undefined,\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle cancel - cancelar ejecución en curso\n  // IMPORTANTE: Mantiene el output (jobId) para poder retomar el job\n  const handleCancel = useCallback(() => {\n    if (!currentStep) return\n\n    // Clear polling interval if running\n    if (pollIntervalRef.current) {\n      clearInterval(pollIntervalRef.current)\n      pollIntervalRef.current = null\n      console.log('[Cancel] Cleared polling interval')\n    }\n\n    // Volver a pending y limpiar progreso, pero MANTENER output (contiene jobId)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      progress: undefined,\n      error: undefined,\n      // NO limpiamos output para mantener el jobId y poder retomar\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle quick retry - retry with same configuration\n  const handleQuickRetry = useCallback(async () => {\n    if (!currentStep || !currentStepState) return\n\n    console.log('[Retry] Quick retry for step:', currentStep.id)\n\n    // Start a new retry attempt\n    try {\n      await stepRetryActions.startRetry(currentStep.id)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Reset step state and re-execute\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input\n    executeStep(currentStep.id, currentStepState.input)\n  }, [currentStep, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle retry with config modification - opens dialog\n  const handleRetryWithConfig = useCallback(() => {\n    if (!currentStep) return\n    setRetryDialogStepId(currentStep.id)\n    setRetryDialogOpen(true)\n  }, [currentStep])\n\n  // Handle retry from dialog with config overrides\n  const handleRetryFromDialog = useCallback(async (configOverrides?: StepAttemptConfig) => {\n    if (!retryDialogStepId || !currentStepState) return\n\n    console.log('[Retry] Retry from dialog for step:', retryDialogStepId, 'with config:', configOverrides)\n\n    // Start a new retry attempt with config\n    try {\n      await stepRetryActions.startRetry(retryDialogStepId, configOverrides)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Close dialog\n    setRetryDialogOpen(false)\n    setRetryDialogStepId(null)\n\n    // Reset step state\n    updateStepState(retryDialogStepId, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input (config overrides are tracked in the attempt)\n    executeStep(retryDialogStepId, currentStepState.input)\n  }, [retryDialogStepId, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle skip step - mark as skipped and continue\n  const handleSkipStep = useCallback(() => {\n    if (!currentStep) return\n\n    console.log('[Skip] Skipping step:', currentStep.id)\n\n    updateStepState(currentStep.id, {\n      status: 'skipped',\n      completedAt: new Date(),\n      error: undefined,\n    })\n\n    // Move to next step\n    handleContinue()\n  }, [currentStep, updateStepState, handleContinue])\n\n  // Get retry info for current step\n  const currentStepRetryInfo = currentStep\n    ? stepRetryActions.getRetryInfo(currentStep.id)\n    : null\n\n  // Check if max retries reached\n  const maxRetriesReached = currentStepRetryInfo\n    ? currentStepRetryInfo.attemptNumber >= currentStepRetryInfo.maxAttempts\n    : false\n\n  // Auto-start current step if it's an auto step, pending, AND user clicked Continue\n  useEffect(() => {\n    console.log('[AutoExecute] Check:', {\n      shouldAutoExecute,\n      currentStepId: currentStep?.id,\n      currentStepType: currentStep?.type,\n      currentStepStatus: currentStepState?.status,\n    })\n    if (\n      shouldAutoExecute &&\n      currentStep &&\n      currentStepState?.status === 'pending' &&\n      ['auto'].includes(currentStep.type)\n    ) {\n      console.log('[AutoExecute] Starting auto execution for:', currentStep.id)\n      // Reset the flag\n      setShouldAutoExecute(false)\n      // Small delay to allow UI to render first\n      const timer = setTimeout(() => {\n        executeStep(currentStep.id)\n      }, 300)\n      return () => clearTimeout(timer)\n    }\n  }, [shouldAutoExecute, currentStep, currentStepState?.status, executeStep])\n\n  // Resume polling for in_progress steps on page reload\n  // This handles the case where user refreshes the page while a SERP job is running\n  useEffect(() => {\n    // Only for search_with_preview steps that are in_progress with a jobId\n    if (\n      currentStep?.type === 'search_with_preview' &&\n      (currentStepState?.status === 'in_progress' || currentStepState?.status === 'pending') &&\n      currentStepState?.output &&\n      !pollIntervalRef.current\n    ) {\n      const output = currentStepState.output as { jobId?: string }\n      const jobId = output.jobId\n\n      if (jobId) {\n        console.log('[Resume] Resuming polling for job:', jobId)\n\n        // First, check if job is already done (immediate check, not polling)\n        fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          .then(res => res.json())\n          .then(statusData => {\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDone) {\n              console.log('[Resume] Job already completed, marking step as done')\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n              return // Don't start polling\n            }\n            // If not done, continue with normal polling setup below\n            startPolling()\n          })\n          .catch(err => {\n            console.error('[Resume] Error checking initial status:', err)\n            startPolling() // Start polling anyway\n          })\n\n        function startPolling() {\n          if (pollIntervalRef.current) return // Already polling\n\n          // Set up polling - same logic as in executeStep\n          let isResuming = false\n          let lastCompletedCount = -1\n          let stallCount = 0\n          let initialCompleted = -1\n\n          pollIntervalRef.current = setInterval(async () => {\n          try {\n            const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n            const statusData = await statusResponse.json()\n\n            const completed = statusData.progress?.serp?.completed || 0\n            const total = statusData.progress?.serp?.total || 0\n            const remaining = total - completed\n            const label = total > 0\n              ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n              : 'Reconectando...'\n\n            updateStepState(currentStep.id, {\n              progress: {\n                current: completed,\n                total: total,\n                label,\n              },\n            })\n\n            // Track initial value on first poll\n            if (initialCompleted === -1) {\n              initialCompleted = completed\n              console.log('[Resume] Initial completed:', initialCompleted)\n            }\n\n            // Auto-resume if job was interrupted\n            if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n              if (lastCompletedCount === completed && remaining > 0) {\n                stallCount++\n                const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                if (stallCount >= 2 || noProgressSinceStart) {\n                  console.log(`[Resume] Job stalled at ${completed}/${total}, auto-resuming...`)\n                  isResuming = true\n                  stallCount = 0\n                  fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                    .then(res => res.json())\n                    .then(data => {\n                      console.log('[Resume] Resume response:', data)\n                      isResuming = false\n                    })\n                    .catch(err => {\n                      console.error('[Resume] Resume error:', err)\n                      isResuming = false\n                    })\n                }\n              } else {\n                stallCount = 0\n              }\n            }\n            lastCompletedCount = completed\n\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDoneInPoll = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDoneInPoll) {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n            } else if (statusData.status === 'failed' || statusData.status === 'error') {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'error',\n                error: statusData.job?.error_message || 'Job failed',\n              })\n            }\n          } catch (pollError) {\n            console.error('[Resume] Poll error:', pollError)\n            // Don't stop polling on transient errors\n          }\n        }, 2000)\n        } // End startPolling function\n\n        // Cleanup on unmount\n        return () => {\n          if (pollIntervalRef.current) {\n            clearInterval(pollIntervalRef.current)\n            pollIntervalRef.current = null\n          }\n        }\n      }\n    }\n  }, [currentStep?.id, currentStep?.type, currentStepState?.status, currentStepState?.output, updateStepState, goToNextStep])\n\n  if (!currentPhase || !currentStep || !currentStepState) {\n    return (\n      <div className=\"flex items-center justify-center h-64 text-gray-500\">\n        Error: Configuración de playbook inválida\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n      {/* Header with mode selector */}\n      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3\">\n          <span className=\"text-xl\">{playbookConfig.icon}</span>\n          <h2 className=\"text-lg font-semibold text-gray-900\">{playbookConfig.name}</h2>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}\n          <div className=\"relative flex items-center gap-1\">\n            <button\n              onClick={() => {\n                setMode('campaign')\n                setShowCampaignDropdown(!showCampaignDropdown)\n              }}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                mode === 'campaign'\n                  ? 'bg-blue-100 text-blue-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Folder size={16} />\n              {selectedCampaign ? selectedCampaign.name : 'Seleccionar Campaña'}\n              <ChevronDown size={16} />\n            </button>\n\n            {/* Edit campaign settings button */}\n            {selectedCampaignId && (\n              <button\n                onClick={() => setShowCampaignSettings(true)}\n                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg\"\n                title=\"Editar configuración de campaña\"\n              >\n                <Pencil size={14} />\n              </button>\n            )}\n\n            {/* Dropdown */}\n            {showCampaignDropdown && (\n              <div className=\"absolute right-0 top-full mt-1 w-64 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50\">\n                {campaigns.length === 0 ? (\n                  <div className=\"px-3 py-2 text-sm text-gray-500\">No hay campañas</div>\n                ) : (\n                  campaigns.map(campaign => (\n                    <div\n                      key={campaign.id}\n                      className={`flex items-center justify-between px-3 py-2 text-sm hover:bg-gray-50 ${\n                        selectedCampaignId === campaign.id ? 'bg-blue-50' : ''\n                      }`}\n                    >\n                      <button\n                        onClick={() => {\n                          setSelectedCampaignId(campaign.id)\n                          setShowCampaignDropdown(false)\n                        }}\n                        className=\"flex-1 flex items-center justify-between text-left\"\n                      >\n                        <span className=\"font-medium text-gray-900\">{campaign.name}</span>\n                        <span className=\"text-gray-500 mr-2\">\n                          {campaign.completedSteps}/{campaign.totalSteps}\n                        </span>\n                      </button>\n                      <button\n                        onClick={(e) => {\n                          e.stopPropagation()\n                          deleteCampaign(campaign.id)\n                        }}\n                        className=\"p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded\"\n                        title=\"Eliminar campaña\"\n                      >\n                        <Trash2 size={14} />\n                      </button>\n                    </div>\n                  ))\n                )}\n                <div className=\"border-t border-gray-100 mt-1 pt-1\">\n                  <button\n                    onClick={() => {\n                      setShowWizard(true)\n                      setShowCampaignDropdown(false)\n                    }}\n                    className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-blue-600 hover:bg-blue-50\"\n                  >\n                    <Plus size={16} />\n                    Nueva Campaña\n                  </button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Main content */}\n      {mode === 'config' ? (\n        /* Configuration Mode - Full width */\n        <div className=\"flex-1 overflow-hidden\">\n          <ConfigurationMode\n            projectId={projectId}\n            playbookConfig={playbookConfig}\n            onSave={() => {\n              // Optionally refresh something after save\n            }}\n          />\n        </div>\n      ) : (\n        /* Campaign Mode - Dual panel */\n        <div className=\"flex flex-1 overflow-hidden\">\n          {/* Navigation Panel - Left side */}\n          <div className=\"w-80 flex-shrink-0\">\n            <NavigationPanel\n              phases={playbookConfig.phases}\n              phaseStates={state.phases}\n              currentPhaseIndex={state.currentPhaseIndex}\n              currentStepIndex={state.currentStepIndex}\n              onStepClick={goToStep}\n            />\n          </div>\n\n          {/* Work Area - Right side */}\n          <div className=\"flex-1 overflow-y-auto\">\n            {!selectedCampaignId ? (\n              /* No campaign selected - prompt to select or create */\n              <div className=\"flex flex-col items-center justify-center h-full bg-white p-8 text-center\">\n                <Folder className=\"text-gray-300 mb-4\" size={64} />\n                <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                  Selecciona o crea una campaña\n                </h3>\n                <p className=\"text-gray-500 mb-6 max-w-md\">\n                  Para ejecutar el playbook, primero debes seleccionar una campaña existente o crear una nueva.\n                </p>\n                <button\n                  onClick={() => setShowWizard(true)}\n                  className=\"flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n                >\n                  <Plus size={16} />\n                  Nueva Campaña\n                </button>\n              </div>\n            ) : (\n              <>\n                <WorkArea\n                  step={currentStep}\n                  stepState={currentStepState}\n                  onContinue={handleContinue}\n                  onBack={goToPreviousStep}\n                  onExecute={(input) => executeStep(currentStep.id, input)}\n                  onUpdateState={(update) => updateStepState(currentStep.id, update)}\n                  onEdit={handleEdit}\n                  onCancel={handleCancel}\n                  onRerunPrevious={rerunPreviousStep}\n                  onRetry={handleQuickRetry}\n                  onRetryWithConfig={handleRetryWithConfig}\n                  onSkipStep={handleSkipStep}\n                  isFirst={isFirstStep}\n                  isLast={isLastStep}\n                  previousStepOutput={getPreviousStepOutput()}\n                  projectId={projectId}\n                  playbookContext={buildPlaybookContext()}\n                  allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                    phase.steps.map((stepDef, stepIdx) => ({\n                      definition: stepDef,\n                      state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                    }))\n                  )}\n                  saveState={sessionId ? stepPersistenceState : undefined}\n                  retryInfo={currentStepRetryInfo || undefined}\n                  maxRetriesReached={maxRetriesReached}\n                  sessionId={sessionId}\n                />\n\n                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Campaign Wizard Modal */}\n      {showWizard && (\n        <CampaignWizard\n          projectId={projectId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowWizard(false)}\n          onCreated={(campaignId) => {\n            setSelectedCampaignId(campaignId)\n            setShowWizard(false)\n            // Reload campaigns\n            loadCampaigns()\n          }}\n        />\n      )}\n\n      {/* Campaign Settings Modal */}\n      {showCampaignSettings && selectedCampaignId && (\n        <CampaignSettings\n          campaignId={selectedCampaignId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowCampaignSettings(false)}\n          onSaved={() => {\n            loadCampaigns()\n          }}\n        />\n      )}\n    </div>\n  )\n}\n","structuredPatch":[{"oldStart":14,"oldLines":7,"newStart":14,"newLines":8,"lines":[" import ConfigurationMode from './ConfigurationMode'"," import CampaignWizard from './CampaignWizard'"," import CampaignSettings from './CampaignSettings'","-import { Settings, ChevronDown, Plus, Folder, Pencil, Trash2 } from 'lucide-react'","+import { Settings, ChevronDown, Plus, Folder, Pencil, Trash2, Database } from 'lucide-react'","+import { ArtifactBrowser } from './ArtifactBrowser'"," import { useStepPersistence } from '@/hooks/useStepPersistence'"," import { useStepRetry } from '@/hooks/useStepRetry'"," import { StepAttemptConfig, StepRetryInfo } from './types'"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JninZLtbQg5n2Gq1FfsKhZ","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add state for the ArtifactBrowser visibility and the Session Data button. Let me find where the state declarations are:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":588,"cache_read_input_tokens":125512,"cache_creation":{"ephemeral_5m_input_tokens":588,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"2bf1babd-fa2e-48e0-abcb-b621b8da9235"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JninZLtbQg5n2Gq1FfsKhZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YK9McTF1GRwQNee6ghk52q","name":"Grep","input":{"pattern":"const \\[showWizard|const \\[showCampaignSettings","path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":588,"cache_read_input_tokens":125512,"cache_creation":{"ephemeral_5m_input_tokens":588,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"ee51836f-f367-4c96-b6cc-f1406656fa90"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YK9McTF1GRwQNee6ghk52q","type":"tool_result","content":"172:  const [showWizard, setShowWizard] = useState(false)\n173:  const [showCampaignSettings, setShowCampaignSettings] = useState(false)"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"e71dae42-9d6c-4ce6-9f8d-6173b2ca02dd","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"172:  const [showWizard, setShowWizard] = useState(false)\n173:  const [showCampaignSettings, setShowCampaignSettings] = useState(false)","numLines":2}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Ez82EekxkZLrMFcZiEbGBz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Bx58SX4a1vKT3LQV2g9KMw","name":"Edit","input":{"replace_all":false,"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","old_string":"  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)","new_string":"  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":246,"cache_read_input_tokens":126100,"cache_creation":{"ephemeral_5m_input_tokens":246,"ephemeral_1h_input_tokens":0},"output_tokens":234,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"8d16a498-1e41-4935-9025-30bf1d0ae954"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Bx58SX4a1vKT3LQV2g9KMw","type":"tool_result","content":"The file /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"eac8e53d-c49f-4e15-b37d-fd1c2ee695cd","tool_use_result":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","oldString":"  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)","newString":"  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)","originalFile":"'use client'\n\nimport { useState, useCallback, useEffect, useRef } from 'react'\nimport {\n  PlaybookShellProps,\n  PlaybookState,\n  PhaseState,\n  StepState,\n  StepDefinition,\n  PhaseDefinition,\n} from './types'\nimport NavigationPanel from './NavigationPanel'\nimport { WorkArea } from './WorkArea'\nimport ConfigurationMode from './ConfigurationMode'\nimport CampaignWizard from './CampaignWizard'\nimport CampaignSettings from './CampaignSettings'\nimport { Settings, ChevronDown, Plus, Folder, Pencil, Trash2, Database } from 'lucide-react'\nimport { ArtifactBrowser } from './ArtifactBrowser'\nimport { useStepPersistence } from '@/hooks/useStepPersistence'\nimport { useStepRetry } from '@/hooks/useStepRetry'\nimport { StepAttemptConfig, StepRetryInfo } from './types'\nimport StepRetryDialog from './StepRetryDialog'\nimport FailedStepActions from './FailedStepActions'\n\n// Mode types for the unified view\ntype PlaybookMode = 'config' | 'campaign'\n\ninterface Campaign {\n  id: string\n  name: string\n  status: 'draft' | 'in_progress' | 'completed'\n  completedSteps: number\n  totalSteps: number\n  customVariables?: Record<string, unknown> // Includes context_type, product, target, etc.\n  playbookState?: PlaybookState // Saved playbook state for persistence\n}\n\nfunction initializeState(\n  projectId: string,\n  playbookConfig: PlaybookShellProps['playbookConfig'],\n  initialState?: Partial<PlaybookState>\n): PlaybookState {\n  const phases: PhaseState[] = playbookConfig.phases.map(phase => ({\n    id: phase.id,\n    status: 'pending',\n    steps: phase.steps.map(step => ({\n      id: step.id,\n      status: 'pending',\n    })),\n  }))\n\n  // Apply initial state if provided - match by ID for robustness when config changes\n  if (initialState?.phases) {\n    initialState.phases.forEach((savedPhaseState) => {\n      // Find phase by ID instead of index\n      const phaseIndex = phases.findIndex(p => p.id === savedPhaseState.id)\n      if (phaseIndex === -1) return\n\n      phases[phaseIndex].status = savedPhaseState.status\n      savedPhaseState.steps.forEach((savedStepState) => {\n        // Find step by ID instead of index\n        const stepIndex = phases[phaseIndex].steps.findIndex(s => s.id === savedStepState.id)\n        if (stepIndex === -1) return\n\n        phases[phaseIndex].steps[stepIndex] = {\n          ...phases[phaseIndex].steps[stepIndex],\n          ...savedStepState,\n        }\n      })\n    })\n  }\n\n  const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n  const completedSteps = phases.reduce(\n    (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n    0\n  )\n\n  // Validate currentPhaseIndex and currentStepIndex are within bounds\n  let currentPhaseIndex = initialState?.currentPhaseIndex ?? 0\n  let currentStepIndex = initialState?.currentStepIndex ?? 0\n\n  // Ensure phase index is valid\n  if (currentPhaseIndex >= playbookConfig.phases.length) {\n    currentPhaseIndex = Math.max(0, playbookConfig.phases.length - 1)\n  }\n\n  // Ensure step index is valid for the current phase\n  const currentPhaseSteps = playbookConfig.phases[currentPhaseIndex]?.steps.length ?? 0\n  if (currentStepIndex >= currentPhaseSteps) {\n    currentStepIndex = Math.max(0, currentPhaseSteps - 1)\n  }\n\n  // If the current step doesn't exist, find the first non-completed step\n  if (currentPhaseSteps === 0 || currentStepIndex < 0) {\n    // Find first pending step\n    for (let pi = 0; pi < phases.length; pi++) {\n      for (let si = 0; si < phases[pi].steps.length; si++) {\n        if (phases[pi].steps[si].status !== 'completed') {\n          currentPhaseIndex = pi\n          currentStepIndex = si\n          break\n        }\n      }\n      if (currentStepIndex >= 0) break\n    }\n    // Default to first step if all completed\n    if (currentStepIndex < 0) {\n      currentPhaseIndex = 0\n      currentStepIndex = 0\n    }\n  }\n\n  console.log('[initializeState] Validated indices:', {\n    originalPhase: initialState?.currentPhaseIndex,\n    originalStep: initialState?.currentStepIndex,\n    validatedPhase: currentPhaseIndex,\n    validatedStep: currentStepIndex,\n    maxPhases: playbookConfig.phases.length,\n    maxSteps: currentPhaseSteps,\n  })\n\n  return {\n    projectId,\n    playbookType: playbookConfig.type,\n    phases,\n    currentPhaseIndex,\n    currentStepIndex,\n    config: initialState?.config ?? {},\n    completedSteps,\n    totalSteps,\n    startedAt: initialState?.startedAt,\n    completedAt: initialState?.completedAt,\n  }\n}\n\nexport default function PlaybookShell({\n  projectId,\n  playbookConfig,\n  initialState,\n  sessionId,\n}: PlaybookShellProps) {\n  const [state, setState] = useState<PlaybookState>(() =>\n    initializeState(projectId, playbookConfig, initialState)\n  )\n\n  // Step persistence hook for auto-saving step data to database\n  const [stepPersistenceState, stepPersistenceActions] = useStepPersistence({\n    sessionId: sessionId || null,\n    autoSaveInterval: 30000, // Auto-save every 30 seconds\n    enabled: !!sessionId, // Only enable if sessionId is provided\n  })\n\n  // Step retry hook for managing retry attempts\n  const [stepRetryState, stepRetryActions] = useStepRetry(sessionId || null, {\n    enabled: !!sessionId,\n  })\n\n  // State for retry dialog\n  const [retryDialogOpen, setRetryDialogOpen] = useState(false)\n  const [retryDialogStepId, setRetryDialogStepId] = useState<string | null>(null)\n\n  // Flag to distinguish between intentional navigation (Continue button)\n  // vs manual navigation (clicking on a step)\n  const [shouldAutoExecute, setShouldAutoExecute] = useState(false)\n\n  // Mode: 'config' for editing base prompts, 'campaign' for execution\n  const [mode, setMode] = useState<PlaybookMode>('campaign')\n  const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null)\n  const [campaigns, setCampaigns] = useState<Campaign[]>([])\n  const [showCampaignDropdown, setShowCampaignDropdown] = useState(false)\n  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n\n  // Load campaigns from database\n  const loadCampaigns = useCallback(async () => {\n    try {\n      const response = await fetch(`/api/campaign/create?projectId=${projectId}`)\n      if (!response.ok) {\n        console.error('Failed to load campaigns')\n        return\n      }\n      const data = await response.json()\n      if (data.campaigns) {\n        const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n        const mappedCampaigns: Campaign[] = data.campaigns.map((c: any) => ({\n          id: c.id,\n          name: c.ecp_name,\n          status: c.status || 'draft',\n          // Calculate completed steps from playbook_state if available\n          completedSteps: c.playbook_state?.completedSteps ?? 0,\n          totalSteps,\n          customVariables: c.custom_variables || {}, // Load campaign variables including context_type\n          playbookState: c.playbook_state || null, // Load saved playbook state\n        }))\n        setCampaigns(mappedCampaigns)\n      }\n    } catch (error) {\n      console.error('Error loading campaigns:', error)\n    }\n  }, [projectId, playbookConfig.phases])\n\n  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)\n\n  // Ref to track if we should save (avoid saving on initial load)\n  const shouldSaveRef = useRef(false)\n  // Ref to prevent duplicate saves\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  // Ref to store polling interval for cancellation\n  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Save playbook state to database (debounced)\n  const savePlaybookState = useCallback(async (stateToSave: PlaybookState) => {\n    if (!selectedCampaignId) return\n\n    try {\n      await fetch(`/api/campaign/${selectedCampaignId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ playbook_state: stateToSave }),\n      })\n    } catch (error) {\n      console.error('Error saving playbook state:', error)\n    }\n  }, [selectedCampaignId])\n\n  // Auto-save state when it changes (debounced)\n  useEffect(() => {\n    if (!shouldSaveRef.current || !selectedCampaignId) return\n\n    // Clear any pending save\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current)\n    }\n\n    // Debounce saves by 500ms to avoid too many API calls\n    saveTimeoutRef.current = setTimeout(() => {\n      savePlaybookState(state)\n    }, 500)\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n      }\n    }\n  }, [state, selectedCampaignId, savePlaybookState])\n\n  // Load saved state when selecting a campaign\n  useEffect(() => {\n    if (!selectedCampaignId) {\n      shouldSaveRef.current = false\n      return\n    }\n\n    const campaign = campaigns.find(c => c.id === selectedCampaignId)\n    if (campaign?.playbookState) {\n      // Load saved state\n      shouldSaveRef.current = false // Don't save while loading\n      setState(initializeState(projectId, playbookConfig, campaign.playbookState))\n      // Enable saving after a short delay\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    } else {\n      // Fresh state for new campaign\n      shouldSaveRef.current = false\n      setState(initializeState(projectId, playbookConfig))\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    }\n  }, [selectedCampaignId, campaigns, projectId, playbookConfig])\n\n  // Load step data from database on session resume (if sessionId is provided)\n  useEffect(() => {\n    if (!sessionId) return\n\n    const loadStepData = async () => {\n      try {\n        const savedSteps = await stepPersistenceActions.loadAllSteps()\n        if (Object.keys(savedSteps).length === 0) return\n\n        console.log('[PlaybookShell] Loaded step data from session:', Object.keys(savedSteps))\n\n        // Merge saved step data into current state\n        setState(prev => {\n          const newPhases = prev.phases.map(phase => ({\n            ...phase,\n            steps: phase.steps.map(step => {\n              const savedStep = savedSteps[step.id]\n              if (savedStep) {\n                return {\n                  ...step,\n                  ...savedStep,\n                }\n              }\n              return step\n            }),\n          }))\n\n          // Recalculate phase status\n          newPhases.forEach(phase => {\n            const hasError = phase.steps.some(s => s.status === 'error')\n            const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n            const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n            if (hasError) {\n              phase.status = 'error'\n            } else if (allCompleted) {\n              phase.status = 'completed'\n            } else if (hasInProgress) {\n              phase.status = 'in_progress'\n            } else {\n              phase.status = 'pending'\n            }\n          })\n\n          // Recalculate completed steps\n          const completedSteps = newPhases.reduce(\n            (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n            0\n          )\n\n          // Find the first non-completed step to set as current\n          let currentPhaseIndex = 0\n          let currentStepIndex = 0\n          outer: for (let pi = 0; pi < newPhases.length; pi++) {\n            for (let si = 0; si < newPhases[pi].steps.length; si++) {\n              if (newPhases[pi].steps[si].status !== 'completed') {\n                currentPhaseIndex = pi\n                currentStepIndex = si\n                break outer\n              }\n            }\n          }\n\n          return {\n            ...prev,\n            phases: newPhases,\n            completedSteps,\n            currentPhaseIndex,\n            currentStepIndex,\n          }\n        })\n      } catch (error) {\n        console.error('[PlaybookShell] Error loading step data:', error)\n      }\n    }\n\n    loadStepData()\n  }, [sessionId, stepPersistenceActions])\n\n  // Delete a campaign\n  const deleteCampaign = useCallback(async (campaignId: string) => {\n    if (!confirm('¿Estás seguro de que quieres eliminar esta campaña? Esta acción no se puede deshacer.')) {\n      return\n    }\n\n    try {\n      const response = await fetch(`/api/campaign/${campaignId}`, {\n        method: 'DELETE',\n      })\n\n      if (!response.ok) {\n        throw new Error('Error al eliminar campaña')\n      }\n\n      // If we deleted the selected campaign, clear selection\n      if (selectedCampaignId === campaignId) {\n        setSelectedCampaignId(null)\n      }\n\n      // Reload campaigns\n      loadCampaigns()\n    } catch (error) {\n      console.error('Error deleting campaign:', error)\n      alert('Error al eliminar la campaña')\n    }\n  }, [selectedCampaignId, loadCampaigns])\n\n  // Helper function to get the output from the previous step\n  const getPreviousStepOutput = (): string | undefined => {\n    // Find the current step's dependencies\n    if (!currentStep?.dependsOn?.length) return undefined\n\n    // Get the first dependency's output\n    const dependencyId = currentStep.dependsOn[0]\n\n    // Search for this step across all phases\n    for (const phase of state.phases) {\n      const stepState = phase.steps.find(s => s.id === dependencyId)\n      if (stepState?.output) {\n        return typeof stepState.output === 'string'\n          ? stepState.output\n          : JSON.stringify(stepState.output, null, 2)\n      }\n    }\n\n    return undefined\n  }\n\n  // Build context for LLM-based suggestion generation\n  const buildPlaybookContext = (): Record<string, unknown> => {\n    // Start with campaign's custom_variables (includes context_type, product, target, etc.)\n    const campaignVars = selectedCampaign?.customVariables || {}\n\n    const context: Record<string, unknown> = {\n      ...campaignVars, // Include all campaign variables\n      product: campaignVars.product || state.config?.product || '',\n      target: campaignVars.target || state.config?.target || '',\n      context_type: campaignVars.context_type || 'both', // Explicitly include context_type\n    }\n\n    // DEBUG: Log all steps to see their state\n    console.log('[buildPlaybookContext] All steps:', state.phases.flatMap(p =>\n      p.steps.map(s => ({ id: s.id, status: s.status, hasOutput: !!s.output }))\n    ))\n\n    // Collect values from completed steps\n    for (const phase of state.phases) {\n      for (const stepState of phase.steps) {\n        // DEBUG: Log keyword_config step specifically\n        if (stepState.id === 'keyword_config') {\n          console.log('[buildPlaybookContext] keyword_config step:', {\n            status: stepState.status,\n            hasOutput: !!stepState.output,\n            outputKeys: stepState.output ? Object.keys(stepState.output as object) : [],\n            output: stepState.output,\n          })\n        }\n\n        if (stepState.status === 'completed' || stepState.decision || stepState.suggestions) {\n          // Get decision value\n          if (stepState.decision) {\n            context[stepState.id] = stepState.decision\n          }\n\n          // Get selected suggestions as array of labels\n          if (stepState.suggestions?.length) {\n            const selectedLabels = stepState.suggestions\n              .filter(s => s.selected)\n              .map(s => s.label)\n            if (selectedLabels.length > 0) {\n              context[stepState.id] = selectedLabels\n            }\n          }\n\n          // Get output if available\n          if (stepState.output) {\n            context[`${stepState.id}_output`] = stepState.output\n          }\n\n          // Special case: Extract serpJobId from serp_search or search_and_preview step output\n          // This is needed for review_urls/review_and_scrape step to display SERP results\n          // Note: We check this inside the completed block, but also outside below\n          if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Also extract serpJobId from review_and_scrape step (the scrape step)\n          // This ensures scrape_results step can find the jobId after scraping completes\n          if (stepState.id === 'review_and_scrape' && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId && !context.serpJobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Special case: Parse sources step output for QueryPreviewPanel\n          // The LLM returns a JSON string that needs to be parsed\n          if (stepState.id === 'sources' && stepState.output) {\n            try {\n              let parsedSources = stepState.output\n              if (typeof stepState.output === 'string') {\n                // Try to extract JSON from the LLM response\n                const jsonMatch = stepState.output.match(/\\{[\\s\\S]*\\}/)\n                if (jsonMatch) {\n                  parsedSources = JSON.parse(jsonMatch[0])\n                }\n              }\n              // Only set if it's a valid sources config object\n              if (parsedSources && typeof parsedSources === 'object' &&\n                  ('reddit' in parsedSources || 'thematic_forums' in parsedSources || 'general_forums' in parsedSources)) {\n                context.sources = parsedSources\n              }\n            } catch (e) {\n              console.error('[buildPlaybookContext] Error parsing sources output:', e)\n              // Don't set context.sources - let it use default values\n            }\n          }\n\n          // Special case: Extract keyword_config unified output for SearchWithPreviewStep\n          // The unified panel saves data in two formats:\n          // 1. lifeContexts, needWords, indicators as arrays of objects (for UI)\n          // 2. life_contexts, product_words, indicators as arrays of strings (for SERP job)\n          if (stepState.id === 'keyword_config' && stepState.output) {\n            const output = stepState.output as {\n              // Object arrays (for UI state)\n              lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n              needWords?: Array<{ id: string; label: string; selected: boolean }>\n              indicators?: Array<{ id: string; label: string; selected: boolean }>\n              // String arrays (pre-extracted for SERP job)\n              life_contexts?: string[]\n              product_words?: string[]\n              sources?: {\n                reddit_general?: { enabled: boolean }\n                reddit?: { enabled: boolean; subreddits?: string[] }\n                thematic_forums?: { enabled: boolean; forums?: string[] }\n                general_forums?: { enabled: boolean; forums?: string[] }\n              }\n            }\n\n            // First try to use pre-extracted string arrays (set on completion)\n            if (output.life_contexts && Array.isArray(output.life_contexts)) {\n              context.life_contexts = output.life_contexts\n            } else if (output.lifeContexts) {\n              // Fall back to extracting from object array\n              context.life_contexts = output.lifeContexts\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            // Check multiple possible keys for need words\n            if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n              context.need_words = output.product_words\n              console.log('[buildPlaybookContext] Got need_words from product_words:', output.product_words)\n            } else if ((output as any).need_words && Array.isArray((output as any).need_words) && (output as any).need_words.length > 0) {\n              // Also check for 'need_words' key (alternative naming)\n              context.need_words = (output as any).need_words\n              console.log('[buildPlaybookContext] Got need_words from need_words key:', (output as any).need_words)\n            } else if (output.needWords && Array.isArray(output.needWords)) {\n              const extracted = output.needWords\n                .filter(item => item.selected)\n                .map(item => item.label)\n              if (extracted.length > 0) {\n                context.need_words = extracted\n                console.log('[buildPlaybookContext] Got need_words from needWords (selected):', extracted)\n              } else {\n                console.warn('[buildPlaybookContext] needWords array exists but no items selected:', output.needWords)\n              }\n            } else {\n              console.warn('[buildPlaybookContext] Could not find need_words in output:', {\n                hasProductWords: !!output.product_words,\n                productWordsLength: output.product_words?.length,\n                hasNeedWords: !!(output as any).need_words,\n                hasNeedWordsArray: !!output.needWords,\n                outputKeys: Object.keys(output),\n              })\n            }\n\n            if (output.indicators && Array.isArray(output.indicators) && typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else if (output.indicators && Array.isArray(output.indicators)) {\n              context.indicators = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            if (output.sources) {\n              context.sources = output.sources\n            }\n\n            // DEBUG: Log what we extracted from keyword_config\n            console.log('[buildPlaybookContext] Extracted from keyword_config:', {\n              life_contexts: context.life_contexts,\n              need_words: context.need_words,\n              indicators: context.indicators,\n              sources: context.sources,\n            })\n          }\n        }\n\n        // IMPORTANT: Extract serpJobId even from non-completed steps (e.g., after cancel)\n        // This allows review_and_scrape to show URLs from a cancelled SERP job\n        if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also check review_and_scrape for non-completed steps (e.g., in progress or cancelled)\n        if (stepState.id === 'review_and_scrape' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also extract serpJobId from scrape_results step (for extraction step)\n        if (stepState.id === 'scrape_results' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // IMPORTANT: Also extract keyword_config data even if step is not 'completed'\n        // This ensures retry/navigation doesn't lose the config\n        if (stepState.id === 'keyword_config' && stepState.output && !context.life_contexts) {\n          console.log('[buildPlaybookContext] Extracting keyword_config from non-completed step')\n          const output = stepState.output as {\n            lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n            needWords?: Array<{ id: string; label: string; selected: boolean }>\n            indicators?: Array<{ id: string; label: string; selected: boolean }>\n            life_contexts?: string[]\n            product_words?: string[]\n            sources?: Record<string, unknown>\n          }\n\n          if (output.life_contexts && Array.isArray(output.life_contexts) && output.life_contexts.length > 0) {\n            context.life_contexts = output.life_contexts\n          } else if (output.lifeContexts) {\n            const extracted = output.lifeContexts.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.life_contexts = extracted\n            }\n          }\n\n          if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n            context.need_words = output.product_words\n          } else if (output.needWords) {\n            const extracted = output.needWords.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.need_words = extracted\n            }\n          }\n\n          if (output.indicators && Array.isArray(output.indicators) && output.indicators.length > 0) {\n            if (typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else {\n              const extracted = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected).map(item => item.label)\n              if (extracted.length > 0) {\n                context.indicators = extracted\n              }\n            }\n          }\n\n          if (output.sources && !context.sources) {\n            context.sources = output.sources\n          }\n\n          console.log('[buildPlaybookContext] Extracted from non-completed keyword_config:', {\n            life_contexts: context.life_contexts,\n            need_words: context.need_words,\n          })\n        }\n      }\n    }\n\n    // DEBUG: Log final context\n    console.log('[buildPlaybookContext] Final context:', {\n      life_contexts: context.life_contexts,\n      need_words: context.need_words,\n      indicators: context.indicators,\n      sources: context.sources,\n      serpJobId: context.serpJobId,\n    })\n\n    return context\n  }\n\n  // Get current phase and step definitions\n  const currentPhase = playbookConfig.phases[state.currentPhaseIndex]\n  const currentStep = currentPhase?.steps[state.currentStepIndex]\n  const currentStepState = state.phases[state.currentPhaseIndex]?.steps[state.currentStepIndex]\n\n  // Calculate navigation bounds\n  const isFirstStep = state.currentPhaseIndex === 0 && state.currentStepIndex === 0\n  const isLastStep =\n    state.currentPhaseIndex === playbookConfig.phases.length - 1 &&\n    state.currentStepIndex === currentPhase.steps.length - 1\n\n  // Navigate to a specific step\n  const goToStep = useCallback((phaseIndex: number, stepIndex: number) => {\n    // Save current state immediately before navigating (don't wait for debounce)\n    if (shouldSaveRef.current && selectedCampaignId) {\n      // Clear pending debounced save\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n        saveTimeoutRef.current = null\n      }\n      // Save current state synchronously\n      savePlaybookState(state)\n    }\n\n    setState(prev => ({\n      ...prev,\n      currentPhaseIndex: phaseIndex,\n      currentStepIndex: stepIndex,\n    }))\n  }, [selectedCampaignId, state, savePlaybookState])\n\n  // Go to next step\n  const goToNextStep = useCallback(() => {\n    setState(prev => {\n      const currentPhase = playbookConfig.phases[prev.currentPhaseIndex]\n\n      // Check if there's a next step in current phase\n      if (prev.currentStepIndex < currentPhase.steps.length - 1) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex + 1,\n        }\n      }\n\n      // Check if there's a next phase\n      if (prev.currentPhaseIndex < playbookConfig.phases.length - 1) {\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex + 1,\n          currentStepIndex: 0,\n        }\n      }\n\n      // Already at the end\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Go to previous step\n  const goToPreviousStep = useCallback(() => {\n    setState(prev => {\n      // Check if there's a previous step in current phase\n      if (prev.currentStepIndex > 0) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex - 1,\n        }\n      }\n\n      // Check if there's a previous phase\n      if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex - 1,\n          currentStepIndex: prevPhase.steps.length - 1,\n        }\n      }\n\n      // Already at the beginning\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Re-run the previous step (go back and reset its state to pending)\n  const rerunPreviousStep = useCallback(() => {\n    setState(prev => {\n      let newPhaseIndex = prev.currentPhaseIndex\n      let newStepIndex = prev.currentStepIndex\n\n      // Find previous step\n      if (prev.currentStepIndex > 0) {\n        newStepIndex = prev.currentStepIndex - 1\n      } else if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        newPhaseIndex = prev.currentPhaseIndex - 1\n        newStepIndex = prevPhase.steps.length - 1\n      } else {\n        // Already at the beginning, nothing to rerun\n        return prev\n      }\n\n      // Get the previous step ID\n      const prevStepId = playbookConfig.phases[newPhaseIndex].steps[newStepIndex].id\n\n      // Reset the previous step state to pending and navigate to it\n      const newPhases = prev.phases.map((phase, pi) => ({\n        ...phase,\n        steps: phase.steps.map((step, si) => {\n          if (pi === newPhaseIndex && si === newStepIndex) {\n            return {\n              ...step,\n              status: 'pending' as const,\n              output: undefined,\n              error: undefined,\n            }\n          }\n          return step\n        }),\n      }))\n\n      return {\n        ...prev,\n        phases: newPhases,\n        currentPhaseIndex: newPhaseIndex,\n        currentStepIndex: newStepIndex,\n      }\n    })\n    // Trigger auto-execute after navigating\n    setShouldAutoExecute(true)\n  }, [playbookConfig.phases])\n\n  // Update step state\n  const updateStepState = useCallback(\n    (stepId: string, update: Partial<StepState>) => {\n      console.log('[updateStepState] Updating step:', stepId, 'with:', {\n        ...update,\n        output: update.output ? `[output with keys: ${Object.keys(update.output as object).join(', ')}]` : undefined,\n      })\n\n      // Persist step changes to database (if sessionId is provided)\n      if (sessionId) {\n        // Handle status-specific persistence\n        if (update.status === 'in_progress') {\n          stepPersistenceActions.markStepRunning(stepId, update.input)\n        } else if (update.status === 'completed') {\n          stepPersistenceActions.markStepCompleted(stepId, update.output)\n        } else if (update.status === 'error') {\n          stepPersistenceActions.markStepFailed(stepId, update.error || 'Unknown error')\n        } else if (update.output !== undefined) {\n          // For output-only updates (during execution), schedule auto-save\n          stepPersistenceActions.scheduleAutoSave(stepId, update.output)\n        }\n      }\n\n      setState(prev => {\n        // Find the current step to log what we're merging\n        const currentStep = prev.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n        if (stepId === 'keyword_config') {\n          console.log('[updateStepState] keyword_config before merge:', {\n            status: currentStep?.status,\n            hasOutput: !!currentStep?.output,\n            outputKeys: currentStep?.output ? Object.keys(currentStep.output as object) : [],\n          })\n        }\n\n        const newPhases = prev.phases.map(phase => ({\n          ...phase,\n          steps: phase.steps.map(step =>\n            step.id === stepId ? { ...step, ...update } : step\n          ),\n        }))\n\n        // Log the merged result for keyword_config\n        if (stepId === 'keyword_config') {\n          const mergedStep = newPhases.flatMap(p => p.steps).find(s => s.id === stepId)\n          console.log('[updateStepState] keyword_config after merge:', {\n            status: mergedStep?.status,\n            hasOutput: !!mergedStep?.output,\n            outputKeys: mergedStep?.output ? Object.keys(mergedStep.output as object) : [],\n          })\n        }\n\n        // Recalculate phase status\n        newPhases.forEach(phase => {\n          const hasError = phase.steps.some(s => s.status === 'error')\n          const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n          const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n          if (hasError) {\n            phase.status = 'error'\n          } else if (allCompleted) {\n            phase.status = 'completed'\n          } else if (hasInProgress) {\n            phase.status = 'in_progress'\n          } else {\n            phase.status = 'pending'\n          }\n        })\n\n        // Recalculate completed steps\n        const completedSteps = newPhases.reduce(\n          (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n          0\n        )\n\n        return {\n          ...prev,\n          phases: newPhases,\n          completedSteps,\n        }\n      })\n    },\n    [sessionId, stepPersistenceActions]\n  )\n\n  // Execute a step\n  const executeStep = useCallback(\n    async (stepId: string, input?: any) => {\n      console.log('[executeStep] Starting execution for step:', stepId, 'with input:', input)\n\n      const step = playbookConfig.phases\n        .flatMap(p => p.steps)\n        .find(s => s.id === stepId)\n\n      if (!step) {\n        console.error('[executeStep] Step not found:', stepId)\n        return\n      }\n\n      console.log('[executeStep] Found step:', step.id, 'type:', step.type, 'executor:', step.executor, 'jobType:', step.jobType)\n\n      // Mark as in progress\n      updateStepState(stepId, {\n        status: 'in_progress',\n        startedAt: new Date(),\n        input,\n      })\n\n      try {\n        let result: any\n\n        // Special case: Execute extraction from scrape_results step\n        if (step.id === 'scrape_results' && input?.action === 'extract' && input?.jobId) {\n          console.log('[EXTRACT from scrape_results] Starting extraction for job:', input.jobId)\n          const jobId = input.jobId\n\n          updateStepState(stepId, {\n            output: { jobId },\n            progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' },\n            partialResults: { extracted: 0, filtered: 0 },\n          })\n\n          // Get total URLs to extract from job status\n          const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          const statusData = await statusResponse.json()\n          const scrapedUrlCount = statusData.url_counts?.scraped || 0\n          const totalUrls = scrapedUrlCount || statusData.job?.urls_scraped || 0\n          const existingExtractedCount = statusData.job?.niches_extracted || 0\n          const existingFilteredCount = statusData.url_counts?.filtered || 0\n\n          console.log('[EXTRACT] Status check:', {\n            scrapedUrlCount,\n            totalUrls,\n            existingExtractedCount,\n            existingFilteredCount,\n            jobStatus: statusData.job?.status,\n            urlsFailed: statusData.url_counts?.failed || 0,\n          })\n\n          // Check if there's nothing to extract (all URLs failed or filtered)\n          if (scrapedUrlCount === 0 && existingExtractedCount === 0) {\n            const failedCount = statusData.url_counts?.failed || 0\n            console.log('[EXTRACT] No URLs to extract and no existing results. Failed:', failedCount, 'Filtered:', existingFilteredCount)\n\n            // Show error state - nothing to extract\n            updateStepState(stepId, {\n              status: 'error',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: 0,\n                filteredCount: existingFilteredCount,\n                error: failedCount > 0\n                  ? `El scraping falló para ${failedCount} URLs (posible bloqueo de Reddit API). No hay contenido disponible para extraer.`\n                  : 'No hay URLs disponibles para extraer. Verifica que el scraping se completó correctamente.',\n              },\n              progress: undefined,\n            })\n\n            return // Stop - nothing to do\n          }\n\n          // Check if extraction was already done (no URLs to process but results exist)\n          if (scrapedUrlCount === 0 && existingExtractedCount > 0) {\n            console.log('[EXTRACT] Extraction already completed, using existing results')\n            updateStepState(stepId, {\n              progress: { current: 100, total: 100, label: `Usando resultados existentes: ${existingExtractedCount} problemas encontrados` },\n            })\n\n            // Skip extraction loop and jump to results fetching\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // Mark scrape_results as completed\n            updateStepState(stepId, {\n              status: 'completed',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: existingExtractedCount,\n                filteredCount: existingFilteredCount,\n              },\n              progress: undefined,\n            })\n\n            // Also update extract_problems step for clean_filter to use\n            console.log('[EXTRACT] Updating extract_problems step with existing CSV results')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,\n              partialResults: {\n                extracted: existingExtractedCount,\n                filtered: existingFilteredCount,\n                successCount: niches.length,\n              }\n            })\n\n            console.log('[EXTRACT] Using existing results:', niches.length, 'problems')\n            return // Don't proceed with new extraction\n          }\n\n          updateStepState(stepId, {\n            progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` },\n          })\n\n          // Call extract endpoint in batches until has_more=false\n          let hasMore = true\n          let extractedTotal = 0\n          let filteredTotal = 0\n          let processedTotal = 0\n\n          while (hasMore) {\n            try {\n              const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout)\n              const contentType = extractResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                console.error('[EXTRACT] Non-JSON response, polling status...')\n                await new Promise(resolve => setTimeout(resolve, 2000))\n\n                // Check current status\n                const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                const checkData = await checkResponse.json()\n\n                if (checkData.status === 'completed') {\n                  hasMore = false\n                  extractedTotal = checkData.job?.niches_extracted || 0\n                }\n                continue\n              }\n\n              const extractData = await extractResponse.json()\n              console.log('[EXTRACT] Batch response:', extractData)\n\n              if (extractData.error) {\n                throw new Error(extractData.error)\n              }\n\n              extractedTotal += extractData.extracted || 0\n              filteredTotal += extractData.filtered || 0\n              processedTotal = extractedTotal + filteredTotal\n              hasMore = extractData.has_more || false\n\n              updateStepState(stepId, {\n                progress: {\n                  current: processedTotal,\n                  total: totalUrls,\n                  label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                },\n                partialResults: {\n                  extracted: extractedTotal,\n                  filtered: filteredTotal,\n                },\n              })\n            } catch (extractError) {\n              console.error('[EXTRACT] Batch error:', extractError)\n              await new Promise(resolve => setTimeout(resolve, 2000))\n\n              // Check if we should stop\n              const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const checkData = await checkResponse.json()\n              if (checkData.status === 'completed' || checkData.status === 'failed') {\n                hasMore = false\n                if (checkData.status === 'failed') {\n                  throw new Error(checkData.job?.error_message || 'Extraction failed')\n                }\n              }\n            }\n          }\n\n          // Mark as completed\n          updateStepState(stepId, {\n            status: 'completed',\n            completedAt: new Date(),\n            output: {\n              jobId,\n              extractedCount: extractedTotal,\n              filteredCount: filteredTotal,\n            },\n            progress: undefined, // Clear progress\n          })\n\n          console.log('[EXTRACT] Completed! Extracted:', extractedTotal, 'Filtered:', filteredTotal)\n\n          // Save results to Context Lake automatically\n          try {\n            // Get project data (includes client_id)\n            const projectResponse = await fetch(`/api/projects/${projectId}`)\n            const projectData = await projectResponse.json()\n\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // IMPORTANT: Also update extract_problems step so clean_filter can use the results\n            // clean_filter depends on extract_problems, not scrape_results\n            console.log('[EXTRACT] Updating extract_problems step with CSV results for clean_filter')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,  // CSV string that clean_filter will use\n              partialResults: {\n                extracted: extractedTotal,\n                filtered: filteredTotal,\n                successCount: niches.length,\n              }\n            })\n\n            const dateStr = new Date().toISOString().split('T')[0]\n            const campaignSlug = selectedCampaign?.name?.toLowerCase().replace(/\\s+/g, '-') || 'sin-nombre'\n            const projectSlug = projectData.name?.toLowerCase().replace(/\\s+/g, '-') || 'proyecto'\n\n            const documentData = {\n              projectId: projectId,\n              clientId: projectData.client_id,\n              filename: `Niche Finder - ${selectedCampaign?.name || 'Sin nombre'} - ${dateStr}`,\n              category: 'research',\n              content: csvContent,\n              description: `${extractedTotal} problemas extraídos del Niche Finder. ${filteredTotal} URLs filtradas de ${totalUrls} procesadas.`,\n              tags: [\n                `fecha:${dateStr}`,\n                `proyecto:${projectSlug}`,\n                `campaña:${campaignSlug}`,\n                `job:${jobId}`,\n                'niche-finder',\n                'problemas-extraidos'\n              ],\n              folder: `niche-finder/${campaignSlug}`,\n              userId: 'system', // TODO: Get actual user ID from session\n              sourceMetadata: {\n                origin_type: 'flow_step_output',\n                playbook_id: playbookConfig.type || 'niche-finder',\n                playbook_name: playbookConfig.name,\n                campaign_id: selectedCampaignId || '',\n                campaign_name: selectedCampaign?.name || '',\n                campaign_variables: selectedCampaign?.customVariables || {},\n                step_id: 'scrape_results',\n                step_name: 'Extracción de Problemas',\n                step_order: 3,\n                executed_at: new Date().toISOString(),\n                model_used: 'openai/gpt-4o-mini',\n                model_provider: 'openrouter',\n                input_tokens: 0,\n                output_tokens: 0,\n                input_document_ids: [],\n                input_previous_step_ids: ['search_and_preview', 'review_and_scrape'],\n                converted_at: new Date().toISOString(),\n                converted_by: 'system',\n                was_edited_before_conversion: false\n              },\n              sourceCampaignId: selectedCampaignId || '',\n              sourceStepId: 'scrape_results',\n              sourceStepName: 'Extracción de Problemas',\n              sourcePlaybookId: playbookConfig.type\n            }\n\n            const saveResponse = await fetch('/api/documents/from-step-output', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify(documentData)\n            })\n\n            if (saveResponse.ok) {\n              const savedDoc = await saveResponse.json()\n              console.log('[EXTRACT] Results saved to Context Lake:', savedDoc.document?.id)\n            } else {\n              console.error('[EXTRACT] Failed to save to Context Lake:', await saveResponse.text())\n            }\n          } catch (saveError) {\n            console.error('[EXTRACT] Error saving to Context Lake:', saveError)\n            // Don't fail the extraction if saving to Context Lake fails\n          }\n\n          return // Don't fall through to the switch\n        }\n\n        switch (step.executor) {\n          case 'llm':\n            // Build variables including campaign custom_variables (product, target, industry, etc.)\n            const campaignVars = selectedCampaign?.customVariables || {}\n            const stepVariables = {\n              ...Object.fromEntries(\n                Object.entries(campaignVars).map(([k, v]) => [k, String(v ?? '')])\n              ),\n              ...(input || {}),\n            }\n            // Call LLM API\n            const response = await fetch('/api/playbook/execute-step', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({\n                projectId,\n                stepId,\n                playbookType: playbookConfig.type,\n                promptKey: step.promptKey,\n                variables: stepVariables,\n              }),\n            })\n            const data = await response.json()\n            if (!data.success) throw new Error(data.error || 'Error ejecutando paso')\n            result = data.output\n            break\n\n          case 'api':\n            // Call custom API endpoint\n            if (step.apiEndpoint) {\n              // Build payload with previous step outputs and campaign variables\n              const campaignVarsForApi = selectedCampaign?.customVariables || {}\n\n              // Get outputs from previous steps (dependsOn)\n              const previousOutputs: Record<string, unknown> = {}\n              if (step.dependsOn?.length) {\n                for (const depId of step.dependsOn) {\n                  for (const phase of state.phases) {\n                    const depStep = phase.steps.find(s => s.id === depId)\n                    if (depStep?.output) {\n                      previousOutputs[depId] = depStep.output\n                    }\n                  }\n                }\n              }\n\n              // Build scenes array from generate_scenes output (for video-viral generate-clips)\n              let scenes: string[] | undefined\n              if (previousOutputs.generate_scenes) {\n                let scenesOutput = previousOutputs.generate_scenes\n\n                // Parse JSON if output is a string (LLM outputs often come as strings)\n                if (typeof scenesOutput === 'string') {\n                  try {\n                    // Try to extract JSON from the string (might be wrapped in markdown code blocks)\n                    const jsonMatch = scenesOutput.match(/```(?:json)?\\s*(\\{[\\s\\S]*?\\})\\s*```/) ||\n                                     scenesOutput.match(/(\\{[\\s\\S]*\\})/)\n                    if (jsonMatch) {\n                      scenesOutput = JSON.parse(jsonMatch[1])\n                    }\n                  } catch (e) {\n                    console.error('[executeStep] Failed to parse generate_scenes output:', e)\n                  }\n                }\n\n                // Extract scene_1, scene_2, scene_3, etc. from the output\n                if (typeof scenesOutput === 'object' && scenesOutput !== null) {\n                  const scenesRecord = scenesOutput as Record<string, string>\n                  scenes = Object.entries(scenesRecord)\n                    .filter(([key]) => key.startsWith('scene_'))\n                    .sort(([a], [b]) => a.localeCompare(b))\n                    .map(([, value]) => value)\n                  console.log('[executeStep] Extracted scenes:', scenes)\n                }\n              }\n\n              const apiResponse = await fetch(step.apiEndpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                  projectId,\n                  stepId,\n                  input,\n                  ...campaignVarsForApi,\n                  previousOutputs,\n                  scenes, // For generate-clips endpoint\n                }),\n              })\n              const apiData = await apiResponse.json()\n              if (!apiData.success && apiData.error) throw new Error(apiData.error)\n              result = apiData\n            }\n            break\n\n          case 'job':\n            // Job-based execution: create job, execute, poll for status\n            console.log('[executeStep] Executor is JOB, jobType:', step.jobType)\n\n            if (step.jobType === 'niche_finder_serp') {\n              // Check if we have an existing job to resume (from cancelled execution)\n              const currentStepForJob = state.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n              const existingJobId = (currentStepForJob?.output as { jobId?: string })?.jobId\n\n              let jobId: string\n\n              if (existingJobId) {\n                // Resume existing job\n                console.log('[SERP] Resuming existing job:', existingJobId)\n                jobId = existingJobId\n                updateStepState(stepId, { progress: { current: 0, total: 0, label: 'Retomando búsqueda SERP...' } })\n              } else {\n                // Build job config from completed steps OR from input (for search_with_preview)\n                let jobConfig: {\n                  life_contexts: string[]\n                  product_words: string[]\n                  indicators: string[]\n                  sources: { reddit: boolean | { enabled?: boolean; subreddits?: string[] }; thematic_forums: boolean | { enabled?: boolean; forums?: string[] }; general_forums: string[] | { enabled?: boolean; forums?: string[] } }\n                  serp_pages: number\n                  // Campaign metadata for extraction to use correct variables\n                  campaign_id?: string | null\n                  ecp_name?: string\n                  ecp_product?: string\n                  ecp_target?: string\n                  ecp_industry?: string\n                  ecp_category?: string\n                  ecp_country?: string\n                }\n\n                // If input is provided (from SearchWithPreviewPanel), use it directly\n                console.log('[SERP] Input received:', JSON.stringify(input, null, 2))\n\n                if (input && input.life_contexts && input.product_words) {\n                  // Warn if arrays are empty\n                  if (input.life_contexts.length === 0 || input.product_words.length === 0) {\n                    console.warn('[SERP] WARNING: life_contexts or product_words is empty!', {\n                      life_contexts: input.life_contexts,\n                      product_words: input.product_words\n                    })\n                  }\n\n                  jobConfig = {\n                    life_contexts: input.life_contexts,\n                    product_words: input.product_words,\n                    indicators: input.indicators || [],\n                    sources: input.sources || { reddit: true, thematic_forums: false, general_forums: [] },\n                    serp_pages: input.serp_pages || 5,\n                  }\n                } else {\n                  console.log('[SERP] No valid input, falling back to completed steps...')\n                  // Fall back to building from completed steps (legacy flow)\n                  const lifeContextsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'life_contexts')\n                  const needWordsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'need_words')\n                  const indicatorsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'indicators')\n                  const sourcesStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'sources')\n\n                  const selectedContexts = lifeContextsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedNeedWords = needWordsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedIndicators = indicatorsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n\n                  // Parse sources output (can be JSON string from LLM or already parsed object)\n                  let sourcesConfig: { reddit: { enabled: boolean; subreddits: string[] }; thematic_forums: { enabled: boolean; forums: string[] }; general_forums: { enabled: boolean; forums: string[] } } = { reddit: { enabled: true, subreddits: [] }, thematic_forums: { enabled: false, forums: [] }, general_forums: { enabled: false, forums: [] } }\n                  try {\n                    if (sourcesStep?.output) {\n                      // Check if output is already an object (parsed)\n                      if (typeof sourcesStep.output === 'object' && sourcesStep.output !== null) {\n                        sourcesConfig = sourcesStep.output as typeof sourcesConfig\n                      } else if (typeof sourcesStep.output === 'string') {\n                        // Try to extract JSON from string\n                        const jsonMatch = sourcesStep.output.match(/\\{[\\s\\S]*\\}/)\n                        if (jsonMatch) {\n                          sourcesConfig = JSON.parse(jsonMatch[0])\n                        }\n                      }\n                    }\n                  } catch (e) {\n                    console.error('Error parsing sources config:', e)\n                  }\n\n                  // Get campaign variables with proper typing\n                  const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                  jobConfig = {\n                    campaign_id: selectedCampaignId, // CRITICAL: Pass campaign_id so extract uses correct variables\n                    life_contexts: selectedContexts,\n                    product_words: selectedNeedWords,\n                    indicators: selectedIndicators,\n                    sources: sourcesConfig,\n                    serp_pages: (campaignVars?.serp_pages as number) || 5,\n                    // Also pass campaign variables directly in config for reliability\n                    ecp_name: (campaignVars?.company_name as string) || selectedCampaign?.name,\n                    ecp_product: campaignVars?.product as string | undefined,\n                    ecp_target: campaignVars?.target as string | undefined,\n                    ecp_industry: campaignVars?.industry as string | undefined,\n                    ecp_category: campaignVars?.category as string | undefined,\n                    ecp_country: campaignVars?.country as string | undefined,\n                  }\n                }\n\n                console.log('[SERP] Starting job with config:', JSON.stringify(jobConfig, null, 2))\n\n                // 1. Create job\n                const createResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: jobConfig,\n                  }),\n                })\n                const createData = await createResponse.json()\n                console.log('[SERP] Create job response:', createData)\n\n                if (!createData.success) {\n                  throw new Error(createData.error || 'Error creando job')\n                }\n\n                jobId = createData.job_id\n                console.log('[SERP] Job created with ID:', jobId)\n                updateStepState(stepId, { output: { jobId }, progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' } })\n              }\n\n              // 2. Execute SERP job (this will resume from where it left off if job was interrupted)\n              console.log('[SERP] Executing SERP search...')\n              const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout HTML pages)\n              const contentType = serpResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                const text = await serpResponse.text()\n                console.error('[SERP] Non-JSON response:', text.slice(0, 500))\n                // If we got a non-JSON response, the job might still be running in the background\n                // Continue to polling to check status\n                console.log('[SERP] Continuing to poll for job status despite non-JSON response...')\n              } else {\n                const serpData = await serpResponse.json()\n                console.log('[SERP] SERP response:', serpData)\n\n                if (serpData.error) {\n                  // Check if it's a missing API key error\n                  if (serpData.code === 'MISSING_API_KEY') {\n                    throw new Error(`API Key faltante: ${serpData.service}. Configura tu API key en Ajustes > APIs.`)\n                  }\n                  throw new Error(serpData.error)\n                }\n              }\n\n              // 3. Poll for status and auto-resume if needed\n              let isResuming = false\n              let lastCompletedCount = -1 // Track previous poll value\n              let stallCount = 0 // Count consecutive stalls\n              let initialCompleted = -1 // Track initial value when polling started\n\n              // Clear any existing poll interval\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n              }\n\n              pollIntervalRef.current = setInterval(async () => {\n                try {\n                  const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const statusData = await statusResponse.json()\n\n                  const completed = statusData.progress?.serp?.completed || 0\n                  const total = statusData.progress?.serp?.total || 0\n                  const remaining = total - completed\n                  const label = total > 0\n                    ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n                    : 'Iniciando búsqueda SERP...'\n                  updateStepState(stepId, {\n                    progress: {\n                      current: completed,\n                      total: total,\n                      label,\n                    },\n                  })\n\n                  // Track initial value on first poll\n                  if (initialCompleted === -1) {\n                    initialCompleted = completed\n                  }\n\n                  // Auto-resume if job was interrupted (still serp_running but not progressing)\n                  // This handles Vercel timeout scenarios\n                  if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n                    // Check if progress has stalled (same value as PREVIOUS poll)\n                    if (lastCompletedCount === completed && remaining > 0) {\n                      stallCount++\n                      // After 2 consecutive stalls (4+ seconds), OR if no progress since we started polling\n                      const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                      if (stallCount >= 2 || noProgressSinceStart) {\n                        console.log(`[SERP] Job stalled at ${completed}/${total} (stallCount=${stallCount}, initialCompleted=${initialCompleted}), auto-resuming...`)\n                        isResuming = true\n                        stallCount = 0\n                        // Resume the job by calling SERP endpoint again\n                        fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                          .then(res => res.json())\n                          .then(data => {\n                            console.log('[SERP] Resume response:', data)\n                            isResuming = false\n                          })\n                          .catch(err => {\n                            console.error('[SERP] Resume error:', err)\n                            isResuming = false\n                          })\n                      }\n                    } else {\n                      stallCount = 0 // Reset stall count if progress is being made\n                    }\n                  }\n\n                  // Update last completed for next poll comparison\n                  lastCompletedCount = completed\n\n                  // Check if SERP phase is done (includes later states that imply SERP finished)\n                  const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n                  if (serpDone) {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    updateStepState(stepId, {\n                      status: 'completed',\n                      completedAt: new Date(),\n                      output: {\n                        jobId,\n                        urlsFound: statusData.job?.urls_found || 0,\n                        costs: statusData.costs,\n                      },\n                      progress: undefined, // Clear progress to stop spinner\n                    })\n                    setTimeout(goToNextStep, 500)\n                  } else if (statusData.status === 'failed' || statusData.status === 'error') {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    throw new Error(statusData.job?.error_message || 'Job failed')\n                  }\n                } catch (pollError) {\n                  if (pollIntervalRef.current) {\n                    clearInterval(pollIntervalRef.current)\n                    pollIntervalRef.current = null\n                  }\n                  updateStepState(stepId, {\n                    status: 'error',\n                    error: pollError instanceof Error ? pollError.message : 'Error checking job status',\n                  })\n                }\n              }, 2000) // Poll every 2 seconds\n\n              // Don't fall through to the completion logic below\n              return\n            }\n\n            // SCRAPE JOB: Scrape URLs from the SERP results\n            if (step.jobType === 'niche_finder_scrape') {\n              // Get the jobId from the previous step (search_and_preview)\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n              console.log('[SCRAPE] Looking for search_and_preview step:', searchStep)\n              console.log('[SCRAPE] search_and_preview output:', searchStep?.output)\n\n              // Also check for serp_search (legacy step name)\n              const serpStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'serp_search')\n              console.log('[SCRAPE] Looking for serp_search step:', serpStep)\n              console.log('[SCRAPE] serp_search output:', serpStep?.output)\n\n              // Try to get jobId from either step\n              let jobId = (searchStep?.output as { jobId?: string })?.jobId ||\n                          (serpStep?.output as { jobId?: string })?.jobId\n\n              // If still no jobId, try from input (might be passed from ReviewAndScrapePanel)\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n                console.log('[SCRAPE] Got jobId from input:', jobId)\n              }\n\n              if (!jobId) {\n                console.error('[SCRAPE] No jobId found. All steps:', state.phases.flatMap(p => p.steps).map(s => ({ id: s.id, output: s.output })))\n                throw new Error('No se encontró el Job ID del paso de búsqueda')\n              }\n\n              console.log('[SCRAPE] Starting scrape for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando scraping...' }\n              })\n\n              // Get total URLs to scrape\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.urls_found || 0\n\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Scrapeando 0/${totalUrls} URLs...` }\n              })\n\n              // Start scraping - this will scrape in batches\n              let scrapedCount = 0\n              let failedCount = 0\n              let hasMore = true\n\n              while (hasMore) {\n                try {\n                  const scrapeResponse = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = scrapeResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[SCRAPE] Non-JSON response, continuing...')\n                    // Wait a bit and continue polling\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'scrape_done') {\n                      hasMore = false\n                      scrapedCount = checkData.job?.scrape_success_count || 0\n                      failedCount = checkData.job?.scrape_failed_count || 0\n                    }\n                    continue\n                  }\n\n                  const scrapeData = await scrapeResponse.json()\n                  console.log('[SCRAPE] Batch response:', scrapeData)\n\n                  if (scrapeData.error) {\n                    throw new Error(scrapeData.error)\n                  }\n\n                  scrapedCount += scrapeData.scraped || 0\n                  failedCount += scrapeData.failed || 0\n                  hasMore = scrapeData.has_more || false\n\n                  // Update progress with real-time feedback\n                  updateStepState(stepId, {\n                    progress: {\n                      current: scrapedCount + failedCount,\n                      total: totalUrls,\n                      label: `Scrapeando ${scrapedCount + failedCount}/${totalUrls} URLs...`,\n                    },\n                    partialResults: {\n                      successCount: scrapedCount,\n                      failedCount: failedCount,\n                      lastUrl: scrapeData.last_scraped_url,\n                      lastSnippet: scrapeData.last_scraped_snippet,\n                    },\n                  })\n\n                } catch (scrapeError) {\n                  console.error('[SCRAPE] Batch error:', scrapeError)\n                  // Don't throw - try to continue with next batch\n                  // The endpoint will mark failed URLs and continue\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'scrape_done' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Scraping failed')\n                    }\n                  }\n                }\n              }\n\n              // Mark as completed\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  scrapedCount,\n                  failedCount,\n                },\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            if (step.jobType === 'niche_finder_extract') {\n              // Get jobId from previous steps (review_and_scrape or scrape_results)\n              const scrapeResultsStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'scrape_results')\n              const reviewAndScrapeStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'review_and_scrape')\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n\n              console.log('[EXTRACT] Looking for jobId from steps:', {\n                scrape_results: scrapeResultsStep?.output,\n                review_and_scrape: reviewAndScrapeStep?.output,\n                search_and_preview: searchStep?.output,\n              })\n\n              let jobId = (scrapeResultsStep?.output as { jobId?: string })?.jobId ||\n                          (reviewAndScrapeStep?.output as { jobId?: string })?.jobId ||\n                          (searchStep?.output as { jobId?: string })?.jobId\n\n              // Also try from input\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n              }\n\n              if (!jobId) {\n                console.error('[EXTRACT] No jobId found')\n                throw new Error('No se encontró el Job ID. Por favor ejecuta los pasos anteriores primero.')\n              }\n\n              console.log('[EXTRACT] Starting extraction for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' }\n              })\n\n              // Get total URLs to extract from job status\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.scrape_success_count || 0\n\n              console.log('[EXTRACT] Total URLs to process:', totalUrls)\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` }\n              })\n\n              // Call extract endpoint in batches until has_more=false\n              let hasMore = true\n              let extractedTotal = 0\n              let filteredTotal = 0\n              let processedTotal = 0\n\n              while (hasMore) {\n                try {\n                  const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = extractResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[EXTRACT] Non-JSON response, polling status...')\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'completed') {\n                      hasMore = false\n                      extractedTotal = checkData.job?.niches_extracted || 0\n                    }\n                    continue\n                  }\n\n                  const extractData = await extractResponse.json()\n                  console.log('[EXTRACT] Batch response:', extractData)\n\n                  if (extractData.error) {\n                    throw new Error(extractData.error)\n                  }\n\n                  extractedTotal += extractData.extracted || 0\n                  filteredTotal += extractData.filtered || 0\n                  processedTotal = extractedTotal + filteredTotal\n                  hasMore = extractData.has_more || false\n\n                  updateStepState(stepId, {\n                    progress: {\n                      current: processedTotal,\n                      total: totalUrls,\n                      label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                    },\n                    partialResults: {\n                      successCount: extractedTotal,\n                      failedCount: filteredTotal,\n                    },\n                  })\n                } catch (extractError) {\n                  console.error('[EXTRACT] Batch error:', extractError)\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'completed' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Extraction failed')\n                    }\n                  }\n                }\n              }\n\n              // Get extracted problems and format as CSV\n              console.log('[EXTRACT] Getting results from /api/niche-finder/results/', jobId)\n              const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n\n              if (!resultsResponse.ok) {\n                console.error('[EXTRACT] Failed to get results:', resultsResponse.status, resultsResponse.statusText)\n                throw new Error(`Error obteniendo resultados: ${resultsResponse.status}`)\n              }\n\n              const resultsData = await resultsResponse.json()\n              console.log('[EXTRACT] Results data:', {\n                hasNiches: !!resultsData.niches,\n                nichesCount: resultsData.niches?.length || 0,\n                status: resultsData.status,\n                urls: resultsData.urls,\n              })\n\n              // Format niches as CSV string with all relevant columns\n              const niches = resultsData.niches || []\n              let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n              for (const niche of niches) {\n                const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                const url = niche.source_url || ''\n                csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n              }\n\n              console.log('[EXTRACT] Completed. Total problems:', niches.length, 'CSV preview:', csvOutput.substring(0, 200))\n\n              // Mark as completed with CSV output\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: csvOutput,\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            // UNIFIED SEARCH + EXTRACT: Handles both SERP and analysis in one step\n            if (step.jobType === 'niche_finder_unified') {\n              const action = (input as { action?: string })?.action\n\n              // ============ ACTION: SERP ============\n              if (action === 'serp') {\n                const config = (input as { config?: { life_contexts: string[]; product_words: string[]; indicators: string[]; sources: { reddit: boolean; thematic_forums: boolean; general_forums: string[] }; serp_pages: number } }).config\n                if (!config) {\n                  throw new Error('No se recibió configuración para la búsqueda')\n                }\n\n                console.log('[UNIFIED] Starting SERP with config:', config)\n\n                // Get campaign variables\n                const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                // Create the SERP job\n                const jobResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: {\n                      ...config,\n                      campaign_id: selectedCampaignId,\n                      ecp_name: campaignVars?.['ECP Name'] || campaignVars?.ecp_name,\n                      ecp_product: campaignVars?.['ECP Product'] || campaignVars?.ecp_product,\n                      ecp_target: campaignVars?.['ECP Target'] || campaignVars?.ecp_target,\n                      ecp_industry: campaignVars?.['ECP Industry'] || campaignVars?.ecp_industry,\n                      ecp_category: campaignVars?.['ECP Category'] || campaignVars?.ecp_category,\n                      ecp_country: campaignVars?.['ECP Country'] || campaignVars?.ecp_country,\n                    }\n                  }),\n                })\n\n                if (!jobResponse.ok) {\n                  const errorText = await jobResponse.text()\n                  throw new Error(`Error al crear job: ${jobResponse.status} - ${errorText || 'Sin respuesta'}`)\n                }\n\n                const jobText = await jobResponse.text()\n                if (!jobText || jobText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al crear el job')\n                }\n\n                const jobData = JSON.parse(jobText)\n                const jobId = jobData.job_id\n\n                if (!jobId) {\n                  throw new Error('No se pudo crear el job de búsqueda')\n                }\n\n                console.log('[UNIFIED] SERP Job created:', jobId)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'serp_executing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' },\n                })\n\n                // Start SERP execution\n                const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n\n                if (!serpResponse.ok) {\n                  const serpErrorText = await serpResponse.text()\n                  let errorMessage = `Error al iniciar búsqueda SERP: ${serpResponse.status}`\n                  try {\n                    const serpError = JSON.parse(serpErrorText)\n                    if (serpError.code === 'MISSING_API_KEY') {\n                      errorMessage = `${serpError.error}`\n                    } else if (serpError.error) {\n                      errorMessage = serpError.error\n                    }\n                  } catch {\n                    if (serpErrorText) errorMessage += ` - ${serpErrorText}`\n                  }\n                  throw new Error(errorMessage)\n                }\n\n                console.log('[UNIFIED] SERP execution started successfully')\n\n                // Poll for SERP completion\n                let serpComplete = false\n                let pollRetries = 0\n                const MAX_POLL_RETRIES = 3\n                while (!serpComplete) {\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n                  try {\n                    const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n\n                    if (!statusRes.ok) {\n                      console.warn(`[UNIFIED] Status poll failed with ${statusRes.status}`)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error(`Error al consultar estado del job: ${statusRes.status}`)\n                      }\n                      continue\n                    }\n\n                    const text = await statusRes.text()\n                    if (!text || text.trim() === '') {\n                      console.warn('[UNIFIED] Empty response from status endpoint, retrying...')\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('El servidor no está respondiendo correctamente')\n                      }\n                      continue\n                    }\n\n                    const statusData = JSON.parse(text)\n                    pollRetries = 0 // Reset retries on success\n\n                    const urlsFound = statusData.job?.urls_found || 0\n                    // Status API returns serp_total and serp_completed (not total_queries/completed_queries)\n                    const totalSearches = statusData.job?.serp_total || statusData.progress?.serp?.total || 0\n                    const completedSearches = statusData.job?.serp_completed || statusData.progress?.serp?.completed || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: completedSearches,\n                        total: totalSearches,\n                        label: `Buscando... ${urlsFound} URLs encontradas`,\n                      },\n                    })\n\n                    if (['serp_done', 'serp_completed', 'scrape_done', 'completed'].includes(statusData.status)) {\n                      serpComplete = true\n                      console.log('[UNIFIED] SERP completed. URLs found:', urlsFound)\n                      updateStepState(stepId, {\n                        output: { jobId, phase: 'serp_complete', urlsFound },\n                        progress: undefined,\n                      })\n                    } else if (statusData.status === 'failed') {\n                      throw new Error(statusData.job?.error_message || 'SERP falló')\n                    }\n                  } catch (pollError) {\n                    if (pollError instanceof SyntaxError) {\n                      console.warn('[UNIFIED] JSON parse error in poll, retrying...', pollError)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('Error al procesar respuesta del servidor')\n                      }\n                    } else {\n                      throw pollError\n                    }\n                  }\n                }\n                return // Don't mark as completed - wait for analyze action\n              }\n\n              // ============ ACTION: ANALYZE (Scrape + Extract) ============\n              if (action === 'analyze') {\n                const jobId = (input as { jobId?: string }).jobId\n                const selectedSources = (input as { selectedSources?: string[] }).selectedSources || []\n                const extractionPrompt = (input as { extractionPrompt?: string }).extractionPrompt\n\n                if (!jobId) {\n                  throw new Error('No se encontró el Job ID')\n                }\n\n                console.log('[UNIFIED] Starting analysis for job:', jobId, 'sources:', selectedSources, 'custom prompt:', !!extractionPrompt)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'analyzing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando análisis...' },\n                })\n\n                // If a custom extraction prompt was provided, update the job config\n                if (extractionPrompt) {\n                  console.log('[UNIFIED] Updating job with custom extraction prompt')\n                  const updateRes = await fetch(`/api/niche-finder/jobs/${jobId}`, {\n                    method: 'PATCH',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ extraction_prompt: extractionPrompt }),\n                  })\n                  if (!updateRes.ok) {\n                    console.warn('[UNIFIED] Failed to update job with custom prompt:', updateRes.status)\n                  }\n                }\n\n                // Get total URLs to process\n                const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                if (!statusRes.ok) {\n                  throw new Error(`Error al obtener estado del job: ${statusRes.status}`)\n                }\n                const statusText = await statusRes.text()\n                if (!statusText || statusText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al consultar estado')\n                }\n                const statusData = JSON.parse(statusText)\n                const totalUrls = statusData.job?.urls_found || 0\n\n                // Start scraping - call API repeatedly until all URLs are processed\n                console.log('[UNIFIED] Starting scrape for', totalUrls, 'URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: totalUrls, label: 'Descargando contenido...' },\n                })\n\n                let scrapeComplete = false\n                let scrapeRetries = 0\n                let totalScraped = 0\n                let totalFailed = 0\n                const MAX_SCRAPE_RETRIES = 5 // More retries for transient failures\n\n                while (!scrapeComplete) {\n                  try {\n                    console.log(`[UNIFIED] Scrape batch starting, totalScraped=${totalScraped}, retries=${scrapeRetries}`)\n\n                    // Call scrape API with timeout (120s to allow for slow scrapes)\n                    const controller = new AbortController()\n                    const timeout = setTimeout(() => controller.abort(), 120000)\n\n                    const scrapeRes = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                      method: 'POST',\n                      headers: { 'Content-Type': 'application/json' },\n                      body: JSON.stringify({ sources: selectedSources }),\n                      signal: controller.signal,\n                    })\n                    clearTimeout(timeout)\n\n                    if (!scrapeRes.ok) {\n                      const errorText = await scrapeRes.text().catch(() => '')\n                      console.error(`[UNIFIED] Scrape response not ok: ${scrapeRes.status}`, errorText)\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(`Error en scraping: ${scrapeRes.status} - ${errorText || 'Unknown error'}`)\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeText = await scrapeRes.text()\n                    if (!scrapeText) {\n                      console.warn('[UNIFIED] Empty scrape response, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Respuesta vacía del servidor después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeData = JSON.parse(scrapeText)\n                    scrapeRetries = 0 // Reset on successful response\n\n                    if (scrapeData.error) {\n                      // Check if it's a retryable error\n                      if (scrapeData.error.includes('Rate limit') || scrapeData.error.includes('timeout')) {\n                        console.warn(`[UNIFIED] Retryable scrape error: ${scrapeData.error}`)\n                        scrapeRetries++\n                        if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(scrapeData.error)\n                        await new Promise(r => setTimeout(r, 5000))\n                        continue\n                      }\n                      throw new Error(scrapeData.error)\n                    }\n\n                    // Update progress with scraped count from this batch\n                    totalScraped += scrapeData.scraped || 0\n                    totalFailed += scrapeData.failed || 0\n                    const remaining = scrapeData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: totalScraped,\n                        total: totalUrls,\n                        label: `Descargando... ${totalScraped}/${totalUrls} URLs${totalFailed > 0 ? ` (${totalFailed} fallidas)` : ''}`,\n                      },\n                      partialResults: {\n                        successCount: totalScraped,\n                        failedCount: totalFailed,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Scrape batch complete: +${scrapeData.scraped} scraped, ${remaining} remaining, has_more: ${scrapeData.has_more}`)\n\n                    // Check if scraping is complete\n                    if (!scrapeData.has_more || remaining === 0) {\n                      scrapeComplete = true\n                    }\n                  } catch (e) {\n                    console.error('[UNIFIED] Scrape error:', e)\n                    if (e instanceof SyntaxError) {\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 3000))\n                    } else if (e instanceof Error && e.name === 'AbortError') {\n                      // Timeout - retry with longer wait\n                      console.warn('[UNIFIED] Scrape request timed out, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Timeout en scraping después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 5000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Scraping complete, total scraped:', totalScraped)\n\n                // Start extraction - use totalScraped as the base since only scraped URLs can be extracted\n                const extractionTotal = totalScraped || totalUrls // Fallback to totalUrls if scraping tracked differently\n                console.log('[UNIFIED] Starting extraction for', extractionTotal, 'scraped URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: extractionTotal, label: 'Extrayendo problemas...' },\n                })\n\n                let extractComplete = false\n                let extractedTotal = 0\n                let filteredTotal = 0\n                let extractRetries = 0\n\n                while (!extractComplete) {\n                  try {\n                    const extractRes = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, { method: 'POST' })\n                    if (!extractRes.ok) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error(`Error en extracción: ${extractRes.status}`)\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const text = await extractRes.text()\n                    if (!text) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Respuesta vacía del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const extractData = JSON.parse(text)\n                    extractRetries = 0\n\n                    if (extractData.error) {\n                      throw new Error(extractData.error)\n                    }\n\n                    extractedTotal += extractData.extracted || 0\n                    filteredTotal += extractData.filtered || 0\n                    const processed = extractedTotal + filteredTotal\n                    const remaining = extractData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: processed,\n                        total: extractionTotal,\n                        label: `Extrayendo... ${extractedTotal} problemas de ${processed}/${extractionTotal} URLs${filteredTotal > 0 ? ` (${filteredTotal} filtradas)` : ''}`,\n                      },\n                      partialResults: {\n                        extracted: extractedTotal,\n                        filtered: filteredTotal,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Extract batch: ${extractData.extracted} extracted, ${extractData.filtered} filtered, ${remaining} remaining, has_more: ${extractData.has_more}`)\n\n                    if (!extractData.has_more || remaining === 0) {\n                      extractComplete = true\n                    }\n                  } catch (e) {\n                    if (e instanceof SyntaxError) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Extraction complete. Problems:', extractedTotal, 'Filtered:', filteredTotal)\n\n                // Get results and format as CSV\n                console.log('[UNIFIED] Getting results')\n                const resultsRes = await fetch(`/api/niche-finder/results/${jobId}`)\n                if (!resultsRes.ok) {\n                  throw new Error(`Error al obtener resultados: ${resultsRes.status}`)\n                }\n                const resultsText = await resultsRes.text()\n                const resultsData = resultsText ? JSON.parse(resultsText) : { niches: [] }\n                const niches = resultsData.niches || []\n\n                let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n                for (const niche of niches) {\n                  const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                  const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                  const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                  const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                  const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                  const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                  const url = niche.source_url || ''\n                  csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n                }\n\n                console.log('[UNIFIED] Complete. Problems:', niches.length)\n                updateStepState(stepId, {\n                  status: 'completed',\n                  completedAt: new Date(),\n                  output: { jobId, extractedCount: niches.length, csv: csvOutput },\n                })\n                setTimeout(goToNextStep, 500)\n                return\n              }\n\n              // Unknown action\n              console.warn('[UNIFIED] Unknown action:', action)\n            }\n\n            // For other job types, just mark as pending\n            result = input\n            break\n\n          case 'none':\n          default:\n            // No execution needed, just proceed\n            result = input\n            break\n        }\n\n        // Mark as completed\n        updateStepState(stepId, {\n          status: 'completed',\n          completedAt: new Date(),\n          output: result,\n        })\n\n        // Auto-advance for auto steps\n        if (['auto', 'auto_with_review'].includes(step.type)) {\n          setTimeout(goToNextStep, 500)\n        }\n      } catch (error) {\n        updateStepState(stepId, {\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Error desconocido',\n        })\n      }\n    },\n    [projectId, playbookConfig.type, playbookConfig.phases, updateStepState, goToNextStep, selectedCampaign, state.phases]\n  )\n\n  // Handle continue from current step\n  const handleContinue = useCallback(() => {\n    console.log('[handleContinue] Called for step:', currentStep?.id, 'current status:', currentStepState?.status)\n    // Note: Don't update step state here if the caller (WorkArea) already updated it.\n    // The caller is responsible for setting status and output correctly before calling onContinue.\n    // We only set completedAt if not already completed, and we do it in a way that preserves output.\n    if (currentStepState?.status !== 'completed') {\n      console.log('[handleContinue] Status is not completed, updating step state (without output)')\n      // Mark as completed, but preserve any existing output that might have been set\n      // by the caller in the same tick (before React re-renders)\n      updateStepState(currentStep.id, {\n        status: 'completed',\n        completedAt: new Date(),\n        // Don't set output - it should already be set by the caller\n      })\n    } else {\n      console.log('[handleContinue] Status is already completed, not updating')\n    }\n    // Enable auto-execution for the next step (if it's an auto step)\n    setShouldAutoExecute(true)\n    goToNextStep()\n  }, [currentStep?.id, currentStepState?.status, updateStepState, goToNextStep])\n\n  // Handle edit - volver a editar un paso completado\n  const handleEdit = useCallback(() => {\n    if (!currentStep) return\n    // Cambiar status a pending sin perder los datos (suggestions, output, etc.)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      completedAt: undefined,\n      error: undefined,\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle cancel - cancelar ejecución en curso\n  // IMPORTANTE: Mantiene el output (jobId) para poder retomar el job\n  const handleCancel = useCallback(() => {\n    if (!currentStep) return\n\n    // Clear polling interval if running\n    if (pollIntervalRef.current) {\n      clearInterval(pollIntervalRef.current)\n      pollIntervalRef.current = null\n      console.log('[Cancel] Cleared polling interval')\n    }\n\n    // Volver a pending y limpiar progreso, pero MANTENER output (contiene jobId)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      progress: undefined,\n      error: undefined,\n      // NO limpiamos output para mantener el jobId y poder retomar\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle quick retry - retry with same configuration\n  const handleQuickRetry = useCallback(async () => {\n    if (!currentStep || !currentStepState) return\n\n    console.log('[Retry] Quick retry for step:', currentStep.id)\n\n    // Start a new retry attempt\n    try {\n      await stepRetryActions.startRetry(currentStep.id)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Reset step state and re-execute\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input\n    executeStep(currentStep.id, currentStepState.input)\n  }, [currentStep, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle retry with config modification - opens dialog\n  const handleRetryWithConfig = useCallback(() => {\n    if (!currentStep) return\n    setRetryDialogStepId(currentStep.id)\n    setRetryDialogOpen(true)\n  }, [currentStep])\n\n  // Handle retry from dialog with config overrides\n  const handleRetryFromDialog = useCallback(async (configOverrides?: StepAttemptConfig) => {\n    if (!retryDialogStepId || !currentStepState) return\n\n    console.log('[Retry] Retry from dialog for step:', retryDialogStepId, 'with config:', configOverrides)\n\n    // Start a new retry attempt with config\n    try {\n      await stepRetryActions.startRetry(retryDialogStepId, configOverrides)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Close dialog\n    setRetryDialogOpen(false)\n    setRetryDialogStepId(null)\n\n    // Reset step state\n    updateStepState(retryDialogStepId, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input (config overrides are tracked in the attempt)\n    executeStep(retryDialogStepId, currentStepState.input)\n  }, [retryDialogStepId, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle skip step - mark as skipped and continue\n  const handleSkipStep = useCallback(() => {\n    if (!currentStep) return\n\n    console.log('[Skip] Skipping step:', currentStep.id)\n\n    updateStepState(currentStep.id, {\n      status: 'skipped',\n      completedAt: new Date(),\n      error: undefined,\n    })\n\n    // Move to next step\n    handleContinue()\n  }, [currentStep, updateStepState, handleContinue])\n\n  // Get retry info for current step\n  const currentStepRetryInfo = currentStep\n    ? stepRetryActions.getRetryInfo(currentStep.id)\n    : null\n\n  // Check if max retries reached\n  const maxRetriesReached = currentStepRetryInfo\n    ? currentStepRetryInfo.attemptNumber >= currentStepRetryInfo.maxAttempts\n    : false\n\n  // Auto-start current step if it's an auto step, pending, AND user clicked Continue\n  useEffect(() => {\n    console.log('[AutoExecute] Check:', {\n      shouldAutoExecute,\n      currentStepId: currentStep?.id,\n      currentStepType: currentStep?.type,\n      currentStepStatus: currentStepState?.status,\n    })\n    if (\n      shouldAutoExecute &&\n      currentStep &&\n      currentStepState?.status === 'pending' &&\n      ['auto'].includes(currentStep.type)\n    ) {\n      console.log('[AutoExecute] Starting auto execution for:', currentStep.id)\n      // Reset the flag\n      setShouldAutoExecute(false)\n      // Small delay to allow UI to render first\n      const timer = setTimeout(() => {\n        executeStep(currentStep.id)\n      }, 300)\n      return () => clearTimeout(timer)\n    }\n  }, [shouldAutoExecute, currentStep, currentStepState?.status, executeStep])\n\n  // Resume polling for in_progress steps on page reload\n  // This handles the case where user refreshes the page while a SERP job is running\n  useEffect(() => {\n    // Only for search_with_preview steps that are in_progress with a jobId\n    if (\n      currentStep?.type === 'search_with_preview' &&\n      (currentStepState?.status === 'in_progress' || currentStepState?.status === 'pending') &&\n      currentStepState?.output &&\n      !pollIntervalRef.current\n    ) {\n      const output = currentStepState.output as { jobId?: string }\n      const jobId = output.jobId\n\n      if (jobId) {\n        console.log('[Resume] Resuming polling for job:', jobId)\n\n        // First, check if job is already done (immediate check, not polling)\n        fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          .then(res => res.json())\n          .then(statusData => {\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDone) {\n              console.log('[Resume] Job already completed, marking step as done')\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n              return // Don't start polling\n            }\n            // If not done, continue with normal polling setup below\n            startPolling()\n          })\n          .catch(err => {\n            console.error('[Resume] Error checking initial status:', err)\n            startPolling() // Start polling anyway\n          })\n\n        function startPolling() {\n          if (pollIntervalRef.current) return // Already polling\n\n          // Set up polling - same logic as in executeStep\n          let isResuming = false\n          let lastCompletedCount = -1\n          let stallCount = 0\n          let initialCompleted = -1\n\n          pollIntervalRef.current = setInterval(async () => {\n          try {\n            const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n            const statusData = await statusResponse.json()\n\n            const completed = statusData.progress?.serp?.completed || 0\n            const total = statusData.progress?.serp?.total || 0\n            const remaining = total - completed\n            const label = total > 0\n              ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n              : 'Reconectando...'\n\n            updateStepState(currentStep.id, {\n              progress: {\n                current: completed,\n                total: total,\n                label,\n              },\n            })\n\n            // Track initial value on first poll\n            if (initialCompleted === -1) {\n              initialCompleted = completed\n              console.log('[Resume] Initial completed:', initialCompleted)\n            }\n\n            // Auto-resume if job was interrupted\n            if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n              if (lastCompletedCount === completed && remaining > 0) {\n                stallCount++\n                const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                if (stallCount >= 2 || noProgressSinceStart) {\n                  console.log(`[Resume] Job stalled at ${completed}/${total}, auto-resuming...`)\n                  isResuming = true\n                  stallCount = 0\n                  fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                    .then(res => res.json())\n                    .then(data => {\n                      console.log('[Resume] Resume response:', data)\n                      isResuming = false\n                    })\n                    .catch(err => {\n                      console.error('[Resume] Resume error:', err)\n                      isResuming = false\n                    })\n                }\n              } else {\n                stallCount = 0\n              }\n            }\n            lastCompletedCount = completed\n\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDoneInPoll = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDoneInPoll) {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n            } else if (statusData.status === 'failed' || statusData.status === 'error') {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'error',\n                error: statusData.job?.error_message || 'Job failed',\n              })\n            }\n          } catch (pollError) {\n            console.error('[Resume] Poll error:', pollError)\n            // Don't stop polling on transient errors\n          }\n        }, 2000)\n        } // End startPolling function\n\n        // Cleanup on unmount\n        return () => {\n          if (pollIntervalRef.current) {\n            clearInterval(pollIntervalRef.current)\n            pollIntervalRef.current = null\n          }\n        }\n      }\n    }\n  }, [currentStep?.id, currentStep?.type, currentStepState?.status, currentStepState?.output, updateStepState, goToNextStep])\n\n  if (!currentPhase || !currentStep || !currentStepState) {\n    return (\n      <div className=\"flex items-center justify-center h-64 text-gray-500\">\n        Error: Configuración de playbook inválida\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n      {/* Header with mode selector */}\n      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3\">\n          <span className=\"text-xl\">{playbookConfig.icon}</span>\n          <h2 className=\"text-lg font-semibold text-gray-900\">{playbookConfig.name}</h2>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}\n          <div className=\"relative flex items-center gap-1\">\n            <button\n              onClick={() => {\n                setMode('campaign')\n                setShowCampaignDropdown(!showCampaignDropdown)\n              }}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                mode === 'campaign'\n                  ? 'bg-blue-100 text-blue-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Folder size={16} />\n              {selectedCampaign ? selectedCampaign.name : 'Seleccionar Campaña'}\n              <ChevronDown size={16} />\n            </button>\n\n            {/* Edit campaign settings button */}\n            {selectedCampaignId && (\n              <button\n                onClick={() => setShowCampaignSettings(true)}\n                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg\"\n                title=\"Editar configuración de campaña\"\n              >\n                <Pencil size={14} />\n              </button>\n            )}\n\n            {/* Dropdown */}\n            {showCampaignDropdown && (\n              <div className=\"absolute right-0 top-full mt-1 w-64 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50\">\n                {campaigns.length === 0 ? (\n                  <div className=\"px-3 py-2 text-sm text-gray-500\">No hay campañas</div>\n                ) : (\n                  campaigns.map(campaign => (\n                    <div\n                      key={campaign.id}\n                      className={`flex items-center justify-between px-3 py-2 text-sm hover:bg-gray-50 ${\n                        selectedCampaignId === campaign.id ? 'bg-blue-50' : ''\n                      }`}\n                    >\n                      <button\n                        onClick={() => {\n                          setSelectedCampaignId(campaign.id)\n                          setShowCampaignDropdown(false)\n                        }}\n                        className=\"flex-1 flex items-center justify-between text-left\"\n                      >\n                        <span className=\"font-medium text-gray-900\">{campaign.name}</span>\n                        <span className=\"text-gray-500 mr-2\">\n                          {campaign.completedSteps}/{campaign.totalSteps}\n                        </span>\n                      </button>\n                      <button\n                        onClick={(e) => {\n                          e.stopPropagation()\n                          deleteCampaign(campaign.id)\n                        }}\n                        className=\"p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded\"\n                        title=\"Eliminar campaña\"\n                      >\n                        <Trash2 size={14} />\n                      </button>\n                    </div>\n                  ))\n                )}\n                <div className=\"border-t border-gray-100 mt-1 pt-1\">\n                  <button\n                    onClick={() => {\n                      setShowWizard(true)\n                      setShowCampaignDropdown(false)\n                    }}\n                    className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-blue-600 hover:bg-blue-50\"\n                  >\n                    <Plus size={16} />\n                    Nueva Campaña\n                  </button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Main content */}\n      {mode === 'config' ? (\n        /* Configuration Mode - Full width */\n        <div className=\"flex-1 overflow-hidden\">\n          <ConfigurationMode\n            projectId={projectId}\n            playbookConfig={playbookConfig}\n            onSave={() => {\n              // Optionally refresh something after save\n            }}\n          />\n        </div>\n      ) : (\n        /* Campaign Mode - Dual panel */\n        <div className=\"flex flex-1 overflow-hidden\">\n          {/* Navigation Panel - Left side */}\n          <div className=\"w-80 flex-shrink-0\">\n            <NavigationPanel\n              phases={playbookConfig.phases}\n              phaseStates={state.phases}\n              currentPhaseIndex={state.currentPhaseIndex}\n              currentStepIndex={state.currentStepIndex}\n              onStepClick={goToStep}\n            />\n          </div>\n\n          {/* Work Area - Right side */}\n          <div className=\"flex-1 overflow-y-auto\">\n            {!selectedCampaignId ? (\n              /* No campaign selected - prompt to select or create */\n              <div className=\"flex flex-col items-center justify-center h-full bg-white p-8 text-center\">\n                <Folder className=\"text-gray-300 mb-4\" size={64} />\n                <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                  Selecciona o crea una campaña\n                </h3>\n                <p className=\"text-gray-500 mb-6 max-w-md\">\n                  Para ejecutar el playbook, primero debes seleccionar una campaña existente o crear una nueva.\n                </p>\n                <button\n                  onClick={() => setShowWizard(true)}\n                  className=\"flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n                >\n                  <Plus size={16} />\n                  Nueva Campaña\n                </button>\n              </div>\n            ) : (\n              <>\n                <WorkArea\n                  step={currentStep}\n                  stepState={currentStepState}\n                  onContinue={handleContinue}\n                  onBack={goToPreviousStep}\n                  onExecute={(input) => executeStep(currentStep.id, input)}\n                  onUpdateState={(update) => updateStepState(currentStep.id, update)}\n                  onEdit={handleEdit}\n                  onCancel={handleCancel}\n                  onRerunPrevious={rerunPreviousStep}\n                  onRetry={handleQuickRetry}\n                  onRetryWithConfig={handleRetryWithConfig}\n                  onSkipStep={handleSkipStep}\n                  isFirst={isFirstStep}\n                  isLast={isLastStep}\n                  previousStepOutput={getPreviousStepOutput()}\n                  projectId={projectId}\n                  playbookContext={buildPlaybookContext()}\n                  allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                    phase.steps.map((stepDef, stepIdx) => ({\n                      definition: stepDef,\n                      state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                    }))\n                  )}\n                  saveState={sessionId ? stepPersistenceState : undefined}\n                  retryInfo={currentStepRetryInfo || undefined}\n                  maxRetriesReached={maxRetriesReached}\n                  sessionId={sessionId}\n                />\n\n                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Campaign Wizard Modal */}\n      {showWizard && (\n        <CampaignWizard\n          projectId={projectId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowWizard(false)}\n          onCreated={(campaignId) => {\n            setSelectedCampaignId(campaignId)\n            setShowWizard(false)\n            // Reload campaigns\n            loadCampaigns()\n          }}\n        />\n      )}\n\n      {/* Campaign Settings Modal */}\n      {showCampaignSettings && selectedCampaignId && (\n        <CampaignSettings\n          campaignId={selectedCampaignId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowCampaignSettings(false)}\n          onSaved={() => {\n            loadCampaigns()\n          }}\n        />\n      )}\n    </div>\n  )\n}\n","structuredPatch":[{"oldStart":171,"oldLines":6,"newStart":171,"newLines":7,"lines":["   const [showCampaignDropdown, setShowCampaignDropdown] = useState(false)","   const [showWizard, setShowWizard] = useState(false)","   const [showCampaignSettings, setShowCampaignSettings] = useState(false)","+  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)"," ","   // Load campaigns from database","   const loadCampaigns = useCallback(async () => {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012E6DnkXJKw7NEzVcsNDcZz","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the Session Data button in the header. Let me find the exact location:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":307,"cache_read_input_tokens":126346,"cache_creation":{"ephemeral_5m_input_tokens":307,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"cd844528-d892-43ac-9b1e-9dbffbe966c9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012E6DnkXJKw7NEzVcsNDcZz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019TtHrxE56y2AjGhewjnus5","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","offset":2615,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":307,"cache_read_input_tokens":126346,"cache_creation":{"ephemeral_5m_input_tokens":307,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"df3b4edf-56a7-4239-aa97-e62d1562b1ca"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019TtHrxE56y2AjGhewjnus5","type":"tool_result","content":"  2615→\n  2616→  return (\n  2617→    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n  2618→      {/* Header with mode selector */}\n  2619→      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n  2620→        <div className=\"flex items-center gap-3\">\n  2621→          <span className=\"text-xl\">{playbookConfig.icon}</span>\n  2622→          <h2 className=\"text-lg font-semibold text-gray-900\">{playbookConfig.name}</h2>\n  2623→        </div>\n  2624→\n  2625→        <div className=\"flex items-center gap-2\">\n  2626→          {/* Config Base button */}\n  2627→          <button\n  2628→            onClick={() => setMode('config')}\n  2629→            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n  2630→              mode === 'config'\n  2631→                ? 'bg-blue-100 text-blue-700'\n  2632→                : 'text-gray-600 hover:bg-gray-100'\n  2633→            }`}\n  2634→          >\n  2635→            <Settings size={16} />\n  2636→            Configuración Base\n  2637→          </button>\n  2638→\n  2639→          {/* Campaign selector */}\n  2640→          <div className=\"relative flex items-center gap-1\">\n  2641→            <button\n  2642→              onClick={() => {\n  2643→                setMode('campaign')\n  2644→                setShowCampaignDropdown(!showCampaignDropdown)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"dc3d098b-f25f-46b1-8970-01be9531e3cb","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","content":"\n  return (\n    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n      {/* Header with mode selector */}\n      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3\">\n          <span className=\"text-xl\">{playbookConfig.icon}</span>\n          <h2 className=\"text-lg font-semibold text-gray-900\">{playbookConfig.name}</h2>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}\n          <div className=\"relative flex items-center gap-1\">\n            <button\n              onClick={() => {\n                setMode('campaign')\n                setShowCampaignDropdown(!showCampaignDropdown)","numLines":30,"startLine":2615,"totalLines":2852}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Am6VKEEJbJ17dpsgSoziZN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QW7zowhErEiiyN5gFrFX8s","name":"Edit","input":{"replace_all":false,"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","old_string":"        <div className=\"flex items-center gap-2\">\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}","new_string":"        <div className=\"flex items-center gap-2\">\n          {/* Session Data button */}\n          {selectedCampaignId && mode === 'campaign' && (\n            <button\n              onClick={() => setShowArtifactBrowser(!showArtifactBrowser)}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                showArtifactBrowser\n                  ? 'bg-indigo-100 text-indigo-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n              title=\"Browse all session artifacts\"\n            >\n              <Database size={16} />\n              Session Data\n            </button>\n          )}\n\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":730,"cache_read_input_tokens":126653,"cache_creation":{"ephemeral_5m_input_tokens":730,"ephemeral_1h_input_tokens":0},"output_tokens":623,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"6daf5233-2c70-493b-8778-b14d83067d73"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QW7zowhErEiiyN5gFrFX8s","type":"tool_result","content":"The file /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"23373793-b7ec-48b0-a9a4-982d8158ff39","tool_use_result":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","oldString":"        <div className=\"flex items-center gap-2\">\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}","newString":"        <div className=\"flex items-center gap-2\">\n          {/* Session Data button */}\n          {selectedCampaignId && mode === 'campaign' && (\n            <button\n              onClick={() => setShowArtifactBrowser(!showArtifactBrowser)}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                showArtifactBrowser\n                  ? 'bg-indigo-100 text-indigo-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n              title=\"Browse all session artifacts\"\n            >\n              <Database size={16} />\n              Session Data\n            </button>\n          )}\n\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}","originalFile":"'use client'\n\nimport { useState, useCallback, useEffect, useRef } from 'react'\nimport {\n  PlaybookShellProps,\n  PlaybookState,\n  PhaseState,\n  StepState,\n  StepDefinition,\n  PhaseDefinition,\n} from './types'\nimport NavigationPanel from './NavigationPanel'\nimport { WorkArea } from './WorkArea'\nimport ConfigurationMode from './ConfigurationMode'\nimport CampaignWizard from './CampaignWizard'\nimport CampaignSettings from './CampaignSettings'\nimport { Settings, ChevronDown, Plus, Folder, Pencil, Trash2, Database } from 'lucide-react'\nimport { ArtifactBrowser } from './ArtifactBrowser'\nimport { useStepPersistence } from '@/hooks/useStepPersistence'\nimport { useStepRetry } from '@/hooks/useStepRetry'\nimport { StepAttemptConfig, StepRetryInfo } from './types'\nimport StepRetryDialog from './StepRetryDialog'\nimport FailedStepActions from './FailedStepActions'\n\n// Mode types for the unified view\ntype PlaybookMode = 'config' | 'campaign'\n\ninterface Campaign {\n  id: string\n  name: string\n  status: 'draft' | 'in_progress' | 'completed'\n  completedSteps: number\n  totalSteps: number\n  customVariables?: Record<string, unknown> // Includes context_type, product, target, etc.\n  playbookState?: PlaybookState // Saved playbook state for persistence\n}\n\nfunction initializeState(\n  projectId: string,\n  playbookConfig: PlaybookShellProps['playbookConfig'],\n  initialState?: Partial<PlaybookState>\n): PlaybookState {\n  const phases: PhaseState[] = playbookConfig.phases.map(phase => ({\n    id: phase.id,\n    status: 'pending',\n    steps: phase.steps.map(step => ({\n      id: step.id,\n      status: 'pending',\n    })),\n  }))\n\n  // Apply initial state if provided - match by ID for robustness when config changes\n  if (initialState?.phases) {\n    initialState.phases.forEach((savedPhaseState) => {\n      // Find phase by ID instead of index\n      const phaseIndex = phases.findIndex(p => p.id === savedPhaseState.id)\n      if (phaseIndex === -1) return\n\n      phases[phaseIndex].status = savedPhaseState.status\n      savedPhaseState.steps.forEach((savedStepState) => {\n        // Find step by ID instead of index\n        const stepIndex = phases[phaseIndex].steps.findIndex(s => s.id === savedStepState.id)\n        if (stepIndex === -1) return\n\n        phases[phaseIndex].steps[stepIndex] = {\n          ...phases[phaseIndex].steps[stepIndex],\n          ...savedStepState,\n        }\n      })\n    })\n  }\n\n  const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n  const completedSteps = phases.reduce(\n    (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n    0\n  )\n\n  // Validate currentPhaseIndex and currentStepIndex are within bounds\n  let currentPhaseIndex = initialState?.currentPhaseIndex ?? 0\n  let currentStepIndex = initialState?.currentStepIndex ?? 0\n\n  // Ensure phase index is valid\n  if (currentPhaseIndex >= playbookConfig.phases.length) {\n    currentPhaseIndex = Math.max(0, playbookConfig.phases.length - 1)\n  }\n\n  // Ensure step index is valid for the current phase\n  const currentPhaseSteps = playbookConfig.phases[currentPhaseIndex]?.steps.length ?? 0\n  if (currentStepIndex >= currentPhaseSteps) {\n    currentStepIndex = Math.max(0, currentPhaseSteps - 1)\n  }\n\n  // If the current step doesn't exist, find the first non-completed step\n  if (currentPhaseSteps === 0 || currentStepIndex < 0) {\n    // Find first pending step\n    for (let pi = 0; pi < phases.length; pi++) {\n      for (let si = 0; si < phases[pi].steps.length; si++) {\n        if (phases[pi].steps[si].status !== 'completed') {\n          currentPhaseIndex = pi\n          currentStepIndex = si\n          break\n        }\n      }\n      if (currentStepIndex >= 0) break\n    }\n    // Default to first step if all completed\n    if (currentStepIndex < 0) {\n      currentPhaseIndex = 0\n      currentStepIndex = 0\n    }\n  }\n\n  console.log('[initializeState] Validated indices:', {\n    originalPhase: initialState?.currentPhaseIndex,\n    originalStep: initialState?.currentStepIndex,\n    validatedPhase: currentPhaseIndex,\n    validatedStep: currentStepIndex,\n    maxPhases: playbookConfig.phases.length,\n    maxSteps: currentPhaseSteps,\n  })\n\n  return {\n    projectId,\n    playbookType: playbookConfig.type,\n    phases,\n    currentPhaseIndex,\n    currentStepIndex,\n    config: initialState?.config ?? {},\n    completedSteps,\n    totalSteps,\n    startedAt: initialState?.startedAt,\n    completedAt: initialState?.completedAt,\n  }\n}\n\nexport default function PlaybookShell({\n  projectId,\n  playbookConfig,\n  initialState,\n  sessionId,\n}: PlaybookShellProps) {\n  const [state, setState] = useState<PlaybookState>(() =>\n    initializeState(projectId, playbookConfig, initialState)\n  )\n\n  // Step persistence hook for auto-saving step data to database\n  const [stepPersistenceState, stepPersistenceActions] = useStepPersistence({\n    sessionId: sessionId || null,\n    autoSaveInterval: 30000, // Auto-save every 30 seconds\n    enabled: !!sessionId, // Only enable if sessionId is provided\n  })\n\n  // Step retry hook for managing retry attempts\n  const [stepRetryState, stepRetryActions] = useStepRetry(sessionId || null, {\n    enabled: !!sessionId,\n  })\n\n  // State for retry dialog\n  const [retryDialogOpen, setRetryDialogOpen] = useState(false)\n  const [retryDialogStepId, setRetryDialogStepId] = useState<string | null>(null)\n\n  // Flag to distinguish between intentional navigation (Continue button)\n  // vs manual navigation (clicking on a step)\n  const [shouldAutoExecute, setShouldAutoExecute] = useState(false)\n\n  // Mode: 'config' for editing base prompts, 'campaign' for execution\n  const [mode, setMode] = useState<PlaybookMode>('campaign')\n  const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null)\n  const [campaigns, setCampaigns] = useState<Campaign[]>([])\n  const [showCampaignDropdown, setShowCampaignDropdown] = useState(false)\n  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)\n\n  // Load campaigns from database\n  const loadCampaigns = useCallback(async () => {\n    try {\n      const response = await fetch(`/api/campaign/create?projectId=${projectId}`)\n      if (!response.ok) {\n        console.error('Failed to load campaigns')\n        return\n      }\n      const data = await response.json()\n      if (data.campaigns) {\n        const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n        const mappedCampaigns: Campaign[] = data.campaigns.map((c: any) => ({\n          id: c.id,\n          name: c.ecp_name,\n          status: c.status || 'draft',\n          // Calculate completed steps from playbook_state if available\n          completedSteps: c.playbook_state?.completedSteps ?? 0,\n          totalSteps,\n          customVariables: c.custom_variables || {}, // Load campaign variables including context_type\n          playbookState: c.playbook_state || null, // Load saved playbook state\n        }))\n        setCampaigns(mappedCampaigns)\n      }\n    } catch (error) {\n      console.error('Error loading campaigns:', error)\n    }\n  }, [projectId, playbookConfig.phases])\n\n  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)\n\n  // Ref to track if we should save (avoid saving on initial load)\n  const shouldSaveRef = useRef(false)\n  // Ref to prevent duplicate saves\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  // Ref to store polling interval for cancellation\n  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Save playbook state to database (debounced)\n  const savePlaybookState = useCallback(async (stateToSave: PlaybookState) => {\n    if (!selectedCampaignId) return\n\n    try {\n      await fetch(`/api/campaign/${selectedCampaignId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ playbook_state: stateToSave }),\n      })\n    } catch (error) {\n      console.error('Error saving playbook state:', error)\n    }\n  }, [selectedCampaignId])\n\n  // Auto-save state when it changes (debounced)\n  useEffect(() => {\n    if (!shouldSaveRef.current || !selectedCampaignId) return\n\n    // Clear any pending save\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current)\n    }\n\n    // Debounce saves by 500ms to avoid too many API calls\n    saveTimeoutRef.current = setTimeout(() => {\n      savePlaybookState(state)\n    }, 500)\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n      }\n    }\n  }, [state, selectedCampaignId, savePlaybookState])\n\n  // Load saved state when selecting a campaign\n  useEffect(() => {\n    if (!selectedCampaignId) {\n      shouldSaveRef.current = false\n      return\n    }\n\n    const campaign = campaigns.find(c => c.id === selectedCampaignId)\n    if (campaign?.playbookState) {\n      // Load saved state\n      shouldSaveRef.current = false // Don't save while loading\n      setState(initializeState(projectId, playbookConfig, campaign.playbookState))\n      // Enable saving after a short delay\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    } else {\n      // Fresh state for new campaign\n      shouldSaveRef.current = false\n      setState(initializeState(projectId, playbookConfig))\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    }\n  }, [selectedCampaignId, campaigns, projectId, playbookConfig])\n\n  // Load step data from database on session resume (if sessionId is provided)\n  useEffect(() => {\n    if (!sessionId) return\n\n    const loadStepData = async () => {\n      try {\n        const savedSteps = await stepPersistenceActions.loadAllSteps()\n        if (Object.keys(savedSteps).length === 0) return\n\n        console.log('[PlaybookShell] Loaded step data from session:', Object.keys(savedSteps))\n\n        // Merge saved step data into current state\n        setState(prev => {\n          const newPhases = prev.phases.map(phase => ({\n            ...phase,\n            steps: phase.steps.map(step => {\n              const savedStep = savedSteps[step.id]\n              if (savedStep) {\n                return {\n                  ...step,\n                  ...savedStep,\n                }\n              }\n              return step\n            }),\n          }))\n\n          // Recalculate phase status\n          newPhases.forEach(phase => {\n            const hasError = phase.steps.some(s => s.status === 'error')\n            const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n            const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n            if (hasError) {\n              phase.status = 'error'\n            } else if (allCompleted) {\n              phase.status = 'completed'\n            } else if (hasInProgress) {\n              phase.status = 'in_progress'\n            } else {\n              phase.status = 'pending'\n            }\n          })\n\n          // Recalculate completed steps\n          const completedSteps = newPhases.reduce(\n            (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n            0\n          )\n\n          // Find the first non-completed step to set as current\n          let currentPhaseIndex = 0\n          let currentStepIndex = 0\n          outer: for (let pi = 0; pi < newPhases.length; pi++) {\n            for (let si = 0; si < newPhases[pi].steps.length; si++) {\n              if (newPhases[pi].steps[si].status !== 'completed') {\n                currentPhaseIndex = pi\n                currentStepIndex = si\n                break outer\n              }\n            }\n          }\n\n          return {\n            ...prev,\n            phases: newPhases,\n            completedSteps,\n            currentPhaseIndex,\n            currentStepIndex,\n          }\n        })\n      } catch (error) {\n        console.error('[PlaybookShell] Error loading step data:', error)\n      }\n    }\n\n    loadStepData()\n  }, [sessionId, stepPersistenceActions])\n\n  // Delete a campaign\n  const deleteCampaign = useCallback(async (campaignId: string) => {\n    if (!confirm('¿Estás seguro de que quieres eliminar esta campaña? Esta acción no se puede deshacer.')) {\n      return\n    }\n\n    try {\n      const response = await fetch(`/api/campaign/${campaignId}`, {\n        method: 'DELETE',\n      })\n\n      if (!response.ok) {\n        throw new Error('Error al eliminar campaña')\n      }\n\n      // If we deleted the selected campaign, clear selection\n      if (selectedCampaignId === campaignId) {\n        setSelectedCampaignId(null)\n      }\n\n      // Reload campaigns\n      loadCampaigns()\n    } catch (error) {\n      console.error('Error deleting campaign:', error)\n      alert('Error al eliminar la campaña')\n    }\n  }, [selectedCampaignId, loadCampaigns])\n\n  // Helper function to get the output from the previous step\n  const getPreviousStepOutput = (): string | undefined => {\n    // Find the current step's dependencies\n    if (!currentStep?.dependsOn?.length) return undefined\n\n    // Get the first dependency's output\n    const dependencyId = currentStep.dependsOn[0]\n\n    // Search for this step across all phases\n    for (const phase of state.phases) {\n      const stepState = phase.steps.find(s => s.id === dependencyId)\n      if (stepState?.output) {\n        return typeof stepState.output === 'string'\n          ? stepState.output\n          : JSON.stringify(stepState.output, null, 2)\n      }\n    }\n\n    return undefined\n  }\n\n  // Build context for LLM-based suggestion generation\n  const buildPlaybookContext = (): Record<string, unknown> => {\n    // Start with campaign's custom_variables (includes context_type, product, target, etc.)\n    const campaignVars = selectedCampaign?.customVariables || {}\n\n    const context: Record<string, unknown> = {\n      ...campaignVars, // Include all campaign variables\n      product: campaignVars.product || state.config?.product || '',\n      target: campaignVars.target || state.config?.target || '',\n      context_type: campaignVars.context_type || 'both', // Explicitly include context_type\n    }\n\n    // DEBUG: Log all steps to see their state\n    console.log('[buildPlaybookContext] All steps:', state.phases.flatMap(p =>\n      p.steps.map(s => ({ id: s.id, status: s.status, hasOutput: !!s.output }))\n    ))\n\n    // Collect values from completed steps\n    for (const phase of state.phases) {\n      for (const stepState of phase.steps) {\n        // DEBUG: Log keyword_config step specifically\n        if (stepState.id === 'keyword_config') {\n          console.log('[buildPlaybookContext] keyword_config step:', {\n            status: stepState.status,\n            hasOutput: !!stepState.output,\n            outputKeys: stepState.output ? Object.keys(stepState.output as object) : [],\n            output: stepState.output,\n          })\n        }\n\n        if (stepState.status === 'completed' || stepState.decision || stepState.suggestions) {\n          // Get decision value\n          if (stepState.decision) {\n            context[stepState.id] = stepState.decision\n          }\n\n          // Get selected suggestions as array of labels\n          if (stepState.suggestions?.length) {\n            const selectedLabels = stepState.suggestions\n              .filter(s => s.selected)\n              .map(s => s.label)\n            if (selectedLabels.length > 0) {\n              context[stepState.id] = selectedLabels\n            }\n          }\n\n          // Get output if available\n          if (stepState.output) {\n            context[`${stepState.id}_output`] = stepState.output\n          }\n\n          // Special case: Extract serpJobId from serp_search or search_and_preview step output\n          // This is needed for review_urls/review_and_scrape step to display SERP results\n          // Note: We check this inside the completed block, but also outside below\n          if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Also extract serpJobId from review_and_scrape step (the scrape step)\n          // This ensures scrape_results step can find the jobId after scraping completes\n          if (stepState.id === 'review_and_scrape' && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId && !context.serpJobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Special case: Parse sources step output for QueryPreviewPanel\n          // The LLM returns a JSON string that needs to be parsed\n          if (stepState.id === 'sources' && stepState.output) {\n            try {\n              let parsedSources = stepState.output\n              if (typeof stepState.output === 'string') {\n                // Try to extract JSON from the LLM response\n                const jsonMatch = stepState.output.match(/\\{[\\s\\S]*\\}/)\n                if (jsonMatch) {\n                  parsedSources = JSON.parse(jsonMatch[0])\n                }\n              }\n              // Only set if it's a valid sources config object\n              if (parsedSources && typeof parsedSources === 'object' &&\n                  ('reddit' in parsedSources || 'thematic_forums' in parsedSources || 'general_forums' in parsedSources)) {\n                context.sources = parsedSources\n              }\n            } catch (e) {\n              console.error('[buildPlaybookContext] Error parsing sources output:', e)\n              // Don't set context.sources - let it use default values\n            }\n          }\n\n          // Special case: Extract keyword_config unified output for SearchWithPreviewStep\n          // The unified panel saves data in two formats:\n          // 1. lifeContexts, needWords, indicators as arrays of objects (for UI)\n          // 2. life_contexts, product_words, indicators as arrays of strings (for SERP job)\n          if (stepState.id === 'keyword_config' && stepState.output) {\n            const output = stepState.output as {\n              // Object arrays (for UI state)\n              lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n              needWords?: Array<{ id: string; label: string; selected: boolean }>\n              indicators?: Array<{ id: string; label: string; selected: boolean }>\n              // String arrays (pre-extracted for SERP job)\n              life_contexts?: string[]\n              product_words?: string[]\n              sources?: {\n                reddit_general?: { enabled: boolean }\n                reddit?: { enabled: boolean; subreddits?: string[] }\n                thematic_forums?: { enabled: boolean; forums?: string[] }\n                general_forums?: { enabled: boolean; forums?: string[] }\n              }\n            }\n\n            // First try to use pre-extracted string arrays (set on completion)\n            if (output.life_contexts && Array.isArray(output.life_contexts)) {\n              context.life_contexts = output.life_contexts\n            } else if (output.lifeContexts) {\n              // Fall back to extracting from object array\n              context.life_contexts = output.lifeContexts\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            // Check multiple possible keys for need words\n            if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n              context.need_words = output.product_words\n              console.log('[buildPlaybookContext] Got need_words from product_words:', output.product_words)\n            } else if ((output as any).need_words && Array.isArray((output as any).need_words) && (output as any).need_words.length > 0) {\n              // Also check for 'need_words' key (alternative naming)\n              context.need_words = (output as any).need_words\n              console.log('[buildPlaybookContext] Got need_words from need_words key:', (output as any).need_words)\n            } else if (output.needWords && Array.isArray(output.needWords)) {\n              const extracted = output.needWords\n                .filter(item => item.selected)\n                .map(item => item.label)\n              if (extracted.length > 0) {\n                context.need_words = extracted\n                console.log('[buildPlaybookContext] Got need_words from needWords (selected):', extracted)\n              } else {\n                console.warn('[buildPlaybookContext] needWords array exists but no items selected:', output.needWords)\n              }\n            } else {\n              console.warn('[buildPlaybookContext] Could not find need_words in output:', {\n                hasProductWords: !!output.product_words,\n                productWordsLength: output.product_words?.length,\n                hasNeedWords: !!(output as any).need_words,\n                hasNeedWordsArray: !!output.needWords,\n                outputKeys: Object.keys(output),\n              })\n            }\n\n            if (output.indicators && Array.isArray(output.indicators) && typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else if (output.indicators && Array.isArray(output.indicators)) {\n              context.indicators = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            if (output.sources) {\n              context.sources = output.sources\n            }\n\n            // DEBUG: Log what we extracted from keyword_config\n            console.log('[buildPlaybookContext] Extracted from keyword_config:', {\n              life_contexts: context.life_contexts,\n              need_words: context.need_words,\n              indicators: context.indicators,\n              sources: context.sources,\n            })\n          }\n        }\n\n        // IMPORTANT: Extract serpJobId even from non-completed steps (e.g., after cancel)\n        // This allows review_and_scrape to show URLs from a cancelled SERP job\n        if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also check review_and_scrape for non-completed steps (e.g., in progress or cancelled)\n        if (stepState.id === 'review_and_scrape' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also extract serpJobId from scrape_results step (for extraction step)\n        if (stepState.id === 'scrape_results' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // IMPORTANT: Also extract keyword_config data even if step is not 'completed'\n        // This ensures retry/navigation doesn't lose the config\n        if (stepState.id === 'keyword_config' && stepState.output && !context.life_contexts) {\n          console.log('[buildPlaybookContext] Extracting keyword_config from non-completed step')\n          const output = stepState.output as {\n            lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n            needWords?: Array<{ id: string; label: string; selected: boolean }>\n            indicators?: Array<{ id: string; label: string; selected: boolean }>\n            life_contexts?: string[]\n            product_words?: string[]\n            sources?: Record<string, unknown>\n          }\n\n          if (output.life_contexts && Array.isArray(output.life_contexts) && output.life_contexts.length > 0) {\n            context.life_contexts = output.life_contexts\n          } else if (output.lifeContexts) {\n            const extracted = output.lifeContexts.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.life_contexts = extracted\n            }\n          }\n\n          if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n            context.need_words = output.product_words\n          } else if (output.needWords) {\n            const extracted = output.needWords.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.need_words = extracted\n            }\n          }\n\n          if (output.indicators && Array.isArray(output.indicators) && output.indicators.length > 0) {\n            if (typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else {\n              const extracted = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected).map(item => item.label)\n              if (extracted.length > 0) {\n                context.indicators = extracted\n              }\n            }\n          }\n\n          if (output.sources && !context.sources) {\n            context.sources = output.sources\n          }\n\n          console.log('[buildPlaybookContext] Extracted from non-completed keyword_config:', {\n            life_contexts: context.life_contexts,\n            need_words: context.need_words,\n          })\n        }\n      }\n    }\n\n    // DEBUG: Log final context\n    console.log('[buildPlaybookContext] Final context:', {\n      life_contexts: context.life_contexts,\n      need_words: context.need_words,\n      indicators: context.indicators,\n      sources: context.sources,\n      serpJobId: context.serpJobId,\n    })\n\n    return context\n  }\n\n  // Get current phase and step definitions\n  const currentPhase = playbookConfig.phases[state.currentPhaseIndex]\n  const currentStep = currentPhase?.steps[state.currentStepIndex]\n  const currentStepState = state.phases[state.currentPhaseIndex]?.steps[state.currentStepIndex]\n\n  // Calculate navigation bounds\n  const isFirstStep = state.currentPhaseIndex === 0 && state.currentStepIndex === 0\n  const isLastStep =\n    state.currentPhaseIndex === playbookConfig.phases.length - 1 &&\n    state.currentStepIndex === currentPhase.steps.length - 1\n\n  // Navigate to a specific step\n  const goToStep = useCallback((phaseIndex: number, stepIndex: number) => {\n    // Save current state immediately before navigating (don't wait for debounce)\n    if (shouldSaveRef.current && selectedCampaignId) {\n      // Clear pending debounced save\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n        saveTimeoutRef.current = null\n      }\n      // Save current state synchronously\n      savePlaybookState(state)\n    }\n\n    setState(prev => ({\n      ...prev,\n      currentPhaseIndex: phaseIndex,\n      currentStepIndex: stepIndex,\n    }))\n  }, [selectedCampaignId, state, savePlaybookState])\n\n  // Go to next step\n  const goToNextStep = useCallback(() => {\n    setState(prev => {\n      const currentPhase = playbookConfig.phases[prev.currentPhaseIndex]\n\n      // Check if there's a next step in current phase\n      if (prev.currentStepIndex < currentPhase.steps.length - 1) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex + 1,\n        }\n      }\n\n      // Check if there's a next phase\n      if (prev.currentPhaseIndex < playbookConfig.phases.length - 1) {\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex + 1,\n          currentStepIndex: 0,\n        }\n      }\n\n      // Already at the end\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Go to previous step\n  const goToPreviousStep = useCallback(() => {\n    setState(prev => {\n      // Check if there's a previous step in current phase\n      if (prev.currentStepIndex > 0) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex - 1,\n        }\n      }\n\n      // Check if there's a previous phase\n      if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex - 1,\n          currentStepIndex: prevPhase.steps.length - 1,\n        }\n      }\n\n      // Already at the beginning\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Re-run the previous step (go back and reset its state to pending)\n  const rerunPreviousStep = useCallback(() => {\n    setState(prev => {\n      let newPhaseIndex = prev.currentPhaseIndex\n      let newStepIndex = prev.currentStepIndex\n\n      // Find previous step\n      if (prev.currentStepIndex > 0) {\n        newStepIndex = prev.currentStepIndex - 1\n      } else if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        newPhaseIndex = prev.currentPhaseIndex - 1\n        newStepIndex = prevPhase.steps.length - 1\n      } else {\n        // Already at the beginning, nothing to rerun\n        return prev\n      }\n\n      // Get the previous step ID\n      const prevStepId = playbookConfig.phases[newPhaseIndex].steps[newStepIndex].id\n\n      // Reset the previous step state to pending and navigate to it\n      const newPhases = prev.phases.map((phase, pi) => ({\n        ...phase,\n        steps: phase.steps.map((step, si) => {\n          if (pi === newPhaseIndex && si === newStepIndex) {\n            return {\n              ...step,\n              status: 'pending' as const,\n              output: undefined,\n              error: undefined,\n            }\n          }\n          return step\n        }),\n      }))\n\n      return {\n        ...prev,\n        phases: newPhases,\n        currentPhaseIndex: newPhaseIndex,\n        currentStepIndex: newStepIndex,\n      }\n    })\n    // Trigger auto-execute after navigating\n    setShouldAutoExecute(true)\n  }, [playbookConfig.phases])\n\n  // Update step state\n  const updateStepState = useCallback(\n    (stepId: string, update: Partial<StepState>) => {\n      console.log('[updateStepState] Updating step:', stepId, 'with:', {\n        ...update,\n        output: update.output ? `[output with keys: ${Object.keys(update.output as object).join(', ')}]` : undefined,\n      })\n\n      // Persist step changes to database (if sessionId is provided)\n      if (sessionId) {\n        // Handle status-specific persistence\n        if (update.status === 'in_progress') {\n          stepPersistenceActions.markStepRunning(stepId, update.input)\n        } else if (update.status === 'completed') {\n          stepPersistenceActions.markStepCompleted(stepId, update.output)\n        } else if (update.status === 'error') {\n          stepPersistenceActions.markStepFailed(stepId, update.error || 'Unknown error')\n        } else if (update.output !== undefined) {\n          // For output-only updates (during execution), schedule auto-save\n          stepPersistenceActions.scheduleAutoSave(stepId, update.output)\n        }\n      }\n\n      setState(prev => {\n        // Find the current step to log what we're merging\n        const currentStep = prev.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n        if (stepId === 'keyword_config') {\n          console.log('[updateStepState] keyword_config before merge:', {\n            status: currentStep?.status,\n            hasOutput: !!currentStep?.output,\n            outputKeys: currentStep?.output ? Object.keys(currentStep.output as object) : [],\n          })\n        }\n\n        const newPhases = prev.phases.map(phase => ({\n          ...phase,\n          steps: phase.steps.map(step =>\n            step.id === stepId ? { ...step, ...update } : step\n          ),\n        }))\n\n        // Log the merged result for keyword_config\n        if (stepId === 'keyword_config') {\n          const mergedStep = newPhases.flatMap(p => p.steps).find(s => s.id === stepId)\n          console.log('[updateStepState] keyword_config after merge:', {\n            status: mergedStep?.status,\n            hasOutput: !!mergedStep?.output,\n            outputKeys: mergedStep?.output ? Object.keys(mergedStep.output as object) : [],\n          })\n        }\n\n        // Recalculate phase status\n        newPhases.forEach(phase => {\n          const hasError = phase.steps.some(s => s.status === 'error')\n          const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n          const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n          if (hasError) {\n            phase.status = 'error'\n          } else if (allCompleted) {\n            phase.status = 'completed'\n          } else if (hasInProgress) {\n            phase.status = 'in_progress'\n          } else {\n            phase.status = 'pending'\n          }\n        })\n\n        // Recalculate completed steps\n        const completedSteps = newPhases.reduce(\n          (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n          0\n        )\n\n        return {\n          ...prev,\n          phases: newPhases,\n          completedSteps,\n        }\n      })\n    },\n    [sessionId, stepPersistenceActions]\n  )\n\n  // Execute a step\n  const executeStep = useCallback(\n    async (stepId: string, input?: any) => {\n      console.log('[executeStep] Starting execution for step:', stepId, 'with input:', input)\n\n      const step = playbookConfig.phases\n        .flatMap(p => p.steps)\n        .find(s => s.id === stepId)\n\n      if (!step) {\n        console.error('[executeStep] Step not found:', stepId)\n        return\n      }\n\n      console.log('[executeStep] Found step:', step.id, 'type:', step.type, 'executor:', step.executor, 'jobType:', step.jobType)\n\n      // Mark as in progress\n      updateStepState(stepId, {\n        status: 'in_progress',\n        startedAt: new Date(),\n        input,\n      })\n\n      try {\n        let result: any\n\n        // Special case: Execute extraction from scrape_results step\n        if (step.id === 'scrape_results' && input?.action === 'extract' && input?.jobId) {\n          console.log('[EXTRACT from scrape_results] Starting extraction for job:', input.jobId)\n          const jobId = input.jobId\n\n          updateStepState(stepId, {\n            output: { jobId },\n            progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' },\n            partialResults: { extracted: 0, filtered: 0 },\n          })\n\n          // Get total URLs to extract from job status\n          const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          const statusData = await statusResponse.json()\n          const scrapedUrlCount = statusData.url_counts?.scraped || 0\n          const totalUrls = scrapedUrlCount || statusData.job?.urls_scraped || 0\n          const existingExtractedCount = statusData.job?.niches_extracted || 0\n          const existingFilteredCount = statusData.url_counts?.filtered || 0\n\n          console.log('[EXTRACT] Status check:', {\n            scrapedUrlCount,\n            totalUrls,\n            existingExtractedCount,\n            existingFilteredCount,\n            jobStatus: statusData.job?.status,\n            urlsFailed: statusData.url_counts?.failed || 0,\n          })\n\n          // Check if there's nothing to extract (all URLs failed or filtered)\n          if (scrapedUrlCount === 0 && existingExtractedCount === 0) {\n            const failedCount = statusData.url_counts?.failed || 0\n            console.log('[EXTRACT] No URLs to extract and no existing results. Failed:', failedCount, 'Filtered:', existingFilteredCount)\n\n            // Show error state - nothing to extract\n            updateStepState(stepId, {\n              status: 'error',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: 0,\n                filteredCount: existingFilteredCount,\n                error: failedCount > 0\n                  ? `El scraping falló para ${failedCount} URLs (posible bloqueo de Reddit API). No hay contenido disponible para extraer.`\n                  : 'No hay URLs disponibles para extraer. Verifica que el scraping se completó correctamente.',\n              },\n              progress: undefined,\n            })\n\n            return // Stop - nothing to do\n          }\n\n          // Check if extraction was already done (no URLs to process but results exist)\n          if (scrapedUrlCount === 0 && existingExtractedCount > 0) {\n            console.log('[EXTRACT] Extraction already completed, using existing results')\n            updateStepState(stepId, {\n              progress: { current: 100, total: 100, label: `Usando resultados existentes: ${existingExtractedCount} problemas encontrados` },\n            })\n\n            // Skip extraction loop and jump to results fetching\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // Mark scrape_results as completed\n            updateStepState(stepId, {\n              status: 'completed',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: existingExtractedCount,\n                filteredCount: existingFilteredCount,\n              },\n              progress: undefined,\n            })\n\n            // Also update extract_problems step for clean_filter to use\n            console.log('[EXTRACT] Updating extract_problems step with existing CSV results')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,\n              partialResults: {\n                extracted: existingExtractedCount,\n                filtered: existingFilteredCount,\n                successCount: niches.length,\n              }\n            })\n\n            console.log('[EXTRACT] Using existing results:', niches.length, 'problems')\n            return // Don't proceed with new extraction\n          }\n\n          updateStepState(stepId, {\n            progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` },\n          })\n\n          // Call extract endpoint in batches until has_more=false\n          let hasMore = true\n          let extractedTotal = 0\n          let filteredTotal = 0\n          let processedTotal = 0\n\n          while (hasMore) {\n            try {\n              const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout)\n              const contentType = extractResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                console.error('[EXTRACT] Non-JSON response, polling status...')\n                await new Promise(resolve => setTimeout(resolve, 2000))\n\n                // Check current status\n                const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                const checkData = await checkResponse.json()\n\n                if (checkData.status === 'completed') {\n                  hasMore = false\n                  extractedTotal = checkData.job?.niches_extracted || 0\n                }\n                continue\n              }\n\n              const extractData = await extractResponse.json()\n              console.log('[EXTRACT] Batch response:', extractData)\n\n              if (extractData.error) {\n                throw new Error(extractData.error)\n              }\n\n              extractedTotal += extractData.extracted || 0\n              filteredTotal += extractData.filtered || 0\n              processedTotal = extractedTotal + filteredTotal\n              hasMore = extractData.has_more || false\n\n              updateStepState(stepId, {\n                progress: {\n                  current: processedTotal,\n                  total: totalUrls,\n                  label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                },\n                partialResults: {\n                  extracted: extractedTotal,\n                  filtered: filteredTotal,\n                },\n              })\n            } catch (extractError) {\n              console.error('[EXTRACT] Batch error:', extractError)\n              await new Promise(resolve => setTimeout(resolve, 2000))\n\n              // Check if we should stop\n              const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const checkData = await checkResponse.json()\n              if (checkData.status === 'completed' || checkData.status === 'failed') {\n                hasMore = false\n                if (checkData.status === 'failed') {\n                  throw new Error(checkData.job?.error_message || 'Extraction failed')\n                }\n              }\n            }\n          }\n\n          // Mark as completed\n          updateStepState(stepId, {\n            status: 'completed',\n            completedAt: new Date(),\n            output: {\n              jobId,\n              extractedCount: extractedTotal,\n              filteredCount: filteredTotal,\n            },\n            progress: undefined, // Clear progress\n          })\n\n          console.log('[EXTRACT] Completed! Extracted:', extractedTotal, 'Filtered:', filteredTotal)\n\n          // Save results to Context Lake automatically\n          try {\n            // Get project data (includes client_id)\n            const projectResponse = await fetch(`/api/projects/${projectId}`)\n            const projectData = await projectResponse.json()\n\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // IMPORTANT: Also update extract_problems step so clean_filter can use the results\n            // clean_filter depends on extract_problems, not scrape_results\n            console.log('[EXTRACT] Updating extract_problems step with CSV results for clean_filter')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,  // CSV string that clean_filter will use\n              partialResults: {\n                extracted: extractedTotal,\n                filtered: filteredTotal,\n                successCount: niches.length,\n              }\n            })\n\n            const dateStr = new Date().toISOString().split('T')[0]\n            const campaignSlug = selectedCampaign?.name?.toLowerCase().replace(/\\s+/g, '-') || 'sin-nombre'\n            const projectSlug = projectData.name?.toLowerCase().replace(/\\s+/g, '-') || 'proyecto'\n\n            const documentData = {\n              projectId: projectId,\n              clientId: projectData.client_id,\n              filename: `Niche Finder - ${selectedCampaign?.name || 'Sin nombre'} - ${dateStr}`,\n              category: 'research',\n              content: csvContent,\n              description: `${extractedTotal} problemas extraídos del Niche Finder. ${filteredTotal} URLs filtradas de ${totalUrls} procesadas.`,\n              tags: [\n                `fecha:${dateStr}`,\n                `proyecto:${projectSlug}`,\n                `campaña:${campaignSlug}`,\n                `job:${jobId}`,\n                'niche-finder',\n                'problemas-extraidos'\n              ],\n              folder: `niche-finder/${campaignSlug}`,\n              userId: 'system', // TODO: Get actual user ID from session\n              sourceMetadata: {\n                origin_type: 'flow_step_output',\n                playbook_id: playbookConfig.type || 'niche-finder',\n                playbook_name: playbookConfig.name,\n                campaign_id: selectedCampaignId || '',\n                campaign_name: selectedCampaign?.name || '',\n                campaign_variables: selectedCampaign?.customVariables || {},\n                step_id: 'scrape_results',\n                step_name: 'Extracción de Problemas',\n                step_order: 3,\n                executed_at: new Date().toISOString(),\n                model_used: 'openai/gpt-4o-mini',\n                model_provider: 'openrouter',\n                input_tokens: 0,\n                output_tokens: 0,\n                input_document_ids: [],\n                input_previous_step_ids: ['search_and_preview', 'review_and_scrape'],\n                converted_at: new Date().toISOString(),\n                converted_by: 'system',\n                was_edited_before_conversion: false\n              },\n              sourceCampaignId: selectedCampaignId || '',\n              sourceStepId: 'scrape_results',\n              sourceStepName: 'Extracción de Problemas',\n              sourcePlaybookId: playbookConfig.type\n            }\n\n            const saveResponse = await fetch('/api/documents/from-step-output', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify(documentData)\n            })\n\n            if (saveResponse.ok) {\n              const savedDoc = await saveResponse.json()\n              console.log('[EXTRACT] Results saved to Context Lake:', savedDoc.document?.id)\n            } else {\n              console.error('[EXTRACT] Failed to save to Context Lake:', await saveResponse.text())\n            }\n          } catch (saveError) {\n            console.error('[EXTRACT] Error saving to Context Lake:', saveError)\n            // Don't fail the extraction if saving to Context Lake fails\n          }\n\n          return // Don't fall through to the switch\n        }\n\n        switch (step.executor) {\n          case 'llm':\n            // Build variables including campaign custom_variables (product, target, industry, etc.)\n            const campaignVars = selectedCampaign?.customVariables || {}\n            const stepVariables = {\n              ...Object.fromEntries(\n                Object.entries(campaignVars).map(([k, v]) => [k, String(v ?? '')])\n              ),\n              ...(input || {}),\n            }\n            // Call LLM API\n            const response = await fetch('/api/playbook/execute-step', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({\n                projectId,\n                stepId,\n                playbookType: playbookConfig.type,\n                promptKey: step.promptKey,\n                variables: stepVariables,\n              }),\n            })\n            const data = await response.json()\n            if (!data.success) throw new Error(data.error || 'Error ejecutando paso')\n            result = data.output\n            break\n\n          case 'api':\n            // Call custom API endpoint\n            if (step.apiEndpoint) {\n              // Build payload with previous step outputs and campaign variables\n              const campaignVarsForApi = selectedCampaign?.customVariables || {}\n\n              // Get outputs from previous steps (dependsOn)\n              const previousOutputs: Record<string, unknown> = {}\n              if (step.dependsOn?.length) {\n                for (const depId of step.dependsOn) {\n                  for (const phase of state.phases) {\n                    const depStep = phase.steps.find(s => s.id === depId)\n                    if (depStep?.output) {\n                      previousOutputs[depId] = depStep.output\n                    }\n                  }\n                }\n              }\n\n              // Build scenes array from generate_scenes output (for video-viral generate-clips)\n              let scenes: string[] | undefined\n              if (previousOutputs.generate_scenes) {\n                let scenesOutput = previousOutputs.generate_scenes\n\n                // Parse JSON if output is a string (LLM outputs often come as strings)\n                if (typeof scenesOutput === 'string') {\n                  try {\n                    // Try to extract JSON from the string (might be wrapped in markdown code blocks)\n                    const jsonMatch = scenesOutput.match(/```(?:json)?\\s*(\\{[\\s\\S]*?\\})\\s*```/) ||\n                                     scenesOutput.match(/(\\{[\\s\\S]*\\})/)\n                    if (jsonMatch) {\n                      scenesOutput = JSON.parse(jsonMatch[1])\n                    }\n                  } catch (e) {\n                    console.error('[executeStep] Failed to parse generate_scenes output:', e)\n                  }\n                }\n\n                // Extract scene_1, scene_2, scene_3, etc. from the output\n                if (typeof scenesOutput === 'object' && scenesOutput !== null) {\n                  const scenesRecord = scenesOutput as Record<string, string>\n                  scenes = Object.entries(scenesRecord)\n                    .filter(([key]) => key.startsWith('scene_'))\n                    .sort(([a], [b]) => a.localeCompare(b))\n                    .map(([, value]) => value)\n                  console.log('[executeStep] Extracted scenes:', scenes)\n                }\n              }\n\n              const apiResponse = await fetch(step.apiEndpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                  projectId,\n                  stepId,\n                  input,\n                  ...campaignVarsForApi,\n                  previousOutputs,\n                  scenes, // For generate-clips endpoint\n                }),\n              })\n              const apiData = await apiResponse.json()\n              if (!apiData.success && apiData.error) throw new Error(apiData.error)\n              result = apiData\n            }\n            break\n\n          case 'job':\n            // Job-based execution: create job, execute, poll for status\n            console.log('[executeStep] Executor is JOB, jobType:', step.jobType)\n\n            if (step.jobType === 'niche_finder_serp') {\n              // Check if we have an existing job to resume (from cancelled execution)\n              const currentStepForJob = state.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n              const existingJobId = (currentStepForJob?.output as { jobId?: string })?.jobId\n\n              let jobId: string\n\n              if (existingJobId) {\n                // Resume existing job\n                console.log('[SERP] Resuming existing job:', existingJobId)\n                jobId = existingJobId\n                updateStepState(stepId, { progress: { current: 0, total: 0, label: 'Retomando búsqueda SERP...' } })\n              } else {\n                // Build job config from completed steps OR from input (for search_with_preview)\n                let jobConfig: {\n                  life_contexts: string[]\n                  product_words: string[]\n                  indicators: string[]\n                  sources: { reddit: boolean | { enabled?: boolean; subreddits?: string[] }; thematic_forums: boolean | { enabled?: boolean; forums?: string[] }; general_forums: string[] | { enabled?: boolean; forums?: string[] } }\n                  serp_pages: number\n                  // Campaign metadata for extraction to use correct variables\n                  campaign_id?: string | null\n                  ecp_name?: string\n                  ecp_product?: string\n                  ecp_target?: string\n                  ecp_industry?: string\n                  ecp_category?: string\n                  ecp_country?: string\n                }\n\n                // If input is provided (from SearchWithPreviewPanel), use it directly\n                console.log('[SERP] Input received:', JSON.stringify(input, null, 2))\n\n                if (input && input.life_contexts && input.product_words) {\n                  // Warn if arrays are empty\n                  if (input.life_contexts.length === 0 || input.product_words.length === 0) {\n                    console.warn('[SERP] WARNING: life_contexts or product_words is empty!', {\n                      life_contexts: input.life_contexts,\n                      product_words: input.product_words\n                    })\n                  }\n\n                  jobConfig = {\n                    life_contexts: input.life_contexts,\n                    product_words: input.product_words,\n                    indicators: input.indicators || [],\n                    sources: input.sources || { reddit: true, thematic_forums: false, general_forums: [] },\n                    serp_pages: input.serp_pages || 5,\n                  }\n                } else {\n                  console.log('[SERP] No valid input, falling back to completed steps...')\n                  // Fall back to building from completed steps (legacy flow)\n                  const lifeContextsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'life_contexts')\n                  const needWordsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'need_words')\n                  const indicatorsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'indicators')\n                  const sourcesStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'sources')\n\n                  const selectedContexts = lifeContextsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedNeedWords = needWordsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedIndicators = indicatorsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n\n                  // Parse sources output (can be JSON string from LLM or already parsed object)\n                  let sourcesConfig: { reddit: { enabled: boolean; subreddits: string[] }; thematic_forums: { enabled: boolean; forums: string[] }; general_forums: { enabled: boolean; forums: string[] } } = { reddit: { enabled: true, subreddits: [] }, thematic_forums: { enabled: false, forums: [] }, general_forums: { enabled: false, forums: [] } }\n                  try {\n                    if (sourcesStep?.output) {\n                      // Check if output is already an object (parsed)\n                      if (typeof sourcesStep.output === 'object' && sourcesStep.output !== null) {\n                        sourcesConfig = sourcesStep.output as typeof sourcesConfig\n                      } else if (typeof sourcesStep.output === 'string') {\n                        // Try to extract JSON from string\n                        const jsonMatch = sourcesStep.output.match(/\\{[\\s\\S]*\\}/)\n                        if (jsonMatch) {\n                          sourcesConfig = JSON.parse(jsonMatch[0])\n                        }\n                      }\n                    }\n                  } catch (e) {\n                    console.error('Error parsing sources config:', e)\n                  }\n\n                  // Get campaign variables with proper typing\n                  const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                  jobConfig = {\n                    campaign_id: selectedCampaignId, // CRITICAL: Pass campaign_id so extract uses correct variables\n                    life_contexts: selectedContexts,\n                    product_words: selectedNeedWords,\n                    indicators: selectedIndicators,\n                    sources: sourcesConfig,\n                    serp_pages: (campaignVars?.serp_pages as number) || 5,\n                    // Also pass campaign variables directly in config for reliability\n                    ecp_name: (campaignVars?.company_name as string) || selectedCampaign?.name,\n                    ecp_product: campaignVars?.product as string | undefined,\n                    ecp_target: campaignVars?.target as string | undefined,\n                    ecp_industry: campaignVars?.industry as string | undefined,\n                    ecp_category: campaignVars?.category as string | undefined,\n                    ecp_country: campaignVars?.country as string | undefined,\n                  }\n                }\n\n                console.log('[SERP] Starting job with config:', JSON.stringify(jobConfig, null, 2))\n\n                // 1. Create job\n                const createResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: jobConfig,\n                  }),\n                })\n                const createData = await createResponse.json()\n                console.log('[SERP] Create job response:', createData)\n\n                if (!createData.success) {\n                  throw new Error(createData.error || 'Error creando job')\n                }\n\n                jobId = createData.job_id\n                console.log('[SERP] Job created with ID:', jobId)\n                updateStepState(stepId, { output: { jobId }, progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' } })\n              }\n\n              // 2. Execute SERP job (this will resume from where it left off if job was interrupted)\n              console.log('[SERP] Executing SERP search...')\n              const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout HTML pages)\n              const contentType = serpResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                const text = await serpResponse.text()\n                console.error('[SERP] Non-JSON response:', text.slice(0, 500))\n                // If we got a non-JSON response, the job might still be running in the background\n                // Continue to polling to check status\n                console.log('[SERP] Continuing to poll for job status despite non-JSON response...')\n              } else {\n                const serpData = await serpResponse.json()\n                console.log('[SERP] SERP response:', serpData)\n\n                if (serpData.error) {\n                  // Check if it's a missing API key error\n                  if (serpData.code === 'MISSING_API_KEY') {\n                    throw new Error(`API Key faltante: ${serpData.service}. Configura tu API key en Ajustes > APIs.`)\n                  }\n                  throw new Error(serpData.error)\n                }\n              }\n\n              // 3. Poll for status and auto-resume if needed\n              let isResuming = false\n              let lastCompletedCount = -1 // Track previous poll value\n              let stallCount = 0 // Count consecutive stalls\n              let initialCompleted = -1 // Track initial value when polling started\n\n              // Clear any existing poll interval\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n              }\n\n              pollIntervalRef.current = setInterval(async () => {\n                try {\n                  const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const statusData = await statusResponse.json()\n\n                  const completed = statusData.progress?.serp?.completed || 0\n                  const total = statusData.progress?.serp?.total || 0\n                  const remaining = total - completed\n                  const label = total > 0\n                    ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n                    : 'Iniciando búsqueda SERP...'\n                  updateStepState(stepId, {\n                    progress: {\n                      current: completed,\n                      total: total,\n                      label,\n                    },\n                  })\n\n                  // Track initial value on first poll\n                  if (initialCompleted === -1) {\n                    initialCompleted = completed\n                  }\n\n                  // Auto-resume if job was interrupted (still serp_running but not progressing)\n                  // This handles Vercel timeout scenarios\n                  if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n                    // Check if progress has stalled (same value as PREVIOUS poll)\n                    if (lastCompletedCount === completed && remaining > 0) {\n                      stallCount++\n                      // After 2 consecutive stalls (4+ seconds), OR if no progress since we started polling\n                      const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                      if (stallCount >= 2 || noProgressSinceStart) {\n                        console.log(`[SERP] Job stalled at ${completed}/${total} (stallCount=${stallCount}, initialCompleted=${initialCompleted}), auto-resuming...`)\n                        isResuming = true\n                        stallCount = 0\n                        // Resume the job by calling SERP endpoint again\n                        fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                          .then(res => res.json())\n                          .then(data => {\n                            console.log('[SERP] Resume response:', data)\n                            isResuming = false\n                          })\n                          .catch(err => {\n                            console.error('[SERP] Resume error:', err)\n                            isResuming = false\n                          })\n                      }\n                    } else {\n                      stallCount = 0 // Reset stall count if progress is being made\n                    }\n                  }\n\n                  // Update last completed for next poll comparison\n                  lastCompletedCount = completed\n\n                  // Check if SERP phase is done (includes later states that imply SERP finished)\n                  const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n                  if (serpDone) {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    updateStepState(stepId, {\n                      status: 'completed',\n                      completedAt: new Date(),\n                      output: {\n                        jobId,\n                        urlsFound: statusData.job?.urls_found || 0,\n                        costs: statusData.costs,\n                      },\n                      progress: undefined, // Clear progress to stop spinner\n                    })\n                    setTimeout(goToNextStep, 500)\n                  } else if (statusData.status === 'failed' || statusData.status === 'error') {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    throw new Error(statusData.job?.error_message || 'Job failed')\n                  }\n                } catch (pollError) {\n                  if (pollIntervalRef.current) {\n                    clearInterval(pollIntervalRef.current)\n                    pollIntervalRef.current = null\n                  }\n                  updateStepState(stepId, {\n                    status: 'error',\n                    error: pollError instanceof Error ? pollError.message : 'Error checking job status',\n                  })\n                }\n              }, 2000) // Poll every 2 seconds\n\n              // Don't fall through to the completion logic below\n              return\n            }\n\n            // SCRAPE JOB: Scrape URLs from the SERP results\n            if (step.jobType === 'niche_finder_scrape') {\n              // Get the jobId from the previous step (search_and_preview)\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n              console.log('[SCRAPE] Looking for search_and_preview step:', searchStep)\n              console.log('[SCRAPE] search_and_preview output:', searchStep?.output)\n\n              // Also check for serp_search (legacy step name)\n              const serpStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'serp_search')\n              console.log('[SCRAPE] Looking for serp_search step:', serpStep)\n              console.log('[SCRAPE] serp_search output:', serpStep?.output)\n\n              // Try to get jobId from either step\n              let jobId = (searchStep?.output as { jobId?: string })?.jobId ||\n                          (serpStep?.output as { jobId?: string })?.jobId\n\n              // If still no jobId, try from input (might be passed from ReviewAndScrapePanel)\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n                console.log('[SCRAPE] Got jobId from input:', jobId)\n              }\n\n              if (!jobId) {\n                console.error('[SCRAPE] No jobId found. All steps:', state.phases.flatMap(p => p.steps).map(s => ({ id: s.id, output: s.output })))\n                throw new Error('No se encontró el Job ID del paso de búsqueda')\n              }\n\n              console.log('[SCRAPE] Starting scrape for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando scraping...' }\n              })\n\n              // Get total URLs to scrape\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.urls_found || 0\n\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Scrapeando 0/${totalUrls} URLs...` }\n              })\n\n              // Start scraping - this will scrape in batches\n              let scrapedCount = 0\n              let failedCount = 0\n              let hasMore = true\n\n              while (hasMore) {\n                try {\n                  const scrapeResponse = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = scrapeResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[SCRAPE] Non-JSON response, continuing...')\n                    // Wait a bit and continue polling\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'scrape_done') {\n                      hasMore = false\n                      scrapedCount = checkData.job?.scrape_success_count || 0\n                      failedCount = checkData.job?.scrape_failed_count || 0\n                    }\n                    continue\n                  }\n\n                  const scrapeData = await scrapeResponse.json()\n                  console.log('[SCRAPE] Batch response:', scrapeData)\n\n                  if (scrapeData.error) {\n                    throw new Error(scrapeData.error)\n                  }\n\n                  scrapedCount += scrapeData.scraped || 0\n                  failedCount += scrapeData.failed || 0\n                  hasMore = scrapeData.has_more || false\n\n                  // Update progress with real-time feedback\n                  updateStepState(stepId, {\n                    progress: {\n                      current: scrapedCount + failedCount,\n                      total: totalUrls,\n                      label: `Scrapeando ${scrapedCount + failedCount}/${totalUrls} URLs...`,\n                    },\n                    partialResults: {\n                      successCount: scrapedCount,\n                      failedCount: failedCount,\n                      lastUrl: scrapeData.last_scraped_url,\n                      lastSnippet: scrapeData.last_scraped_snippet,\n                    },\n                  })\n\n                } catch (scrapeError) {\n                  console.error('[SCRAPE] Batch error:', scrapeError)\n                  // Don't throw - try to continue with next batch\n                  // The endpoint will mark failed URLs and continue\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'scrape_done' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Scraping failed')\n                    }\n                  }\n                }\n              }\n\n              // Mark as completed\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  scrapedCount,\n                  failedCount,\n                },\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            if (step.jobType === 'niche_finder_extract') {\n              // Get jobId from previous steps (review_and_scrape or scrape_results)\n              const scrapeResultsStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'scrape_results')\n              const reviewAndScrapeStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'review_and_scrape')\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n\n              console.log('[EXTRACT] Looking for jobId from steps:', {\n                scrape_results: scrapeResultsStep?.output,\n                review_and_scrape: reviewAndScrapeStep?.output,\n                search_and_preview: searchStep?.output,\n              })\n\n              let jobId = (scrapeResultsStep?.output as { jobId?: string })?.jobId ||\n                          (reviewAndScrapeStep?.output as { jobId?: string })?.jobId ||\n                          (searchStep?.output as { jobId?: string })?.jobId\n\n              // Also try from input\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n              }\n\n              if (!jobId) {\n                console.error('[EXTRACT] No jobId found')\n                throw new Error('No se encontró el Job ID. Por favor ejecuta los pasos anteriores primero.')\n              }\n\n              console.log('[EXTRACT] Starting extraction for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' }\n              })\n\n              // Get total URLs to extract from job status\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.scrape_success_count || 0\n\n              console.log('[EXTRACT] Total URLs to process:', totalUrls)\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` }\n              })\n\n              // Call extract endpoint in batches until has_more=false\n              let hasMore = true\n              let extractedTotal = 0\n              let filteredTotal = 0\n              let processedTotal = 0\n\n              while (hasMore) {\n                try {\n                  const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = extractResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[EXTRACT] Non-JSON response, polling status...')\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'completed') {\n                      hasMore = false\n                      extractedTotal = checkData.job?.niches_extracted || 0\n                    }\n                    continue\n                  }\n\n                  const extractData = await extractResponse.json()\n                  console.log('[EXTRACT] Batch response:', extractData)\n\n                  if (extractData.error) {\n                    throw new Error(extractData.error)\n                  }\n\n                  extractedTotal += extractData.extracted || 0\n                  filteredTotal += extractData.filtered || 0\n                  processedTotal = extractedTotal + filteredTotal\n                  hasMore = extractData.has_more || false\n\n                  updateStepState(stepId, {\n                    progress: {\n                      current: processedTotal,\n                      total: totalUrls,\n                      label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                    },\n                    partialResults: {\n                      successCount: extractedTotal,\n                      failedCount: filteredTotal,\n                    },\n                  })\n                } catch (extractError) {\n                  console.error('[EXTRACT] Batch error:', extractError)\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'completed' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Extraction failed')\n                    }\n                  }\n                }\n              }\n\n              // Get extracted problems and format as CSV\n              console.log('[EXTRACT] Getting results from /api/niche-finder/results/', jobId)\n              const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n\n              if (!resultsResponse.ok) {\n                console.error('[EXTRACT] Failed to get results:', resultsResponse.status, resultsResponse.statusText)\n                throw new Error(`Error obteniendo resultados: ${resultsResponse.status}`)\n              }\n\n              const resultsData = await resultsResponse.json()\n              console.log('[EXTRACT] Results data:', {\n                hasNiches: !!resultsData.niches,\n                nichesCount: resultsData.niches?.length || 0,\n                status: resultsData.status,\n                urls: resultsData.urls,\n              })\n\n              // Format niches as CSV string with all relevant columns\n              const niches = resultsData.niches || []\n              let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n              for (const niche of niches) {\n                const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                const url = niche.source_url || ''\n                csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n              }\n\n              console.log('[EXTRACT] Completed. Total problems:', niches.length, 'CSV preview:', csvOutput.substring(0, 200))\n\n              // Mark as completed with CSV output\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: csvOutput,\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            // UNIFIED SEARCH + EXTRACT: Handles both SERP and analysis in one step\n            if (step.jobType === 'niche_finder_unified') {\n              const action = (input as { action?: string })?.action\n\n              // ============ ACTION: SERP ============\n              if (action === 'serp') {\n                const config = (input as { config?: { life_contexts: string[]; product_words: string[]; indicators: string[]; sources: { reddit: boolean; thematic_forums: boolean; general_forums: string[] }; serp_pages: number } }).config\n                if (!config) {\n                  throw new Error('No se recibió configuración para la búsqueda')\n                }\n\n                console.log('[UNIFIED] Starting SERP with config:', config)\n\n                // Get campaign variables\n                const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                // Create the SERP job\n                const jobResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: {\n                      ...config,\n                      campaign_id: selectedCampaignId,\n                      ecp_name: campaignVars?.['ECP Name'] || campaignVars?.ecp_name,\n                      ecp_product: campaignVars?.['ECP Product'] || campaignVars?.ecp_product,\n                      ecp_target: campaignVars?.['ECP Target'] || campaignVars?.ecp_target,\n                      ecp_industry: campaignVars?.['ECP Industry'] || campaignVars?.ecp_industry,\n                      ecp_category: campaignVars?.['ECP Category'] || campaignVars?.ecp_category,\n                      ecp_country: campaignVars?.['ECP Country'] || campaignVars?.ecp_country,\n                    }\n                  }),\n                })\n\n                if (!jobResponse.ok) {\n                  const errorText = await jobResponse.text()\n                  throw new Error(`Error al crear job: ${jobResponse.status} - ${errorText || 'Sin respuesta'}`)\n                }\n\n                const jobText = await jobResponse.text()\n                if (!jobText || jobText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al crear el job')\n                }\n\n                const jobData = JSON.parse(jobText)\n                const jobId = jobData.job_id\n\n                if (!jobId) {\n                  throw new Error('No se pudo crear el job de búsqueda')\n                }\n\n                console.log('[UNIFIED] SERP Job created:', jobId)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'serp_executing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' },\n                })\n\n                // Start SERP execution\n                const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n\n                if (!serpResponse.ok) {\n                  const serpErrorText = await serpResponse.text()\n                  let errorMessage = `Error al iniciar búsqueda SERP: ${serpResponse.status}`\n                  try {\n                    const serpError = JSON.parse(serpErrorText)\n                    if (serpError.code === 'MISSING_API_KEY') {\n                      errorMessage = `${serpError.error}`\n                    } else if (serpError.error) {\n                      errorMessage = serpError.error\n                    }\n                  } catch {\n                    if (serpErrorText) errorMessage += ` - ${serpErrorText}`\n                  }\n                  throw new Error(errorMessage)\n                }\n\n                console.log('[UNIFIED] SERP execution started successfully')\n\n                // Poll for SERP completion\n                let serpComplete = false\n                let pollRetries = 0\n                const MAX_POLL_RETRIES = 3\n                while (!serpComplete) {\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n                  try {\n                    const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n\n                    if (!statusRes.ok) {\n                      console.warn(`[UNIFIED] Status poll failed with ${statusRes.status}`)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error(`Error al consultar estado del job: ${statusRes.status}`)\n                      }\n                      continue\n                    }\n\n                    const text = await statusRes.text()\n                    if (!text || text.trim() === '') {\n                      console.warn('[UNIFIED] Empty response from status endpoint, retrying...')\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('El servidor no está respondiendo correctamente')\n                      }\n                      continue\n                    }\n\n                    const statusData = JSON.parse(text)\n                    pollRetries = 0 // Reset retries on success\n\n                    const urlsFound = statusData.job?.urls_found || 0\n                    // Status API returns serp_total and serp_completed (not total_queries/completed_queries)\n                    const totalSearches = statusData.job?.serp_total || statusData.progress?.serp?.total || 0\n                    const completedSearches = statusData.job?.serp_completed || statusData.progress?.serp?.completed || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: completedSearches,\n                        total: totalSearches,\n                        label: `Buscando... ${urlsFound} URLs encontradas`,\n                      },\n                    })\n\n                    if (['serp_done', 'serp_completed', 'scrape_done', 'completed'].includes(statusData.status)) {\n                      serpComplete = true\n                      console.log('[UNIFIED] SERP completed. URLs found:', urlsFound)\n                      updateStepState(stepId, {\n                        output: { jobId, phase: 'serp_complete', urlsFound },\n                        progress: undefined,\n                      })\n                    } else if (statusData.status === 'failed') {\n                      throw new Error(statusData.job?.error_message || 'SERP falló')\n                    }\n                  } catch (pollError) {\n                    if (pollError instanceof SyntaxError) {\n                      console.warn('[UNIFIED] JSON parse error in poll, retrying...', pollError)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('Error al procesar respuesta del servidor')\n                      }\n                    } else {\n                      throw pollError\n                    }\n                  }\n                }\n                return // Don't mark as completed - wait for analyze action\n              }\n\n              // ============ ACTION: ANALYZE (Scrape + Extract) ============\n              if (action === 'analyze') {\n                const jobId = (input as { jobId?: string }).jobId\n                const selectedSources = (input as { selectedSources?: string[] }).selectedSources || []\n                const extractionPrompt = (input as { extractionPrompt?: string }).extractionPrompt\n\n                if (!jobId) {\n                  throw new Error('No se encontró el Job ID')\n                }\n\n                console.log('[UNIFIED] Starting analysis for job:', jobId, 'sources:', selectedSources, 'custom prompt:', !!extractionPrompt)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'analyzing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando análisis...' },\n                })\n\n                // If a custom extraction prompt was provided, update the job config\n                if (extractionPrompt) {\n                  console.log('[UNIFIED] Updating job with custom extraction prompt')\n                  const updateRes = await fetch(`/api/niche-finder/jobs/${jobId}`, {\n                    method: 'PATCH',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ extraction_prompt: extractionPrompt }),\n                  })\n                  if (!updateRes.ok) {\n                    console.warn('[UNIFIED] Failed to update job with custom prompt:', updateRes.status)\n                  }\n                }\n\n                // Get total URLs to process\n                const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                if (!statusRes.ok) {\n                  throw new Error(`Error al obtener estado del job: ${statusRes.status}`)\n                }\n                const statusText = await statusRes.text()\n                if (!statusText || statusText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al consultar estado')\n                }\n                const statusData = JSON.parse(statusText)\n                const totalUrls = statusData.job?.urls_found || 0\n\n                // Start scraping - call API repeatedly until all URLs are processed\n                console.log('[UNIFIED] Starting scrape for', totalUrls, 'URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: totalUrls, label: 'Descargando contenido...' },\n                })\n\n                let scrapeComplete = false\n                let scrapeRetries = 0\n                let totalScraped = 0\n                let totalFailed = 0\n                const MAX_SCRAPE_RETRIES = 5 // More retries for transient failures\n\n                while (!scrapeComplete) {\n                  try {\n                    console.log(`[UNIFIED] Scrape batch starting, totalScraped=${totalScraped}, retries=${scrapeRetries}`)\n\n                    // Call scrape API with timeout (120s to allow for slow scrapes)\n                    const controller = new AbortController()\n                    const timeout = setTimeout(() => controller.abort(), 120000)\n\n                    const scrapeRes = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                      method: 'POST',\n                      headers: { 'Content-Type': 'application/json' },\n                      body: JSON.stringify({ sources: selectedSources }),\n                      signal: controller.signal,\n                    })\n                    clearTimeout(timeout)\n\n                    if (!scrapeRes.ok) {\n                      const errorText = await scrapeRes.text().catch(() => '')\n                      console.error(`[UNIFIED] Scrape response not ok: ${scrapeRes.status}`, errorText)\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(`Error en scraping: ${scrapeRes.status} - ${errorText || 'Unknown error'}`)\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeText = await scrapeRes.text()\n                    if (!scrapeText) {\n                      console.warn('[UNIFIED] Empty scrape response, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Respuesta vacía del servidor después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeData = JSON.parse(scrapeText)\n                    scrapeRetries = 0 // Reset on successful response\n\n                    if (scrapeData.error) {\n                      // Check if it's a retryable error\n                      if (scrapeData.error.includes('Rate limit') || scrapeData.error.includes('timeout')) {\n                        console.warn(`[UNIFIED] Retryable scrape error: ${scrapeData.error}`)\n                        scrapeRetries++\n                        if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(scrapeData.error)\n                        await new Promise(r => setTimeout(r, 5000))\n                        continue\n                      }\n                      throw new Error(scrapeData.error)\n                    }\n\n                    // Update progress with scraped count from this batch\n                    totalScraped += scrapeData.scraped || 0\n                    totalFailed += scrapeData.failed || 0\n                    const remaining = scrapeData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: totalScraped,\n                        total: totalUrls,\n                        label: `Descargando... ${totalScraped}/${totalUrls} URLs${totalFailed > 0 ? ` (${totalFailed} fallidas)` : ''}`,\n                      },\n                      partialResults: {\n                        successCount: totalScraped,\n                        failedCount: totalFailed,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Scrape batch complete: +${scrapeData.scraped} scraped, ${remaining} remaining, has_more: ${scrapeData.has_more}`)\n\n                    // Check if scraping is complete\n                    if (!scrapeData.has_more || remaining === 0) {\n                      scrapeComplete = true\n                    }\n                  } catch (e) {\n                    console.error('[UNIFIED] Scrape error:', e)\n                    if (e instanceof SyntaxError) {\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 3000))\n                    } else if (e instanceof Error && e.name === 'AbortError') {\n                      // Timeout - retry with longer wait\n                      console.warn('[UNIFIED] Scrape request timed out, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Timeout en scraping después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 5000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Scraping complete, total scraped:', totalScraped)\n\n                // Start extraction - use totalScraped as the base since only scraped URLs can be extracted\n                const extractionTotal = totalScraped || totalUrls // Fallback to totalUrls if scraping tracked differently\n                console.log('[UNIFIED] Starting extraction for', extractionTotal, 'scraped URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: extractionTotal, label: 'Extrayendo problemas...' },\n                })\n\n                let extractComplete = false\n                let extractedTotal = 0\n                let filteredTotal = 0\n                let extractRetries = 0\n\n                while (!extractComplete) {\n                  try {\n                    const extractRes = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, { method: 'POST' })\n                    if (!extractRes.ok) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error(`Error en extracción: ${extractRes.status}`)\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const text = await extractRes.text()\n                    if (!text) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Respuesta vacía del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const extractData = JSON.parse(text)\n                    extractRetries = 0\n\n                    if (extractData.error) {\n                      throw new Error(extractData.error)\n                    }\n\n                    extractedTotal += extractData.extracted || 0\n                    filteredTotal += extractData.filtered || 0\n                    const processed = extractedTotal + filteredTotal\n                    const remaining = extractData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: processed,\n                        total: extractionTotal,\n                        label: `Extrayendo... ${extractedTotal} problemas de ${processed}/${extractionTotal} URLs${filteredTotal > 0 ? ` (${filteredTotal} filtradas)` : ''}`,\n                      },\n                      partialResults: {\n                        extracted: extractedTotal,\n                        filtered: filteredTotal,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Extract batch: ${extractData.extracted} extracted, ${extractData.filtered} filtered, ${remaining} remaining, has_more: ${extractData.has_more}`)\n\n                    if (!extractData.has_more || remaining === 0) {\n                      extractComplete = true\n                    }\n                  } catch (e) {\n                    if (e instanceof SyntaxError) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Extraction complete. Problems:', extractedTotal, 'Filtered:', filteredTotal)\n\n                // Get results and format as CSV\n                console.log('[UNIFIED] Getting results')\n                const resultsRes = await fetch(`/api/niche-finder/results/${jobId}`)\n                if (!resultsRes.ok) {\n                  throw new Error(`Error al obtener resultados: ${resultsRes.status}`)\n                }\n                const resultsText = await resultsRes.text()\n                const resultsData = resultsText ? JSON.parse(resultsText) : { niches: [] }\n                const niches = resultsData.niches || []\n\n                let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n                for (const niche of niches) {\n                  const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                  const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                  const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                  const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                  const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                  const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                  const url = niche.source_url || ''\n                  csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n                }\n\n                console.log('[UNIFIED] Complete. Problems:', niches.length)\n                updateStepState(stepId, {\n                  status: 'completed',\n                  completedAt: new Date(),\n                  output: { jobId, extractedCount: niches.length, csv: csvOutput },\n                })\n                setTimeout(goToNextStep, 500)\n                return\n              }\n\n              // Unknown action\n              console.warn('[UNIFIED] Unknown action:', action)\n            }\n\n            // For other job types, just mark as pending\n            result = input\n            break\n\n          case 'none':\n          default:\n            // No execution needed, just proceed\n            result = input\n            break\n        }\n\n        // Mark as completed\n        updateStepState(stepId, {\n          status: 'completed',\n          completedAt: new Date(),\n          output: result,\n        })\n\n        // Auto-advance for auto steps\n        if (['auto', 'auto_with_review'].includes(step.type)) {\n          setTimeout(goToNextStep, 500)\n        }\n      } catch (error) {\n        updateStepState(stepId, {\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Error desconocido',\n        })\n      }\n    },\n    [projectId, playbookConfig.type, playbookConfig.phases, updateStepState, goToNextStep, selectedCampaign, state.phases]\n  )\n\n  // Handle continue from current step\n  const handleContinue = useCallback(() => {\n    console.log('[handleContinue] Called for step:', currentStep?.id, 'current status:', currentStepState?.status)\n    // Note: Don't update step state here if the caller (WorkArea) already updated it.\n    // The caller is responsible for setting status and output correctly before calling onContinue.\n    // We only set completedAt if not already completed, and we do it in a way that preserves output.\n    if (currentStepState?.status !== 'completed') {\n      console.log('[handleContinue] Status is not completed, updating step state (without output)')\n      // Mark as completed, but preserve any existing output that might have been set\n      // by the caller in the same tick (before React re-renders)\n      updateStepState(currentStep.id, {\n        status: 'completed',\n        completedAt: new Date(),\n        // Don't set output - it should already be set by the caller\n      })\n    } else {\n      console.log('[handleContinue] Status is already completed, not updating')\n    }\n    // Enable auto-execution for the next step (if it's an auto step)\n    setShouldAutoExecute(true)\n    goToNextStep()\n  }, [currentStep?.id, currentStepState?.status, updateStepState, goToNextStep])\n\n  // Handle edit - volver a editar un paso completado\n  const handleEdit = useCallback(() => {\n    if (!currentStep) return\n    // Cambiar status a pending sin perder los datos (suggestions, output, etc.)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      completedAt: undefined,\n      error: undefined,\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle cancel - cancelar ejecución en curso\n  // IMPORTANTE: Mantiene el output (jobId) para poder retomar el job\n  const handleCancel = useCallback(() => {\n    if (!currentStep) return\n\n    // Clear polling interval if running\n    if (pollIntervalRef.current) {\n      clearInterval(pollIntervalRef.current)\n      pollIntervalRef.current = null\n      console.log('[Cancel] Cleared polling interval')\n    }\n\n    // Volver a pending y limpiar progreso, pero MANTENER output (contiene jobId)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      progress: undefined,\n      error: undefined,\n      // NO limpiamos output para mantener el jobId y poder retomar\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle quick retry - retry with same configuration\n  const handleQuickRetry = useCallback(async () => {\n    if (!currentStep || !currentStepState) return\n\n    console.log('[Retry] Quick retry for step:', currentStep.id)\n\n    // Start a new retry attempt\n    try {\n      await stepRetryActions.startRetry(currentStep.id)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Reset step state and re-execute\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input\n    executeStep(currentStep.id, currentStepState.input)\n  }, [currentStep, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle retry with config modification - opens dialog\n  const handleRetryWithConfig = useCallback(() => {\n    if (!currentStep) return\n    setRetryDialogStepId(currentStep.id)\n    setRetryDialogOpen(true)\n  }, [currentStep])\n\n  // Handle retry from dialog with config overrides\n  const handleRetryFromDialog = useCallback(async (configOverrides?: StepAttemptConfig) => {\n    if (!retryDialogStepId || !currentStepState) return\n\n    console.log('[Retry] Retry from dialog for step:', retryDialogStepId, 'with config:', configOverrides)\n\n    // Start a new retry attempt with config\n    try {\n      await stepRetryActions.startRetry(retryDialogStepId, configOverrides)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Close dialog\n    setRetryDialogOpen(false)\n    setRetryDialogStepId(null)\n\n    // Reset step state\n    updateStepState(retryDialogStepId, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input (config overrides are tracked in the attempt)\n    executeStep(retryDialogStepId, currentStepState.input)\n  }, [retryDialogStepId, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle skip step - mark as skipped and continue\n  const handleSkipStep = useCallback(() => {\n    if (!currentStep) return\n\n    console.log('[Skip] Skipping step:', currentStep.id)\n\n    updateStepState(currentStep.id, {\n      status: 'skipped',\n      completedAt: new Date(),\n      error: undefined,\n    })\n\n    // Move to next step\n    handleContinue()\n  }, [currentStep, updateStepState, handleContinue])\n\n  // Get retry info for current step\n  const currentStepRetryInfo = currentStep\n    ? stepRetryActions.getRetryInfo(currentStep.id)\n    : null\n\n  // Check if max retries reached\n  const maxRetriesReached = currentStepRetryInfo\n    ? currentStepRetryInfo.attemptNumber >= currentStepRetryInfo.maxAttempts\n    : false\n\n  // Auto-start current step if it's an auto step, pending, AND user clicked Continue\n  useEffect(() => {\n    console.log('[AutoExecute] Check:', {\n      shouldAutoExecute,\n      currentStepId: currentStep?.id,\n      currentStepType: currentStep?.type,\n      currentStepStatus: currentStepState?.status,\n    })\n    if (\n      shouldAutoExecute &&\n      currentStep &&\n      currentStepState?.status === 'pending' &&\n      ['auto'].includes(currentStep.type)\n    ) {\n      console.log('[AutoExecute] Starting auto execution for:', currentStep.id)\n      // Reset the flag\n      setShouldAutoExecute(false)\n      // Small delay to allow UI to render first\n      const timer = setTimeout(() => {\n        executeStep(currentStep.id)\n      }, 300)\n      return () => clearTimeout(timer)\n    }\n  }, [shouldAutoExecute, currentStep, currentStepState?.status, executeStep])\n\n  // Resume polling for in_progress steps on page reload\n  // This handles the case where user refreshes the page while a SERP job is running\n  useEffect(() => {\n    // Only for search_with_preview steps that are in_progress with a jobId\n    if (\n      currentStep?.type === 'search_with_preview' &&\n      (currentStepState?.status === 'in_progress' || currentStepState?.status === 'pending') &&\n      currentStepState?.output &&\n      !pollIntervalRef.current\n    ) {\n      const output = currentStepState.output as { jobId?: string }\n      const jobId = output.jobId\n\n      if (jobId) {\n        console.log('[Resume] Resuming polling for job:', jobId)\n\n        // First, check if job is already done (immediate check, not polling)\n        fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          .then(res => res.json())\n          .then(statusData => {\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDone) {\n              console.log('[Resume] Job already completed, marking step as done')\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n              return // Don't start polling\n            }\n            // If not done, continue with normal polling setup below\n            startPolling()\n          })\n          .catch(err => {\n            console.error('[Resume] Error checking initial status:', err)\n            startPolling() // Start polling anyway\n          })\n\n        function startPolling() {\n          if (pollIntervalRef.current) return // Already polling\n\n          // Set up polling - same logic as in executeStep\n          let isResuming = false\n          let lastCompletedCount = -1\n          let stallCount = 0\n          let initialCompleted = -1\n\n          pollIntervalRef.current = setInterval(async () => {\n          try {\n            const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n            const statusData = await statusResponse.json()\n\n            const completed = statusData.progress?.serp?.completed || 0\n            const total = statusData.progress?.serp?.total || 0\n            const remaining = total - completed\n            const label = total > 0\n              ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n              : 'Reconectando...'\n\n            updateStepState(currentStep.id, {\n              progress: {\n                current: completed,\n                total: total,\n                label,\n              },\n            })\n\n            // Track initial value on first poll\n            if (initialCompleted === -1) {\n              initialCompleted = completed\n              console.log('[Resume] Initial completed:', initialCompleted)\n            }\n\n            // Auto-resume if job was interrupted\n            if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n              if (lastCompletedCount === completed && remaining > 0) {\n                stallCount++\n                const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                if (stallCount >= 2 || noProgressSinceStart) {\n                  console.log(`[Resume] Job stalled at ${completed}/${total}, auto-resuming...`)\n                  isResuming = true\n                  stallCount = 0\n                  fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                    .then(res => res.json())\n                    .then(data => {\n                      console.log('[Resume] Resume response:', data)\n                      isResuming = false\n                    })\n                    .catch(err => {\n                      console.error('[Resume] Resume error:', err)\n                      isResuming = false\n                    })\n                }\n              } else {\n                stallCount = 0\n              }\n            }\n            lastCompletedCount = completed\n\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDoneInPoll = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDoneInPoll) {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n            } else if (statusData.status === 'failed' || statusData.status === 'error') {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'error',\n                error: statusData.job?.error_message || 'Job failed',\n              })\n            }\n          } catch (pollError) {\n            console.error('[Resume] Poll error:', pollError)\n            // Don't stop polling on transient errors\n          }\n        }, 2000)\n        } // End startPolling function\n\n        // Cleanup on unmount\n        return () => {\n          if (pollIntervalRef.current) {\n            clearInterval(pollIntervalRef.current)\n            pollIntervalRef.current = null\n          }\n        }\n      }\n    }\n  }, [currentStep?.id, currentStep?.type, currentStepState?.status, currentStepState?.output, updateStepState, goToNextStep])\n\n  if (!currentPhase || !currentStep || !currentStepState) {\n    return (\n      <div className=\"flex items-center justify-center h-64 text-gray-500\">\n        Error: Configuración de playbook inválida\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n      {/* Header with mode selector */}\n      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3\">\n          <span className=\"text-xl\">{playbookConfig.icon}</span>\n          <h2 className=\"text-lg font-semibold text-gray-900\">{playbookConfig.name}</h2>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}\n          <div className=\"relative flex items-center gap-1\">\n            <button\n              onClick={() => {\n                setMode('campaign')\n                setShowCampaignDropdown(!showCampaignDropdown)\n              }}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                mode === 'campaign'\n                  ? 'bg-blue-100 text-blue-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Folder size={16} />\n              {selectedCampaign ? selectedCampaign.name : 'Seleccionar Campaña'}\n              <ChevronDown size={16} />\n            </button>\n\n            {/* Edit campaign settings button */}\n            {selectedCampaignId && (\n              <button\n                onClick={() => setShowCampaignSettings(true)}\n                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg\"\n                title=\"Editar configuración de campaña\"\n              >\n                <Pencil size={14} />\n              </button>\n            )}\n\n            {/* Dropdown */}\n            {showCampaignDropdown && (\n              <div className=\"absolute right-0 top-full mt-1 w-64 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50\">\n                {campaigns.length === 0 ? (\n                  <div className=\"px-3 py-2 text-sm text-gray-500\">No hay campañas</div>\n                ) : (\n                  campaigns.map(campaign => (\n                    <div\n                      key={campaign.id}\n                      className={`flex items-center justify-between px-3 py-2 text-sm hover:bg-gray-50 ${\n                        selectedCampaignId === campaign.id ? 'bg-blue-50' : ''\n                      }`}\n                    >\n                      <button\n                        onClick={() => {\n                          setSelectedCampaignId(campaign.id)\n                          setShowCampaignDropdown(false)\n                        }}\n                        className=\"flex-1 flex items-center justify-between text-left\"\n                      >\n                        <span className=\"font-medium text-gray-900\">{campaign.name}</span>\n                        <span className=\"text-gray-500 mr-2\">\n                          {campaign.completedSteps}/{campaign.totalSteps}\n                        </span>\n                      </button>\n                      <button\n                        onClick={(e) => {\n                          e.stopPropagation()\n                          deleteCampaign(campaign.id)\n                        }}\n                        className=\"p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded\"\n                        title=\"Eliminar campaña\"\n                      >\n                        <Trash2 size={14} />\n                      </button>\n                    </div>\n                  ))\n                )}\n                <div className=\"border-t border-gray-100 mt-1 pt-1\">\n                  <button\n                    onClick={() => {\n                      setShowWizard(true)\n                      setShowCampaignDropdown(false)\n                    }}\n                    className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-blue-600 hover:bg-blue-50\"\n                  >\n                    <Plus size={16} />\n                    Nueva Campaña\n                  </button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Main content */}\n      {mode === 'config' ? (\n        /* Configuration Mode - Full width */\n        <div className=\"flex-1 overflow-hidden\">\n          <ConfigurationMode\n            projectId={projectId}\n            playbookConfig={playbookConfig}\n            onSave={() => {\n              // Optionally refresh something after save\n            }}\n          />\n        </div>\n      ) : (\n        /* Campaign Mode - Dual panel */\n        <div className=\"flex flex-1 overflow-hidden\">\n          {/* Navigation Panel - Left side */}\n          <div className=\"w-80 flex-shrink-0\">\n            <NavigationPanel\n              phases={playbookConfig.phases}\n              phaseStates={state.phases}\n              currentPhaseIndex={state.currentPhaseIndex}\n              currentStepIndex={state.currentStepIndex}\n              onStepClick={goToStep}\n            />\n          </div>\n\n          {/* Work Area - Right side */}\n          <div className=\"flex-1 overflow-y-auto\">\n            {!selectedCampaignId ? (\n              /* No campaign selected - prompt to select or create */\n              <div className=\"flex flex-col items-center justify-center h-full bg-white p-8 text-center\">\n                <Folder className=\"text-gray-300 mb-4\" size={64} />\n                <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                  Selecciona o crea una campaña\n                </h3>\n                <p className=\"text-gray-500 mb-6 max-w-md\">\n                  Para ejecutar el playbook, primero debes seleccionar una campaña existente o crear una nueva.\n                </p>\n                <button\n                  onClick={() => setShowWizard(true)}\n                  className=\"flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n                >\n                  <Plus size={16} />\n                  Nueva Campaña\n                </button>\n              </div>\n            ) : (\n              <>\n                <WorkArea\n                  step={currentStep}\n                  stepState={currentStepState}\n                  onContinue={handleContinue}\n                  onBack={goToPreviousStep}\n                  onExecute={(input) => executeStep(currentStep.id, input)}\n                  onUpdateState={(update) => updateStepState(currentStep.id, update)}\n                  onEdit={handleEdit}\n                  onCancel={handleCancel}\n                  onRerunPrevious={rerunPreviousStep}\n                  onRetry={handleQuickRetry}\n                  onRetryWithConfig={handleRetryWithConfig}\n                  onSkipStep={handleSkipStep}\n                  isFirst={isFirstStep}\n                  isLast={isLastStep}\n                  previousStepOutput={getPreviousStepOutput()}\n                  projectId={projectId}\n                  playbookContext={buildPlaybookContext()}\n                  allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                    phase.steps.map((stepDef, stepIdx) => ({\n                      definition: stepDef,\n                      state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                    }))\n                  )}\n                  saveState={sessionId ? stepPersistenceState : undefined}\n                  retryInfo={currentStepRetryInfo || undefined}\n                  maxRetriesReached={maxRetriesReached}\n                  sessionId={sessionId}\n                />\n\n                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Campaign Wizard Modal */}\n      {showWizard && (\n        <CampaignWizard\n          projectId={projectId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowWizard(false)}\n          onCreated={(campaignId) => {\n            setSelectedCampaignId(campaignId)\n            setShowWizard(false)\n            // Reload campaigns\n            loadCampaigns()\n          }}\n        />\n      )}\n\n      {/* Campaign Settings Modal */}\n      {showCampaignSettings && selectedCampaignId && (\n        <CampaignSettings\n          campaignId={selectedCampaignId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowCampaignSettings(false)}\n          onSaved={() => {\n            loadCampaigns()\n          }}\n        />\n      )}\n    </div>\n  )\n}\n","structuredPatch":[{"oldStart":2623,"oldLines":6,"newStart":2623,"newLines":22,"lines":["         </div>"," ","         <div className=\"flex items-center gap-2\">","+          {/* Session Data button */}","+          {selectedCampaignId && mode === 'campaign' && (","+            <button","+              onClick={() => setShowArtifactBrowser(!showArtifactBrowser)}","+              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${","+                showArtifactBrowser","+                  ? 'bg-indigo-100 text-indigo-700'","+                  : 'text-gray-600 hover:bg-gray-100'","+              }`}","+              title=\"Browse all session artifacts\"","+            >","+              <Database size={16} />","+              Session Data","+            </button>","+          )}","+","           {/* Config Base button */}","           <button","             onClick={() => setMode('config')}"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TqLCPsLXMWJKfkqmjUzwec","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the ArtifactBrowser panel in the layout. Let me find where the WorkArea is rendered and add the ArtifactBrowser panel:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":677,"cache_read_input_tokens":127383,"cache_creation":{"ephemeral_5m_input_tokens":677,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"561e3026-113c-46e4-b8c2-cb48a68a0e76"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TqLCPsLXMWJKfkqmjUzwec","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Dj2kpJmV1j3oUJDTdAuG5Q","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","offset":2798,"limit":60}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":677,"cache_read_input_tokens":127383,"cache_creation":{"ephemeral_5m_input_tokens":677,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"038ce788-31b7-45d0-82d3-98345613fe2b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Dj2kpJmV1j3oUJDTdAuG5Q","type":"tool_result","content":"  2798→                  onRetry={handleQuickRetry}\n  2799→                  onRetryWithConfig={handleRetryWithConfig}\n  2800→                  onSkipStep={handleSkipStep}\n  2801→                  isFirst={isFirstStep}\n  2802→                  isLast={isLastStep}\n  2803→                  previousStepOutput={getPreviousStepOutput()}\n  2804→                  projectId={projectId}\n  2805→                  playbookContext={buildPlaybookContext()}\n  2806→                  allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n  2807→                    phase.steps.map((stepDef, stepIdx) => ({\n  2808→                      definition: stepDef,\n  2809→                      state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n  2810→                    }))\n  2811→                  )}\n  2812→                  saveState={sessionId ? stepPersistenceState : undefined}\n  2813→                  retryInfo={currentStepRetryInfo || undefined}\n  2814→                  maxRetriesReached={maxRetriesReached}\n  2815→                  sessionId={sessionId}\n  2816→                />\n  2817→\n  2818→                {/* Retry Dialog */}\n  2819→                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n  2820→                  <StepRetryDialog\n  2821→                    isOpen={retryDialogOpen}\n  2822→                    stepName={currentStep.name}\n  2823→                    errorMessage={currentStepState.error || 'Unknown error'}\n  2824→                    retryInfo={currentStepRetryInfo}\n  2825→                    onRetry={handleRetryFromDialog}\n  2826→                    onClose={() => {\n  2827→                      setRetryDialogOpen(false)\n  2828→                      setRetryDialogStepId(null)\n  2829→                    }}\n  2830→                    isRetrying={stepRetryState.isRetrying}\n  2831→                  />\n  2832→                )}\n  2833→              </>\n  2834→            )}\n  2835→          </div>\n  2836→        </div>\n  2837→      )}\n  2838→\n  2839→      {/* Campaign Wizard Modal */}\n  2840→      {showWizard && (\n  2841→        <CampaignWizard\n  2842→          projectId={projectId}\n  2843→          playbookConfig={playbookConfig}\n  2844→          onClose={() => setShowWizard(false)}\n  2845→          onCreated={(campaignId) => {\n  2846→            setSelectedCampaignId(campaignId)\n  2847→            setShowWizard(false)\n  2848→            // Reload campaigns\n  2849→            loadCampaigns()\n  2850→          }}\n  2851→        />\n  2852→      )}\n  2853→\n  2854→      {/* Campaign Settings Modal */}\n  2855→      {showCampaignSettings && selectedCampaignId && (\n  2856→        <CampaignSettings\n  2857→          campaignId={selectedCampaignId}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"ddff38c7-1f71-4396-862c-7ea2d9dfec07","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","content":"                  onRetry={handleQuickRetry}\n                  onRetryWithConfig={handleRetryWithConfig}\n                  onSkipStep={handleSkipStep}\n                  isFirst={isFirstStep}\n                  isLast={isLastStep}\n                  previousStepOutput={getPreviousStepOutput()}\n                  projectId={projectId}\n                  playbookContext={buildPlaybookContext()}\n                  allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                    phase.steps.map((stepDef, stepIdx) => ({\n                      definition: stepDef,\n                      state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                    }))\n                  )}\n                  saveState={sessionId ? stepPersistenceState : undefined}\n                  retryInfo={currentStepRetryInfo || undefined}\n                  maxRetriesReached={maxRetriesReached}\n                  sessionId={sessionId}\n                />\n\n                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Campaign Wizard Modal */}\n      {showWizard && (\n        <CampaignWizard\n          projectId={projectId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowWizard(false)}\n          onCreated={(campaignId) => {\n            setSelectedCampaignId(campaignId)\n            setShowWizard(false)\n            // Reload campaigns\n            loadCampaigns()\n          }}\n        />\n      )}\n\n      {/* Campaign Settings Modal */}\n      {showCampaignSettings && selectedCampaignId && (\n        <CampaignSettings\n          campaignId={selectedCampaignId}","numLines":60,"startLine":2798,"totalLines":2868}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RLS2v6j9B1QH3W3xJjbHGa","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the ArtifactBrowser panel. I'll add it after the WorkArea div but within the layout:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1116,"cache_read_input_tokens":128060,"cache_creation":{"ephemeral_5m_input_tokens":1116,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"88ee3ccf-b8e5-4bfb-9a94-aabe2b8be871"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RLS2v6j9B1QH3W3xJjbHGa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WVXEiDRu5LwbxTXqCQgUxA","name":"Edit","input":{"replace_all":false,"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","old_string":"                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n        </div>\n      )}","new_string":"                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n\n          {/* Artifact Browser Panel - Right side */}\n          {showArtifactBrowser && selectedCampaignId && (\n            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">\n              <ArtifactBrowser\n                sessionId={sessionId}\n                projectId={projectId}\n                clientId=\"\"\n                userId=\"system\"\n                campaignId={selectedCampaignId}\n                campaignName={selectedCampaign?.name || ''}\n                playbookId={playbookConfig.id}\n                playbookName={playbookConfig.name}\n                playbookType={playbookConfig.type}\n                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                  phase.steps.map((stepDef, stepIdx) => ({\n                    definition: stepDef,\n                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                  }))\n                )}\n                isVisible={showArtifactBrowser}\n                onClose={() => setShowArtifactBrowser(false)}\n              />\n            </div>\n          )}\n        </div>\n      )}"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1116,"cache_read_input_tokens":128060,"cache_creation":{"ephemeral_5m_input_tokens":1116,"ephemeral_1h_input_tokens":0},"output_tokens":854,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"db4fe871-175c-46bc-8fbd-6a700a0d8039"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WVXEiDRu5LwbxTXqCQgUxA","type":"tool_result","content":"The file /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"cdb3edcb-806c-42de-808f-207f5b8ea3e4","tool_use_result":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","oldString":"                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n        </div>\n      )}","newString":"                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n\n          {/* Artifact Browser Panel - Right side */}\n          {showArtifactBrowser && selectedCampaignId && (\n            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">\n              <ArtifactBrowser\n                sessionId={sessionId}\n                projectId={projectId}\n                clientId=\"\"\n                userId=\"system\"\n                campaignId={selectedCampaignId}\n                campaignName={selectedCampaign?.name || ''}\n                playbookId={playbookConfig.id}\n                playbookName={playbookConfig.name}\n                playbookType={playbookConfig.type}\n                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                  phase.steps.map((stepDef, stepIdx) => ({\n                    definition: stepDef,\n                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                  }))\n                )}\n                isVisible={showArtifactBrowser}\n                onClose={() => setShowArtifactBrowser(false)}\n              />\n            </div>\n          )}\n        </div>\n      )}","originalFile":"'use client'\n\nimport { useState, useCallback, useEffect, useRef } from 'react'\nimport {\n  PlaybookShellProps,\n  PlaybookState,\n  PhaseState,\n  StepState,\n  StepDefinition,\n  PhaseDefinition,\n} from './types'\nimport NavigationPanel from './NavigationPanel'\nimport { WorkArea } from './WorkArea'\nimport ConfigurationMode from './ConfigurationMode'\nimport CampaignWizard from './CampaignWizard'\nimport CampaignSettings from './CampaignSettings'\nimport { Settings, ChevronDown, Plus, Folder, Pencil, Trash2, Database } from 'lucide-react'\nimport { ArtifactBrowser } from './ArtifactBrowser'\nimport { useStepPersistence } from '@/hooks/useStepPersistence'\nimport { useStepRetry } from '@/hooks/useStepRetry'\nimport { StepAttemptConfig, StepRetryInfo } from './types'\nimport StepRetryDialog from './StepRetryDialog'\nimport FailedStepActions from './FailedStepActions'\n\n// Mode types for the unified view\ntype PlaybookMode = 'config' | 'campaign'\n\ninterface Campaign {\n  id: string\n  name: string\n  status: 'draft' | 'in_progress' | 'completed'\n  completedSteps: number\n  totalSteps: number\n  customVariables?: Record<string, unknown> // Includes context_type, product, target, etc.\n  playbookState?: PlaybookState // Saved playbook state for persistence\n}\n\nfunction initializeState(\n  projectId: string,\n  playbookConfig: PlaybookShellProps['playbookConfig'],\n  initialState?: Partial<PlaybookState>\n): PlaybookState {\n  const phases: PhaseState[] = playbookConfig.phases.map(phase => ({\n    id: phase.id,\n    status: 'pending',\n    steps: phase.steps.map(step => ({\n      id: step.id,\n      status: 'pending',\n    })),\n  }))\n\n  // Apply initial state if provided - match by ID for robustness when config changes\n  if (initialState?.phases) {\n    initialState.phases.forEach((savedPhaseState) => {\n      // Find phase by ID instead of index\n      const phaseIndex = phases.findIndex(p => p.id === savedPhaseState.id)\n      if (phaseIndex === -1) return\n\n      phases[phaseIndex].status = savedPhaseState.status\n      savedPhaseState.steps.forEach((savedStepState) => {\n        // Find step by ID instead of index\n        const stepIndex = phases[phaseIndex].steps.findIndex(s => s.id === savedStepState.id)\n        if (stepIndex === -1) return\n\n        phases[phaseIndex].steps[stepIndex] = {\n          ...phases[phaseIndex].steps[stepIndex],\n          ...savedStepState,\n        }\n      })\n    })\n  }\n\n  const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n  const completedSteps = phases.reduce(\n    (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n    0\n  )\n\n  // Validate currentPhaseIndex and currentStepIndex are within bounds\n  let currentPhaseIndex = initialState?.currentPhaseIndex ?? 0\n  let currentStepIndex = initialState?.currentStepIndex ?? 0\n\n  // Ensure phase index is valid\n  if (currentPhaseIndex >= playbookConfig.phases.length) {\n    currentPhaseIndex = Math.max(0, playbookConfig.phases.length - 1)\n  }\n\n  // Ensure step index is valid for the current phase\n  const currentPhaseSteps = playbookConfig.phases[currentPhaseIndex]?.steps.length ?? 0\n  if (currentStepIndex >= currentPhaseSteps) {\n    currentStepIndex = Math.max(0, currentPhaseSteps - 1)\n  }\n\n  // If the current step doesn't exist, find the first non-completed step\n  if (currentPhaseSteps === 0 || currentStepIndex < 0) {\n    // Find first pending step\n    for (let pi = 0; pi < phases.length; pi++) {\n      for (let si = 0; si < phases[pi].steps.length; si++) {\n        if (phases[pi].steps[si].status !== 'completed') {\n          currentPhaseIndex = pi\n          currentStepIndex = si\n          break\n        }\n      }\n      if (currentStepIndex >= 0) break\n    }\n    // Default to first step if all completed\n    if (currentStepIndex < 0) {\n      currentPhaseIndex = 0\n      currentStepIndex = 0\n    }\n  }\n\n  console.log('[initializeState] Validated indices:', {\n    originalPhase: initialState?.currentPhaseIndex,\n    originalStep: initialState?.currentStepIndex,\n    validatedPhase: currentPhaseIndex,\n    validatedStep: currentStepIndex,\n    maxPhases: playbookConfig.phases.length,\n    maxSteps: currentPhaseSteps,\n  })\n\n  return {\n    projectId,\n    playbookType: playbookConfig.type,\n    phases,\n    currentPhaseIndex,\n    currentStepIndex,\n    config: initialState?.config ?? {},\n    completedSteps,\n    totalSteps,\n    startedAt: initialState?.startedAt,\n    completedAt: initialState?.completedAt,\n  }\n}\n\nexport default function PlaybookShell({\n  projectId,\n  playbookConfig,\n  initialState,\n  sessionId,\n}: PlaybookShellProps) {\n  const [state, setState] = useState<PlaybookState>(() =>\n    initializeState(projectId, playbookConfig, initialState)\n  )\n\n  // Step persistence hook for auto-saving step data to database\n  const [stepPersistenceState, stepPersistenceActions] = useStepPersistence({\n    sessionId: sessionId || null,\n    autoSaveInterval: 30000, // Auto-save every 30 seconds\n    enabled: !!sessionId, // Only enable if sessionId is provided\n  })\n\n  // Step retry hook for managing retry attempts\n  const [stepRetryState, stepRetryActions] = useStepRetry(sessionId || null, {\n    enabled: !!sessionId,\n  })\n\n  // State for retry dialog\n  const [retryDialogOpen, setRetryDialogOpen] = useState(false)\n  const [retryDialogStepId, setRetryDialogStepId] = useState<string | null>(null)\n\n  // Flag to distinguish between intentional navigation (Continue button)\n  // vs manual navigation (clicking on a step)\n  const [shouldAutoExecute, setShouldAutoExecute] = useState(false)\n\n  // Mode: 'config' for editing base prompts, 'campaign' for execution\n  const [mode, setMode] = useState<PlaybookMode>('campaign')\n  const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null)\n  const [campaigns, setCampaigns] = useState<Campaign[]>([])\n  const [showCampaignDropdown, setShowCampaignDropdown] = useState(false)\n  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)\n\n  // Load campaigns from database\n  const loadCampaigns = useCallback(async () => {\n    try {\n      const response = await fetch(`/api/campaign/create?projectId=${projectId}`)\n      if (!response.ok) {\n        console.error('Failed to load campaigns')\n        return\n      }\n      const data = await response.json()\n      if (data.campaigns) {\n        const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n        const mappedCampaigns: Campaign[] = data.campaigns.map((c: any) => ({\n          id: c.id,\n          name: c.ecp_name,\n          status: c.status || 'draft',\n          // Calculate completed steps from playbook_state if available\n          completedSteps: c.playbook_state?.completedSteps ?? 0,\n          totalSteps,\n          customVariables: c.custom_variables || {}, // Load campaign variables including context_type\n          playbookState: c.playbook_state || null, // Load saved playbook state\n        }))\n        setCampaigns(mappedCampaigns)\n      }\n    } catch (error) {\n      console.error('Error loading campaigns:', error)\n    }\n  }, [projectId, playbookConfig.phases])\n\n  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)\n\n  // Ref to track if we should save (avoid saving on initial load)\n  const shouldSaveRef = useRef(false)\n  // Ref to prevent duplicate saves\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  // Ref to store polling interval for cancellation\n  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Save playbook state to database (debounced)\n  const savePlaybookState = useCallback(async (stateToSave: PlaybookState) => {\n    if (!selectedCampaignId) return\n\n    try {\n      await fetch(`/api/campaign/${selectedCampaignId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ playbook_state: stateToSave }),\n      })\n    } catch (error) {\n      console.error('Error saving playbook state:', error)\n    }\n  }, [selectedCampaignId])\n\n  // Auto-save state when it changes (debounced)\n  useEffect(() => {\n    if (!shouldSaveRef.current || !selectedCampaignId) return\n\n    // Clear any pending save\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current)\n    }\n\n    // Debounce saves by 500ms to avoid too many API calls\n    saveTimeoutRef.current = setTimeout(() => {\n      savePlaybookState(state)\n    }, 500)\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n      }\n    }\n  }, [state, selectedCampaignId, savePlaybookState])\n\n  // Load saved state when selecting a campaign\n  useEffect(() => {\n    if (!selectedCampaignId) {\n      shouldSaveRef.current = false\n      return\n    }\n\n    const campaign = campaigns.find(c => c.id === selectedCampaignId)\n    if (campaign?.playbookState) {\n      // Load saved state\n      shouldSaveRef.current = false // Don't save while loading\n      setState(initializeState(projectId, playbookConfig, campaign.playbookState))\n      // Enable saving after a short delay\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    } else {\n      // Fresh state for new campaign\n      shouldSaveRef.current = false\n      setState(initializeState(projectId, playbookConfig))\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    }\n  }, [selectedCampaignId, campaigns, projectId, playbookConfig])\n\n  // Load step data from database on session resume (if sessionId is provided)\n  useEffect(() => {\n    if (!sessionId) return\n\n    const loadStepData = async () => {\n      try {\n        const savedSteps = await stepPersistenceActions.loadAllSteps()\n        if (Object.keys(savedSteps).length === 0) return\n\n        console.log('[PlaybookShell] Loaded step data from session:', Object.keys(savedSteps))\n\n        // Merge saved step data into current state\n        setState(prev => {\n          const newPhases = prev.phases.map(phase => ({\n            ...phase,\n            steps: phase.steps.map(step => {\n              const savedStep = savedSteps[step.id]\n              if (savedStep) {\n                return {\n                  ...step,\n                  ...savedStep,\n                }\n              }\n              return step\n            }),\n          }))\n\n          // Recalculate phase status\n          newPhases.forEach(phase => {\n            const hasError = phase.steps.some(s => s.status === 'error')\n            const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n            const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n            if (hasError) {\n              phase.status = 'error'\n            } else if (allCompleted) {\n              phase.status = 'completed'\n            } else if (hasInProgress) {\n              phase.status = 'in_progress'\n            } else {\n              phase.status = 'pending'\n            }\n          })\n\n          // Recalculate completed steps\n          const completedSteps = newPhases.reduce(\n            (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n            0\n          )\n\n          // Find the first non-completed step to set as current\n          let currentPhaseIndex = 0\n          let currentStepIndex = 0\n          outer: for (let pi = 0; pi < newPhases.length; pi++) {\n            for (let si = 0; si < newPhases[pi].steps.length; si++) {\n              if (newPhases[pi].steps[si].status !== 'completed') {\n                currentPhaseIndex = pi\n                currentStepIndex = si\n                break outer\n              }\n            }\n          }\n\n          return {\n            ...prev,\n            phases: newPhases,\n            completedSteps,\n            currentPhaseIndex,\n            currentStepIndex,\n          }\n        })\n      } catch (error) {\n        console.error('[PlaybookShell] Error loading step data:', error)\n      }\n    }\n\n    loadStepData()\n  }, [sessionId, stepPersistenceActions])\n\n  // Delete a campaign\n  const deleteCampaign = useCallback(async (campaignId: string) => {\n    if (!confirm('¿Estás seguro de que quieres eliminar esta campaña? Esta acción no se puede deshacer.')) {\n      return\n    }\n\n    try {\n      const response = await fetch(`/api/campaign/${campaignId}`, {\n        method: 'DELETE',\n      })\n\n      if (!response.ok) {\n        throw new Error('Error al eliminar campaña')\n      }\n\n      // If we deleted the selected campaign, clear selection\n      if (selectedCampaignId === campaignId) {\n        setSelectedCampaignId(null)\n      }\n\n      // Reload campaigns\n      loadCampaigns()\n    } catch (error) {\n      console.error('Error deleting campaign:', error)\n      alert('Error al eliminar la campaña')\n    }\n  }, [selectedCampaignId, loadCampaigns])\n\n  // Helper function to get the output from the previous step\n  const getPreviousStepOutput = (): string | undefined => {\n    // Find the current step's dependencies\n    if (!currentStep?.dependsOn?.length) return undefined\n\n    // Get the first dependency's output\n    const dependencyId = currentStep.dependsOn[0]\n\n    // Search for this step across all phases\n    for (const phase of state.phases) {\n      const stepState = phase.steps.find(s => s.id === dependencyId)\n      if (stepState?.output) {\n        return typeof stepState.output === 'string'\n          ? stepState.output\n          : JSON.stringify(stepState.output, null, 2)\n      }\n    }\n\n    return undefined\n  }\n\n  // Build context for LLM-based suggestion generation\n  const buildPlaybookContext = (): Record<string, unknown> => {\n    // Start with campaign's custom_variables (includes context_type, product, target, etc.)\n    const campaignVars = selectedCampaign?.customVariables || {}\n\n    const context: Record<string, unknown> = {\n      ...campaignVars, // Include all campaign variables\n      product: campaignVars.product || state.config?.product || '',\n      target: campaignVars.target || state.config?.target || '',\n      context_type: campaignVars.context_type || 'both', // Explicitly include context_type\n    }\n\n    // DEBUG: Log all steps to see their state\n    console.log('[buildPlaybookContext] All steps:', state.phases.flatMap(p =>\n      p.steps.map(s => ({ id: s.id, status: s.status, hasOutput: !!s.output }))\n    ))\n\n    // Collect values from completed steps\n    for (const phase of state.phases) {\n      for (const stepState of phase.steps) {\n        // DEBUG: Log keyword_config step specifically\n        if (stepState.id === 'keyword_config') {\n          console.log('[buildPlaybookContext] keyword_config step:', {\n            status: stepState.status,\n            hasOutput: !!stepState.output,\n            outputKeys: stepState.output ? Object.keys(stepState.output as object) : [],\n            output: stepState.output,\n          })\n        }\n\n        if (stepState.status === 'completed' || stepState.decision || stepState.suggestions) {\n          // Get decision value\n          if (stepState.decision) {\n            context[stepState.id] = stepState.decision\n          }\n\n          // Get selected suggestions as array of labels\n          if (stepState.suggestions?.length) {\n            const selectedLabels = stepState.suggestions\n              .filter(s => s.selected)\n              .map(s => s.label)\n            if (selectedLabels.length > 0) {\n              context[stepState.id] = selectedLabels\n            }\n          }\n\n          // Get output if available\n          if (stepState.output) {\n            context[`${stepState.id}_output`] = stepState.output\n          }\n\n          // Special case: Extract serpJobId from serp_search or search_and_preview step output\n          // This is needed for review_urls/review_and_scrape step to display SERP results\n          // Note: We check this inside the completed block, but also outside below\n          if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Also extract serpJobId from review_and_scrape step (the scrape step)\n          // This ensures scrape_results step can find the jobId after scraping completes\n          if (stepState.id === 'review_and_scrape' && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId && !context.serpJobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Special case: Parse sources step output for QueryPreviewPanel\n          // The LLM returns a JSON string that needs to be parsed\n          if (stepState.id === 'sources' && stepState.output) {\n            try {\n              let parsedSources = stepState.output\n              if (typeof stepState.output === 'string') {\n                // Try to extract JSON from the LLM response\n                const jsonMatch = stepState.output.match(/\\{[\\s\\S]*\\}/)\n                if (jsonMatch) {\n                  parsedSources = JSON.parse(jsonMatch[0])\n                }\n              }\n              // Only set if it's a valid sources config object\n              if (parsedSources && typeof parsedSources === 'object' &&\n                  ('reddit' in parsedSources || 'thematic_forums' in parsedSources || 'general_forums' in parsedSources)) {\n                context.sources = parsedSources\n              }\n            } catch (e) {\n              console.error('[buildPlaybookContext] Error parsing sources output:', e)\n              // Don't set context.sources - let it use default values\n            }\n          }\n\n          // Special case: Extract keyword_config unified output for SearchWithPreviewStep\n          // The unified panel saves data in two formats:\n          // 1. lifeContexts, needWords, indicators as arrays of objects (for UI)\n          // 2. life_contexts, product_words, indicators as arrays of strings (for SERP job)\n          if (stepState.id === 'keyword_config' && stepState.output) {\n            const output = stepState.output as {\n              // Object arrays (for UI state)\n              lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n              needWords?: Array<{ id: string; label: string; selected: boolean }>\n              indicators?: Array<{ id: string; label: string; selected: boolean }>\n              // String arrays (pre-extracted for SERP job)\n              life_contexts?: string[]\n              product_words?: string[]\n              sources?: {\n                reddit_general?: { enabled: boolean }\n                reddit?: { enabled: boolean; subreddits?: string[] }\n                thematic_forums?: { enabled: boolean; forums?: string[] }\n                general_forums?: { enabled: boolean; forums?: string[] }\n              }\n            }\n\n            // First try to use pre-extracted string arrays (set on completion)\n            if (output.life_contexts && Array.isArray(output.life_contexts)) {\n              context.life_contexts = output.life_contexts\n            } else if (output.lifeContexts) {\n              // Fall back to extracting from object array\n              context.life_contexts = output.lifeContexts\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            // Check multiple possible keys for need words\n            if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n              context.need_words = output.product_words\n              console.log('[buildPlaybookContext] Got need_words from product_words:', output.product_words)\n            } else if ((output as any).need_words && Array.isArray((output as any).need_words) && (output as any).need_words.length > 0) {\n              // Also check for 'need_words' key (alternative naming)\n              context.need_words = (output as any).need_words\n              console.log('[buildPlaybookContext] Got need_words from need_words key:', (output as any).need_words)\n            } else if (output.needWords && Array.isArray(output.needWords)) {\n              const extracted = output.needWords\n                .filter(item => item.selected)\n                .map(item => item.label)\n              if (extracted.length > 0) {\n                context.need_words = extracted\n                console.log('[buildPlaybookContext] Got need_words from needWords (selected):', extracted)\n              } else {\n                console.warn('[buildPlaybookContext] needWords array exists but no items selected:', output.needWords)\n              }\n            } else {\n              console.warn('[buildPlaybookContext] Could not find need_words in output:', {\n                hasProductWords: !!output.product_words,\n                productWordsLength: output.product_words?.length,\n                hasNeedWords: !!(output as any).need_words,\n                hasNeedWordsArray: !!output.needWords,\n                outputKeys: Object.keys(output),\n              })\n            }\n\n            if (output.indicators && Array.isArray(output.indicators) && typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else if (output.indicators && Array.isArray(output.indicators)) {\n              context.indicators = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            if (output.sources) {\n              context.sources = output.sources\n            }\n\n            // DEBUG: Log what we extracted from keyword_config\n            console.log('[buildPlaybookContext] Extracted from keyword_config:', {\n              life_contexts: context.life_contexts,\n              need_words: context.need_words,\n              indicators: context.indicators,\n              sources: context.sources,\n            })\n          }\n        }\n\n        // IMPORTANT: Extract serpJobId even from non-completed steps (e.g., after cancel)\n        // This allows review_and_scrape to show URLs from a cancelled SERP job\n        if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also check review_and_scrape for non-completed steps (e.g., in progress or cancelled)\n        if (stepState.id === 'review_and_scrape' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also extract serpJobId from scrape_results step (for extraction step)\n        if (stepState.id === 'scrape_results' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // IMPORTANT: Also extract keyword_config data even if step is not 'completed'\n        // This ensures retry/navigation doesn't lose the config\n        if (stepState.id === 'keyword_config' && stepState.output && !context.life_contexts) {\n          console.log('[buildPlaybookContext] Extracting keyword_config from non-completed step')\n          const output = stepState.output as {\n            lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n            needWords?: Array<{ id: string; label: string; selected: boolean }>\n            indicators?: Array<{ id: string; label: string; selected: boolean }>\n            life_contexts?: string[]\n            product_words?: string[]\n            sources?: Record<string, unknown>\n          }\n\n          if (output.life_contexts && Array.isArray(output.life_contexts) && output.life_contexts.length > 0) {\n            context.life_contexts = output.life_contexts\n          } else if (output.lifeContexts) {\n            const extracted = output.lifeContexts.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.life_contexts = extracted\n            }\n          }\n\n          if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n            context.need_words = output.product_words\n          } else if (output.needWords) {\n            const extracted = output.needWords.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.need_words = extracted\n            }\n          }\n\n          if (output.indicators && Array.isArray(output.indicators) && output.indicators.length > 0) {\n            if (typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else {\n              const extracted = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected).map(item => item.label)\n              if (extracted.length > 0) {\n                context.indicators = extracted\n              }\n            }\n          }\n\n          if (output.sources && !context.sources) {\n            context.sources = output.sources\n          }\n\n          console.log('[buildPlaybookContext] Extracted from non-completed keyword_config:', {\n            life_contexts: context.life_contexts,\n            need_words: context.need_words,\n          })\n        }\n      }\n    }\n\n    // DEBUG: Log final context\n    console.log('[buildPlaybookContext] Final context:', {\n      life_contexts: context.life_contexts,\n      need_words: context.need_words,\n      indicators: context.indicators,\n      sources: context.sources,\n      serpJobId: context.serpJobId,\n    })\n\n    return context\n  }\n\n  // Get current phase and step definitions\n  const currentPhase = playbookConfig.phases[state.currentPhaseIndex]\n  const currentStep = currentPhase?.steps[state.currentStepIndex]\n  const currentStepState = state.phases[state.currentPhaseIndex]?.steps[state.currentStepIndex]\n\n  // Calculate navigation bounds\n  const isFirstStep = state.currentPhaseIndex === 0 && state.currentStepIndex === 0\n  const isLastStep =\n    state.currentPhaseIndex === playbookConfig.phases.length - 1 &&\n    state.currentStepIndex === currentPhase.steps.length - 1\n\n  // Navigate to a specific step\n  const goToStep = useCallback((phaseIndex: number, stepIndex: number) => {\n    // Save current state immediately before navigating (don't wait for debounce)\n    if (shouldSaveRef.current && selectedCampaignId) {\n      // Clear pending debounced save\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n        saveTimeoutRef.current = null\n      }\n      // Save current state synchronously\n      savePlaybookState(state)\n    }\n\n    setState(prev => ({\n      ...prev,\n      currentPhaseIndex: phaseIndex,\n      currentStepIndex: stepIndex,\n    }))\n  }, [selectedCampaignId, state, savePlaybookState])\n\n  // Go to next step\n  const goToNextStep = useCallback(() => {\n    setState(prev => {\n      const currentPhase = playbookConfig.phases[prev.currentPhaseIndex]\n\n      // Check if there's a next step in current phase\n      if (prev.currentStepIndex < currentPhase.steps.length - 1) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex + 1,\n        }\n      }\n\n      // Check if there's a next phase\n      if (prev.currentPhaseIndex < playbookConfig.phases.length - 1) {\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex + 1,\n          currentStepIndex: 0,\n        }\n      }\n\n      // Already at the end\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Go to previous step\n  const goToPreviousStep = useCallback(() => {\n    setState(prev => {\n      // Check if there's a previous step in current phase\n      if (prev.currentStepIndex > 0) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex - 1,\n        }\n      }\n\n      // Check if there's a previous phase\n      if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex - 1,\n          currentStepIndex: prevPhase.steps.length - 1,\n        }\n      }\n\n      // Already at the beginning\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Re-run the previous step (go back and reset its state to pending)\n  const rerunPreviousStep = useCallback(() => {\n    setState(prev => {\n      let newPhaseIndex = prev.currentPhaseIndex\n      let newStepIndex = prev.currentStepIndex\n\n      // Find previous step\n      if (prev.currentStepIndex > 0) {\n        newStepIndex = prev.currentStepIndex - 1\n      } else if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        newPhaseIndex = prev.currentPhaseIndex - 1\n        newStepIndex = prevPhase.steps.length - 1\n      } else {\n        // Already at the beginning, nothing to rerun\n        return prev\n      }\n\n      // Get the previous step ID\n      const prevStepId = playbookConfig.phases[newPhaseIndex].steps[newStepIndex].id\n\n      // Reset the previous step state to pending and navigate to it\n      const newPhases = prev.phases.map((phase, pi) => ({\n        ...phase,\n        steps: phase.steps.map((step, si) => {\n          if (pi === newPhaseIndex && si === newStepIndex) {\n            return {\n              ...step,\n              status: 'pending' as const,\n              output: undefined,\n              error: undefined,\n            }\n          }\n          return step\n        }),\n      }))\n\n      return {\n        ...prev,\n        phases: newPhases,\n        currentPhaseIndex: newPhaseIndex,\n        currentStepIndex: newStepIndex,\n      }\n    })\n    // Trigger auto-execute after navigating\n    setShouldAutoExecute(true)\n  }, [playbookConfig.phases])\n\n  // Update step state\n  const updateStepState = useCallback(\n    (stepId: string, update: Partial<StepState>) => {\n      console.log('[updateStepState] Updating step:', stepId, 'with:', {\n        ...update,\n        output: update.output ? `[output with keys: ${Object.keys(update.output as object).join(', ')}]` : undefined,\n      })\n\n      // Persist step changes to database (if sessionId is provided)\n      if (sessionId) {\n        // Handle status-specific persistence\n        if (update.status === 'in_progress') {\n          stepPersistenceActions.markStepRunning(stepId, update.input)\n        } else if (update.status === 'completed') {\n          stepPersistenceActions.markStepCompleted(stepId, update.output)\n        } else if (update.status === 'error') {\n          stepPersistenceActions.markStepFailed(stepId, update.error || 'Unknown error')\n        } else if (update.output !== undefined) {\n          // For output-only updates (during execution), schedule auto-save\n          stepPersistenceActions.scheduleAutoSave(stepId, update.output)\n        }\n      }\n\n      setState(prev => {\n        // Find the current step to log what we're merging\n        const currentStep = prev.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n        if (stepId === 'keyword_config') {\n          console.log('[updateStepState] keyword_config before merge:', {\n            status: currentStep?.status,\n            hasOutput: !!currentStep?.output,\n            outputKeys: currentStep?.output ? Object.keys(currentStep.output as object) : [],\n          })\n        }\n\n        const newPhases = prev.phases.map(phase => ({\n          ...phase,\n          steps: phase.steps.map(step =>\n            step.id === stepId ? { ...step, ...update } : step\n          ),\n        }))\n\n        // Log the merged result for keyword_config\n        if (stepId === 'keyword_config') {\n          const mergedStep = newPhases.flatMap(p => p.steps).find(s => s.id === stepId)\n          console.log('[updateStepState] keyword_config after merge:', {\n            status: mergedStep?.status,\n            hasOutput: !!mergedStep?.output,\n            outputKeys: mergedStep?.output ? Object.keys(mergedStep.output as object) : [],\n          })\n        }\n\n        // Recalculate phase status\n        newPhases.forEach(phase => {\n          const hasError = phase.steps.some(s => s.status === 'error')\n          const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n          const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n          if (hasError) {\n            phase.status = 'error'\n          } else if (allCompleted) {\n            phase.status = 'completed'\n          } else if (hasInProgress) {\n            phase.status = 'in_progress'\n          } else {\n            phase.status = 'pending'\n          }\n        })\n\n        // Recalculate completed steps\n        const completedSteps = newPhases.reduce(\n          (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n          0\n        )\n\n        return {\n          ...prev,\n          phases: newPhases,\n          completedSteps,\n        }\n      })\n    },\n    [sessionId, stepPersistenceActions]\n  )\n\n  // Execute a step\n  const executeStep = useCallback(\n    async (stepId: string, input?: any) => {\n      console.log('[executeStep] Starting execution for step:', stepId, 'with input:', input)\n\n      const step = playbookConfig.phases\n        .flatMap(p => p.steps)\n        .find(s => s.id === stepId)\n\n      if (!step) {\n        console.error('[executeStep] Step not found:', stepId)\n        return\n      }\n\n      console.log('[executeStep] Found step:', step.id, 'type:', step.type, 'executor:', step.executor, 'jobType:', step.jobType)\n\n      // Mark as in progress\n      updateStepState(stepId, {\n        status: 'in_progress',\n        startedAt: new Date(),\n        input,\n      })\n\n      try {\n        let result: any\n\n        // Special case: Execute extraction from scrape_results step\n        if (step.id === 'scrape_results' && input?.action === 'extract' && input?.jobId) {\n          console.log('[EXTRACT from scrape_results] Starting extraction for job:', input.jobId)\n          const jobId = input.jobId\n\n          updateStepState(stepId, {\n            output: { jobId },\n            progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' },\n            partialResults: { extracted: 0, filtered: 0 },\n          })\n\n          // Get total URLs to extract from job status\n          const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          const statusData = await statusResponse.json()\n          const scrapedUrlCount = statusData.url_counts?.scraped || 0\n          const totalUrls = scrapedUrlCount || statusData.job?.urls_scraped || 0\n          const existingExtractedCount = statusData.job?.niches_extracted || 0\n          const existingFilteredCount = statusData.url_counts?.filtered || 0\n\n          console.log('[EXTRACT] Status check:', {\n            scrapedUrlCount,\n            totalUrls,\n            existingExtractedCount,\n            existingFilteredCount,\n            jobStatus: statusData.job?.status,\n            urlsFailed: statusData.url_counts?.failed || 0,\n          })\n\n          // Check if there's nothing to extract (all URLs failed or filtered)\n          if (scrapedUrlCount === 0 && existingExtractedCount === 0) {\n            const failedCount = statusData.url_counts?.failed || 0\n            console.log('[EXTRACT] No URLs to extract and no existing results. Failed:', failedCount, 'Filtered:', existingFilteredCount)\n\n            // Show error state - nothing to extract\n            updateStepState(stepId, {\n              status: 'error',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: 0,\n                filteredCount: existingFilteredCount,\n                error: failedCount > 0\n                  ? `El scraping falló para ${failedCount} URLs (posible bloqueo de Reddit API). No hay contenido disponible para extraer.`\n                  : 'No hay URLs disponibles para extraer. Verifica que el scraping se completó correctamente.',\n              },\n              progress: undefined,\n            })\n\n            return // Stop - nothing to do\n          }\n\n          // Check if extraction was already done (no URLs to process but results exist)\n          if (scrapedUrlCount === 0 && existingExtractedCount > 0) {\n            console.log('[EXTRACT] Extraction already completed, using existing results')\n            updateStepState(stepId, {\n              progress: { current: 100, total: 100, label: `Usando resultados existentes: ${existingExtractedCount} problemas encontrados` },\n            })\n\n            // Skip extraction loop and jump to results fetching\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // Mark scrape_results as completed\n            updateStepState(stepId, {\n              status: 'completed',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: existingExtractedCount,\n                filteredCount: existingFilteredCount,\n              },\n              progress: undefined,\n            })\n\n            // Also update extract_problems step for clean_filter to use\n            console.log('[EXTRACT] Updating extract_problems step with existing CSV results')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,\n              partialResults: {\n                extracted: existingExtractedCount,\n                filtered: existingFilteredCount,\n                successCount: niches.length,\n              }\n            })\n\n            console.log('[EXTRACT] Using existing results:', niches.length, 'problems')\n            return // Don't proceed with new extraction\n          }\n\n          updateStepState(stepId, {\n            progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` },\n          })\n\n          // Call extract endpoint in batches until has_more=false\n          let hasMore = true\n          let extractedTotal = 0\n          let filteredTotal = 0\n          let processedTotal = 0\n\n          while (hasMore) {\n            try {\n              const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout)\n              const contentType = extractResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                console.error('[EXTRACT] Non-JSON response, polling status...')\n                await new Promise(resolve => setTimeout(resolve, 2000))\n\n                // Check current status\n                const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                const checkData = await checkResponse.json()\n\n                if (checkData.status === 'completed') {\n                  hasMore = false\n                  extractedTotal = checkData.job?.niches_extracted || 0\n                }\n                continue\n              }\n\n              const extractData = await extractResponse.json()\n              console.log('[EXTRACT] Batch response:', extractData)\n\n              if (extractData.error) {\n                throw new Error(extractData.error)\n              }\n\n              extractedTotal += extractData.extracted || 0\n              filteredTotal += extractData.filtered || 0\n              processedTotal = extractedTotal + filteredTotal\n              hasMore = extractData.has_more || false\n\n              updateStepState(stepId, {\n                progress: {\n                  current: processedTotal,\n                  total: totalUrls,\n                  label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                },\n                partialResults: {\n                  extracted: extractedTotal,\n                  filtered: filteredTotal,\n                },\n              })\n            } catch (extractError) {\n              console.error('[EXTRACT] Batch error:', extractError)\n              await new Promise(resolve => setTimeout(resolve, 2000))\n\n              // Check if we should stop\n              const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const checkData = await checkResponse.json()\n              if (checkData.status === 'completed' || checkData.status === 'failed') {\n                hasMore = false\n                if (checkData.status === 'failed') {\n                  throw new Error(checkData.job?.error_message || 'Extraction failed')\n                }\n              }\n            }\n          }\n\n          // Mark as completed\n          updateStepState(stepId, {\n            status: 'completed',\n            completedAt: new Date(),\n            output: {\n              jobId,\n              extractedCount: extractedTotal,\n              filteredCount: filteredTotal,\n            },\n            progress: undefined, // Clear progress\n          })\n\n          console.log('[EXTRACT] Completed! Extracted:', extractedTotal, 'Filtered:', filteredTotal)\n\n          // Save results to Context Lake automatically\n          try {\n            // Get project data (includes client_id)\n            const projectResponse = await fetch(`/api/projects/${projectId}`)\n            const projectData = await projectResponse.json()\n\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // IMPORTANT: Also update extract_problems step so clean_filter can use the results\n            // clean_filter depends on extract_problems, not scrape_results\n            console.log('[EXTRACT] Updating extract_problems step with CSV results for clean_filter')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,  // CSV string that clean_filter will use\n              partialResults: {\n                extracted: extractedTotal,\n                filtered: filteredTotal,\n                successCount: niches.length,\n              }\n            })\n\n            const dateStr = new Date().toISOString().split('T')[0]\n            const campaignSlug = selectedCampaign?.name?.toLowerCase().replace(/\\s+/g, '-') || 'sin-nombre'\n            const projectSlug = projectData.name?.toLowerCase().replace(/\\s+/g, '-') || 'proyecto'\n\n            const documentData = {\n              projectId: projectId,\n              clientId: projectData.client_id,\n              filename: `Niche Finder - ${selectedCampaign?.name || 'Sin nombre'} - ${dateStr}`,\n              category: 'research',\n              content: csvContent,\n              description: `${extractedTotal} problemas extraídos del Niche Finder. ${filteredTotal} URLs filtradas de ${totalUrls} procesadas.`,\n              tags: [\n                `fecha:${dateStr}`,\n                `proyecto:${projectSlug}`,\n                `campaña:${campaignSlug}`,\n                `job:${jobId}`,\n                'niche-finder',\n                'problemas-extraidos'\n              ],\n              folder: `niche-finder/${campaignSlug}`,\n              userId: 'system', // TODO: Get actual user ID from session\n              sourceMetadata: {\n                origin_type: 'flow_step_output',\n                playbook_id: playbookConfig.type || 'niche-finder',\n                playbook_name: playbookConfig.name,\n                campaign_id: selectedCampaignId || '',\n                campaign_name: selectedCampaign?.name || '',\n                campaign_variables: selectedCampaign?.customVariables || {},\n                step_id: 'scrape_results',\n                step_name: 'Extracción de Problemas',\n                step_order: 3,\n                executed_at: new Date().toISOString(),\n                model_used: 'openai/gpt-4o-mini',\n                model_provider: 'openrouter',\n                input_tokens: 0,\n                output_tokens: 0,\n                input_document_ids: [],\n                input_previous_step_ids: ['search_and_preview', 'review_and_scrape'],\n                converted_at: new Date().toISOString(),\n                converted_by: 'system',\n                was_edited_before_conversion: false\n              },\n              sourceCampaignId: selectedCampaignId || '',\n              sourceStepId: 'scrape_results',\n              sourceStepName: 'Extracción de Problemas',\n              sourcePlaybookId: playbookConfig.type\n            }\n\n            const saveResponse = await fetch('/api/documents/from-step-output', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify(documentData)\n            })\n\n            if (saveResponse.ok) {\n              const savedDoc = await saveResponse.json()\n              console.log('[EXTRACT] Results saved to Context Lake:', savedDoc.document?.id)\n            } else {\n              console.error('[EXTRACT] Failed to save to Context Lake:', await saveResponse.text())\n            }\n          } catch (saveError) {\n            console.error('[EXTRACT] Error saving to Context Lake:', saveError)\n            // Don't fail the extraction if saving to Context Lake fails\n          }\n\n          return // Don't fall through to the switch\n        }\n\n        switch (step.executor) {\n          case 'llm':\n            // Build variables including campaign custom_variables (product, target, industry, etc.)\n            const campaignVars = selectedCampaign?.customVariables || {}\n            const stepVariables = {\n              ...Object.fromEntries(\n                Object.entries(campaignVars).map(([k, v]) => [k, String(v ?? '')])\n              ),\n              ...(input || {}),\n            }\n            // Call LLM API\n            const response = await fetch('/api/playbook/execute-step', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({\n                projectId,\n                stepId,\n                playbookType: playbookConfig.type,\n                promptKey: step.promptKey,\n                variables: stepVariables,\n              }),\n            })\n            const data = await response.json()\n            if (!data.success) throw new Error(data.error || 'Error ejecutando paso')\n            result = data.output\n            break\n\n          case 'api':\n            // Call custom API endpoint\n            if (step.apiEndpoint) {\n              // Build payload with previous step outputs and campaign variables\n              const campaignVarsForApi = selectedCampaign?.customVariables || {}\n\n              // Get outputs from previous steps (dependsOn)\n              const previousOutputs: Record<string, unknown> = {}\n              if (step.dependsOn?.length) {\n                for (const depId of step.dependsOn) {\n                  for (const phase of state.phases) {\n                    const depStep = phase.steps.find(s => s.id === depId)\n                    if (depStep?.output) {\n                      previousOutputs[depId] = depStep.output\n                    }\n                  }\n                }\n              }\n\n              // Build scenes array from generate_scenes output (for video-viral generate-clips)\n              let scenes: string[] | undefined\n              if (previousOutputs.generate_scenes) {\n                let scenesOutput = previousOutputs.generate_scenes\n\n                // Parse JSON if output is a string (LLM outputs often come as strings)\n                if (typeof scenesOutput === 'string') {\n                  try {\n                    // Try to extract JSON from the string (might be wrapped in markdown code blocks)\n                    const jsonMatch = scenesOutput.match(/```(?:json)?\\s*(\\{[\\s\\S]*?\\})\\s*```/) ||\n                                     scenesOutput.match(/(\\{[\\s\\S]*\\})/)\n                    if (jsonMatch) {\n                      scenesOutput = JSON.parse(jsonMatch[1])\n                    }\n                  } catch (e) {\n                    console.error('[executeStep] Failed to parse generate_scenes output:', e)\n                  }\n                }\n\n                // Extract scene_1, scene_2, scene_3, etc. from the output\n                if (typeof scenesOutput === 'object' && scenesOutput !== null) {\n                  const scenesRecord = scenesOutput as Record<string, string>\n                  scenes = Object.entries(scenesRecord)\n                    .filter(([key]) => key.startsWith('scene_'))\n                    .sort(([a], [b]) => a.localeCompare(b))\n                    .map(([, value]) => value)\n                  console.log('[executeStep] Extracted scenes:', scenes)\n                }\n              }\n\n              const apiResponse = await fetch(step.apiEndpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                  projectId,\n                  stepId,\n                  input,\n                  ...campaignVarsForApi,\n                  previousOutputs,\n                  scenes, // For generate-clips endpoint\n                }),\n              })\n              const apiData = await apiResponse.json()\n              if (!apiData.success && apiData.error) throw new Error(apiData.error)\n              result = apiData\n            }\n            break\n\n          case 'job':\n            // Job-based execution: create job, execute, poll for status\n            console.log('[executeStep] Executor is JOB, jobType:', step.jobType)\n\n            if (step.jobType === 'niche_finder_serp') {\n              // Check if we have an existing job to resume (from cancelled execution)\n              const currentStepForJob = state.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n              const existingJobId = (currentStepForJob?.output as { jobId?: string })?.jobId\n\n              let jobId: string\n\n              if (existingJobId) {\n                // Resume existing job\n                console.log('[SERP] Resuming existing job:', existingJobId)\n                jobId = existingJobId\n                updateStepState(stepId, { progress: { current: 0, total: 0, label: 'Retomando búsqueda SERP...' } })\n              } else {\n                // Build job config from completed steps OR from input (for search_with_preview)\n                let jobConfig: {\n                  life_contexts: string[]\n                  product_words: string[]\n                  indicators: string[]\n                  sources: { reddit: boolean | { enabled?: boolean; subreddits?: string[] }; thematic_forums: boolean | { enabled?: boolean; forums?: string[] }; general_forums: string[] | { enabled?: boolean; forums?: string[] } }\n                  serp_pages: number\n                  // Campaign metadata for extraction to use correct variables\n                  campaign_id?: string | null\n                  ecp_name?: string\n                  ecp_product?: string\n                  ecp_target?: string\n                  ecp_industry?: string\n                  ecp_category?: string\n                  ecp_country?: string\n                }\n\n                // If input is provided (from SearchWithPreviewPanel), use it directly\n                console.log('[SERP] Input received:', JSON.stringify(input, null, 2))\n\n                if (input && input.life_contexts && input.product_words) {\n                  // Warn if arrays are empty\n                  if (input.life_contexts.length === 0 || input.product_words.length === 0) {\n                    console.warn('[SERP] WARNING: life_contexts or product_words is empty!', {\n                      life_contexts: input.life_contexts,\n                      product_words: input.product_words\n                    })\n                  }\n\n                  jobConfig = {\n                    life_contexts: input.life_contexts,\n                    product_words: input.product_words,\n                    indicators: input.indicators || [],\n                    sources: input.sources || { reddit: true, thematic_forums: false, general_forums: [] },\n                    serp_pages: input.serp_pages || 5,\n                  }\n                } else {\n                  console.log('[SERP] No valid input, falling back to completed steps...')\n                  // Fall back to building from completed steps (legacy flow)\n                  const lifeContextsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'life_contexts')\n                  const needWordsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'need_words')\n                  const indicatorsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'indicators')\n                  const sourcesStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'sources')\n\n                  const selectedContexts = lifeContextsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedNeedWords = needWordsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedIndicators = indicatorsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n\n                  // Parse sources output (can be JSON string from LLM or already parsed object)\n                  let sourcesConfig: { reddit: { enabled: boolean; subreddits: string[] }; thematic_forums: { enabled: boolean; forums: string[] }; general_forums: { enabled: boolean; forums: string[] } } = { reddit: { enabled: true, subreddits: [] }, thematic_forums: { enabled: false, forums: [] }, general_forums: { enabled: false, forums: [] } }\n                  try {\n                    if (sourcesStep?.output) {\n                      // Check if output is already an object (parsed)\n                      if (typeof sourcesStep.output === 'object' && sourcesStep.output !== null) {\n                        sourcesConfig = sourcesStep.output as typeof sourcesConfig\n                      } else if (typeof sourcesStep.output === 'string') {\n                        // Try to extract JSON from string\n                        const jsonMatch = sourcesStep.output.match(/\\{[\\s\\S]*\\}/)\n                        if (jsonMatch) {\n                          sourcesConfig = JSON.parse(jsonMatch[0])\n                        }\n                      }\n                    }\n                  } catch (e) {\n                    console.error('Error parsing sources config:', e)\n                  }\n\n                  // Get campaign variables with proper typing\n                  const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                  jobConfig = {\n                    campaign_id: selectedCampaignId, // CRITICAL: Pass campaign_id so extract uses correct variables\n                    life_contexts: selectedContexts,\n                    product_words: selectedNeedWords,\n                    indicators: selectedIndicators,\n                    sources: sourcesConfig,\n                    serp_pages: (campaignVars?.serp_pages as number) || 5,\n                    // Also pass campaign variables directly in config for reliability\n                    ecp_name: (campaignVars?.company_name as string) || selectedCampaign?.name,\n                    ecp_product: campaignVars?.product as string | undefined,\n                    ecp_target: campaignVars?.target as string | undefined,\n                    ecp_industry: campaignVars?.industry as string | undefined,\n                    ecp_category: campaignVars?.category as string | undefined,\n                    ecp_country: campaignVars?.country as string | undefined,\n                  }\n                }\n\n                console.log('[SERP] Starting job with config:', JSON.stringify(jobConfig, null, 2))\n\n                // 1. Create job\n                const createResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: jobConfig,\n                  }),\n                })\n                const createData = await createResponse.json()\n                console.log('[SERP] Create job response:', createData)\n\n                if (!createData.success) {\n                  throw new Error(createData.error || 'Error creando job')\n                }\n\n                jobId = createData.job_id\n                console.log('[SERP] Job created with ID:', jobId)\n                updateStepState(stepId, { output: { jobId }, progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' } })\n              }\n\n              // 2. Execute SERP job (this will resume from where it left off if job was interrupted)\n              console.log('[SERP] Executing SERP search...')\n              const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout HTML pages)\n              const contentType = serpResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                const text = await serpResponse.text()\n                console.error('[SERP] Non-JSON response:', text.slice(0, 500))\n                // If we got a non-JSON response, the job might still be running in the background\n                // Continue to polling to check status\n                console.log('[SERP] Continuing to poll for job status despite non-JSON response...')\n              } else {\n                const serpData = await serpResponse.json()\n                console.log('[SERP] SERP response:', serpData)\n\n                if (serpData.error) {\n                  // Check if it's a missing API key error\n                  if (serpData.code === 'MISSING_API_KEY') {\n                    throw new Error(`API Key faltante: ${serpData.service}. Configura tu API key en Ajustes > APIs.`)\n                  }\n                  throw new Error(serpData.error)\n                }\n              }\n\n              // 3. Poll for status and auto-resume if needed\n              let isResuming = false\n              let lastCompletedCount = -1 // Track previous poll value\n              let stallCount = 0 // Count consecutive stalls\n              let initialCompleted = -1 // Track initial value when polling started\n\n              // Clear any existing poll interval\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n              }\n\n              pollIntervalRef.current = setInterval(async () => {\n                try {\n                  const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const statusData = await statusResponse.json()\n\n                  const completed = statusData.progress?.serp?.completed || 0\n                  const total = statusData.progress?.serp?.total || 0\n                  const remaining = total - completed\n                  const label = total > 0\n                    ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n                    : 'Iniciando búsqueda SERP...'\n                  updateStepState(stepId, {\n                    progress: {\n                      current: completed,\n                      total: total,\n                      label,\n                    },\n                  })\n\n                  // Track initial value on first poll\n                  if (initialCompleted === -1) {\n                    initialCompleted = completed\n                  }\n\n                  // Auto-resume if job was interrupted (still serp_running but not progressing)\n                  // This handles Vercel timeout scenarios\n                  if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n                    // Check if progress has stalled (same value as PREVIOUS poll)\n                    if (lastCompletedCount === completed && remaining > 0) {\n                      stallCount++\n                      // After 2 consecutive stalls (4+ seconds), OR if no progress since we started polling\n                      const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                      if (stallCount >= 2 || noProgressSinceStart) {\n                        console.log(`[SERP] Job stalled at ${completed}/${total} (stallCount=${stallCount}, initialCompleted=${initialCompleted}), auto-resuming...`)\n                        isResuming = true\n                        stallCount = 0\n                        // Resume the job by calling SERP endpoint again\n                        fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                          .then(res => res.json())\n                          .then(data => {\n                            console.log('[SERP] Resume response:', data)\n                            isResuming = false\n                          })\n                          .catch(err => {\n                            console.error('[SERP] Resume error:', err)\n                            isResuming = false\n                          })\n                      }\n                    } else {\n                      stallCount = 0 // Reset stall count if progress is being made\n                    }\n                  }\n\n                  // Update last completed for next poll comparison\n                  lastCompletedCount = completed\n\n                  // Check if SERP phase is done (includes later states that imply SERP finished)\n                  const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n                  if (serpDone) {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    updateStepState(stepId, {\n                      status: 'completed',\n                      completedAt: new Date(),\n                      output: {\n                        jobId,\n                        urlsFound: statusData.job?.urls_found || 0,\n                        costs: statusData.costs,\n                      },\n                      progress: undefined, // Clear progress to stop spinner\n                    })\n                    setTimeout(goToNextStep, 500)\n                  } else if (statusData.status === 'failed' || statusData.status === 'error') {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    throw new Error(statusData.job?.error_message || 'Job failed')\n                  }\n                } catch (pollError) {\n                  if (pollIntervalRef.current) {\n                    clearInterval(pollIntervalRef.current)\n                    pollIntervalRef.current = null\n                  }\n                  updateStepState(stepId, {\n                    status: 'error',\n                    error: pollError instanceof Error ? pollError.message : 'Error checking job status',\n                  })\n                }\n              }, 2000) // Poll every 2 seconds\n\n              // Don't fall through to the completion logic below\n              return\n            }\n\n            // SCRAPE JOB: Scrape URLs from the SERP results\n            if (step.jobType === 'niche_finder_scrape') {\n              // Get the jobId from the previous step (search_and_preview)\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n              console.log('[SCRAPE] Looking for search_and_preview step:', searchStep)\n              console.log('[SCRAPE] search_and_preview output:', searchStep?.output)\n\n              // Also check for serp_search (legacy step name)\n              const serpStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'serp_search')\n              console.log('[SCRAPE] Looking for serp_search step:', serpStep)\n              console.log('[SCRAPE] serp_search output:', serpStep?.output)\n\n              // Try to get jobId from either step\n              let jobId = (searchStep?.output as { jobId?: string })?.jobId ||\n                          (serpStep?.output as { jobId?: string })?.jobId\n\n              // If still no jobId, try from input (might be passed from ReviewAndScrapePanel)\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n                console.log('[SCRAPE] Got jobId from input:', jobId)\n              }\n\n              if (!jobId) {\n                console.error('[SCRAPE] No jobId found. All steps:', state.phases.flatMap(p => p.steps).map(s => ({ id: s.id, output: s.output })))\n                throw new Error('No se encontró el Job ID del paso de búsqueda')\n              }\n\n              console.log('[SCRAPE] Starting scrape for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando scraping...' }\n              })\n\n              // Get total URLs to scrape\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.urls_found || 0\n\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Scrapeando 0/${totalUrls} URLs...` }\n              })\n\n              // Start scraping - this will scrape in batches\n              let scrapedCount = 0\n              let failedCount = 0\n              let hasMore = true\n\n              while (hasMore) {\n                try {\n                  const scrapeResponse = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = scrapeResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[SCRAPE] Non-JSON response, continuing...')\n                    // Wait a bit and continue polling\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'scrape_done') {\n                      hasMore = false\n                      scrapedCount = checkData.job?.scrape_success_count || 0\n                      failedCount = checkData.job?.scrape_failed_count || 0\n                    }\n                    continue\n                  }\n\n                  const scrapeData = await scrapeResponse.json()\n                  console.log('[SCRAPE] Batch response:', scrapeData)\n\n                  if (scrapeData.error) {\n                    throw new Error(scrapeData.error)\n                  }\n\n                  scrapedCount += scrapeData.scraped || 0\n                  failedCount += scrapeData.failed || 0\n                  hasMore = scrapeData.has_more || false\n\n                  // Update progress with real-time feedback\n                  updateStepState(stepId, {\n                    progress: {\n                      current: scrapedCount + failedCount,\n                      total: totalUrls,\n                      label: `Scrapeando ${scrapedCount + failedCount}/${totalUrls} URLs...`,\n                    },\n                    partialResults: {\n                      successCount: scrapedCount,\n                      failedCount: failedCount,\n                      lastUrl: scrapeData.last_scraped_url,\n                      lastSnippet: scrapeData.last_scraped_snippet,\n                    },\n                  })\n\n                } catch (scrapeError) {\n                  console.error('[SCRAPE] Batch error:', scrapeError)\n                  // Don't throw - try to continue with next batch\n                  // The endpoint will mark failed URLs and continue\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'scrape_done' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Scraping failed')\n                    }\n                  }\n                }\n              }\n\n              // Mark as completed\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  scrapedCount,\n                  failedCount,\n                },\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            if (step.jobType === 'niche_finder_extract') {\n              // Get jobId from previous steps (review_and_scrape or scrape_results)\n              const scrapeResultsStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'scrape_results')\n              const reviewAndScrapeStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'review_and_scrape')\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n\n              console.log('[EXTRACT] Looking for jobId from steps:', {\n                scrape_results: scrapeResultsStep?.output,\n                review_and_scrape: reviewAndScrapeStep?.output,\n                search_and_preview: searchStep?.output,\n              })\n\n              let jobId = (scrapeResultsStep?.output as { jobId?: string })?.jobId ||\n                          (reviewAndScrapeStep?.output as { jobId?: string })?.jobId ||\n                          (searchStep?.output as { jobId?: string })?.jobId\n\n              // Also try from input\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n              }\n\n              if (!jobId) {\n                console.error('[EXTRACT] No jobId found')\n                throw new Error('No se encontró el Job ID. Por favor ejecuta los pasos anteriores primero.')\n              }\n\n              console.log('[EXTRACT] Starting extraction for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' }\n              })\n\n              // Get total URLs to extract from job status\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.scrape_success_count || 0\n\n              console.log('[EXTRACT] Total URLs to process:', totalUrls)\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` }\n              })\n\n              // Call extract endpoint in batches until has_more=false\n              let hasMore = true\n              let extractedTotal = 0\n              let filteredTotal = 0\n              let processedTotal = 0\n\n              while (hasMore) {\n                try {\n                  const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = extractResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[EXTRACT] Non-JSON response, polling status...')\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'completed') {\n                      hasMore = false\n                      extractedTotal = checkData.job?.niches_extracted || 0\n                    }\n                    continue\n                  }\n\n                  const extractData = await extractResponse.json()\n                  console.log('[EXTRACT] Batch response:', extractData)\n\n                  if (extractData.error) {\n                    throw new Error(extractData.error)\n                  }\n\n                  extractedTotal += extractData.extracted || 0\n                  filteredTotal += extractData.filtered || 0\n                  processedTotal = extractedTotal + filteredTotal\n                  hasMore = extractData.has_more || false\n\n                  updateStepState(stepId, {\n                    progress: {\n                      current: processedTotal,\n                      total: totalUrls,\n                      label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                    },\n                    partialResults: {\n                      successCount: extractedTotal,\n                      failedCount: filteredTotal,\n                    },\n                  })\n                } catch (extractError) {\n                  console.error('[EXTRACT] Batch error:', extractError)\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'completed' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Extraction failed')\n                    }\n                  }\n                }\n              }\n\n              // Get extracted problems and format as CSV\n              console.log('[EXTRACT] Getting results from /api/niche-finder/results/', jobId)\n              const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n\n              if (!resultsResponse.ok) {\n                console.error('[EXTRACT] Failed to get results:', resultsResponse.status, resultsResponse.statusText)\n                throw new Error(`Error obteniendo resultados: ${resultsResponse.status}`)\n              }\n\n              const resultsData = await resultsResponse.json()\n              console.log('[EXTRACT] Results data:', {\n                hasNiches: !!resultsData.niches,\n                nichesCount: resultsData.niches?.length || 0,\n                status: resultsData.status,\n                urls: resultsData.urls,\n              })\n\n              // Format niches as CSV string with all relevant columns\n              const niches = resultsData.niches || []\n              let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n              for (const niche of niches) {\n                const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                const url = niche.source_url || ''\n                csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n              }\n\n              console.log('[EXTRACT] Completed. Total problems:', niches.length, 'CSV preview:', csvOutput.substring(0, 200))\n\n              // Mark as completed with CSV output\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: csvOutput,\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            // UNIFIED SEARCH + EXTRACT: Handles both SERP and analysis in one step\n            if (step.jobType === 'niche_finder_unified') {\n              const action = (input as { action?: string })?.action\n\n              // ============ ACTION: SERP ============\n              if (action === 'serp') {\n                const config = (input as { config?: { life_contexts: string[]; product_words: string[]; indicators: string[]; sources: { reddit: boolean; thematic_forums: boolean; general_forums: string[] }; serp_pages: number } }).config\n                if (!config) {\n                  throw new Error('No se recibió configuración para la búsqueda')\n                }\n\n                console.log('[UNIFIED] Starting SERP with config:', config)\n\n                // Get campaign variables\n                const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                // Create the SERP job\n                const jobResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: {\n                      ...config,\n                      campaign_id: selectedCampaignId,\n                      ecp_name: campaignVars?.['ECP Name'] || campaignVars?.ecp_name,\n                      ecp_product: campaignVars?.['ECP Product'] || campaignVars?.ecp_product,\n                      ecp_target: campaignVars?.['ECP Target'] || campaignVars?.ecp_target,\n                      ecp_industry: campaignVars?.['ECP Industry'] || campaignVars?.ecp_industry,\n                      ecp_category: campaignVars?.['ECP Category'] || campaignVars?.ecp_category,\n                      ecp_country: campaignVars?.['ECP Country'] || campaignVars?.ecp_country,\n                    }\n                  }),\n                })\n\n                if (!jobResponse.ok) {\n                  const errorText = await jobResponse.text()\n                  throw new Error(`Error al crear job: ${jobResponse.status} - ${errorText || 'Sin respuesta'}`)\n                }\n\n                const jobText = await jobResponse.text()\n                if (!jobText || jobText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al crear el job')\n                }\n\n                const jobData = JSON.parse(jobText)\n                const jobId = jobData.job_id\n\n                if (!jobId) {\n                  throw new Error('No se pudo crear el job de búsqueda')\n                }\n\n                console.log('[UNIFIED] SERP Job created:', jobId)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'serp_executing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' },\n                })\n\n                // Start SERP execution\n                const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n\n                if (!serpResponse.ok) {\n                  const serpErrorText = await serpResponse.text()\n                  let errorMessage = `Error al iniciar búsqueda SERP: ${serpResponse.status}`\n                  try {\n                    const serpError = JSON.parse(serpErrorText)\n                    if (serpError.code === 'MISSING_API_KEY') {\n                      errorMessage = `${serpError.error}`\n                    } else if (serpError.error) {\n                      errorMessage = serpError.error\n                    }\n                  } catch {\n                    if (serpErrorText) errorMessage += ` - ${serpErrorText}`\n                  }\n                  throw new Error(errorMessage)\n                }\n\n                console.log('[UNIFIED] SERP execution started successfully')\n\n                // Poll for SERP completion\n                let serpComplete = false\n                let pollRetries = 0\n                const MAX_POLL_RETRIES = 3\n                while (!serpComplete) {\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n                  try {\n                    const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n\n                    if (!statusRes.ok) {\n                      console.warn(`[UNIFIED] Status poll failed with ${statusRes.status}`)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error(`Error al consultar estado del job: ${statusRes.status}`)\n                      }\n                      continue\n                    }\n\n                    const text = await statusRes.text()\n                    if (!text || text.trim() === '') {\n                      console.warn('[UNIFIED] Empty response from status endpoint, retrying...')\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('El servidor no está respondiendo correctamente')\n                      }\n                      continue\n                    }\n\n                    const statusData = JSON.parse(text)\n                    pollRetries = 0 // Reset retries on success\n\n                    const urlsFound = statusData.job?.urls_found || 0\n                    // Status API returns serp_total and serp_completed (not total_queries/completed_queries)\n                    const totalSearches = statusData.job?.serp_total || statusData.progress?.serp?.total || 0\n                    const completedSearches = statusData.job?.serp_completed || statusData.progress?.serp?.completed || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: completedSearches,\n                        total: totalSearches,\n                        label: `Buscando... ${urlsFound} URLs encontradas`,\n                      },\n                    })\n\n                    if (['serp_done', 'serp_completed', 'scrape_done', 'completed'].includes(statusData.status)) {\n                      serpComplete = true\n                      console.log('[UNIFIED] SERP completed. URLs found:', urlsFound)\n                      updateStepState(stepId, {\n                        output: { jobId, phase: 'serp_complete', urlsFound },\n                        progress: undefined,\n                      })\n                    } else if (statusData.status === 'failed') {\n                      throw new Error(statusData.job?.error_message || 'SERP falló')\n                    }\n                  } catch (pollError) {\n                    if (pollError instanceof SyntaxError) {\n                      console.warn('[UNIFIED] JSON parse error in poll, retrying...', pollError)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('Error al procesar respuesta del servidor')\n                      }\n                    } else {\n                      throw pollError\n                    }\n                  }\n                }\n                return // Don't mark as completed - wait for analyze action\n              }\n\n              // ============ ACTION: ANALYZE (Scrape + Extract) ============\n              if (action === 'analyze') {\n                const jobId = (input as { jobId?: string }).jobId\n                const selectedSources = (input as { selectedSources?: string[] }).selectedSources || []\n                const extractionPrompt = (input as { extractionPrompt?: string }).extractionPrompt\n\n                if (!jobId) {\n                  throw new Error('No se encontró el Job ID')\n                }\n\n                console.log('[UNIFIED] Starting analysis for job:', jobId, 'sources:', selectedSources, 'custom prompt:', !!extractionPrompt)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'analyzing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando análisis...' },\n                })\n\n                // If a custom extraction prompt was provided, update the job config\n                if (extractionPrompt) {\n                  console.log('[UNIFIED] Updating job with custom extraction prompt')\n                  const updateRes = await fetch(`/api/niche-finder/jobs/${jobId}`, {\n                    method: 'PATCH',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ extraction_prompt: extractionPrompt }),\n                  })\n                  if (!updateRes.ok) {\n                    console.warn('[UNIFIED] Failed to update job with custom prompt:', updateRes.status)\n                  }\n                }\n\n                // Get total URLs to process\n                const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                if (!statusRes.ok) {\n                  throw new Error(`Error al obtener estado del job: ${statusRes.status}`)\n                }\n                const statusText = await statusRes.text()\n                if (!statusText || statusText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al consultar estado')\n                }\n                const statusData = JSON.parse(statusText)\n                const totalUrls = statusData.job?.urls_found || 0\n\n                // Start scraping - call API repeatedly until all URLs are processed\n                console.log('[UNIFIED] Starting scrape for', totalUrls, 'URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: totalUrls, label: 'Descargando contenido...' },\n                })\n\n                let scrapeComplete = false\n                let scrapeRetries = 0\n                let totalScraped = 0\n                let totalFailed = 0\n                const MAX_SCRAPE_RETRIES = 5 // More retries for transient failures\n\n                while (!scrapeComplete) {\n                  try {\n                    console.log(`[UNIFIED] Scrape batch starting, totalScraped=${totalScraped}, retries=${scrapeRetries}`)\n\n                    // Call scrape API with timeout (120s to allow for slow scrapes)\n                    const controller = new AbortController()\n                    const timeout = setTimeout(() => controller.abort(), 120000)\n\n                    const scrapeRes = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                      method: 'POST',\n                      headers: { 'Content-Type': 'application/json' },\n                      body: JSON.stringify({ sources: selectedSources }),\n                      signal: controller.signal,\n                    })\n                    clearTimeout(timeout)\n\n                    if (!scrapeRes.ok) {\n                      const errorText = await scrapeRes.text().catch(() => '')\n                      console.error(`[UNIFIED] Scrape response not ok: ${scrapeRes.status}`, errorText)\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(`Error en scraping: ${scrapeRes.status} - ${errorText || 'Unknown error'}`)\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeText = await scrapeRes.text()\n                    if (!scrapeText) {\n                      console.warn('[UNIFIED] Empty scrape response, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Respuesta vacía del servidor después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeData = JSON.parse(scrapeText)\n                    scrapeRetries = 0 // Reset on successful response\n\n                    if (scrapeData.error) {\n                      // Check if it's a retryable error\n                      if (scrapeData.error.includes('Rate limit') || scrapeData.error.includes('timeout')) {\n                        console.warn(`[UNIFIED] Retryable scrape error: ${scrapeData.error}`)\n                        scrapeRetries++\n                        if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(scrapeData.error)\n                        await new Promise(r => setTimeout(r, 5000))\n                        continue\n                      }\n                      throw new Error(scrapeData.error)\n                    }\n\n                    // Update progress with scraped count from this batch\n                    totalScraped += scrapeData.scraped || 0\n                    totalFailed += scrapeData.failed || 0\n                    const remaining = scrapeData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: totalScraped,\n                        total: totalUrls,\n                        label: `Descargando... ${totalScraped}/${totalUrls} URLs${totalFailed > 0 ? ` (${totalFailed} fallidas)` : ''}`,\n                      },\n                      partialResults: {\n                        successCount: totalScraped,\n                        failedCount: totalFailed,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Scrape batch complete: +${scrapeData.scraped} scraped, ${remaining} remaining, has_more: ${scrapeData.has_more}`)\n\n                    // Check if scraping is complete\n                    if (!scrapeData.has_more || remaining === 0) {\n                      scrapeComplete = true\n                    }\n                  } catch (e) {\n                    console.error('[UNIFIED] Scrape error:', e)\n                    if (e instanceof SyntaxError) {\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 3000))\n                    } else if (e instanceof Error && e.name === 'AbortError') {\n                      // Timeout - retry with longer wait\n                      console.warn('[UNIFIED] Scrape request timed out, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Timeout en scraping después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 5000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Scraping complete, total scraped:', totalScraped)\n\n                // Start extraction - use totalScraped as the base since only scraped URLs can be extracted\n                const extractionTotal = totalScraped || totalUrls // Fallback to totalUrls if scraping tracked differently\n                console.log('[UNIFIED] Starting extraction for', extractionTotal, 'scraped URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: extractionTotal, label: 'Extrayendo problemas...' },\n                })\n\n                let extractComplete = false\n                let extractedTotal = 0\n                let filteredTotal = 0\n                let extractRetries = 0\n\n                while (!extractComplete) {\n                  try {\n                    const extractRes = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, { method: 'POST' })\n                    if (!extractRes.ok) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error(`Error en extracción: ${extractRes.status}`)\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const text = await extractRes.text()\n                    if (!text) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Respuesta vacía del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const extractData = JSON.parse(text)\n                    extractRetries = 0\n\n                    if (extractData.error) {\n                      throw new Error(extractData.error)\n                    }\n\n                    extractedTotal += extractData.extracted || 0\n                    filteredTotal += extractData.filtered || 0\n                    const processed = extractedTotal + filteredTotal\n                    const remaining = extractData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: processed,\n                        total: extractionTotal,\n                        label: `Extrayendo... ${extractedTotal} problemas de ${processed}/${extractionTotal} URLs${filteredTotal > 0 ? ` (${filteredTotal} filtradas)` : ''}`,\n                      },\n                      partialResults: {\n                        extracted: extractedTotal,\n                        filtered: filteredTotal,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Extract batch: ${extractData.extracted} extracted, ${extractData.filtered} filtered, ${remaining} remaining, has_more: ${extractData.has_more}`)\n\n                    if (!extractData.has_more || remaining === 0) {\n                      extractComplete = true\n                    }\n                  } catch (e) {\n                    if (e instanceof SyntaxError) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Extraction complete. Problems:', extractedTotal, 'Filtered:', filteredTotal)\n\n                // Get results and format as CSV\n                console.log('[UNIFIED] Getting results')\n                const resultsRes = await fetch(`/api/niche-finder/results/${jobId}`)\n                if (!resultsRes.ok) {\n                  throw new Error(`Error al obtener resultados: ${resultsRes.status}`)\n                }\n                const resultsText = await resultsRes.text()\n                const resultsData = resultsText ? JSON.parse(resultsText) : { niches: [] }\n                const niches = resultsData.niches || []\n\n                let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n                for (const niche of niches) {\n                  const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                  const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                  const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                  const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                  const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                  const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                  const url = niche.source_url || ''\n                  csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n                }\n\n                console.log('[UNIFIED] Complete. Problems:', niches.length)\n                updateStepState(stepId, {\n                  status: 'completed',\n                  completedAt: new Date(),\n                  output: { jobId, extractedCount: niches.length, csv: csvOutput },\n                })\n                setTimeout(goToNextStep, 500)\n                return\n              }\n\n              // Unknown action\n              console.warn('[UNIFIED] Unknown action:', action)\n            }\n\n            // For other job types, just mark as pending\n            result = input\n            break\n\n          case 'none':\n          default:\n            // No execution needed, just proceed\n            result = input\n            break\n        }\n\n        // Mark as completed\n        updateStepState(stepId, {\n          status: 'completed',\n          completedAt: new Date(),\n          output: result,\n        })\n\n        // Auto-advance for auto steps\n        if (['auto', 'auto_with_review'].includes(step.type)) {\n          setTimeout(goToNextStep, 500)\n        }\n      } catch (error) {\n        updateStepState(stepId, {\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Error desconocido',\n        })\n      }\n    },\n    [projectId, playbookConfig.type, playbookConfig.phases, updateStepState, goToNextStep, selectedCampaign, state.phases]\n  )\n\n  // Handle continue from current step\n  const handleContinue = useCallback(() => {\n    console.log('[handleContinue] Called for step:', currentStep?.id, 'current status:', currentStepState?.status)\n    // Note: Don't update step state here if the caller (WorkArea) already updated it.\n    // The caller is responsible for setting status and output correctly before calling onContinue.\n    // We only set completedAt if not already completed, and we do it in a way that preserves output.\n    if (currentStepState?.status !== 'completed') {\n      console.log('[handleContinue] Status is not completed, updating step state (without output)')\n      // Mark as completed, but preserve any existing output that might have been set\n      // by the caller in the same tick (before React re-renders)\n      updateStepState(currentStep.id, {\n        status: 'completed',\n        completedAt: new Date(),\n        // Don't set output - it should already be set by the caller\n      })\n    } else {\n      console.log('[handleContinue] Status is already completed, not updating')\n    }\n    // Enable auto-execution for the next step (if it's an auto step)\n    setShouldAutoExecute(true)\n    goToNextStep()\n  }, [currentStep?.id, currentStepState?.status, updateStepState, goToNextStep])\n\n  // Handle edit - volver a editar un paso completado\n  const handleEdit = useCallback(() => {\n    if (!currentStep) return\n    // Cambiar status a pending sin perder los datos (suggestions, output, etc.)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      completedAt: undefined,\n      error: undefined,\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle cancel - cancelar ejecución en curso\n  // IMPORTANTE: Mantiene el output (jobId) para poder retomar el job\n  const handleCancel = useCallback(() => {\n    if (!currentStep) return\n\n    // Clear polling interval if running\n    if (pollIntervalRef.current) {\n      clearInterval(pollIntervalRef.current)\n      pollIntervalRef.current = null\n      console.log('[Cancel] Cleared polling interval')\n    }\n\n    // Volver a pending y limpiar progreso, pero MANTENER output (contiene jobId)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      progress: undefined,\n      error: undefined,\n      // NO limpiamos output para mantener el jobId y poder retomar\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle quick retry - retry with same configuration\n  const handleQuickRetry = useCallback(async () => {\n    if (!currentStep || !currentStepState) return\n\n    console.log('[Retry] Quick retry for step:', currentStep.id)\n\n    // Start a new retry attempt\n    try {\n      await stepRetryActions.startRetry(currentStep.id)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Reset step state and re-execute\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input\n    executeStep(currentStep.id, currentStepState.input)\n  }, [currentStep, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle retry with config modification - opens dialog\n  const handleRetryWithConfig = useCallback(() => {\n    if (!currentStep) return\n    setRetryDialogStepId(currentStep.id)\n    setRetryDialogOpen(true)\n  }, [currentStep])\n\n  // Handle retry from dialog with config overrides\n  const handleRetryFromDialog = useCallback(async (configOverrides?: StepAttemptConfig) => {\n    if (!retryDialogStepId || !currentStepState) return\n\n    console.log('[Retry] Retry from dialog for step:', retryDialogStepId, 'with config:', configOverrides)\n\n    // Start a new retry attempt with config\n    try {\n      await stepRetryActions.startRetry(retryDialogStepId, configOverrides)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Close dialog\n    setRetryDialogOpen(false)\n    setRetryDialogStepId(null)\n\n    // Reset step state\n    updateStepState(retryDialogStepId, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input (config overrides are tracked in the attempt)\n    executeStep(retryDialogStepId, currentStepState.input)\n  }, [retryDialogStepId, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle skip step - mark as skipped and continue\n  const handleSkipStep = useCallback(() => {\n    if (!currentStep) return\n\n    console.log('[Skip] Skipping step:', currentStep.id)\n\n    updateStepState(currentStep.id, {\n      status: 'skipped',\n      completedAt: new Date(),\n      error: undefined,\n    })\n\n    // Move to next step\n    handleContinue()\n  }, [currentStep, updateStepState, handleContinue])\n\n  // Get retry info for current step\n  const currentStepRetryInfo = currentStep\n    ? stepRetryActions.getRetryInfo(currentStep.id)\n    : null\n\n  // Check if max retries reached\n  const maxRetriesReached = currentStepRetryInfo\n    ? currentStepRetryInfo.attemptNumber >= currentStepRetryInfo.maxAttempts\n    : false\n\n  // Auto-start current step if it's an auto step, pending, AND user clicked Continue\n  useEffect(() => {\n    console.log('[AutoExecute] Check:', {\n      shouldAutoExecute,\n      currentStepId: currentStep?.id,\n      currentStepType: currentStep?.type,\n      currentStepStatus: currentStepState?.status,\n    })\n    if (\n      shouldAutoExecute &&\n      currentStep &&\n      currentStepState?.status === 'pending' &&\n      ['auto'].includes(currentStep.type)\n    ) {\n      console.log('[AutoExecute] Starting auto execution for:', currentStep.id)\n      // Reset the flag\n      setShouldAutoExecute(false)\n      // Small delay to allow UI to render first\n      const timer = setTimeout(() => {\n        executeStep(currentStep.id)\n      }, 300)\n      return () => clearTimeout(timer)\n    }\n  }, [shouldAutoExecute, currentStep, currentStepState?.status, executeStep])\n\n  // Resume polling for in_progress steps on page reload\n  // This handles the case where user refreshes the page while a SERP job is running\n  useEffect(() => {\n    // Only for search_with_preview steps that are in_progress with a jobId\n    if (\n      currentStep?.type === 'search_with_preview' &&\n      (currentStepState?.status === 'in_progress' || currentStepState?.status === 'pending') &&\n      currentStepState?.output &&\n      !pollIntervalRef.current\n    ) {\n      const output = currentStepState.output as { jobId?: string }\n      const jobId = output.jobId\n\n      if (jobId) {\n        console.log('[Resume] Resuming polling for job:', jobId)\n\n        // First, check if job is already done (immediate check, not polling)\n        fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          .then(res => res.json())\n          .then(statusData => {\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDone) {\n              console.log('[Resume] Job already completed, marking step as done')\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n              return // Don't start polling\n            }\n            // If not done, continue with normal polling setup below\n            startPolling()\n          })\n          .catch(err => {\n            console.error('[Resume] Error checking initial status:', err)\n            startPolling() // Start polling anyway\n          })\n\n        function startPolling() {\n          if (pollIntervalRef.current) return // Already polling\n\n          // Set up polling - same logic as in executeStep\n          let isResuming = false\n          let lastCompletedCount = -1\n          let stallCount = 0\n          let initialCompleted = -1\n\n          pollIntervalRef.current = setInterval(async () => {\n          try {\n            const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n            const statusData = await statusResponse.json()\n\n            const completed = statusData.progress?.serp?.completed || 0\n            const total = statusData.progress?.serp?.total || 0\n            const remaining = total - completed\n            const label = total > 0\n              ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n              : 'Reconectando...'\n\n            updateStepState(currentStep.id, {\n              progress: {\n                current: completed,\n                total: total,\n                label,\n              },\n            })\n\n            // Track initial value on first poll\n            if (initialCompleted === -1) {\n              initialCompleted = completed\n              console.log('[Resume] Initial completed:', initialCompleted)\n            }\n\n            // Auto-resume if job was interrupted\n            if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n              if (lastCompletedCount === completed && remaining > 0) {\n                stallCount++\n                const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                if (stallCount >= 2 || noProgressSinceStart) {\n                  console.log(`[Resume] Job stalled at ${completed}/${total}, auto-resuming...`)\n                  isResuming = true\n                  stallCount = 0\n                  fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                    .then(res => res.json())\n                    .then(data => {\n                      console.log('[Resume] Resume response:', data)\n                      isResuming = false\n                    })\n                    .catch(err => {\n                      console.error('[Resume] Resume error:', err)\n                      isResuming = false\n                    })\n                }\n              } else {\n                stallCount = 0\n              }\n            }\n            lastCompletedCount = completed\n\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDoneInPoll = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDoneInPoll) {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n            } else if (statusData.status === 'failed' || statusData.status === 'error') {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'error',\n                error: statusData.job?.error_message || 'Job failed',\n              })\n            }\n          } catch (pollError) {\n            console.error('[Resume] Poll error:', pollError)\n            // Don't stop polling on transient errors\n          }\n        }, 2000)\n        } // End startPolling function\n\n        // Cleanup on unmount\n        return () => {\n          if (pollIntervalRef.current) {\n            clearInterval(pollIntervalRef.current)\n            pollIntervalRef.current = null\n          }\n        }\n      }\n    }\n  }, [currentStep?.id, currentStep?.type, currentStepState?.status, currentStepState?.output, updateStepState, goToNextStep])\n\n  if (!currentPhase || !currentStep || !currentStepState) {\n    return (\n      <div className=\"flex items-center justify-center h-64 text-gray-500\">\n        Error: Configuración de playbook inválida\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n      {/* Header with mode selector */}\n      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3\">\n          <span className=\"text-xl\">{playbookConfig.icon}</span>\n          <h2 className=\"text-lg font-semibold text-gray-900\">{playbookConfig.name}</h2>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {/* Session Data button */}\n          {selectedCampaignId && mode === 'campaign' && (\n            <button\n              onClick={() => setShowArtifactBrowser(!showArtifactBrowser)}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                showArtifactBrowser\n                  ? 'bg-indigo-100 text-indigo-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n              title=\"Browse all session artifacts\"\n            >\n              <Database size={16} />\n              Session Data\n            </button>\n          )}\n\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}\n          <div className=\"relative flex items-center gap-1\">\n            <button\n              onClick={() => {\n                setMode('campaign')\n                setShowCampaignDropdown(!showCampaignDropdown)\n              }}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                mode === 'campaign'\n                  ? 'bg-blue-100 text-blue-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Folder size={16} />\n              {selectedCampaign ? selectedCampaign.name : 'Seleccionar Campaña'}\n              <ChevronDown size={16} />\n            </button>\n\n            {/* Edit campaign settings button */}\n            {selectedCampaignId && (\n              <button\n                onClick={() => setShowCampaignSettings(true)}\n                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg\"\n                title=\"Editar configuración de campaña\"\n              >\n                <Pencil size={14} />\n              </button>\n            )}\n\n            {/* Dropdown */}\n            {showCampaignDropdown && (\n              <div className=\"absolute right-0 top-full mt-1 w-64 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50\">\n                {campaigns.length === 0 ? (\n                  <div className=\"px-3 py-2 text-sm text-gray-500\">No hay campañas</div>\n                ) : (\n                  campaigns.map(campaign => (\n                    <div\n                      key={campaign.id}\n                      className={`flex items-center justify-between px-3 py-2 text-sm hover:bg-gray-50 ${\n                        selectedCampaignId === campaign.id ? 'bg-blue-50' : ''\n                      }`}\n                    >\n                      <button\n                        onClick={() => {\n                          setSelectedCampaignId(campaign.id)\n                          setShowCampaignDropdown(false)\n                        }}\n                        className=\"flex-1 flex items-center justify-between text-left\"\n                      >\n                        <span className=\"font-medium text-gray-900\">{campaign.name}</span>\n                        <span className=\"text-gray-500 mr-2\">\n                          {campaign.completedSteps}/{campaign.totalSteps}\n                        </span>\n                      </button>\n                      <button\n                        onClick={(e) => {\n                          e.stopPropagation()\n                          deleteCampaign(campaign.id)\n                        }}\n                        className=\"p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded\"\n                        title=\"Eliminar campaña\"\n                      >\n                        <Trash2 size={14} />\n                      </button>\n                    </div>\n                  ))\n                )}\n                <div className=\"border-t border-gray-100 mt-1 pt-1\">\n                  <button\n                    onClick={() => {\n                      setShowWizard(true)\n                      setShowCampaignDropdown(false)\n                    }}\n                    className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-blue-600 hover:bg-blue-50\"\n                  >\n                    <Plus size={16} />\n                    Nueva Campaña\n                  </button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Main content */}\n      {mode === 'config' ? (\n        /* Configuration Mode - Full width */\n        <div className=\"flex-1 overflow-hidden\">\n          <ConfigurationMode\n            projectId={projectId}\n            playbookConfig={playbookConfig}\n            onSave={() => {\n              // Optionally refresh something after save\n            }}\n          />\n        </div>\n      ) : (\n        /* Campaign Mode - Dual panel */\n        <div className=\"flex flex-1 overflow-hidden\">\n          {/* Navigation Panel - Left side */}\n          <div className=\"w-80 flex-shrink-0\">\n            <NavigationPanel\n              phases={playbookConfig.phases}\n              phaseStates={state.phases}\n              currentPhaseIndex={state.currentPhaseIndex}\n              currentStepIndex={state.currentStepIndex}\n              onStepClick={goToStep}\n            />\n          </div>\n\n          {/* Work Area - Right side */}\n          <div className=\"flex-1 overflow-y-auto\">\n            {!selectedCampaignId ? (\n              /* No campaign selected - prompt to select or create */\n              <div className=\"flex flex-col items-center justify-center h-full bg-white p-8 text-center\">\n                <Folder className=\"text-gray-300 mb-4\" size={64} />\n                <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                  Selecciona o crea una campaña\n                </h3>\n                <p className=\"text-gray-500 mb-6 max-w-md\">\n                  Para ejecutar el playbook, primero debes seleccionar una campaña existente o crear una nueva.\n                </p>\n                <button\n                  onClick={() => setShowWizard(true)}\n                  className=\"flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n                >\n                  <Plus size={16} />\n                  Nueva Campaña\n                </button>\n              </div>\n            ) : (\n              <>\n                <WorkArea\n                  step={currentStep}\n                  stepState={currentStepState}\n                  onContinue={handleContinue}\n                  onBack={goToPreviousStep}\n                  onExecute={(input) => executeStep(currentStep.id, input)}\n                  onUpdateState={(update) => updateStepState(currentStep.id, update)}\n                  onEdit={handleEdit}\n                  onCancel={handleCancel}\n                  onRerunPrevious={rerunPreviousStep}\n                  onRetry={handleQuickRetry}\n                  onRetryWithConfig={handleRetryWithConfig}\n                  onSkipStep={handleSkipStep}\n                  isFirst={isFirstStep}\n                  isLast={isLastStep}\n                  previousStepOutput={getPreviousStepOutput()}\n                  projectId={projectId}\n                  playbookContext={buildPlaybookContext()}\n                  allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                    phase.steps.map((stepDef, stepIdx) => ({\n                      definition: stepDef,\n                      state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                    }))\n                  )}\n                  saveState={sessionId ? stepPersistenceState : undefined}\n                  retryInfo={currentStepRetryInfo || undefined}\n                  maxRetriesReached={maxRetriesReached}\n                  sessionId={sessionId}\n                />\n\n                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Campaign Wizard Modal */}\n      {showWizard && (\n        <CampaignWizard\n          projectId={projectId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowWizard(false)}\n          onCreated={(campaignId) => {\n            setSelectedCampaignId(campaignId)\n            setShowWizard(false)\n            // Reload campaigns\n            loadCampaigns()\n          }}\n        />\n      )}\n\n      {/* Campaign Settings Modal */}\n      {showCampaignSettings && selectedCampaignId && (\n        <CampaignSettings\n          campaignId={selectedCampaignId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowCampaignSettings(false)}\n          onSaved={() => {\n            loadCampaigns()\n          }}\n        />\n      )}\n    </div>\n  )\n}\n","structuredPatch":[{"oldStart":2833,"oldLines":6,"newStart":2833,"newLines":31,"lines":["               </>","             )}","           </div>","+","+          {/* Artifact Browser Panel - Right side */}","+          {showArtifactBrowser && selectedCampaignId && (","+            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">","+              <ArtifactBrowser","+                sessionId={sessionId}","+                projectId={projectId}","+                clientId=\"\"","+                userId=\"system\"","+                campaignId={selectedCampaignId}","+                campaignName={selectedCampaign?.name || ''}","+                playbookId={playbookConfig.id}","+                playbookName={playbookConfig.name}","+                playbookType={playbookConfig.type}","+                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>","+                  phase.steps.map((stepDef, stepIdx) => ({","+                    definition: stepDef,","+                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },","+                  }))","+                )}","+                isVisible={showArtifactBrowser}","+                onClose={() => setShowArtifactBrowser(false)}","+              />","+            </div>","+          )}","         </div>","       )}"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JxXz4WBVXpCaX5UJYXH46w","type":"message","role":"assistant","content":[{"type":"text","text":"I need to get the actual clientId and userId. Let me check how the project data is accessed:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1180,"cache_read_input_tokens":129176,"cache_creation":{"ephemeral_5m_input_tokens":1180,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"fded3801-4639-49cf-95e8-27318c0598da"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JxXz4WBVXpCaX5UJYXH46w","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012TJnFZrvvwLZeatKbiu51N","name":"Grep","input":{"pattern":"projectData|client_id|getProject","path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","output_mode":"content","-n":true,"-C":3}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1180,"cache_read_input_tokens":129176,"cache_creation":{"ephemeral_5m_input_tokens":1180,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"9b47b718-be1f-45cf-9638-6402561bfbec"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012TJnFZrvvwLZeatKbiu51N","type":"tool_result","content":"1106-\n1107-          // Save results to Context Lake automatically\n1108-          try {\n1109:            // Get project data (includes client_id)\n1110-            const projectResponse = await fetch(`/api/projects/${projectId}`)\n1111:            const projectData = await projectResponse.json()\n1112-\n1113-            // Get extracted niches for CSV content\n1114-            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n--\n1144-\n1145-            const dateStr = new Date().toISOString().split('T')[0]\n1146-            const campaignSlug = selectedCampaign?.name?.toLowerCase().replace(/\\s+/g, '-') || 'sin-nombre'\n1147:            const projectSlug = projectData.name?.toLowerCase().replace(/\\s+/g, '-') || 'proyecto'\n1148-\n1149-            const documentData = {\n1150-              projectId: projectId,\n1151:              clientId: projectData.client_id,\n1152-              filename: `Niche Finder - ${selectedCampaign?.name || 'Sin nombre'} - ${dateStr}`,\n1153-              category: 'research',\n1154-              content: csvContent,"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"e8da0254-7ab2-4ca8-9f61-405f9f9618eb","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"1106-\n1107-          // Save results to Context Lake automatically\n1108-          try {\n1109:            // Get project data (includes client_id)\n1110-            const projectResponse = await fetch(`/api/projects/${projectId}`)\n1111:            const projectData = await projectResponse.json()\n1112-\n1113-            // Get extracted niches for CSV content\n1114-            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n--\n1144-\n1145-            const dateStr = new Date().toISOString().split('T')[0]\n1146-            const campaignSlug = selectedCampaign?.name?.toLowerCase().replace(/\\s+/g, '-') || 'sin-nombre'\n1147:            const projectSlug = projectData.name?.toLowerCase().replace(/\\s+/g, '-') || 'proyecto'\n1148-\n1149-            const documentData = {\n1150-              projectId: projectId,\n1151:              clientId: projectData.client_id,\n1152-              filename: `Niche Finder - ${selectedCampaign?.name || 'Sin nombre'} - ${dateStr}`,\n1153-              category: 'research',\n1154-              content: csvContent,","numLines":21}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MycRUguwVRkT2N2pFZax3v","type":"message","role":"assistant","content":[{"type":"text","text":"I see. The clientId comes from the project data which is fetched asynchronously. For a simpler integration, I could:\n1. Add a state to store the project data/clientId\n2. Or pass it through props\n\nLet me check if there's a simpler approach - perhaps getting it from props or context. Let me look at how the component is used:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":513,"cache_read_input_tokens":130356,"cache_creation":{"ephemeral_5m_input_tokens":513,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"babf8c55-e593-4f5e-a252-0b3c7d4cf9ed"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MycRUguwVRkT2N2pFZax3v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LhNZRxyvSaUf4Wdgzfo5Vo","name":"Grep","input":{"pattern":"PlaybookShell","path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":513,"cache_read_input_tokens":130356,"cache_creation":{"ephemeral_5m_input_tokens":513,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"1f2c909f-9fb0-40b8-9d77-ed1f3081612b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LhNZRxyvSaUf4Wdgzfo5Vo","type":"tool_result","content":"Found 6 files\nsrc/components/playbook/PlaybookShell.tsx\nsrc/components/playbook/types.ts\nsrc/components/playbook/index.ts\nsrc/components/niche-finder/NicheFinderPlaybookV2.tsx\nsrc/types/scraper.types.ts\nsrc/components/video-viral-ia/VideoViralIAPlaybook.tsx"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"3e0cff7c-9767-4451-a81e-e744dda2f247","tool_use_result":{"mode":"files_with_matches","filenames":["src/components/playbook/PlaybookShell.tsx","src/components/playbook/types.ts","src/components/playbook/index.ts","src/components/niche-finder/NicheFinderPlaybookV2.tsx","src/types/scraper.types.ts","src/components/video-viral-ia/VideoViralIAPlaybook.tsx"],"numFiles":6}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01K7jwi4nHRCNYwLhNvFtzEK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SqHFYM4rNaCkUF9DLzTGwT","name":"Grep","input":{"pattern":"PlaybookShell|client_id|clientId","path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/niche-finder/NicheFinderPlaybookV2.tsx","output_mode":"content","-n":true,"-C":2}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":306,"cache_read_input_tokens":130869,"cache_creation":{"ephemeral_5m_input_tokens":306,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"6569d2ee-d153-4bca-bbe2-7e7a321b7d94"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SqHFYM4rNaCkUF9DLzTGwT","type":"tool_result","content":"3-import { useState, useEffect } from 'react'\n4-import { useRouter, useSearchParams } from 'next/navigation'\n5:import { PlaybookShell, nicheFinderConfig } from '../playbook'\n6-import { PlaybookState } from '../playbook/types'\n7-import StartSessionDialog from '../playbook/StartSessionDialog'\n--\n15- * NicheFinderPlaybook V2 - Using the new unified playbook architecture\n16- *\n17: * This component wraps the PlaybookShell with the niche finder configuration.\n18- * It provides:\n19- * - Session initialization dialog for new sessions\n--\n169-\n170-  return (\n171:    <PlaybookShell\n172-      projectId={projectId}\n173-      playbookConfig={nicheFinderConfig}"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"43d595f3-cb5f-46c8-a4c5-35c5e22b34b5","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"3-import { useState, useEffect } from 'react'\n4-import { useRouter, useSearchParams } from 'next/navigation'\n5:import { PlaybookShell, nicheFinderConfig } from '../playbook'\n6-import { PlaybookState } from '../playbook/types'\n7-import StartSessionDialog from '../playbook/StartSessionDialog'\n--\n15- * NicheFinderPlaybook V2 - Using the new unified playbook architecture\n16- *\n17: * This component wraps the PlaybookShell with the niche finder configuration.\n18- * It provides:\n19- * - Session initialization dialog for new sessions\n--\n169-\n170-  return (\n171:    <PlaybookShell\n172-      projectId={projectId}\n173-      playbookConfig={nicheFinderConfig}","numLines":17}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LkbVLShFvPqY5azQBqpTBb","type":"message","role":"assistant","content":[{"type":"text","text":"The clientId is not directly available. For now, I'll keep a simple placeholder and add a state to fetch it. Let me update the PlaybookShell to fetch project data on mount:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":389,"cache_read_input_tokens":131175,"cache_creation":{"ephemeral_5m_input_tokens":389,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"e866dcdc-cfdd-45ef-be14-fc11821f5d3d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LkbVLShFvPqY5azQBqpTBb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012oQE1zVy3HrPWbzsD9TD2K","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","offset":200,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":389,"cache_read_input_tokens":131175,"cache_creation":{"ephemeral_5m_input_tokens":389,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"37c36b4d-8730-4075-9cdb-ccea71169ec3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012oQE1zVy3HrPWbzsD9TD2K","type":"tool_result","content":"   200→      console.error('Error loading campaigns:', error)\n   201→    }\n   202→  }, [projectId, playbookConfig.phases])\n   203→\n   204→  useEffect(() => {\n   205→    loadCampaigns()\n   206→  }, [loadCampaigns])\n   207→\n   208→  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)\n   209→\n   210→  // Ref to track if we should save (avoid saving on initial load)\n   211→  const shouldSaveRef = useRef(false)\n   212→  // Ref to prevent duplicate saves\n   213→  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n   214→  // Ref to store polling interval for cancellation\n   215→  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)\n   216→\n   217→  // Save playbook state to database (debounced)\n   218→  const savePlaybookState = useCallback(async (stateToSave: PlaybookState) => {\n   219→    if (!selectedCampaignId) return\n   220→\n   221→    try {\n   222→      await fetch(`/api/campaign/${selectedCampaignId}`, {\n   223→        method: 'PATCH',\n   224→        headers: { 'Content-Type': 'application/json' },\n   225→        body: JSON.stringify({ playbook_state: stateToSave }),\n   226→      })\n   227→    } catch (error) {\n   228→      console.error('Error saving playbook state:', error)\n   229→    }\n   230→  }, [selectedCampaignId])\n   231→\n   232→  // Auto-save state when it changes (debounced)\n   233→  useEffect(() => {\n   234→    if (!shouldSaveRef.current || !selectedCampaignId) return\n   235→\n   236→    // Clear any pending save\n   237→    if (saveTimeoutRef.current) {\n   238→      clearTimeout(saveTimeoutRef.current)\n   239→    }\n   240→\n   241→    // Debounce saves by 500ms to avoid too many API calls\n   242→    saveTimeoutRef.current = setTimeout(() => {\n   243→      savePlaybookState(state)\n   244→    }, 500)\n   245→\n   246→    return () => {\n   247→      if (saveTimeoutRef.current) {\n   248→        clearTimeout(saveTimeoutRef.current)\n   249→      }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"09038de7-b88e-46c0-933f-eb3d40f3aff9","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","content":"      console.error('Error loading campaigns:', error)\n    }\n  }, [projectId, playbookConfig.phases])\n\n  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)\n\n  // Ref to track if we should save (avoid saving on initial load)\n  const shouldSaveRef = useRef(false)\n  // Ref to prevent duplicate saves\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  // Ref to store polling interval for cancellation\n  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Save playbook state to database (debounced)\n  const savePlaybookState = useCallback(async (stateToSave: PlaybookState) => {\n    if (!selectedCampaignId) return\n\n    try {\n      await fetch(`/api/campaign/${selectedCampaignId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ playbook_state: stateToSave }),\n      })\n    } catch (error) {\n      console.error('Error saving playbook state:', error)\n    }\n  }, [selectedCampaignId])\n\n  // Auto-save state when it changes (debounced)\n  useEffect(() => {\n    if (!shouldSaveRef.current || !selectedCampaignId) return\n\n    // Clear any pending save\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current)\n    }\n\n    // Debounce saves by 500ms to avoid too many API calls\n    saveTimeoutRef.current = setTimeout(() => {\n      savePlaybookState(state)\n    }, 500)\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n      }","numLines":50,"startLine":200,"totalLines":2893}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019mN2eZ5G2Exsz17AfAuNVA","type":"message","role":"assistant","content":[{"type":"text","text":"Let me add a state to store the project data including clientId:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":905,"cache_read_input_tokens":131564,"cache_creation":{"ephemeral_5m_input_tokens":905,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"4d70fe15-b0ec-4904-95bc-1c3a33e78502"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019mN2eZ5G2Exsz17AfAuNVA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YcLpCLyzo9upowiMexgbxe","name":"Edit","input":{"replace_all":false,"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","old_string":"  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)","new_string":"  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)\n  const [projectData, setProjectData] = useState<{ clientId: string; userId: string } | null>(null)"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":905,"cache_read_input_tokens":131564,"cache_creation":{"ephemeral_5m_input_tokens":905,"ephemeral_1h_input_tokens":0},"output_tokens":323,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"ad592e22-2caa-4159-a023-cb116bb91826"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YcLpCLyzo9upowiMexgbxe","type":"tool_result","content":"The file /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"b3f2dc03-d768-4376-871e-6655b1457efe","tool_use_result":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","oldString":"  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)","newString":"  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)\n  const [projectData, setProjectData] = useState<{ clientId: string; userId: string } | null>(null)","originalFile":"'use client'\n\nimport { useState, useCallback, useEffect, useRef } from 'react'\nimport {\n  PlaybookShellProps,\n  PlaybookState,\n  PhaseState,\n  StepState,\n  StepDefinition,\n  PhaseDefinition,\n} from './types'\nimport NavigationPanel from './NavigationPanel'\nimport { WorkArea } from './WorkArea'\nimport ConfigurationMode from './ConfigurationMode'\nimport CampaignWizard from './CampaignWizard'\nimport CampaignSettings from './CampaignSettings'\nimport { Settings, ChevronDown, Plus, Folder, Pencil, Trash2, Database } from 'lucide-react'\nimport { ArtifactBrowser } from './ArtifactBrowser'\nimport { useStepPersistence } from '@/hooks/useStepPersistence'\nimport { useStepRetry } from '@/hooks/useStepRetry'\nimport { StepAttemptConfig, StepRetryInfo } from './types'\nimport StepRetryDialog from './StepRetryDialog'\nimport FailedStepActions from './FailedStepActions'\n\n// Mode types for the unified view\ntype PlaybookMode = 'config' | 'campaign'\n\ninterface Campaign {\n  id: string\n  name: string\n  status: 'draft' | 'in_progress' | 'completed'\n  completedSteps: number\n  totalSteps: number\n  customVariables?: Record<string, unknown> // Includes context_type, product, target, etc.\n  playbookState?: PlaybookState // Saved playbook state for persistence\n}\n\nfunction initializeState(\n  projectId: string,\n  playbookConfig: PlaybookShellProps['playbookConfig'],\n  initialState?: Partial<PlaybookState>\n): PlaybookState {\n  const phases: PhaseState[] = playbookConfig.phases.map(phase => ({\n    id: phase.id,\n    status: 'pending',\n    steps: phase.steps.map(step => ({\n      id: step.id,\n      status: 'pending',\n    })),\n  }))\n\n  // Apply initial state if provided - match by ID for robustness when config changes\n  if (initialState?.phases) {\n    initialState.phases.forEach((savedPhaseState) => {\n      // Find phase by ID instead of index\n      const phaseIndex = phases.findIndex(p => p.id === savedPhaseState.id)\n      if (phaseIndex === -1) return\n\n      phases[phaseIndex].status = savedPhaseState.status\n      savedPhaseState.steps.forEach((savedStepState) => {\n        // Find step by ID instead of index\n        const stepIndex = phases[phaseIndex].steps.findIndex(s => s.id === savedStepState.id)\n        if (stepIndex === -1) return\n\n        phases[phaseIndex].steps[stepIndex] = {\n          ...phases[phaseIndex].steps[stepIndex],\n          ...savedStepState,\n        }\n      })\n    })\n  }\n\n  const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n  const completedSteps = phases.reduce(\n    (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n    0\n  )\n\n  // Validate currentPhaseIndex and currentStepIndex are within bounds\n  let currentPhaseIndex = initialState?.currentPhaseIndex ?? 0\n  let currentStepIndex = initialState?.currentStepIndex ?? 0\n\n  // Ensure phase index is valid\n  if (currentPhaseIndex >= playbookConfig.phases.length) {\n    currentPhaseIndex = Math.max(0, playbookConfig.phases.length - 1)\n  }\n\n  // Ensure step index is valid for the current phase\n  const currentPhaseSteps = playbookConfig.phases[currentPhaseIndex]?.steps.length ?? 0\n  if (currentStepIndex >= currentPhaseSteps) {\n    currentStepIndex = Math.max(0, currentPhaseSteps - 1)\n  }\n\n  // If the current step doesn't exist, find the first non-completed step\n  if (currentPhaseSteps === 0 || currentStepIndex < 0) {\n    // Find first pending step\n    for (let pi = 0; pi < phases.length; pi++) {\n      for (let si = 0; si < phases[pi].steps.length; si++) {\n        if (phases[pi].steps[si].status !== 'completed') {\n          currentPhaseIndex = pi\n          currentStepIndex = si\n          break\n        }\n      }\n      if (currentStepIndex >= 0) break\n    }\n    // Default to first step if all completed\n    if (currentStepIndex < 0) {\n      currentPhaseIndex = 0\n      currentStepIndex = 0\n    }\n  }\n\n  console.log('[initializeState] Validated indices:', {\n    originalPhase: initialState?.currentPhaseIndex,\n    originalStep: initialState?.currentStepIndex,\n    validatedPhase: currentPhaseIndex,\n    validatedStep: currentStepIndex,\n    maxPhases: playbookConfig.phases.length,\n    maxSteps: currentPhaseSteps,\n  })\n\n  return {\n    projectId,\n    playbookType: playbookConfig.type,\n    phases,\n    currentPhaseIndex,\n    currentStepIndex,\n    config: initialState?.config ?? {},\n    completedSteps,\n    totalSteps,\n    startedAt: initialState?.startedAt,\n    completedAt: initialState?.completedAt,\n  }\n}\n\nexport default function PlaybookShell({\n  projectId,\n  playbookConfig,\n  initialState,\n  sessionId,\n}: PlaybookShellProps) {\n  const [state, setState] = useState<PlaybookState>(() =>\n    initializeState(projectId, playbookConfig, initialState)\n  )\n\n  // Step persistence hook for auto-saving step data to database\n  const [stepPersistenceState, stepPersistenceActions] = useStepPersistence({\n    sessionId: sessionId || null,\n    autoSaveInterval: 30000, // Auto-save every 30 seconds\n    enabled: !!sessionId, // Only enable if sessionId is provided\n  })\n\n  // Step retry hook for managing retry attempts\n  const [stepRetryState, stepRetryActions] = useStepRetry(sessionId || null, {\n    enabled: !!sessionId,\n  })\n\n  // State for retry dialog\n  const [retryDialogOpen, setRetryDialogOpen] = useState(false)\n  const [retryDialogStepId, setRetryDialogStepId] = useState<string | null>(null)\n\n  // Flag to distinguish between intentional navigation (Continue button)\n  // vs manual navigation (clicking on a step)\n  const [shouldAutoExecute, setShouldAutoExecute] = useState(false)\n\n  // Mode: 'config' for editing base prompts, 'campaign' for execution\n  const [mode, setMode] = useState<PlaybookMode>('campaign')\n  const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null)\n  const [campaigns, setCampaigns] = useState<Campaign[]>([])\n  const [showCampaignDropdown, setShowCampaignDropdown] = useState(false)\n  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)\n\n  // Load campaigns from database\n  const loadCampaigns = useCallback(async () => {\n    try {\n      const response = await fetch(`/api/campaign/create?projectId=${projectId}`)\n      if (!response.ok) {\n        console.error('Failed to load campaigns')\n        return\n      }\n      const data = await response.json()\n      if (data.campaigns) {\n        const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n        const mappedCampaigns: Campaign[] = data.campaigns.map((c: any) => ({\n          id: c.id,\n          name: c.ecp_name,\n          status: c.status || 'draft',\n          // Calculate completed steps from playbook_state if available\n          completedSteps: c.playbook_state?.completedSteps ?? 0,\n          totalSteps,\n          customVariables: c.custom_variables || {}, // Load campaign variables including context_type\n          playbookState: c.playbook_state || null, // Load saved playbook state\n        }))\n        setCampaigns(mappedCampaigns)\n      }\n    } catch (error) {\n      console.error('Error loading campaigns:', error)\n    }\n  }, [projectId, playbookConfig.phases])\n\n  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)\n\n  // Ref to track if we should save (avoid saving on initial load)\n  const shouldSaveRef = useRef(false)\n  // Ref to prevent duplicate saves\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  // Ref to store polling interval for cancellation\n  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Save playbook state to database (debounced)\n  const savePlaybookState = useCallback(async (stateToSave: PlaybookState) => {\n    if (!selectedCampaignId) return\n\n    try {\n      await fetch(`/api/campaign/${selectedCampaignId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ playbook_state: stateToSave }),\n      })\n    } catch (error) {\n      console.error('Error saving playbook state:', error)\n    }\n  }, [selectedCampaignId])\n\n  // Auto-save state when it changes (debounced)\n  useEffect(() => {\n    if (!shouldSaveRef.current || !selectedCampaignId) return\n\n    // Clear any pending save\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current)\n    }\n\n    // Debounce saves by 500ms to avoid too many API calls\n    saveTimeoutRef.current = setTimeout(() => {\n      savePlaybookState(state)\n    }, 500)\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n      }\n    }\n  }, [state, selectedCampaignId, savePlaybookState])\n\n  // Load saved state when selecting a campaign\n  useEffect(() => {\n    if (!selectedCampaignId) {\n      shouldSaveRef.current = false\n      return\n    }\n\n    const campaign = campaigns.find(c => c.id === selectedCampaignId)\n    if (campaign?.playbookState) {\n      // Load saved state\n      shouldSaveRef.current = false // Don't save while loading\n      setState(initializeState(projectId, playbookConfig, campaign.playbookState))\n      // Enable saving after a short delay\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    } else {\n      // Fresh state for new campaign\n      shouldSaveRef.current = false\n      setState(initializeState(projectId, playbookConfig))\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    }\n  }, [selectedCampaignId, campaigns, projectId, playbookConfig])\n\n  // Load step data from database on session resume (if sessionId is provided)\n  useEffect(() => {\n    if (!sessionId) return\n\n    const loadStepData = async () => {\n      try {\n        const savedSteps = await stepPersistenceActions.loadAllSteps()\n        if (Object.keys(savedSteps).length === 0) return\n\n        console.log('[PlaybookShell] Loaded step data from session:', Object.keys(savedSteps))\n\n        // Merge saved step data into current state\n        setState(prev => {\n          const newPhases = prev.phases.map(phase => ({\n            ...phase,\n            steps: phase.steps.map(step => {\n              const savedStep = savedSteps[step.id]\n              if (savedStep) {\n                return {\n                  ...step,\n                  ...savedStep,\n                }\n              }\n              return step\n            }),\n          }))\n\n          // Recalculate phase status\n          newPhases.forEach(phase => {\n            const hasError = phase.steps.some(s => s.status === 'error')\n            const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n            const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n            if (hasError) {\n              phase.status = 'error'\n            } else if (allCompleted) {\n              phase.status = 'completed'\n            } else if (hasInProgress) {\n              phase.status = 'in_progress'\n            } else {\n              phase.status = 'pending'\n            }\n          })\n\n          // Recalculate completed steps\n          const completedSteps = newPhases.reduce(\n            (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n            0\n          )\n\n          // Find the first non-completed step to set as current\n          let currentPhaseIndex = 0\n          let currentStepIndex = 0\n          outer: for (let pi = 0; pi < newPhases.length; pi++) {\n            for (let si = 0; si < newPhases[pi].steps.length; si++) {\n              if (newPhases[pi].steps[si].status !== 'completed') {\n                currentPhaseIndex = pi\n                currentStepIndex = si\n                break outer\n              }\n            }\n          }\n\n          return {\n            ...prev,\n            phases: newPhases,\n            completedSteps,\n            currentPhaseIndex,\n            currentStepIndex,\n          }\n        })\n      } catch (error) {\n        console.error('[PlaybookShell] Error loading step data:', error)\n      }\n    }\n\n    loadStepData()\n  }, [sessionId, stepPersistenceActions])\n\n  // Delete a campaign\n  const deleteCampaign = useCallback(async (campaignId: string) => {\n    if (!confirm('¿Estás seguro de que quieres eliminar esta campaña? Esta acción no se puede deshacer.')) {\n      return\n    }\n\n    try {\n      const response = await fetch(`/api/campaign/${campaignId}`, {\n        method: 'DELETE',\n      })\n\n      if (!response.ok) {\n        throw new Error('Error al eliminar campaña')\n      }\n\n      // If we deleted the selected campaign, clear selection\n      if (selectedCampaignId === campaignId) {\n        setSelectedCampaignId(null)\n      }\n\n      // Reload campaigns\n      loadCampaigns()\n    } catch (error) {\n      console.error('Error deleting campaign:', error)\n      alert('Error al eliminar la campaña')\n    }\n  }, [selectedCampaignId, loadCampaigns])\n\n  // Helper function to get the output from the previous step\n  const getPreviousStepOutput = (): string | undefined => {\n    // Find the current step's dependencies\n    if (!currentStep?.dependsOn?.length) return undefined\n\n    // Get the first dependency's output\n    const dependencyId = currentStep.dependsOn[0]\n\n    // Search for this step across all phases\n    for (const phase of state.phases) {\n      const stepState = phase.steps.find(s => s.id === dependencyId)\n      if (stepState?.output) {\n        return typeof stepState.output === 'string'\n          ? stepState.output\n          : JSON.stringify(stepState.output, null, 2)\n      }\n    }\n\n    return undefined\n  }\n\n  // Build context for LLM-based suggestion generation\n  const buildPlaybookContext = (): Record<string, unknown> => {\n    // Start with campaign's custom_variables (includes context_type, product, target, etc.)\n    const campaignVars = selectedCampaign?.customVariables || {}\n\n    const context: Record<string, unknown> = {\n      ...campaignVars, // Include all campaign variables\n      product: campaignVars.product || state.config?.product || '',\n      target: campaignVars.target || state.config?.target || '',\n      context_type: campaignVars.context_type || 'both', // Explicitly include context_type\n    }\n\n    // DEBUG: Log all steps to see their state\n    console.log('[buildPlaybookContext] All steps:', state.phases.flatMap(p =>\n      p.steps.map(s => ({ id: s.id, status: s.status, hasOutput: !!s.output }))\n    ))\n\n    // Collect values from completed steps\n    for (const phase of state.phases) {\n      for (const stepState of phase.steps) {\n        // DEBUG: Log keyword_config step specifically\n        if (stepState.id === 'keyword_config') {\n          console.log('[buildPlaybookContext] keyword_config step:', {\n            status: stepState.status,\n            hasOutput: !!stepState.output,\n            outputKeys: stepState.output ? Object.keys(stepState.output as object) : [],\n            output: stepState.output,\n          })\n        }\n\n        if (stepState.status === 'completed' || stepState.decision || stepState.suggestions) {\n          // Get decision value\n          if (stepState.decision) {\n            context[stepState.id] = stepState.decision\n          }\n\n          // Get selected suggestions as array of labels\n          if (stepState.suggestions?.length) {\n            const selectedLabels = stepState.suggestions\n              .filter(s => s.selected)\n              .map(s => s.label)\n            if (selectedLabels.length > 0) {\n              context[stepState.id] = selectedLabels\n            }\n          }\n\n          // Get output if available\n          if (stepState.output) {\n            context[`${stepState.id}_output`] = stepState.output\n          }\n\n          // Special case: Extract serpJobId from serp_search or search_and_preview step output\n          // This is needed for review_urls/review_and_scrape step to display SERP results\n          // Note: We check this inside the completed block, but also outside below\n          if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Also extract serpJobId from review_and_scrape step (the scrape step)\n          // This ensures scrape_results step can find the jobId after scraping completes\n          if (stepState.id === 'review_and_scrape' && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId && !context.serpJobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Special case: Parse sources step output for QueryPreviewPanel\n          // The LLM returns a JSON string that needs to be parsed\n          if (stepState.id === 'sources' && stepState.output) {\n            try {\n              let parsedSources = stepState.output\n              if (typeof stepState.output === 'string') {\n                // Try to extract JSON from the LLM response\n                const jsonMatch = stepState.output.match(/\\{[\\s\\S]*\\}/)\n                if (jsonMatch) {\n                  parsedSources = JSON.parse(jsonMatch[0])\n                }\n              }\n              // Only set if it's a valid sources config object\n              if (parsedSources && typeof parsedSources === 'object' &&\n                  ('reddit' in parsedSources || 'thematic_forums' in parsedSources || 'general_forums' in parsedSources)) {\n                context.sources = parsedSources\n              }\n            } catch (e) {\n              console.error('[buildPlaybookContext] Error parsing sources output:', e)\n              // Don't set context.sources - let it use default values\n            }\n          }\n\n          // Special case: Extract keyword_config unified output for SearchWithPreviewStep\n          // The unified panel saves data in two formats:\n          // 1. lifeContexts, needWords, indicators as arrays of objects (for UI)\n          // 2. life_contexts, product_words, indicators as arrays of strings (for SERP job)\n          if (stepState.id === 'keyword_config' && stepState.output) {\n            const output = stepState.output as {\n              // Object arrays (for UI state)\n              lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n              needWords?: Array<{ id: string; label: string; selected: boolean }>\n              indicators?: Array<{ id: string; label: string; selected: boolean }>\n              // String arrays (pre-extracted for SERP job)\n              life_contexts?: string[]\n              product_words?: string[]\n              sources?: {\n                reddit_general?: { enabled: boolean }\n                reddit?: { enabled: boolean; subreddits?: string[] }\n                thematic_forums?: { enabled: boolean; forums?: string[] }\n                general_forums?: { enabled: boolean; forums?: string[] }\n              }\n            }\n\n            // First try to use pre-extracted string arrays (set on completion)\n            if (output.life_contexts && Array.isArray(output.life_contexts)) {\n              context.life_contexts = output.life_contexts\n            } else if (output.lifeContexts) {\n              // Fall back to extracting from object array\n              context.life_contexts = output.lifeContexts\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            // Check multiple possible keys for need words\n            if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n              context.need_words = output.product_words\n              console.log('[buildPlaybookContext] Got need_words from product_words:', output.product_words)\n            } else if ((output as any).need_words && Array.isArray((output as any).need_words) && (output as any).need_words.length > 0) {\n              // Also check for 'need_words' key (alternative naming)\n              context.need_words = (output as any).need_words\n              console.log('[buildPlaybookContext] Got need_words from need_words key:', (output as any).need_words)\n            } else if (output.needWords && Array.isArray(output.needWords)) {\n              const extracted = output.needWords\n                .filter(item => item.selected)\n                .map(item => item.label)\n              if (extracted.length > 0) {\n                context.need_words = extracted\n                console.log('[buildPlaybookContext] Got need_words from needWords (selected):', extracted)\n              } else {\n                console.warn('[buildPlaybookContext] needWords array exists but no items selected:', output.needWords)\n              }\n            } else {\n              console.warn('[buildPlaybookContext] Could not find need_words in output:', {\n                hasProductWords: !!output.product_words,\n                productWordsLength: output.product_words?.length,\n                hasNeedWords: !!(output as any).need_words,\n                hasNeedWordsArray: !!output.needWords,\n                outputKeys: Object.keys(output),\n              })\n            }\n\n            if (output.indicators && Array.isArray(output.indicators) && typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else if (output.indicators && Array.isArray(output.indicators)) {\n              context.indicators = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            if (output.sources) {\n              context.sources = output.sources\n            }\n\n            // DEBUG: Log what we extracted from keyword_config\n            console.log('[buildPlaybookContext] Extracted from keyword_config:', {\n              life_contexts: context.life_contexts,\n              need_words: context.need_words,\n              indicators: context.indicators,\n              sources: context.sources,\n            })\n          }\n        }\n\n        // IMPORTANT: Extract serpJobId even from non-completed steps (e.g., after cancel)\n        // This allows review_and_scrape to show URLs from a cancelled SERP job\n        if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also check review_and_scrape for non-completed steps (e.g., in progress or cancelled)\n        if (stepState.id === 'review_and_scrape' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also extract serpJobId from scrape_results step (for extraction step)\n        if (stepState.id === 'scrape_results' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // IMPORTANT: Also extract keyword_config data even if step is not 'completed'\n        // This ensures retry/navigation doesn't lose the config\n        if (stepState.id === 'keyword_config' && stepState.output && !context.life_contexts) {\n          console.log('[buildPlaybookContext] Extracting keyword_config from non-completed step')\n          const output = stepState.output as {\n            lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n            needWords?: Array<{ id: string; label: string; selected: boolean }>\n            indicators?: Array<{ id: string; label: string; selected: boolean }>\n            life_contexts?: string[]\n            product_words?: string[]\n            sources?: Record<string, unknown>\n          }\n\n          if (output.life_contexts && Array.isArray(output.life_contexts) && output.life_contexts.length > 0) {\n            context.life_contexts = output.life_contexts\n          } else if (output.lifeContexts) {\n            const extracted = output.lifeContexts.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.life_contexts = extracted\n            }\n          }\n\n          if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n            context.need_words = output.product_words\n          } else if (output.needWords) {\n            const extracted = output.needWords.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.need_words = extracted\n            }\n          }\n\n          if (output.indicators && Array.isArray(output.indicators) && output.indicators.length > 0) {\n            if (typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else {\n              const extracted = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected).map(item => item.label)\n              if (extracted.length > 0) {\n                context.indicators = extracted\n              }\n            }\n          }\n\n          if (output.sources && !context.sources) {\n            context.sources = output.sources\n          }\n\n          console.log('[buildPlaybookContext] Extracted from non-completed keyword_config:', {\n            life_contexts: context.life_contexts,\n            need_words: context.need_words,\n          })\n        }\n      }\n    }\n\n    // DEBUG: Log final context\n    console.log('[buildPlaybookContext] Final context:', {\n      life_contexts: context.life_contexts,\n      need_words: context.need_words,\n      indicators: context.indicators,\n      sources: context.sources,\n      serpJobId: context.serpJobId,\n    })\n\n    return context\n  }\n\n  // Get current phase and step definitions\n  const currentPhase = playbookConfig.phases[state.currentPhaseIndex]\n  const currentStep = currentPhase?.steps[state.currentStepIndex]\n  const currentStepState = state.phases[state.currentPhaseIndex]?.steps[state.currentStepIndex]\n\n  // Calculate navigation bounds\n  const isFirstStep = state.currentPhaseIndex === 0 && state.currentStepIndex === 0\n  const isLastStep =\n    state.currentPhaseIndex === playbookConfig.phases.length - 1 &&\n    state.currentStepIndex === currentPhase.steps.length - 1\n\n  // Navigate to a specific step\n  const goToStep = useCallback((phaseIndex: number, stepIndex: number) => {\n    // Save current state immediately before navigating (don't wait for debounce)\n    if (shouldSaveRef.current && selectedCampaignId) {\n      // Clear pending debounced save\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n        saveTimeoutRef.current = null\n      }\n      // Save current state synchronously\n      savePlaybookState(state)\n    }\n\n    setState(prev => ({\n      ...prev,\n      currentPhaseIndex: phaseIndex,\n      currentStepIndex: stepIndex,\n    }))\n  }, [selectedCampaignId, state, savePlaybookState])\n\n  // Go to next step\n  const goToNextStep = useCallback(() => {\n    setState(prev => {\n      const currentPhase = playbookConfig.phases[prev.currentPhaseIndex]\n\n      // Check if there's a next step in current phase\n      if (prev.currentStepIndex < currentPhase.steps.length - 1) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex + 1,\n        }\n      }\n\n      // Check if there's a next phase\n      if (prev.currentPhaseIndex < playbookConfig.phases.length - 1) {\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex + 1,\n          currentStepIndex: 0,\n        }\n      }\n\n      // Already at the end\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Go to previous step\n  const goToPreviousStep = useCallback(() => {\n    setState(prev => {\n      // Check if there's a previous step in current phase\n      if (prev.currentStepIndex > 0) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex - 1,\n        }\n      }\n\n      // Check if there's a previous phase\n      if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex - 1,\n          currentStepIndex: prevPhase.steps.length - 1,\n        }\n      }\n\n      // Already at the beginning\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Re-run the previous step (go back and reset its state to pending)\n  const rerunPreviousStep = useCallback(() => {\n    setState(prev => {\n      let newPhaseIndex = prev.currentPhaseIndex\n      let newStepIndex = prev.currentStepIndex\n\n      // Find previous step\n      if (prev.currentStepIndex > 0) {\n        newStepIndex = prev.currentStepIndex - 1\n      } else if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        newPhaseIndex = prev.currentPhaseIndex - 1\n        newStepIndex = prevPhase.steps.length - 1\n      } else {\n        // Already at the beginning, nothing to rerun\n        return prev\n      }\n\n      // Get the previous step ID\n      const prevStepId = playbookConfig.phases[newPhaseIndex].steps[newStepIndex].id\n\n      // Reset the previous step state to pending and navigate to it\n      const newPhases = prev.phases.map((phase, pi) => ({\n        ...phase,\n        steps: phase.steps.map((step, si) => {\n          if (pi === newPhaseIndex && si === newStepIndex) {\n            return {\n              ...step,\n              status: 'pending' as const,\n              output: undefined,\n              error: undefined,\n            }\n          }\n          return step\n        }),\n      }))\n\n      return {\n        ...prev,\n        phases: newPhases,\n        currentPhaseIndex: newPhaseIndex,\n        currentStepIndex: newStepIndex,\n      }\n    })\n    // Trigger auto-execute after navigating\n    setShouldAutoExecute(true)\n  }, [playbookConfig.phases])\n\n  // Update step state\n  const updateStepState = useCallback(\n    (stepId: string, update: Partial<StepState>) => {\n      console.log('[updateStepState] Updating step:', stepId, 'with:', {\n        ...update,\n        output: update.output ? `[output with keys: ${Object.keys(update.output as object).join(', ')}]` : undefined,\n      })\n\n      // Persist step changes to database (if sessionId is provided)\n      if (sessionId) {\n        // Handle status-specific persistence\n        if (update.status === 'in_progress') {\n          stepPersistenceActions.markStepRunning(stepId, update.input)\n        } else if (update.status === 'completed') {\n          stepPersistenceActions.markStepCompleted(stepId, update.output)\n        } else if (update.status === 'error') {\n          stepPersistenceActions.markStepFailed(stepId, update.error || 'Unknown error')\n        } else if (update.output !== undefined) {\n          // For output-only updates (during execution), schedule auto-save\n          stepPersistenceActions.scheduleAutoSave(stepId, update.output)\n        }\n      }\n\n      setState(prev => {\n        // Find the current step to log what we're merging\n        const currentStep = prev.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n        if (stepId === 'keyword_config') {\n          console.log('[updateStepState] keyword_config before merge:', {\n            status: currentStep?.status,\n            hasOutput: !!currentStep?.output,\n            outputKeys: currentStep?.output ? Object.keys(currentStep.output as object) : [],\n          })\n        }\n\n        const newPhases = prev.phases.map(phase => ({\n          ...phase,\n          steps: phase.steps.map(step =>\n            step.id === stepId ? { ...step, ...update } : step\n          ),\n        }))\n\n        // Log the merged result for keyword_config\n        if (stepId === 'keyword_config') {\n          const mergedStep = newPhases.flatMap(p => p.steps).find(s => s.id === stepId)\n          console.log('[updateStepState] keyword_config after merge:', {\n            status: mergedStep?.status,\n            hasOutput: !!mergedStep?.output,\n            outputKeys: mergedStep?.output ? Object.keys(mergedStep.output as object) : [],\n          })\n        }\n\n        // Recalculate phase status\n        newPhases.forEach(phase => {\n          const hasError = phase.steps.some(s => s.status === 'error')\n          const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n          const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n          if (hasError) {\n            phase.status = 'error'\n          } else if (allCompleted) {\n            phase.status = 'completed'\n          } else if (hasInProgress) {\n            phase.status = 'in_progress'\n          } else {\n            phase.status = 'pending'\n          }\n        })\n\n        // Recalculate completed steps\n        const completedSteps = newPhases.reduce(\n          (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n          0\n        )\n\n        return {\n          ...prev,\n          phases: newPhases,\n          completedSteps,\n        }\n      })\n    },\n    [sessionId, stepPersistenceActions]\n  )\n\n  // Execute a step\n  const executeStep = useCallback(\n    async (stepId: string, input?: any) => {\n      console.log('[executeStep] Starting execution for step:', stepId, 'with input:', input)\n\n      const step = playbookConfig.phases\n        .flatMap(p => p.steps)\n        .find(s => s.id === stepId)\n\n      if (!step) {\n        console.error('[executeStep] Step not found:', stepId)\n        return\n      }\n\n      console.log('[executeStep] Found step:', step.id, 'type:', step.type, 'executor:', step.executor, 'jobType:', step.jobType)\n\n      // Mark as in progress\n      updateStepState(stepId, {\n        status: 'in_progress',\n        startedAt: new Date(),\n        input,\n      })\n\n      try {\n        let result: any\n\n        // Special case: Execute extraction from scrape_results step\n        if (step.id === 'scrape_results' && input?.action === 'extract' && input?.jobId) {\n          console.log('[EXTRACT from scrape_results] Starting extraction for job:', input.jobId)\n          const jobId = input.jobId\n\n          updateStepState(stepId, {\n            output: { jobId },\n            progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' },\n            partialResults: { extracted: 0, filtered: 0 },\n          })\n\n          // Get total URLs to extract from job status\n          const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          const statusData = await statusResponse.json()\n          const scrapedUrlCount = statusData.url_counts?.scraped || 0\n          const totalUrls = scrapedUrlCount || statusData.job?.urls_scraped || 0\n          const existingExtractedCount = statusData.job?.niches_extracted || 0\n          const existingFilteredCount = statusData.url_counts?.filtered || 0\n\n          console.log('[EXTRACT] Status check:', {\n            scrapedUrlCount,\n            totalUrls,\n            existingExtractedCount,\n            existingFilteredCount,\n            jobStatus: statusData.job?.status,\n            urlsFailed: statusData.url_counts?.failed || 0,\n          })\n\n          // Check if there's nothing to extract (all URLs failed or filtered)\n          if (scrapedUrlCount === 0 && existingExtractedCount === 0) {\n            const failedCount = statusData.url_counts?.failed || 0\n            console.log('[EXTRACT] No URLs to extract and no existing results. Failed:', failedCount, 'Filtered:', existingFilteredCount)\n\n            // Show error state - nothing to extract\n            updateStepState(stepId, {\n              status: 'error',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: 0,\n                filteredCount: existingFilteredCount,\n                error: failedCount > 0\n                  ? `El scraping falló para ${failedCount} URLs (posible bloqueo de Reddit API). No hay contenido disponible para extraer.`\n                  : 'No hay URLs disponibles para extraer. Verifica que el scraping se completó correctamente.',\n              },\n              progress: undefined,\n            })\n\n            return // Stop - nothing to do\n          }\n\n          // Check if extraction was already done (no URLs to process but results exist)\n          if (scrapedUrlCount === 0 && existingExtractedCount > 0) {\n            console.log('[EXTRACT] Extraction already completed, using existing results')\n            updateStepState(stepId, {\n              progress: { current: 100, total: 100, label: `Usando resultados existentes: ${existingExtractedCount} problemas encontrados` },\n            })\n\n            // Skip extraction loop and jump to results fetching\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // Mark scrape_results as completed\n            updateStepState(stepId, {\n              status: 'completed',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: existingExtractedCount,\n                filteredCount: existingFilteredCount,\n              },\n              progress: undefined,\n            })\n\n            // Also update extract_problems step for clean_filter to use\n            console.log('[EXTRACT] Updating extract_problems step with existing CSV results')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,\n              partialResults: {\n                extracted: existingExtractedCount,\n                filtered: existingFilteredCount,\n                successCount: niches.length,\n              }\n            })\n\n            console.log('[EXTRACT] Using existing results:', niches.length, 'problems')\n            return // Don't proceed with new extraction\n          }\n\n          updateStepState(stepId, {\n            progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` },\n          })\n\n          // Call extract endpoint in batches until has_more=false\n          let hasMore = true\n          let extractedTotal = 0\n          let filteredTotal = 0\n          let processedTotal = 0\n\n          while (hasMore) {\n            try {\n              const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout)\n              const contentType = extractResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                console.error('[EXTRACT] Non-JSON response, polling status...')\n                await new Promise(resolve => setTimeout(resolve, 2000))\n\n                // Check current status\n                const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                const checkData = await checkResponse.json()\n\n                if (checkData.status === 'completed') {\n                  hasMore = false\n                  extractedTotal = checkData.job?.niches_extracted || 0\n                }\n                continue\n              }\n\n              const extractData = await extractResponse.json()\n              console.log('[EXTRACT] Batch response:', extractData)\n\n              if (extractData.error) {\n                throw new Error(extractData.error)\n              }\n\n              extractedTotal += extractData.extracted || 0\n              filteredTotal += extractData.filtered || 0\n              processedTotal = extractedTotal + filteredTotal\n              hasMore = extractData.has_more || false\n\n              updateStepState(stepId, {\n                progress: {\n                  current: processedTotal,\n                  total: totalUrls,\n                  label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                },\n                partialResults: {\n                  extracted: extractedTotal,\n                  filtered: filteredTotal,\n                },\n              })\n            } catch (extractError) {\n              console.error('[EXTRACT] Batch error:', extractError)\n              await new Promise(resolve => setTimeout(resolve, 2000))\n\n              // Check if we should stop\n              const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const checkData = await checkResponse.json()\n              if (checkData.status === 'completed' || checkData.status === 'failed') {\n                hasMore = false\n                if (checkData.status === 'failed') {\n                  throw new Error(checkData.job?.error_message || 'Extraction failed')\n                }\n              }\n            }\n          }\n\n          // Mark as completed\n          updateStepState(stepId, {\n            status: 'completed',\n            completedAt: new Date(),\n            output: {\n              jobId,\n              extractedCount: extractedTotal,\n              filteredCount: filteredTotal,\n            },\n            progress: undefined, // Clear progress\n          })\n\n          console.log('[EXTRACT] Completed! Extracted:', extractedTotal, 'Filtered:', filteredTotal)\n\n          // Save results to Context Lake automatically\n          try {\n            // Get project data (includes client_id)\n            const projectResponse = await fetch(`/api/projects/${projectId}`)\n            const projectData = await projectResponse.json()\n\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // IMPORTANT: Also update extract_problems step so clean_filter can use the results\n            // clean_filter depends on extract_problems, not scrape_results\n            console.log('[EXTRACT] Updating extract_problems step with CSV results for clean_filter')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,  // CSV string that clean_filter will use\n              partialResults: {\n                extracted: extractedTotal,\n                filtered: filteredTotal,\n                successCount: niches.length,\n              }\n            })\n\n            const dateStr = new Date().toISOString().split('T')[0]\n            const campaignSlug = selectedCampaign?.name?.toLowerCase().replace(/\\s+/g, '-') || 'sin-nombre'\n            const projectSlug = projectData.name?.toLowerCase().replace(/\\s+/g, '-') || 'proyecto'\n\n            const documentData = {\n              projectId: projectId,\n              clientId: projectData.client_id,\n              filename: `Niche Finder - ${selectedCampaign?.name || 'Sin nombre'} - ${dateStr}`,\n              category: 'research',\n              content: csvContent,\n              description: `${extractedTotal} problemas extraídos del Niche Finder. ${filteredTotal} URLs filtradas de ${totalUrls} procesadas.`,\n              tags: [\n                `fecha:${dateStr}`,\n                `proyecto:${projectSlug}`,\n                `campaña:${campaignSlug}`,\n                `job:${jobId}`,\n                'niche-finder',\n                'problemas-extraidos'\n              ],\n              folder: `niche-finder/${campaignSlug}`,\n              userId: 'system', // TODO: Get actual user ID from session\n              sourceMetadata: {\n                origin_type: 'flow_step_output',\n                playbook_id: playbookConfig.type || 'niche-finder',\n                playbook_name: playbookConfig.name,\n                campaign_id: selectedCampaignId || '',\n                campaign_name: selectedCampaign?.name || '',\n                campaign_variables: selectedCampaign?.customVariables || {},\n                step_id: 'scrape_results',\n                step_name: 'Extracción de Problemas',\n                step_order: 3,\n                executed_at: new Date().toISOString(),\n                model_used: 'openai/gpt-4o-mini',\n                model_provider: 'openrouter',\n                input_tokens: 0,\n                output_tokens: 0,\n                input_document_ids: [],\n                input_previous_step_ids: ['search_and_preview', 'review_and_scrape'],\n                converted_at: new Date().toISOString(),\n                converted_by: 'system',\n                was_edited_before_conversion: false\n              },\n              sourceCampaignId: selectedCampaignId || '',\n              sourceStepId: 'scrape_results',\n              sourceStepName: 'Extracción de Problemas',\n              sourcePlaybookId: playbookConfig.type\n            }\n\n            const saveResponse = await fetch('/api/documents/from-step-output', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify(documentData)\n            })\n\n            if (saveResponse.ok) {\n              const savedDoc = await saveResponse.json()\n              console.log('[EXTRACT] Results saved to Context Lake:', savedDoc.document?.id)\n            } else {\n              console.error('[EXTRACT] Failed to save to Context Lake:', await saveResponse.text())\n            }\n          } catch (saveError) {\n            console.error('[EXTRACT] Error saving to Context Lake:', saveError)\n            // Don't fail the extraction if saving to Context Lake fails\n          }\n\n          return // Don't fall through to the switch\n        }\n\n        switch (step.executor) {\n          case 'llm':\n            // Build variables including campaign custom_variables (product, target, industry, etc.)\n            const campaignVars = selectedCampaign?.customVariables || {}\n            const stepVariables = {\n              ...Object.fromEntries(\n                Object.entries(campaignVars).map(([k, v]) => [k, String(v ?? '')])\n              ),\n              ...(input || {}),\n            }\n            // Call LLM API\n            const response = await fetch('/api/playbook/execute-step', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({\n                projectId,\n                stepId,\n                playbookType: playbookConfig.type,\n                promptKey: step.promptKey,\n                variables: stepVariables,\n              }),\n            })\n            const data = await response.json()\n            if (!data.success) throw new Error(data.error || 'Error ejecutando paso')\n            result = data.output\n            break\n\n          case 'api':\n            // Call custom API endpoint\n            if (step.apiEndpoint) {\n              // Build payload with previous step outputs and campaign variables\n              const campaignVarsForApi = selectedCampaign?.customVariables || {}\n\n              // Get outputs from previous steps (dependsOn)\n              const previousOutputs: Record<string, unknown> = {}\n              if (step.dependsOn?.length) {\n                for (const depId of step.dependsOn) {\n                  for (const phase of state.phases) {\n                    const depStep = phase.steps.find(s => s.id === depId)\n                    if (depStep?.output) {\n                      previousOutputs[depId] = depStep.output\n                    }\n                  }\n                }\n              }\n\n              // Build scenes array from generate_scenes output (for video-viral generate-clips)\n              let scenes: string[] | undefined\n              if (previousOutputs.generate_scenes) {\n                let scenesOutput = previousOutputs.generate_scenes\n\n                // Parse JSON if output is a string (LLM outputs often come as strings)\n                if (typeof scenesOutput === 'string') {\n                  try {\n                    // Try to extract JSON from the string (might be wrapped in markdown code blocks)\n                    const jsonMatch = scenesOutput.match(/```(?:json)?\\s*(\\{[\\s\\S]*?\\})\\s*```/) ||\n                                     scenesOutput.match(/(\\{[\\s\\S]*\\})/)\n                    if (jsonMatch) {\n                      scenesOutput = JSON.parse(jsonMatch[1])\n                    }\n                  } catch (e) {\n                    console.error('[executeStep] Failed to parse generate_scenes output:', e)\n                  }\n                }\n\n                // Extract scene_1, scene_2, scene_3, etc. from the output\n                if (typeof scenesOutput === 'object' && scenesOutput !== null) {\n                  const scenesRecord = scenesOutput as Record<string, string>\n                  scenes = Object.entries(scenesRecord)\n                    .filter(([key]) => key.startsWith('scene_'))\n                    .sort(([a], [b]) => a.localeCompare(b))\n                    .map(([, value]) => value)\n                  console.log('[executeStep] Extracted scenes:', scenes)\n                }\n              }\n\n              const apiResponse = await fetch(step.apiEndpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                  projectId,\n                  stepId,\n                  input,\n                  ...campaignVarsForApi,\n                  previousOutputs,\n                  scenes, // For generate-clips endpoint\n                }),\n              })\n              const apiData = await apiResponse.json()\n              if (!apiData.success && apiData.error) throw new Error(apiData.error)\n              result = apiData\n            }\n            break\n\n          case 'job':\n            // Job-based execution: create job, execute, poll for status\n            console.log('[executeStep] Executor is JOB, jobType:', step.jobType)\n\n            if (step.jobType === 'niche_finder_serp') {\n              // Check if we have an existing job to resume (from cancelled execution)\n              const currentStepForJob = state.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n              const existingJobId = (currentStepForJob?.output as { jobId?: string })?.jobId\n\n              let jobId: string\n\n              if (existingJobId) {\n                // Resume existing job\n                console.log('[SERP] Resuming existing job:', existingJobId)\n                jobId = existingJobId\n                updateStepState(stepId, { progress: { current: 0, total: 0, label: 'Retomando búsqueda SERP...' } })\n              } else {\n                // Build job config from completed steps OR from input (for search_with_preview)\n                let jobConfig: {\n                  life_contexts: string[]\n                  product_words: string[]\n                  indicators: string[]\n                  sources: { reddit: boolean | { enabled?: boolean; subreddits?: string[] }; thematic_forums: boolean | { enabled?: boolean; forums?: string[] }; general_forums: string[] | { enabled?: boolean; forums?: string[] } }\n                  serp_pages: number\n                  // Campaign metadata for extraction to use correct variables\n                  campaign_id?: string | null\n                  ecp_name?: string\n                  ecp_product?: string\n                  ecp_target?: string\n                  ecp_industry?: string\n                  ecp_category?: string\n                  ecp_country?: string\n                }\n\n                // If input is provided (from SearchWithPreviewPanel), use it directly\n                console.log('[SERP] Input received:', JSON.stringify(input, null, 2))\n\n                if (input && input.life_contexts && input.product_words) {\n                  // Warn if arrays are empty\n                  if (input.life_contexts.length === 0 || input.product_words.length === 0) {\n                    console.warn('[SERP] WARNING: life_contexts or product_words is empty!', {\n                      life_contexts: input.life_contexts,\n                      product_words: input.product_words\n                    })\n                  }\n\n                  jobConfig = {\n                    life_contexts: input.life_contexts,\n                    product_words: input.product_words,\n                    indicators: input.indicators || [],\n                    sources: input.sources || { reddit: true, thematic_forums: false, general_forums: [] },\n                    serp_pages: input.serp_pages || 5,\n                  }\n                } else {\n                  console.log('[SERP] No valid input, falling back to completed steps...')\n                  // Fall back to building from completed steps (legacy flow)\n                  const lifeContextsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'life_contexts')\n                  const needWordsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'need_words')\n                  const indicatorsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'indicators')\n                  const sourcesStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'sources')\n\n                  const selectedContexts = lifeContextsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedNeedWords = needWordsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedIndicators = indicatorsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n\n                  // Parse sources output (can be JSON string from LLM or already parsed object)\n                  let sourcesConfig: { reddit: { enabled: boolean; subreddits: string[] }; thematic_forums: { enabled: boolean; forums: string[] }; general_forums: { enabled: boolean; forums: string[] } } = { reddit: { enabled: true, subreddits: [] }, thematic_forums: { enabled: false, forums: [] }, general_forums: { enabled: false, forums: [] } }\n                  try {\n                    if (sourcesStep?.output) {\n                      // Check if output is already an object (parsed)\n                      if (typeof sourcesStep.output === 'object' && sourcesStep.output !== null) {\n                        sourcesConfig = sourcesStep.output as typeof sourcesConfig\n                      } else if (typeof sourcesStep.output === 'string') {\n                        // Try to extract JSON from string\n                        const jsonMatch = sourcesStep.output.match(/\\{[\\s\\S]*\\}/)\n                        if (jsonMatch) {\n                          sourcesConfig = JSON.parse(jsonMatch[0])\n                        }\n                      }\n                    }\n                  } catch (e) {\n                    console.error('Error parsing sources config:', e)\n                  }\n\n                  // Get campaign variables with proper typing\n                  const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                  jobConfig = {\n                    campaign_id: selectedCampaignId, // CRITICAL: Pass campaign_id so extract uses correct variables\n                    life_contexts: selectedContexts,\n                    product_words: selectedNeedWords,\n                    indicators: selectedIndicators,\n                    sources: sourcesConfig,\n                    serp_pages: (campaignVars?.serp_pages as number) || 5,\n                    // Also pass campaign variables directly in config for reliability\n                    ecp_name: (campaignVars?.company_name as string) || selectedCampaign?.name,\n                    ecp_product: campaignVars?.product as string | undefined,\n                    ecp_target: campaignVars?.target as string | undefined,\n                    ecp_industry: campaignVars?.industry as string | undefined,\n                    ecp_category: campaignVars?.category as string | undefined,\n                    ecp_country: campaignVars?.country as string | undefined,\n                  }\n                }\n\n                console.log('[SERP] Starting job with config:', JSON.stringify(jobConfig, null, 2))\n\n                // 1. Create job\n                const createResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: jobConfig,\n                  }),\n                })\n                const createData = await createResponse.json()\n                console.log('[SERP] Create job response:', createData)\n\n                if (!createData.success) {\n                  throw new Error(createData.error || 'Error creando job')\n                }\n\n                jobId = createData.job_id\n                console.log('[SERP] Job created with ID:', jobId)\n                updateStepState(stepId, { output: { jobId }, progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' } })\n              }\n\n              // 2. Execute SERP job (this will resume from where it left off if job was interrupted)\n              console.log('[SERP] Executing SERP search...')\n              const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout HTML pages)\n              const contentType = serpResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                const text = await serpResponse.text()\n                console.error('[SERP] Non-JSON response:', text.slice(0, 500))\n                // If we got a non-JSON response, the job might still be running in the background\n                // Continue to polling to check status\n                console.log('[SERP] Continuing to poll for job status despite non-JSON response...')\n              } else {\n                const serpData = await serpResponse.json()\n                console.log('[SERP] SERP response:', serpData)\n\n                if (serpData.error) {\n                  // Check if it's a missing API key error\n                  if (serpData.code === 'MISSING_API_KEY') {\n                    throw new Error(`API Key faltante: ${serpData.service}. Configura tu API key en Ajustes > APIs.`)\n                  }\n                  throw new Error(serpData.error)\n                }\n              }\n\n              // 3. Poll for status and auto-resume if needed\n              let isResuming = false\n              let lastCompletedCount = -1 // Track previous poll value\n              let stallCount = 0 // Count consecutive stalls\n              let initialCompleted = -1 // Track initial value when polling started\n\n              // Clear any existing poll interval\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n              }\n\n              pollIntervalRef.current = setInterval(async () => {\n                try {\n                  const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const statusData = await statusResponse.json()\n\n                  const completed = statusData.progress?.serp?.completed || 0\n                  const total = statusData.progress?.serp?.total || 0\n                  const remaining = total - completed\n                  const label = total > 0\n                    ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n                    : 'Iniciando búsqueda SERP...'\n                  updateStepState(stepId, {\n                    progress: {\n                      current: completed,\n                      total: total,\n                      label,\n                    },\n                  })\n\n                  // Track initial value on first poll\n                  if (initialCompleted === -1) {\n                    initialCompleted = completed\n                  }\n\n                  // Auto-resume if job was interrupted (still serp_running but not progressing)\n                  // This handles Vercel timeout scenarios\n                  if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n                    // Check if progress has stalled (same value as PREVIOUS poll)\n                    if (lastCompletedCount === completed && remaining > 0) {\n                      stallCount++\n                      // After 2 consecutive stalls (4+ seconds), OR if no progress since we started polling\n                      const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                      if (stallCount >= 2 || noProgressSinceStart) {\n                        console.log(`[SERP] Job stalled at ${completed}/${total} (stallCount=${stallCount}, initialCompleted=${initialCompleted}), auto-resuming...`)\n                        isResuming = true\n                        stallCount = 0\n                        // Resume the job by calling SERP endpoint again\n                        fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                          .then(res => res.json())\n                          .then(data => {\n                            console.log('[SERP] Resume response:', data)\n                            isResuming = false\n                          })\n                          .catch(err => {\n                            console.error('[SERP] Resume error:', err)\n                            isResuming = false\n                          })\n                      }\n                    } else {\n                      stallCount = 0 // Reset stall count if progress is being made\n                    }\n                  }\n\n                  // Update last completed for next poll comparison\n                  lastCompletedCount = completed\n\n                  // Check if SERP phase is done (includes later states that imply SERP finished)\n                  const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n                  if (serpDone) {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    updateStepState(stepId, {\n                      status: 'completed',\n                      completedAt: new Date(),\n                      output: {\n                        jobId,\n                        urlsFound: statusData.job?.urls_found || 0,\n                        costs: statusData.costs,\n                      },\n                      progress: undefined, // Clear progress to stop spinner\n                    })\n                    setTimeout(goToNextStep, 500)\n                  } else if (statusData.status === 'failed' || statusData.status === 'error') {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    throw new Error(statusData.job?.error_message || 'Job failed')\n                  }\n                } catch (pollError) {\n                  if (pollIntervalRef.current) {\n                    clearInterval(pollIntervalRef.current)\n                    pollIntervalRef.current = null\n                  }\n                  updateStepState(stepId, {\n                    status: 'error',\n                    error: pollError instanceof Error ? pollError.message : 'Error checking job status',\n                  })\n                }\n              }, 2000) // Poll every 2 seconds\n\n              // Don't fall through to the completion logic below\n              return\n            }\n\n            // SCRAPE JOB: Scrape URLs from the SERP results\n            if (step.jobType === 'niche_finder_scrape') {\n              // Get the jobId from the previous step (search_and_preview)\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n              console.log('[SCRAPE] Looking for search_and_preview step:', searchStep)\n              console.log('[SCRAPE] search_and_preview output:', searchStep?.output)\n\n              // Also check for serp_search (legacy step name)\n              const serpStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'serp_search')\n              console.log('[SCRAPE] Looking for serp_search step:', serpStep)\n              console.log('[SCRAPE] serp_search output:', serpStep?.output)\n\n              // Try to get jobId from either step\n              let jobId = (searchStep?.output as { jobId?: string })?.jobId ||\n                          (serpStep?.output as { jobId?: string })?.jobId\n\n              // If still no jobId, try from input (might be passed from ReviewAndScrapePanel)\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n                console.log('[SCRAPE] Got jobId from input:', jobId)\n              }\n\n              if (!jobId) {\n                console.error('[SCRAPE] No jobId found. All steps:', state.phases.flatMap(p => p.steps).map(s => ({ id: s.id, output: s.output })))\n                throw new Error('No se encontró el Job ID del paso de búsqueda')\n              }\n\n              console.log('[SCRAPE] Starting scrape for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando scraping...' }\n              })\n\n              // Get total URLs to scrape\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.urls_found || 0\n\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Scrapeando 0/${totalUrls} URLs...` }\n              })\n\n              // Start scraping - this will scrape in batches\n              let scrapedCount = 0\n              let failedCount = 0\n              let hasMore = true\n\n              while (hasMore) {\n                try {\n                  const scrapeResponse = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = scrapeResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[SCRAPE] Non-JSON response, continuing...')\n                    // Wait a bit and continue polling\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'scrape_done') {\n                      hasMore = false\n                      scrapedCount = checkData.job?.scrape_success_count || 0\n                      failedCount = checkData.job?.scrape_failed_count || 0\n                    }\n                    continue\n                  }\n\n                  const scrapeData = await scrapeResponse.json()\n                  console.log('[SCRAPE] Batch response:', scrapeData)\n\n                  if (scrapeData.error) {\n                    throw new Error(scrapeData.error)\n                  }\n\n                  scrapedCount += scrapeData.scraped || 0\n                  failedCount += scrapeData.failed || 0\n                  hasMore = scrapeData.has_more || false\n\n                  // Update progress with real-time feedback\n                  updateStepState(stepId, {\n                    progress: {\n                      current: scrapedCount + failedCount,\n                      total: totalUrls,\n                      label: `Scrapeando ${scrapedCount + failedCount}/${totalUrls} URLs...`,\n                    },\n                    partialResults: {\n                      successCount: scrapedCount,\n                      failedCount: failedCount,\n                      lastUrl: scrapeData.last_scraped_url,\n                      lastSnippet: scrapeData.last_scraped_snippet,\n                    },\n                  })\n\n                } catch (scrapeError) {\n                  console.error('[SCRAPE] Batch error:', scrapeError)\n                  // Don't throw - try to continue with next batch\n                  // The endpoint will mark failed URLs and continue\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'scrape_done' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Scraping failed')\n                    }\n                  }\n                }\n              }\n\n              // Mark as completed\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  scrapedCount,\n                  failedCount,\n                },\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            if (step.jobType === 'niche_finder_extract') {\n              // Get jobId from previous steps (review_and_scrape or scrape_results)\n              const scrapeResultsStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'scrape_results')\n              const reviewAndScrapeStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'review_and_scrape')\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n\n              console.log('[EXTRACT] Looking for jobId from steps:', {\n                scrape_results: scrapeResultsStep?.output,\n                review_and_scrape: reviewAndScrapeStep?.output,\n                search_and_preview: searchStep?.output,\n              })\n\n              let jobId = (scrapeResultsStep?.output as { jobId?: string })?.jobId ||\n                          (reviewAndScrapeStep?.output as { jobId?: string })?.jobId ||\n                          (searchStep?.output as { jobId?: string })?.jobId\n\n              // Also try from input\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n              }\n\n              if (!jobId) {\n                console.error('[EXTRACT] No jobId found')\n                throw new Error('No se encontró el Job ID. Por favor ejecuta los pasos anteriores primero.')\n              }\n\n              console.log('[EXTRACT] Starting extraction for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' }\n              })\n\n              // Get total URLs to extract from job status\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.scrape_success_count || 0\n\n              console.log('[EXTRACT] Total URLs to process:', totalUrls)\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` }\n              })\n\n              // Call extract endpoint in batches until has_more=false\n              let hasMore = true\n              let extractedTotal = 0\n              let filteredTotal = 0\n              let processedTotal = 0\n\n              while (hasMore) {\n                try {\n                  const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = extractResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[EXTRACT] Non-JSON response, polling status...')\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'completed') {\n                      hasMore = false\n                      extractedTotal = checkData.job?.niches_extracted || 0\n                    }\n                    continue\n                  }\n\n                  const extractData = await extractResponse.json()\n                  console.log('[EXTRACT] Batch response:', extractData)\n\n                  if (extractData.error) {\n                    throw new Error(extractData.error)\n                  }\n\n                  extractedTotal += extractData.extracted || 0\n                  filteredTotal += extractData.filtered || 0\n                  processedTotal = extractedTotal + filteredTotal\n                  hasMore = extractData.has_more || false\n\n                  updateStepState(stepId, {\n                    progress: {\n                      current: processedTotal,\n                      total: totalUrls,\n                      label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                    },\n                    partialResults: {\n                      successCount: extractedTotal,\n                      failedCount: filteredTotal,\n                    },\n                  })\n                } catch (extractError) {\n                  console.error('[EXTRACT] Batch error:', extractError)\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'completed' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Extraction failed')\n                    }\n                  }\n                }\n              }\n\n              // Get extracted problems and format as CSV\n              console.log('[EXTRACT] Getting results from /api/niche-finder/results/', jobId)\n              const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n\n              if (!resultsResponse.ok) {\n                console.error('[EXTRACT] Failed to get results:', resultsResponse.status, resultsResponse.statusText)\n                throw new Error(`Error obteniendo resultados: ${resultsResponse.status}`)\n              }\n\n              const resultsData = await resultsResponse.json()\n              console.log('[EXTRACT] Results data:', {\n                hasNiches: !!resultsData.niches,\n                nichesCount: resultsData.niches?.length || 0,\n                status: resultsData.status,\n                urls: resultsData.urls,\n              })\n\n              // Format niches as CSV string with all relevant columns\n              const niches = resultsData.niches || []\n              let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n              for (const niche of niches) {\n                const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                const url = niche.source_url || ''\n                csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n              }\n\n              console.log('[EXTRACT] Completed. Total problems:', niches.length, 'CSV preview:', csvOutput.substring(0, 200))\n\n              // Mark as completed with CSV output\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: csvOutput,\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            // UNIFIED SEARCH + EXTRACT: Handles both SERP and analysis in one step\n            if (step.jobType === 'niche_finder_unified') {\n              const action = (input as { action?: string })?.action\n\n              // ============ ACTION: SERP ============\n              if (action === 'serp') {\n                const config = (input as { config?: { life_contexts: string[]; product_words: string[]; indicators: string[]; sources: { reddit: boolean; thematic_forums: boolean; general_forums: string[] }; serp_pages: number } }).config\n                if (!config) {\n                  throw new Error('No se recibió configuración para la búsqueda')\n                }\n\n                console.log('[UNIFIED] Starting SERP with config:', config)\n\n                // Get campaign variables\n                const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                // Create the SERP job\n                const jobResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: {\n                      ...config,\n                      campaign_id: selectedCampaignId,\n                      ecp_name: campaignVars?.['ECP Name'] || campaignVars?.ecp_name,\n                      ecp_product: campaignVars?.['ECP Product'] || campaignVars?.ecp_product,\n                      ecp_target: campaignVars?.['ECP Target'] || campaignVars?.ecp_target,\n                      ecp_industry: campaignVars?.['ECP Industry'] || campaignVars?.ecp_industry,\n                      ecp_category: campaignVars?.['ECP Category'] || campaignVars?.ecp_category,\n                      ecp_country: campaignVars?.['ECP Country'] || campaignVars?.ecp_country,\n                    }\n                  }),\n                })\n\n                if (!jobResponse.ok) {\n                  const errorText = await jobResponse.text()\n                  throw new Error(`Error al crear job: ${jobResponse.status} - ${errorText || 'Sin respuesta'}`)\n                }\n\n                const jobText = await jobResponse.text()\n                if (!jobText || jobText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al crear el job')\n                }\n\n                const jobData = JSON.parse(jobText)\n                const jobId = jobData.job_id\n\n                if (!jobId) {\n                  throw new Error('No se pudo crear el job de búsqueda')\n                }\n\n                console.log('[UNIFIED] SERP Job created:', jobId)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'serp_executing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' },\n                })\n\n                // Start SERP execution\n                const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n\n                if (!serpResponse.ok) {\n                  const serpErrorText = await serpResponse.text()\n                  let errorMessage = `Error al iniciar búsqueda SERP: ${serpResponse.status}`\n                  try {\n                    const serpError = JSON.parse(serpErrorText)\n                    if (serpError.code === 'MISSING_API_KEY') {\n                      errorMessage = `${serpError.error}`\n                    } else if (serpError.error) {\n                      errorMessage = serpError.error\n                    }\n                  } catch {\n                    if (serpErrorText) errorMessage += ` - ${serpErrorText}`\n                  }\n                  throw new Error(errorMessage)\n                }\n\n                console.log('[UNIFIED] SERP execution started successfully')\n\n                // Poll for SERP completion\n                let serpComplete = false\n                let pollRetries = 0\n                const MAX_POLL_RETRIES = 3\n                while (!serpComplete) {\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n                  try {\n                    const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n\n                    if (!statusRes.ok) {\n                      console.warn(`[UNIFIED] Status poll failed with ${statusRes.status}`)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error(`Error al consultar estado del job: ${statusRes.status}`)\n                      }\n                      continue\n                    }\n\n                    const text = await statusRes.text()\n                    if (!text || text.trim() === '') {\n                      console.warn('[UNIFIED] Empty response from status endpoint, retrying...')\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('El servidor no está respondiendo correctamente')\n                      }\n                      continue\n                    }\n\n                    const statusData = JSON.parse(text)\n                    pollRetries = 0 // Reset retries on success\n\n                    const urlsFound = statusData.job?.urls_found || 0\n                    // Status API returns serp_total and serp_completed (not total_queries/completed_queries)\n                    const totalSearches = statusData.job?.serp_total || statusData.progress?.serp?.total || 0\n                    const completedSearches = statusData.job?.serp_completed || statusData.progress?.serp?.completed || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: completedSearches,\n                        total: totalSearches,\n                        label: `Buscando... ${urlsFound} URLs encontradas`,\n                      },\n                    })\n\n                    if (['serp_done', 'serp_completed', 'scrape_done', 'completed'].includes(statusData.status)) {\n                      serpComplete = true\n                      console.log('[UNIFIED] SERP completed. URLs found:', urlsFound)\n                      updateStepState(stepId, {\n                        output: { jobId, phase: 'serp_complete', urlsFound },\n                        progress: undefined,\n                      })\n                    } else if (statusData.status === 'failed') {\n                      throw new Error(statusData.job?.error_message || 'SERP falló')\n                    }\n                  } catch (pollError) {\n                    if (pollError instanceof SyntaxError) {\n                      console.warn('[UNIFIED] JSON parse error in poll, retrying...', pollError)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('Error al procesar respuesta del servidor')\n                      }\n                    } else {\n                      throw pollError\n                    }\n                  }\n                }\n                return // Don't mark as completed - wait for analyze action\n              }\n\n              // ============ ACTION: ANALYZE (Scrape + Extract) ============\n              if (action === 'analyze') {\n                const jobId = (input as { jobId?: string }).jobId\n                const selectedSources = (input as { selectedSources?: string[] }).selectedSources || []\n                const extractionPrompt = (input as { extractionPrompt?: string }).extractionPrompt\n\n                if (!jobId) {\n                  throw new Error('No se encontró el Job ID')\n                }\n\n                console.log('[UNIFIED] Starting analysis for job:', jobId, 'sources:', selectedSources, 'custom prompt:', !!extractionPrompt)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'analyzing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando análisis...' },\n                })\n\n                // If a custom extraction prompt was provided, update the job config\n                if (extractionPrompt) {\n                  console.log('[UNIFIED] Updating job with custom extraction prompt')\n                  const updateRes = await fetch(`/api/niche-finder/jobs/${jobId}`, {\n                    method: 'PATCH',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ extraction_prompt: extractionPrompt }),\n                  })\n                  if (!updateRes.ok) {\n                    console.warn('[UNIFIED] Failed to update job with custom prompt:', updateRes.status)\n                  }\n                }\n\n                // Get total URLs to process\n                const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                if (!statusRes.ok) {\n                  throw new Error(`Error al obtener estado del job: ${statusRes.status}`)\n                }\n                const statusText = await statusRes.text()\n                if (!statusText || statusText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al consultar estado')\n                }\n                const statusData = JSON.parse(statusText)\n                const totalUrls = statusData.job?.urls_found || 0\n\n                // Start scraping - call API repeatedly until all URLs are processed\n                console.log('[UNIFIED] Starting scrape for', totalUrls, 'URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: totalUrls, label: 'Descargando contenido...' },\n                })\n\n                let scrapeComplete = false\n                let scrapeRetries = 0\n                let totalScraped = 0\n                let totalFailed = 0\n                const MAX_SCRAPE_RETRIES = 5 // More retries for transient failures\n\n                while (!scrapeComplete) {\n                  try {\n                    console.log(`[UNIFIED] Scrape batch starting, totalScraped=${totalScraped}, retries=${scrapeRetries}`)\n\n                    // Call scrape API with timeout (120s to allow for slow scrapes)\n                    const controller = new AbortController()\n                    const timeout = setTimeout(() => controller.abort(), 120000)\n\n                    const scrapeRes = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                      method: 'POST',\n                      headers: { 'Content-Type': 'application/json' },\n                      body: JSON.stringify({ sources: selectedSources }),\n                      signal: controller.signal,\n                    })\n                    clearTimeout(timeout)\n\n                    if (!scrapeRes.ok) {\n                      const errorText = await scrapeRes.text().catch(() => '')\n                      console.error(`[UNIFIED] Scrape response not ok: ${scrapeRes.status}`, errorText)\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(`Error en scraping: ${scrapeRes.status} - ${errorText || 'Unknown error'}`)\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeText = await scrapeRes.text()\n                    if (!scrapeText) {\n                      console.warn('[UNIFIED] Empty scrape response, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Respuesta vacía del servidor después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeData = JSON.parse(scrapeText)\n                    scrapeRetries = 0 // Reset on successful response\n\n                    if (scrapeData.error) {\n                      // Check if it's a retryable error\n                      if (scrapeData.error.includes('Rate limit') || scrapeData.error.includes('timeout')) {\n                        console.warn(`[UNIFIED] Retryable scrape error: ${scrapeData.error}`)\n                        scrapeRetries++\n                        if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(scrapeData.error)\n                        await new Promise(r => setTimeout(r, 5000))\n                        continue\n                      }\n                      throw new Error(scrapeData.error)\n                    }\n\n                    // Update progress with scraped count from this batch\n                    totalScraped += scrapeData.scraped || 0\n                    totalFailed += scrapeData.failed || 0\n                    const remaining = scrapeData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: totalScraped,\n                        total: totalUrls,\n                        label: `Descargando... ${totalScraped}/${totalUrls} URLs${totalFailed > 0 ? ` (${totalFailed} fallidas)` : ''}`,\n                      },\n                      partialResults: {\n                        successCount: totalScraped,\n                        failedCount: totalFailed,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Scrape batch complete: +${scrapeData.scraped} scraped, ${remaining} remaining, has_more: ${scrapeData.has_more}`)\n\n                    // Check if scraping is complete\n                    if (!scrapeData.has_more || remaining === 0) {\n                      scrapeComplete = true\n                    }\n                  } catch (e) {\n                    console.error('[UNIFIED] Scrape error:', e)\n                    if (e instanceof SyntaxError) {\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 3000))\n                    } else if (e instanceof Error && e.name === 'AbortError') {\n                      // Timeout - retry with longer wait\n                      console.warn('[UNIFIED] Scrape request timed out, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Timeout en scraping después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 5000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Scraping complete, total scraped:', totalScraped)\n\n                // Start extraction - use totalScraped as the base since only scraped URLs can be extracted\n                const extractionTotal = totalScraped || totalUrls // Fallback to totalUrls if scraping tracked differently\n                console.log('[UNIFIED] Starting extraction for', extractionTotal, 'scraped URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: extractionTotal, label: 'Extrayendo problemas...' },\n                })\n\n                let extractComplete = false\n                let extractedTotal = 0\n                let filteredTotal = 0\n                let extractRetries = 0\n\n                while (!extractComplete) {\n                  try {\n                    const extractRes = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, { method: 'POST' })\n                    if (!extractRes.ok) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error(`Error en extracción: ${extractRes.status}`)\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const text = await extractRes.text()\n                    if (!text) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Respuesta vacía del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const extractData = JSON.parse(text)\n                    extractRetries = 0\n\n                    if (extractData.error) {\n                      throw new Error(extractData.error)\n                    }\n\n                    extractedTotal += extractData.extracted || 0\n                    filteredTotal += extractData.filtered || 0\n                    const processed = extractedTotal + filteredTotal\n                    const remaining = extractData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: processed,\n                        total: extractionTotal,\n                        label: `Extrayendo... ${extractedTotal} problemas de ${processed}/${extractionTotal} URLs${filteredTotal > 0 ? ` (${filteredTotal} filtradas)` : ''}`,\n                      },\n                      partialResults: {\n                        extracted: extractedTotal,\n                        filtered: filteredTotal,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Extract batch: ${extractData.extracted} extracted, ${extractData.filtered} filtered, ${remaining} remaining, has_more: ${extractData.has_more}`)\n\n                    if (!extractData.has_more || remaining === 0) {\n                      extractComplete = true\n                    }\n                  } catch (e) {\n                    if (e instanceof SyntaxError) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Extraction complete. Problems:', extractedTotal, 'Filtered:', filteredTotal)\n\n                // Get results and format as CSV\n                console.log('[UNIFIED] Getting results')\n                const resultsRes = await fetch(`/api/niche-finder/results/${jobId}`)\n                if (!resultsRes.ok) {\n                  throw new Error(`Error al obtener resultados: ${resultsRes.status}`)\n                }\n                const resultsText = await resultsRes.text()\n                const resultsData = resultsText ? JSON.parse(resultsText) : { niches: [] }\n                const niches = resultsData.niches || []\n\n                let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n                for (const niche of niches) {\n                  const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                  const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                  const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                  const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                  const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                  const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                  const url = niche.source_url || ''\n                  csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n                }\n\n                console.log('[UNIFIED] Complete. Problems:', niches.length)\n                updateStepState(stepId, {\n                  status: 'completed',\n                  completedAt: new Date(),\n                  output: { jobId, extractedCount: niches.length, csv: csvOutput },\n                })\n                setTimeout(goToNextStep, 500)\n                return\n              }\n\n              // Unknown action\n              console.warn('[UNIFIED] Unknown action:', action)\n            }\n\n            // For other job types, just mark as pending\n            result = input\n            break\n\n          case 'none':\n          default:\n            // No execution needed, just proceed\n            result = input\n            break\n        }\n\n        // Mark as completed\n        updateStepState(stepId, {\n          status: 'completed',\n          completedAt: new Date(),\n          output: result,\n        })\n\n        // Auto-advance for auto steps\n        if (['auto', 'auto_with_review'].includes(step.type)) {\n          setTimeout(goToNextStep, 500)\n        }\n      } catch (error) {\n        updateStepState(stepId, {\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Error desconocido',\n        })\n      }\n    },\n    [projectId, playbookConfig.type, playbookConfig.phases, updateStepState, goToNextStep, selectedCampaign, state.phases]\n  )\n\n  // Handle continue from current step\n  const handleContinue = useCallback(() => {\n    console.log('[handleContinue] Called for step:', currentStep?.id, 'current status:', currentStepState?.status)\n    // Note: Don't update step state here if the caller (WorkArea) already updated it.\n    // The caller is responsible for setting status and output correctly before calling onContinue.\n    // We only set completedAt if not already completed, and we do it in a way that preserves output.\n    if (currentStepState?.status !== 'completed') {\n      console.log('[handleContinue] Status is not completed, updating step state (without output)')\n      // Mark as completed, but preserve any existing output that might have been set\n      // by the caller in the same tick (before React re-renders)\n      updateStepState(currentStep.id, {\n        status: 'completed',\n        completedAt: new Date(),\n        // Don't set output - it should already be set by the caller\n      })\n    } else {\n      console.log('[handleContinue] Status is already completed, not updating')\n    }\n    // Enable auto-execution for the next step (if it's an auto step)\n    setShouldAutoExecute(true)\n    goToNextStep()\n  }, [currentStep?.id, currentStepState?.status, updateStepState, goToNextStep])\n\n  // Handle edit - volver a editar un paso completado\n  const handleEdit = useCallback(() => {\n    if (!currentStep) return\n    // Cambiar status a pending sin perder los datos (suggestions, output, etc.)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      completedAt: undefined,\n      error: undefined,\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle cancel - cancelar ejecución en curso\n  // IMPORTANTE: Mantiene el output (jobId) para poder retomar el job\n  const handleCancel = useCallback(() => {\n    if (!currentStep) return\n\n    // Clear polling interval if running\n    if (pollIntervalRef.current) {\n      clearInterval(pollIntervalRef.current)\n      pollIntervalRef.current = null\n      console.log('[Cancel] Cleared polling interval')\n    }\n\n    // Volver a pending y limpiar progreso, pero MANTENER output (contiene jobId)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      progress: undefined,\n      error: undefined,\n      // NO limpiamos output para mantener el jobId y poder retomar\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle quick retry - retry with same configuration\n  const handleQuickRetry = useCallback(async () => {\n    if (!currentStep || !currentStepState) return\n\n    console.log('[Retry] Quick retry for step:', currentStep.id)\n\n    // Start a new retry attempt\n    try {\n      await stepRetryActions.startRetry(currentStep.id)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Reset step state and re-execute\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input\n    executeStep(currentStep.id, currentStepState.input)\n  }, [currentStep, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle retry with config modification - opens dialog\n  const handleRetryWithConfig = useCallback(() => {\n    if (!currentStep) return\n    setRetryDialogStepId(currentStep.id)\n    setRetryDialogOpen(true)\n  }, [currentStep])\n\n  // Handle retry from dialog with config overrides\n  const handleRetryFromDialog = useCallback(async (configOverrides?: StepAttemptConfig) => {\n    if (!retryDialogStepId || !currentStepState) return\n\n    console.log('[Retry] Retry from dialog for step:', retryDialogStepId, 'with config:', configOverrides)\n\n    // Start a new retry attempt with config\n    try {\n      await stepRetryActions.startRetry(retryDialogStepId, configOverrides)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Close dialog\n    setRetryDialogOpen(false)\n    setRetryDialogStepId(null)\n\n    // Reset step state\n    updateStepState(retryDialogStepId, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input (config overrides are tracked in the attempt)\n    executeStep(retryDialogStepId, currentStepState.input)\n  }, [retryDialogStepId, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle skip step - mark as skipped and continue\n  const handleSkipStep = useCallback(() => {\n    if (!currentStep) return\n\n    console.log('[Skip] Skipping step:', currentStep.id)\n\n    updateStepState(currentStep.id, {\n      status: 'skipped',\n      completedAt: new Date(),\n      error: undefined,\n    })\n\n    // Move to next step\n    handleContinue()\n  }, [currentStep, updateStepState, handleContinue])\n\n  // Get retry info for current step\n  const currentStepRetryInfo = currentStep\n    ? stepRetryActions.getRetryInfo(currentStep.id)\n    : null\n\n  // Check if max retries reached\n  const maxRetriesReached = currentStepRetryInfo\n    ? currentStepRetryInfo.attemptNumber >= currentStepRetryInfo.maxAttempts\n    : false\n\n  // Auto-start current step if it's an auto step, pending, AND user clicked Continue\n  useEffect(() => {\n    console.log('[AutoExecute] Check:', {\n      shouldAutoExecute,\n      currentStepId: currentStep?.id,\n      currentStepType: currentStep?.type,\n      currentStepStatus: currentStepState?.status,\n    })\n    if (\n      shouldAutoExecute &&\n      currentStep &&\n      currentStepState?.status === 'pending' &&\n      ['auto'].includes(currentStep.type)\n    ) {\n      console.log('[AutoExecute] Starting auto execution for:', currentStep.id)\n      // Reset the flag\n      setShouldAutoExecute(false)\n      // Small delay to allow UI to render first\n      const timer = setTimeout(() => {\n        executeStep(currentStep.id)\n      }, 300)\n      return () => clearTimeout(timer)\n    }\n  }, [shouldAutoExecute, currentStep, currentStepState?.status, executeStep])\n\n  // Resume polling for in_progress steps on page reload\n  // This handles the case where user refreshes the page while a SERP job is running\n  useEffect(() => {\n    // Only for search_with_preview steps that are in_progress with a jobId\n    if (\n      currentStep?.type === 'search_with_preview' &&\n      (currentStepState?.status === 'in_progress' || currentStepState?.status === 'pending') &&\n      currentStepState?.output &&\n      !pollIntervalRef.current\n    ) {\n      const output = currentStepState.output as { jobId?: string }\n      const jobId = output.jobId\n\n      if (jobId) {\n        console.log('[Resume] Resuming polling for job:', jobId)\n\n        // First, check if job is already done (immediate check, not polling)\n        fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          .then(res => res.json())\n          .then(statusData => {\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDone) {\n              console.log('[Resume] Job already completed, marking step as done')\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n              return // Don't start polling\n            }\n            // If not done, continue with normal polling setup below\n            startPolling()\n          })\n          .catch(err => {\n            console.error('[Resume] Error checking initial status:', err)\n            startPolling() // Start polling anyway\n          })\n\n        function startPolling() {\n          if (pollIntervalRef.current) return // Already polling\n\n          // Set up polling - same logic as in executeStep\n          let isResuming = false\n          let lastCompletedCount = -1\n          let stallCount = 0\n          let initialCompleted = -1\n\n          pollIntervalRef.current = setInterval(async () => {\n          try {\n            const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n            const statusData = await statusResponse.json()\n\n            const completed = statusData.progress?.serp?.completed || 0\n            const total = statusData.progress?.serp?.total || 0\n            const remaining = total - completed\n            const label = total > 0\n              ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n              : 'Reconectando...'\n\n            updateStepState(currentStep.id, {\n              progress: {\n                current: completed,\n                total: total,\n                label,\n              },\n            })\n\n            // Track initial value on first poll\n            if (initialCompleted === -1) {\n              initialCompleted = completed\n              console.log('[Resume] Initial completed:', initialCompleted)\n            }\n\n            // Auto-resume if job was interrupted\n            if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n              if (lastCompletedCount === completed && remaining > 0) {\n                stallCount++\n                const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                if (stallCount >= 2 || noProgressSinceStart) {\n                  console.log(`[Resume] Job stalled at ${completed}/${total}, auto-resuming...`)\n                  isResuming = true\n                  stallCount = 0\n                  fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                    .then(res => res.json())\n                    .then(data => {\n                      console.log('[Resume] Resume response:', data)\n                      isResuming = false\n                    })\n                    .catch(err => {\n                      console.error('[Resume] Resume error:', err)\n                      isResuming = false\n                    })\n                }\n              } else {\n                stallCount = 0\n              }\n            }\n            lastCompletedCount = completed\n\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDoneInPoll = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDoneInPoll) {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n            } else if (statusData.status === 'failed' || statusData.status === 'error') {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'error',\n                error: statusData.job?.error_message || 'Job failed',\n              })\n            }\n          } catch (pollError) {\n            console.error('[Resume] Poll error:', pollError)\n            // Don't stop polling on transient errors\n          }\n        }, 2000)\n        } // End startPolling function\n\n        // Cleanup on unmount\n        return () => {\n          if (pollIntervalRef.current) {\n            clearInterval(pollIntervalRef.current)\n            pollIntervalRef.current = null\n          }\n        }\n      }\n    }\n  }, [currentStep?.id, currentStep?.type, currentStepState?.status, currentStepState?.output, updateStepState, goToNextStep])\n\n  if (!currentPhase || !currentStep || !currentStepState) {\n    return (\n      <div className=\"flex items-center justify-center h-64 text-gray-500\">\n        Error: Configuración de playbook inválida\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n      {/* Header with mode selector */}\n      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3\">\n          <span className=\"text-xl\">{playbookConfig.icon}</span>\n          <h2 className=\"text-lg font-semibold text-gray-900\">{playbookConfig.name}</h2>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {/* Session Data button */}\n          {selectedCampaignId && mode === 'campaign' && (\n            <button\n              onClick={() => setShowArtifactBrowser(!showArtifactBrowser)}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                showArtifactBrowser\n                  ? 'bg-indigo-100 text-indigo-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n              title=\"Browse all session artifacts\"\n            >\n              <Database size={16} />\n              Session Data\n            </button>\n          )}\n\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}\n          <div className=\"relative flex items-center gap-1\">\n            <button\n              onClick={() => {\n                setMode('campaign')\n                setShowCampaignDropdown(!showCampaignDropdown)\n              }}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                mode === 'campaign'\n                  ? 'bg-blue-100 text-blue-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Folder size={16} />\n              {selectedCampaign ? selectedCampaign.name : 'Seleccionar Campaña'}\n              <ChevronDown size={16} />\n            </button>\n\n            {/* Edit campaign settings button */}\n            {selectedCampaignId && (\n              <button\n                onClick={() => setShowCampaignSettings(true)}\n                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg\"\n                title=\"Editar configuración de campaña\"\n              >\n                <Pencil size={14} />\n              </button>\n            )}\n\n            {/* Dropdown */}\n            {showCampaignDropdown && (\n              <div className=\"absolute right-0 top-full mt-1 w-64 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50\">\n                {campaigns.length === 0 ? (\n                  <div className=\"px-3 py-2 text-sm text-gray-500\">No hay campañas</div>\n                ) : (\n                  campaigns.map(campaign => (\n                    <div\n                      key={campaign.id}\n                      className={`flex items-center justify-between px-3 py-2 text-sm hover:bg-gray-50 ${\n                        selectedCampaignId === campaign.id ? 'bg-blue-50' : ''\n                      }`}\n                    >\n                      <button\n                        onClick={() => {\n                          setSelectedCampaignId(campaign.id)\n                          setShowCampaignDropdown(false)\n                        }}\n                        className=\"flex-1 flex items-center justify-between text-left\"\n                      >\n                        <span className=\"font-medium text-gray-900\">{campaign.name}</span>\n                        <span className=\"text-gray-500 mr-2\">\n                          {campaign.completedSteps}/{campaign.totalSteps}\n                        </span>\n                      </button>\n                      <button\n                        onClick={(e) => {\n                          e.stopPropagation()\n                          deleteCampaign(campaign.id)\n                        }}\n                        className=\"p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded\"\n                        title=\"Eliminar campaña\"\n                      >\n                        <Trash2 size={14} />\n                      </button>\n                    </div>\n                  ))\n                )}\n                <div className=\"border-t border-gray-100 mt-1 pt-1\">\n                  <button\n                    onClick={() => {\n                      setShowWizard(true)\n                      setShowCampaignDropdown(false)\n                    }}\n                    className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-blue-600 hover:bg-blue-50\"\n                  >\n                    <Plus size={16} />\n                    Nueva Campaña\n                  </button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Main content */}\n      {mode === 'config' ? (\n        /* Configuration Mode - Full width */\n        <div className=\"flex-1 overflow-hidden\">\n          <ConfigurationMode\n            projectId={projectId}\n            playbookConfig={playbookConfig}\n            onSave={() => {\n              // Optionally refresh something after save\n            }}\n          />\n        </div>\n      ) : (\n        /* Campaign Mode - Dual panel */\n        <div className=\"flex flex-1 overflow-hidden\">\n          {/* Navigation Panel - Left side */}\n          <div className=\"w-80 flex-shrink-0\">\n            <NavigationPanel\n              phases={playbookConfig.phases}\n              phaseStates={state.phases}\n              currentPhaseIndex={state.currentPhaseIndex}\n              currentStepIndex={state.currentStepIndex}\n              onStepClick={goToStep}\n            />\n          </div>\n\n          {/* Work Area - Right side */}\n          <div className=\"flex-1 overflow-y-auto\">\n            {!selectedCampaignId ? (\n              /* No campaign selected - prompt to select or create */\n              <div className=\"flex flex-col items-center justify-center h-full bg-white p-8 text-center\">\n                <Folder className=\"text-gray-300 mb-4\" size={64} />\n                <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                  Selecciona o crea una campaña\n                </h3>\n                <p className=\"text-gray-500 mb-6 max-w-md\">\n                  Para ejecutar el playbook, primero debes seleccionar una campaña existente o crear una nueva.\n                </p>\n                <button\n                  onClick={() => setShowWizard(true)}\n                  className=\"flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n                >\n                  <Plus size={16} />\n                  Nueva Campaña\n                </button>\n              </div>\n            ) : (\n              <>\n                <WorkArea\n                  step={currentStep}\n                  stepState={currentStepState}\n                  onContinue={handleContinue}\n                  onBack={goToPreviousStep}\n                  onExecute={(input) => executeStep(currentStep.id, input)}\n                  onUpdateState={(update) => updateStepState(currentStep.id, update)}\n                  onEdit={handleEdit}\n                  onCancel={handleCancel}\n                  onRerunPrevious={rerunPreviousStep}\n                  onRetry={handleQuickRetry}\n                  onRetryWithConfig={handleRetryWithConfig}\n                  onSkipStep={handleSkipStep}\n                  isFirst={isFirstStep}\n                  isLast={isLastStep}\n                  previousStepOutput={getPreviousStepOutput()}\n                  projectId={projectId}\n                  playbookContext={buildPlaybookContext()}\n                  allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                    phase.steps.map((stepDef, stepIdx) => ({\n                      definition: stepDef,\n                      state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                    }))\n                  )}\n                  saveState={sessionId ? stepPersistenceState : undefined}\n                  retryInfo={currentStepRetryInfo || undefined}\n                  maxRetriesReached={maxRetriesReached}\n                  sessionId={sessionId}\n                />\n\n                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n\n          {/* Artifact Browser Panel - Right side */}\n          {showArtifactBrowser && selectedCampaignId && (\n            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">\n              <ArtifactBrowser\n                sessionId={sessionId}\n                projectId={projectId}\n                clientId=\"\"\n                userId=\"system\"\n                campaignId={selectedCampaignId}\n                campaignName={selectedCampaign?.name || ''}\n                playbookId={playbookConfig.id}\n                playbookName={playbookConfig.name}\n                playbookType={playbookConfig.type}\n                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                  phase.steps.map((stepDef, stepIdx) => ({\n                    definition: stepDef,\n                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                  }))\n                )}\n                isVisible={showArtifactBrowser}\n                onClose={() => setShowArtifactBrowser(false)}\n              />\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Campaign Wizard Modal */}\n      {showWizard && (\n        <CampaignWizard\n          projectId={projectId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowWizard(false)}\n          onCreated={(campaignId) => {\n            setSelectedCampaignId(campaignId)\n            setShowWizard(false)\n            // Reload campaigns\n            loadCampaigns()\n          }}\n        />\n      )}\n\n      {/* Campaign Settings Modal */}\n      {showCampaignSettings && selectedCampaignId && (\n        <CampaignSettings\n          campaignId={selectedCampaignId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowCampaignSettings(false)}\n          onSaved={() => {\n            loadCampaigns()\n          }}\n        />\n      )}\n    </div>\n  )\n}\n","structuredPatch":[{"oldStart":172,"oldLines":6,"newStart":172,"newLines":7,"lines":["   const [showWizard, setShowWizard] = useState(false)","   const [showCampaignSettings, setShowCampaignSettings] = useState(false)","   const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)","+  const [projectData, setProjectData] = useState<{ clientId: string; userId: string } | null>(null)"," ","   // Load campaigns from database","   const loadCampaigns = useCallback(async () => {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019gUpMWKQsQ3oCMGj33ZeDF","type":"message","role":"assistant","content":[{"type":"text","text":"Now add an effect to fetch the project data:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":377,"cache_read_input_tokens":132469,"cache_creation":{"ephemeral_5m_input_tokens":377,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"b1c75239-a09c-4e18-8c43-57d3fb21978c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019gUpMWKQsQ3oCMGj33ZeDF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T7odWNLN9N7hbZvK3exaPz","name":"Edit","input":{"replace_all":false,"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","old_string":"  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)","new_string":"  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  // Load project data (for clientId)\n  useEffect(() => {\n    async function loadProjectData() {\n      try {\n        const response = await fetch(`/api/projects/${projectId}`)\n        if (response.ok) {\n          const data = await response.json()\n          setProjectData({\n            clientId: data.client_id || '',\n            userId: 'system', // TODO: Get from auth context\n          })\n        }\n      } catch (error) {\n        console.error('Error loading project data:', error)\n      }\n    }\n    loadProjectData()\n  }, [projectId])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":377,"cache_read_input_tokens":132469,"cache_creation":{"ephemeral_5m_input_tokens":377,"ephemeral_1h_input_tokens":0},"output_tokens":398,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"f8145a10-4f91-4230-88ab-8ccfd62aa0ed"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T7odWNLN9N7hbZvK3exaPz","type":"tool_result","content":"The file /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"419e0938-9e5f-4497-b102-bf7392fdfe4a","tool_use_result":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","oldString":"  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)","newString":"  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  // Load project data (for clientId)\n  useEffect(() => {\n    async function loadProjectData() {\n      try {\n        const response = await fetch(`/api/projects/${projectId}`)\n        if (response.ok) {\n          const data = await response.json()\n          setProjectData({\n            clientId: data.client_id || '',\n            userId: 'system', // TODO: Get from auth context\n          })\n        }\n      } catch (error) {\n        console.error('Error loading project data:', error)\n      }\n    }\n    loadProjectData()\n  }, [projectId])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)","originalFile":"'use client'\n\nimport { useState, useCallback, useEffect, useRef } from 'react'\nimport {\n  PlaybookShellProps,\n  PlaybookState,\n  PhaseState,\n  StepState,\n  StepDefinition,\n  PhaseDefinition,\n} from './types'\nimport NavigationPanel from './NavigationPanel'\nimport { WorkArea } from './WorkArea'\nimport ConfigurationMode from './ConfigurationMode'\nimport CampaignWizard from './CampaignWizard'\nimport CampaignSettings from './CampaignSettings'\nimport { Settings, ChevronDown, Plus, Folder, Pencil, Trash2, Database } from 'lucide-react'\nimport { ArtifactBrowser } from './ArtifactBrowser'\nimport { useStepPersistence } from '@/hooks/useStepPersistence'\nimport { useStepRetry } from '@/hooks/useStepRetry'\nimport { StepAttemptConfig, StepRetryInfo } from './types'\nimport StepRetryDialog from './StepRetryDialog'\nimport FailedStepActions from './FailedStepActions'\n\n// Mode types for the unified view\ntype PlaybookMode = 'config' | 'campaign'\n\ninterface Campaign {\n  id: string\n  name: string\n  status: 'draft' | 'in_progress' | 'completed'\n  completedSteps: number\n  totalSteps: number\n  customVariables?: Record<string, unknown> // Includes context_type, product, target, etc.\n  playbookState?: PlaybookState // Saved playbook state for persistence\n}\n\nfunction initializeState(\n  projectId: string,\n  playbookConfig: PlaybookShellProps['playbookConfig'],\n  initialState?: Partial<PlaybookState>\n): PlaybookState {\n  const phases: PhaseState[] = playbookConfig.phases.map(phase => ({\n    id: phase.id,\n    status: 'pending',\n    steps: phase.steps.map(step => ({\n      id: step.id,\n      status: 'pending',\n    })),\n  }))\n\n  // Apply initial state if provided - match by ID for robustness when config changes\n  if (initialState?.phases) {\n    initialState.phases.forEach((savedPhaseState) => {\n      // Find phase by ID instead of index\n      const phaseIndex = phases.findIndex(p => p.id === savedPhaseState.id)\n      if (phaseIndex === -1) return\n\n      phases[phaseIndex].status = savedPhaseState.status\n      savedPhaseState.steps.forEach((savedStepState) => {\n        // Find step by ID instead of index\n        const stepIndex = phases[phaseIndex].steps.findIndex(s => s.id === savedStepState.id)\n        if (stepIndex === -1) return\n\n        phases[phaseIndex].steps[stepIndex] = {\n          ...phases[phaseIndex].steps[stepIndex],\n          ...savedStepState,\n        }\n      })\n    })\n  }\n\n  const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n  const completedSteps = phases.reduce(\n    (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n    0\n  )\n\n  // Validate currentPhaseIndex and currentStepIndex are within bounds\n  let currentPhaseIndex = initialState?.currentPhaseIndex ?? 0\n  let currentStepIndex = initialState?.currentStepIndex ?? 0\n\n  // Ensure phase index is valid\n  if (currentPhaseIndex >= playbookConfig.phases.length) {\n    currentPhaseIndex = Math.max(0, playbookConfig.phases.length - 1)\n  }\n\n  // Ensure step index is valid for the current phase\n  const currentPhaseSteps = playbookConfig.phases[currentPhaseIndex]?.steps.length ?? 0\n  if (currentStepIndex >= currentPhaseSteps) {\n    currentStepIndex = Math.max(0, currentPhaseSteps - 1)\n  }\n\n  // If the current step doesn't exist, find the first non-completed step\n  if (currentPhaseSteps === 0 || currentStepIndex < 0) {\n    // Find first pending step\n    for (let pi = 0; pi < phases.length; pi++) {\n      for (let si = 0; si < phases[pi].steps.length; si++) {\n        if (phases[pi].steps[si].status !== 'completed') {\n          currentPhaseIndex = pi\n          currentStepIndex = si\n          break\n        }\n      }\n      if (currentStepIndex >= 0) break\n    }\n    // Default to first step if all completed\n    if (currentStepIndex < 0) {\n      currentPhaseIndex = 0\n      currentStepIndex = 0\n    }\n  }\n\n  console.log('[initializeState] Validated indices:', {\n    originalPhase: initialState?.currentPhaseIndex,\n    originalStep: initialState?.currentStepIndex,\n    validatedPhase: currentPhaseIndex,\n    validatedStep: currentStepIndex,\n    maxPhases: playbookConfig.phases.length,\n    maxSteps: currentPhaseSteps,\n  })\n\n  return {\n    projectId,\n    playbookType: playbookConfig.type,\n    phases,\n    currentPhaseIndex,\n    currentStepIndex,\n    config: initialState?.config ?? {},\n    completedSteps,\n    totalSteps,\n    startedAt: initialState?.startedAt,\n    completedAt: initialState?.completedAt,\n  }\n}\n\nexport default function PlaybookShell({\n  projectId,\n  playbookConfig,\n  initialState,\n  sessionId,\n}: PlaybookShellProps) {\n  const [state, setState] = useState<PlaybookState>(() =>\n    initializeState(projectId, playbookConfig, initialState)\n  )\n\n  // Step persistence hook for auto-saving step data to database\n  const [stepPersistenceState, stepPersistenceActions] = useStepPersistence({\n    sessionId: sessionId || null,\n    autoSaveInterval: 30000, // Auto-save every 30 seconds\n    enabled: !!sessionId, // Only enable if sessionId is provided\n  })\n\n  // Step retry hook for managing retry attempts\n  const [stepRetryState, stepRetryActions] = useStepRetry(sessionId || null, {\n    enabled: !!sessionId,\n  })\n\n  // State for retry dialog\n  const [retryDialogOpen, setRetryDialogOpen] = useState(false)\n  const [retryDialogStepId, setRetryDialogStepId] = useState<string | null>(null)\n\n  // Flag to distinguish between intentional navigation (Continue button)\n  // vs manual navigation (clicking on a step)\n  const [shouldAutoExecute, setShouldAutoExecute] = useState(false)\n\n  // Mode: 'config' for editing base prompts, 'campaign' for execution\n  const [mode, setMode] = useState<PlaybookMode>('campaign')\n  const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null)\n  const [campaigns, setCampaigns] = useState<Campaign[]>([])\n  const [showCampaignDropdown, setShowCampaignDropdown] = useState(false)\n  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)\n  const [projectData, setProjectData] = useState<{ clientId: string; userId: string } | null>(null)\n\n  // Load campaigns from database\n  const loadCampaigns = useCallback(async () => {\n    try {\n      const response = await fetch(`/api/campaign/create?projectId=${projectId}`)\n      if (!response.ok) {\n        console.error('Failed to load campaigns')\n        return\n      }\n      const data = await response.json()\n      if (data.campaigns) {\n        const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n        const mappedCampaigns: Campaign[] = data.campaigns.map((c: any) => ({\n          id: c.id,\n          name: c.ecp_name,\n          status: c.status || 'draft',\n          // Calculate completed steps from playbook_state if available\n          completedSteps: c.playbook_state?.completedSteps ?? 0,\n          totalSteps,\n          customVariables: c.custom_variables || {}, // Load campaign variables including context_type\n          playbookState: c.playbook_state || null, // Load saved playbook state\n        }))\n        setCampaigns(mappedCampaigns)\n      }\n    } catch (error) {\n      console.error('Error loading campaigns:', error)\n    }\n  }, [projectId, playbookConfig.phases])\n\n  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)\n\n  // Ref to track if we should save (avoid saving on initial load)\n  const shouldSaveRef = useRef(false)\n  // Ref to prevent duplicate saves\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  // Ref to store polling interval for cancellation\n  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Save playbook state to database (debounced)\n  const savePlaybookState = useCallback(async (stateToSave: PlaybookState) => {\n    if (!selectedCampaignId) return\n\n    try {\n      await fetch(`/api/campaign/${selectedCampaignId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ playbook_state: stateToSave }),\n      })\n    } catch (error) {\n      console.error('Error saving playbook state:', error)\n    }\n  }, [selectedCampaignId])\n\n  // Auto-save state when it changes (debounced)\n  useEffect(() => {\n    if (!shouldSaveRef.current || !selectedCampaignId) return\n\n    // Clear any pending save\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current)\n    }\n\n    // Debounce saves by 500ms to avoid too many API calls\n    saveTimeoutRef.current = setTimeout(() => {\n      savePlaybookState(state)\n    }, 500)\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n      }\n    }\n  }, [state, selectedCampaignId, savePlaybookState])\n\n  // Load saved state when selecting a campaign\n  useEffect(() => {\n    if (!selectedCampaignId) {\n      shouldSaveRef.current = false\n      return\n    }\n\n    const campaign = campaigns.find(c => c.id === selectedCampaignId)\n    if (campaign?.playbookState) {\n      // Load saved state\n      shouldSaveRef.current = false // Don't save while loading\n      setState(initializeState(projectId, playbookConfig, campaign.playbookState))\n      // Enable saving after a short delay\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    } else {\n      // Fresh state for new campaign\n      shouldSaveRef.current = false\n      setState(initializeState(projectId, playbookConfig))\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    }\n  }, [selectedCampaignId, campaigns, projectId, playbookConfig])\n\n  // Load step data from database on session resume (if sessionId is provided)\n  useEffect(() => {\n    if (!sessionId) return\n\n    const loadStepData = async () => {\n      try {\n        const savedSteps = await stepPersistenceActions.loadAllSteps()\n        if (Object.keys(savedSteps).length === 0) return\n\n        console.log('[PlaybookShell] Loaded step data from session:', Object.keys(savedSteps))\n\n        // Merge saved step data into current state\n        setState(prev => {\n          const newPhases = prev.phases.map(phase => ({\n            ...phase,\n            steps: phase.steps.map(step => {\n              const savedStep = savedSteps[step.id]\n              if (savedStep) {\n                return {\n                  ...step,\n                  ...savedStep,\n                }\n              }\n              return step\n            }),\n          }))\n\n          // Recalculate phase status\n          newPhases.forEach(phase => {\n            const hasError = phase.steps.some(s => s.status === 'error')\n            const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n            const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n            if (hasError) {\n              phase.status = 'error'\n            } else if (allCompleted) {\n              phase.status = 'completed'\n            } else if (hasInProgress) {\n              phase.status = 'in_progress'\n            } else {\n              phase.status = 'pending'\n            }\n          })\n\n          // Recalculate completed steps\n          const completedSteps = newPhases.reduce(\n            (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n            0\n          )\n\n          // Find the first non-completed step to set as current\n          let currentPhaseIndex = 0\n          let currentStepIndex = 0\n          outer: for (let pi = 0; pi < newPhases.length; pi++) {\n            for (let si = 0; si < newPhases[pi].steps.length; si++) {\n              if (newPhases[pi].steps[si].status !== 'completed') {\n                currentPhaseIndex = pi\n                currentStepIndex = si\n                break outer\n              }\n            }\n          }\n\n          return {\n            ...prev,\n            phases: newPhases,\n            completedSteps,\n            currentPhaseIndex,\n            currentStepIndex,\n          }\n        })\n      } catch (error) {\n        console.error('[PlaybookShell] Error loading step data:', error)\n      }\n    }\n\n    loadStepData()\n  }, [sessionId, stepPersistenceActions])\n\n  // Delete a campaign\n  const deleteCampaign = useCallback(async (campaignId: string) => {\n    if (!confirm('¿Estás seguro de que quieres eliminar esta campaña? Esta acción no se puede deshacer.')) {\n      return\n    }\n\n    try {\n      const response = await fetch(`/api/campaign/${campaignId}`, {\n        method: 'DELETE',\n      })\n\n      if (!response.ok) {\n        throw new Error('Error al eliminar campaña')\n      }\n\n      // If we deleted the selected campaign, clear selection\n      if (selectedCampaignId === campaignId) {\n        setSelectedCampaignId(null)\n      }\n\n      // Reload campaigns\n      loadCampaigns()\n    } catch (error) {\n      console.error('Error deleting campaign:', error)\n      alert('Error al eliminar la campaña')\n    }\n  }, [selectedCampaignId, loadCampaigns])\n\n  // Helper function to get the output from the previous step\n  const getPreviousStepOutput = (): string | undefined => {\n    // Find the current step's dependencies\n    if (!currentStep?.dependsOn?.length) return undefined\n\n    // Get the first dependency's output\n    const dependencyId = currentStep.dependsOn[0]\n\n    // Search for this step across all phases\n    for (const phase of state.phases) {\n      const stepState = phase.steps.find(s => s.id === dependencyId)\n      if (stepState?.output) {\n        return typeof stepState.output === 'string'\n          ? stepState.output\n          : JSON.stringify(stepState.output, null, 2)\n      }\n    }\n\n    return undefined\n  }\n\n  // Build context for LLM-based suggestion generation\n  const buildPlaybookContext = (): Record<string, unknown> => {\n    // Start with campaign's custom_variables (includes context_type, product, target, etc.)\n    const campaignVars = selectedCampaign?.customVariables || {}\n\n    const context: Record<string, unknown> = {\n      ...campaignVars, // Include all campaign variables\n      product: campaignVars.product || state.config?.product || '',\n      target: campaignVars.target || state.config?.target || '',\n      context_type: campaignVars.context_type || 'both', // Explicitly include context_type\n    }\n\n    // DEBUG: Log all steps to see their state\n    console.log('[buildPlaybookContext] All steps:', state.phases.flatMap(p =>\n      p.steps.map(s => ({ id: s.id, status: s.status, hasOutput: !!s.output }))\n    ))\n\n    // Collect values from completed steps\n    for (const phase of state.phases) {\n      for (const stepState of phase.steps) {\n        // DEBUG: Log keyword_config step specifically\n        if (stepState.id === 'keyword_config') {\n          console.log('[buildPlaybookContext] keyword_config step:', {\n            status: stepState.status,\n            hasOutput: !!stepState.output,\n            outputKeys: stepState.output ? Object.keys(stepState.output as object) : [],\n            output: stepState.output,\n          })\n        }\n\n        if (stepState.status === 'completed' || stepState.decision || stepState.suggestions) {\n          // Get decision value\n          if (stepState.decision) {\n            context[stepState.id] = stepState.decision\n          }\n\n          // Get selected suggestions as array of labels\n          if (stepState.suggestions?.length) {\n            const selectedLabels = stepState.suggestions\n              .filter(s => s.selected)\n              .map(s => s.label)\n            if (selectedLabels.length > 0) {\n              context[stepState.id] = selectedLabels\n            }\n          }\n\n          // Get output if available\n          if (stepState.output) {\n            context[`${stepState.id}_output`] = stepState.output\n          }\n\n          // Special case: Extract serpJobId from serp_search or search_and_preview step output\n          // This is needed for review_urls/review_and_scrape step to display SERP results\n          // Note: We check this inside the completed block, but also outside below\n          if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Also extract serpJobId from review_and_scrape step (the scrape step)\n          // This ensures scrape_results step can find the jobId after scraping completes\n          if (stepState.id === 'review_and_scrape' && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId && !context.serpJobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Special case: Parse sources step output for QueryPreviewPanel\n          // The LLM returns a JSON string that needs to be parsed\n          if (stepState.id === 'sources' && stepState.output) {\n            try {\n              let parsedSources = stepState.output\n              if (typeof stepState.output === 'string') {\n                // Try to extract JSON from the LLM response\n                const jsonMatch = stepState.output.match(/\\{[\\s\\S]*\\}/)\n                if (jsonMatch) {\n                  parsedSources = JSON.parse(jsonMatch[0])\n                }\n              }\n              // Only set if it's a valid sources config object\n              if (parsedSources && typeof parsedSources === 'object' &&\n                  ('reddit' in parsedSources || 'thematic_forums' in parsedSources || 'general_forums' in parsedSources)) {\n                context.sources = parsedSources\n              }\n            } catch (e) {\n              console.error('[buildPlaybookContext] Error parsing sources output:', e)\n              // Don't set context.sources - let it use default values\n            }\n          }\n\n          // Special case: Extract keyword_config unified output for SearchWithPreviewStep\n          // The unified panel saves data in two formats:\n          // 1. lifeContexts, needWords, indicators as arrays of objects (for UI)\n          // 2. life_contexts, product_words, indicators as arrays of strings (for SERP job)\n          if (stepState.id === 'keyword_config' && stepState.output) {\n            const output = stepState.output as {\n              // Object arrays (for UI state)\n              lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n              needWords?: Array<{ id: string; label: string; selected: boolean }>\n              indicators?: Array<{ id: string; label: string; selected: boolean }>\n              // String arrays (pre-extracted for SERP job)\n              life_contexts?: string[]\n              product_words?: string[]\n              sources?: {\n                reddit_general?: { enabled: boolean }\n                reddit?: { enabled: boolean; subreddits?: string[] }\n                thematic_forums?: { enabled: boolean; forums?: string[] }\n                general_forums?: { enabled: boolean; forums?: string[] }\n              }\n            }\n\n            // First try to use pre-extracted string arrays (set on completion)\n            if (output.life_contexts && Array.isArray(output.life_contexts)) {\n              context.life_contexts = output.life_contexts\n            } else if (output.lifeContexts) {\n              // Fall back to extracting from object array\n              context.life_contexts = output.lifeContexts\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            // Check multiple possible keys for need words\n            if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n              context.need_words = output.product_words\n              console.log('[buildPlaybookContext] Got need_words from product_words:', output.product_words)\n            } else if ((output as any).need_words && Array.isArray((output as any).need_words) && (output as any).need_words.length > 0) {\n              // Also check for 'need_words' key (alternative naming)\n              context.need_words = (output as any).need_words\n              console.log('[buildPlaybookContext] Got need_words from need_words key:', (output as any).need_words)\n            } else if (output.needWords && Array.isArray(output.needWords)) {\n              const extracted = output.needWords\n                .filter(item => item.selected)\n                .map(item => item.label)\n              if (extracted.length > 0) {\n                context.need_words = extracted\n                console.log('[buildPlaybookContext] Got need_words from needWords (selected):', extracted)\n              } else {\n                console.warn('[buildPlaybookContext] needWords array exists but no items selected:', output.needWords)\n              }\n            } else {\n              console.warn('[buildPlaybookContext] Could not find need_words in output:', {\n                hasProductWords: !!output.product_words,\n                productWordsLength: output.product_words?.length,\n                hasNeedWords: !!(output as any).need_words,\n                hasNeedWordsArray: !!output.needWords,\n                outputKeys: Object.keys(output),\n              })\n            }\n\n            if (output.indicators && Array.isArray(output.indicators) && typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else if (output.indicators && Array.isArray(output.indicators)) {\n              context.indicators = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            if (output.sources) {\n              context.sources = output.sources\n            }\n\n            // DEBUG: Log what we extracted from keyword_config\n            console.log('[buildPlaybookContext] Extracted from keyword_config:', {\n              life_contexts: context.life_contexts,\n              need_words: context.need_words,\n              indicators: context.indicators,\n              sources: context.sources,\n            })\n          }\n        }\n\n        // IMPORTANT: Extract serpJobId even from non-completed steps (e.g., after cancel)\n        // This allows review_and_scrape to show URLs from a cancelled SERP job\n        if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also check review_and_scrape for non-completed steps (e.g., in progress or cancelled)\n        if (stepState.id === 'review_and_scrape' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also extract serpJobId from scrape_results step (for extraction step)\n        if (stepState.id === 'scrape_results' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // IMPORTANT: Also extract keyword_config data even if step is not 'completed'\n        // This ensures retry/navigation doesn't lose the config\n        if (stepState.id === 'keyword_config' && stepState.output && !context.life_contexts) {\n          console.log('[buildPlaybookContext] Extracting keyword_config from non-completed step')\n          const output = stepState.output as {\n            lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n            needWords?: Array<{ id: string; label: string; selected: boolean }>\n            indicators?: Array<{ id: string; label: string; selected: boolean }>\n            life_contexts?: string[]\n            product_words?: string[]\n            sources?: Record<string, unknown>\n          }\n\n          if (output.life_contexts && Array.isArray(output.life_contexts) && output.life_contexts.length > 0) {\n            context.life_contexts = output.life_contexts\n          } else if (output.lifeContexts) {\n            const extracted = output.lifeContexts.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.life_contexts = extracted\n            }\n          }\n\n          if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n            context.need_words = output.product_words\n          } else if (output.needWords) {\n            const extracted = output.needWords.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.need_words = extracted\n            }\n          }\n\n          if (output.indicators && Array.isArray(output.indicators) && output.indicators.length > 0) {\n            if (typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else {\n              const extracted = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected).map(item => item.label)\n              if (extracted.length > 0) {\n                context.indicators = extracted\n              }\n            }\n          }\n\n          if (output.sources && !context.sources) {\n            context.sources = output.sources\n          }\n\n          console.log('[buildPlaybookContext] Extracted from non-completed keyword_config:', {\n            life_contexts: context.life_contexts,\n            need_words: context.need_words,\n          })\n        }\n      }\n    }\n\n    // DEBUG: Log final context\n    console.log('[buildPlaybookContext] Final context:', {\n      life_contexts: context.life_contexts,\n      need_words: context.need_words,\n      indicators: context.indicators,\n      sources: context.sources,\n      serpJobId: context.serpJobId,\n    })\n\n    return context\n  }\n\n  // Get current phase and step definitions\n  const currentPhase = playbookConfig.phases[state.currentPhaseIndex]\n  const currentStep = currentPhase?.steps[state.currentStepIndex]\n  const currentStepState = state.phases[state.currentPhaseIndex]?.steps[state.currentStepIndex]\n\n  // Calculate navigation bounds\n  const isFirstStep = state.currentPhaseIndex === 0 && state.currentStepIndex === 0\n  const isLastStep =\n    state.currentPhaseIndex === playbookConfig.phases.length - 1 &&\n    state.currentStepIndex === currentPhase.steps.length - 1\n\n  // Navigate to a specific step\n  const goToStep = useCallback((phaseIndex: number, stepIndex: number) => {\n    // Save current state immediately before navigating (don't wait for debounce)\n    if (shouldSaveRef.current && selectedCampaignId) {\n      // Clear pending debounced save\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n        saveTimeoutRef.current = null\n      }\n      // Save current state synchronously\n      savePlaybookState(state)\n    }\n\n    setState(prev => ({\n      ...prev,\n      currentPhaseIndex: phaseIndex,\n      currentStepIndex: stepIndex,\n    }))\n  }, [selectedCampaignId, state, savePlaybookState])\n\n  // Go to next step\n  const goToNextStep = useCallback(() => {\n    setState(prev => {\n      const currentPhase = playbookConfig.phases[prev.currentPhaseIndex]\n\n      // Check if there's a next step in current phase\n      if (prev.currentStepIndex < currentPhase.steps.length - 1) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex + 1,\n        }\n      }\n\n      // Check if there's a next phase\n      if (prev.currentPhaseIndex < playbookConfig.phases.length - 1) {\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex + 1,\n          currentStepIndex: 0,\n        }\n      }\n\n      // Already at the end\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Go to previous step\n  const goToPreviousStep = useCallback(() => {\n    setState(prev => {\n      // Check if there's a previous step in current phase\n      if (prev.currentStepIndex > 0) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex - 1,\n        }\n      }\n\n      // Check if there's a previous phase\n      if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex - 1,\n          currentStepIndex: prevPhase.steps.length - 1,\n        }\n      }\n\n      // Already at the beginning\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Re-run the previous step (go back and reset its state to pending)\n  const rerunPreviousStep = useCallback(() => {\n    setState(prev => {\n      let newPhaseIndex = prev.currentPhaseIndex\n      let newStepIndex = prev.currentStepIndex\n\n      // Find previous step\n      if (prev.currentStepIndex > 0) {\n        newStepIndex = prev.currentStepIndex - 1\n      } else if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        newPhaseIndex = prev.currentPhaseIndex - 1\n        newStepIndex = prevPhase.steps.length - 1\n      } else {\n        // Already at the beginning, nothing to rerun\n        return prev\n      }\n\n      // Get the previous step ID\n      const prevStepId = playbookConfig.phases[newPhaseIndex].steps[newStepIndex].id\n\n      // Reset the previous step state to pending and navigate to it\n      const newPhases = prev.phases.map((phase, pi) => ({\n        ...phase,\n        steps: phase.steps.map((step, si) => {\n          if (pi === newPhaseIndex && si === newStepIndex) {\n            return {\n              ...step,\n              status: 'pending' as const,\n              output: undefined,\n              error: undefined,\n            }\n          }\n          return step\n        }),\n      }))\n\n      return {\n        ...prev,\n        phases: newPhases,\n        currentPhaseIndex: newPhaseIndex,\n        currentStepIndex: newStepIndex,\n      }\n    })\n    // Trigger auto-execute after navigating\n    setShouldAutoExecute(true)\n  }, [playbookConfig.phases])\n\n  // Update step state\n  const updateStepState = useCallback(\n    (stepId: string, update: Partial<StepState>) => {\n      console.log('[updateStepState] Updating step:', stepId, 'with:', {\n        ...update,\n        output: update.output ? `[output with keys: ${Object.keys(update.output as object).join(', ')}]` : undefined,\n      })\n\n      // Persist step changes to database (if sessionId is provided)\n      if (sessionId) {\n        // Handle status-specific persistence\n        if (update.status === 'in_progress') {\n          stepPersistenceActions.markStepRunning(stepId, update.input)\n        } else if (update.status === 'completed') {\n          stepPersistenceActions.markStepCompleted(stepId, update.output)\n        } else if (update.status === 'error') {\n          stepPersistenceActions.markStepFailed(stepId, update.error || 'Unknown error')\n        } else if (update.output !== undefined) {\n          // For output-only updates (during execution), schedule auto-save\n          stepPersistenceActions.scheduleAutoSave(stepId, update.output)\n        }\n      }\n\n      setState(prev => {\n        // Find the current step to log what we're merging\n        const currentStep = prev.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n        if (stepId === 'keyword_config') {\n          console.log('[updateStepState] keyword_config before merge:', {\n            status: currentStep?.status,\n            hasOutput: !!currentStep?.output,\n            outputKeys: currentStep?.output ? Object.keys(currentStep.output as object) : [],\n          })\n        }\n\n        const newPhases = prev.phases.map(phase => ({\n          ...phase,\n          steps: phase.steps.map(step =>\n            step.id === stepId ? { ...step, ...update } : step\n          ),\n        }))\n\n        // Log the merged result for keyword_config\n        if (stepId === 'keyword_config') {\n          const mergedStep = newPhases.flatMap(p => p.steps).find(s => s.id === stepId)\n          console.log('[updateStepState] keyword_config after merge:', {\n            status: mergedStep?.status,\n            hasOutput: !!mergedStep?.output,\n            outputKeys: mergedStep?.output ? Object.keys(mergedStep.output as object) : [],\n          })\n        }\n\n        // Recalculate phase status\n        newPhases.forEach(phase => {\n          const hasError = phase.steps.some(s => s.status === 'error')\n          const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n          const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n          if (hasError) {\n            phase.status = 'error'\n          } else if (allCompleted) {\n            phase.status = 'completed'\n          } else if (hasInProgress) {\n            phase.status = 'in_progress'\n          } else {\n            phase.status = 'pending'\n          }\n        })\n\n        // Recalculate completed steps\n        const completedSteps = newPhases.reduce(\n          (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n          0\n        )\n\n        return {\n          ...prev,\n          phases: newPhases,\n          completedSteps,\n        }\n      })\n    },\n    [sessionId, stepPersistenceActions]\n  )\n\n  // Execute a step\n  const executeStep = useCallback(\n    async (stepId: string, input?: any) => {\n      console.log('[executeStep] Starting execution for step:', stepId, 'with input:', input)\n\n      const step = playbookConfig.phases\n        .flatMap(p => p.steps)\n        .find(s => s.id === stepId)\n\n      if (!step) {\n        console.error('[executeStep] Step not found:', stepId)\n        return\n      }\n\n      console.log('[executeStep] Found step:', step.id, 'type:', step.type, 'executor:', step.executor, 'jobType:', step.jobType)\n\n      // Mark as in progress\n      updateStepState(stepId, {\n        status: 'in_progress',\n        startedAt: new Date(),\n        input,\n      })\n\n      try {\n        let result: any\n\n        // Special case: Execute extraction from scrape_results step\n        if (step.id === 'scrape_results' && input?.action === 'extract' && input?.jobId) {\n          console.log('[EXTRACT from scrape_results] Starting extraction for job:', input.jobId)\n          const jobId = input.jobId\n\n          updateStepState(stepId, {\n            output: { jobId },\n            progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' },\n            partialResults: { extracted: 0, filtered: 0 },\n          })\n\n          // Get total URLs to extract from job status\n          const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          const statusData = await statusResponse.json()\n          const scrapedUrlCount = statusData.url_counts?.scraped || 0\n          const totalUrls = scrapedUrlCount || statusData.job?.urls_scraped || 0\n          const existingExtractedCount = statusData.job?.niches_extracted || 0\n          const existingFilteredCount = statusData.url_counts?.filtered || 0\n\n          console.log('[EXTRACT] Status check:', {\n            scrapedUrlCount,\n            totalUrls,\n            existingExtractedCount,\n            existingFilteredCount,\n            jobStatus: statusData.job?.status,\n            urlsFailed: statusData.url_counts?.failed || 0,\n          })\n\n          // Check if there's nothing to extract (all URLs failed or filtered)\n          if (scrapedUrlCount === 0 && existingExtractedCount === 0) {\n            const failedCount = statusData.url_counts?.failed || 0\n            console.log('[EXTRACT] No URLs to extract and no existing results. Failed:', failedCount, 'Filtered:', existingFilteredCount)\n\n            // Show error state - nothing to extract\n            updateStepState(stepId, {\n              status: 'error',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: 0,\n                filteredCount: existingFilteredCount,\n                error: failedCount > 0\n                  ? `El scraping falló para ${failedCount} URLs (posible bloqueo de Reddit API). No hay contenido disponible para extraer.`\n                  : 'No hay URLs disponibles para extraer. Verifica que el scraping se completó correctamente.',\n              },\n              progress: undefined,\n            })\n\n            return // Stop - nothing to do\n          }\n\n          // Check if extraction was already done (no URLs to process but results exist)\n          if (scrapedUrlCount === 0 && existingExtractedCount > 0) {\n            console.log('[EXTRACT] Extraction already completed, using existing results')\n            updateStepState(stepId, {\n              progress: { current: 100, total: 100, label: `Usando resultados existentes: ${existingExtractedCount} problemas encontrados` },\n            })\n\n            // Skip extraction loop and jump to results fetching\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // Mark scrape_results as completed\n            updateStepState(stepId, {\n              status: 'completed',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: existingExtractedCount,\n                filteredCount: existingFilteredCount,\n              },\n              progress: undefined,\n            })\n\n            // Also update extract_problems step for clean_filter to use\n            console.log('[EXTRACT] Updating extract_problems step with existing CSV results')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,\n              partialResults: {\n                extracted: existingExtractedCount,\n                filtered: existingFilteredCount,\n                successCount: niches.length,\n              }\n            })\n\n            console.log('[EXTRACT] Using existing results:', niches.length, 'problems')\n            return // Don't proceed with new extraction\n          }\n\n          updateStepState(stepId, {\n            progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` },\n          })\n\n          // Call extract endpoint in batches until has_more=false\n          let hasMore = true\n          let extractedTotal = 0\n          let filteredTotal = 0\n          let processedTotal = 0\n\n          while (hasMore) {\n            try {\n              const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout)\n              const contentType = extractResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                console.error('[EXTRACT] Non-JSON response, polling status...')\n                await new Promise(resolve => setTimeout(resolve, 2000))\n\n                // Check current status\n                const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                const checkData = await checkResponse.json()\n\n                if (checkData.status === 'completed') {\n                  hasMore = false\n                  extractedTotal = checkData.job?.niches_extracted || 0\n                }\n                continue\n              }\n\n              const extractData = await extractResponse.json()\n              console.log('[EXTRACT] Batch response:', extractData)\n\n              if (extractData.error) {\n                throw new Error(extractData.error)\n              }\n\n              extractedTotal += extractData.extracted || 0\n              filteredTotal += extractData.filtered || 0\n              processedTotal = extractedTotal + filteredTotal\n              hasMore = extractData.has_more || false\n\n              updateStepState(stepId, {\n                progress: {\n                  current: processedTotal,\n                  total: totalUrls,\n                  label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                },\n                partialResults: {\n                  extracted: extractedTotal,\n                  filtered: filteredTotal,\n                },\n              })\n            } catch (extractError) {\n              console.error('[EXTRACT] Batch error:', extractError)\n              await new Promise(resolve => setTimeout(resolve, 2000))\n\n              // Check if we should stop\n              const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const checkData = await checkResponse.json()\n              if (checkData.status === 'completed' || checkData.status === 'failed') {\n                hasMore = false\n                if (checkData.status === 'failed') {\n                  throw new Error(checkData.job?.error_message || 'Extraction failed')\n                }\n              }\n            }\n          }\n\n          // Mark as completed\n          updateStepState(stepId, {\n            status: 'completed',\n            completedAt: new Date(),\n            output: {\n              jobId,\n              extractedCount: extractedTotal,\n              filteredCount: filteredTotal,\n            },\n            progress: undefined, // Clear progress\n          })\n\n          console.log('[EXTRACT] Completed! Extracted:', extractedTotal, 'Filtered:', filteredTotal)\n\n          // Save results to Context Lake automatically\n          try {\n            // Get project data (includes client_id)\n            const projectResponse = await fetch(`/api/projects/${projectId}`)\n            const projectData = await projectResponse.json()\n\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // IMPORTANT: Also update extract_problems step so clean_filter can use the results\n            // clean_filter depends on extract_problems, not scrape_results\n            console.log('[EXTRACT] Updating extract_problems step with CSV results for clean_filter')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,  // CSV string that clean_filter will use\n              partialResults: {\n                extracted: extractedTotal,\n                filtered: filteredTotal,\n                successCount: niches.length,\n              }\n            })\n\n            const dateStr = new Date().toISOString().split('T')[0]\n            const campaignSlug = selectedCampaign?.name?.toLowerCase().replace(/\\s+/g, '-') || 'sin-nombre'\n            const projectSlug = projectData.name?.toLowerCase().replace(/\\s+/g, '-') || 'proyecto'\n\n            const documentData = {\n              projectId: projectId,\n              clientId: projectData.client_id,\n              filename: `Niche Finder - ${selectedCampaign?.name || 'Sin nombre'} - ${dateStr}`,\n              category: 'research',\n              content: csvContent,\n              description: `${extractedTotal} problemas extraídos del Niche Finder. ${filteredTotal} URLs filtradas de ${totalUrls} procesadas.`,\n              tags: [\n                `fecha:${dateStr}`,\n                `proyecto:${projectSlug}`,\n                `campaña:${campaignSlug}`,\n                `job:${jobId}`,\n                'niche-finder',\n                'problemas-extraidos'\n              ],\n              folder: `niche-finder/${campaignSlug}`,\n              userId: 'system', // TODO: Get actual user ID from session\n              sourceMetadata: {\n                origin_type: 'flow_step_output',\n                playbook_id: playbookConfig.type || 'niche-finder',\n                playbook_name: playbookConfig.name,\n                campaign_id: selectedCampaignId || '',\n                campaign_name: selectedCampaign?.name || '',\n                campaign_variables: selectedCampaign?.customVariables || {},\n                step_id: 'scrape_results',\n                step_name: 'Extracción de Problemas',\n                step_order: 3,\n                executed_at: new Date().toISOString(),\n                model_used: 'openai/gpt-4o-mini',\n                model_provider: 'openrouter',\n                input_tokens: 0,\n                output_tokens: 0,\n                input_document_ids: [],\n                input_previous_step_ids: ['search_and_preview', 'review_and_scrape'],\n                converted_at: new Date().toISOString(),\n                converted_by: 'system',\n                was_edited_before_conversion: false\n              },\n              sourceCampaignId: selectedCampaignId || '',\n              sourceStepId: 'scrape_results',\n              sourceStepName: 'Extracción de Problemas',\n              sourcePlaybookId: playbookConfig.type\n            }\n\n            const saveResponse = await fetch('/api/documents/from-step-output', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify(documentData)\n            })\n\n            if (saveResponse.ok) {\n              const savedDoc = await saveResponse.json()\n              console.log('[EXTRACT] Results saved to Context Lake:', savedDoc.document?.id)\n            } else {\n              console.error('[EXTRACT] Failed to save to Context Lake:', await saveResponse.text())\n            }\n          } catch (saveError) {\n            console.error('[EXTRACT] Error saving to Context Lake:', saveError)\n            // Don't fail the extraction if saving to Context Lake fails\n          }\n\n          return // Don't fall through to the switch\n        }\n\n        switch (step.executor) {\n          case 'llm':\n            // Build variables including campaign custom_variables (product, target, industry, etc.)\n            const campaignVars = selectedCampaign?.customVariables || {}\n            const stepVariables = {\n              ...Object.fromEntries(\n                Object.entries(campaignVars).map(([k, v]) => [k, String(v ?? '')])\n              ),\n              ...(input || {}),\n            }\n            // Call LLM API\n            const response = await fetch('/api/playbook/execute-step', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({\n                projectId,\n                stepId,\n                playbookType: playbookConfig.type,\n                promptKey: step.promptKey,\n                variables: stepVariables,\n              }),\n            })\n            const data = await response.json()\n            if (!data.success) throw new Error(data.error || 'Error ejecutando paso')\n            result = data.output\n            break\n\n          case 'api':\n            // Call custom API endpoint\n            if (step.apiEndpoint) {\n              // Build payload with previous step outputs and campaign variables\n              const campaignVarsForApi = selectedCampaign?.customVariables || {}\n\n              // Get outputs from previous steps (dependsOn)\n              const previousOutputs: Record<string, unknown> = {}\n              if (step.dependsOn?.length) {\n                for (const depId of step.dependsOn) {\n                  for (const phase of state.phases) {\n                    const depStep = phase.steps.find(s => s.id === depId)\n                    if (depStep?.output) {\n                      previousOutputs[depId] = depStep.output\n                    }\n                  }\n                }\n              }\n\n              // Build scenes array from generate_scenes output (for video-viral generate-clips)\n              let scenes: string[] | undefined\n              if (previousOutputs.generate_scenes) {\n                let scenesOutput = previousOutputs.generate_scenes\n\n                // Parse JSON if output is a string (LLM outputs often come as strings)\n                if (typeof scenesOutput === 'string') {\n                  try {\n                    // Try to extract JSON from the string (might be wrapped in markdown code blocks)\n                    const jsonMatch = scenesOutput.match(/```(?:json)?\\s*(\\{[\\s\\S]*?\\})\\s*```/) ||\n                                     scenesOutput.match(/(\\{[\\s\\S]*\\})/)\n                    if (jsonMatch) {\n                      scenesOutput = JSON.parse(jsonMatch[1])\n                    }\n                  } catch (e) {\n                    console.error('[executeStep] Failed to parse generate_scenes output:', e)\n                  }\n                }\n\n                // Extract scene_1, scene_2, scene_3, etc. from the output\n                if (typeof scenesOutput === 'object' && scenesOutput !== null) {\n                  const scenesRecord = scenesOutput as Record<string, string>\n                  scenes = Object.entries(scenesRecord)\n                    .filter(([key]) => key.startsWith('scene_'))\n                    .sort(([a], [b]) => a.localeCompare(b))\n                    .map(([, value]) => value)\n                  console.log('[executeStep] Extracted scenes:', scenes)\n                }\n              }\n\n              const apiResponse = await fetch(step.apiEndpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                  projectId,\n                  stepId,\n                  input,\n                  ...campaignVarsForApi,\n                  previousOutputs,\n                  scenes, // For generate-clips endpoint\n                }),\n              })\n              const apiData = await apiResponse.json()\n              if (!apiData.success && apiData.error) throw new Error(apiData.error)\n              result = apiData\n            }\n            break\n\n          case 'job':\n            // Job-based execution: create job, execute, poll for status\n            console.log('[executeStep] Executor is JOB, jobType:', step.jobType)\n\n            if (step.jobType === 'niche_finder_serp') {\n              // Check if we have an existing job to resume (from cancelled execution)\n              const currentStepForJob = state.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n              const existingJobId = (currentStepForJob?.output as { jobId?: string })?.jobId\n\n              let jobId: string\n\n              if (existingJobId) {\n                // Resume existing job\n                console.log('[SERP] Resuming existing job:', existingJobId)\n                jobId = existingJobId\n                updateStepState(stepId, { progress: { current: 0, total: 0, label: 'Retomando búsqueda SERP...' } })\n              } else {\n                // Build job config from completed steps OR from input (for search_with_preview)\n                let jobConfig: {\n                  life_contexts: string[]\n                  product_words: string[]\n                  indicators: string[]\n                  sources: { reddit: boolean | { enabled?: boolean; subreddits?: string[] }; thematic_forums: boolean | { enabled?: boolean; forums?: string[] }; general_forums: string[] | { enabled?: boolean; forums?: string[] } }\n                  serp_pages: number\n                  // Campaign metadata for extraction to use correct variables\n                  campaign_id?: string | null\n                  ecp_name?: string\n                  ecp_product?: string\n                  ecp_target?: string\n                  ecp_industry?: string\n                  ecp_category?: string\n                  ecp_country?: string\n                }\n\n                // If input is provided (from SearchWithPreviewPanel), use it directly\n                console.log('[SERP] Input received:', JSON.stringify(input, null, 2))\n\n                if (input && input.life_contexts && input.product_words) {\n                  // Warn if arrays are empty\n                  if (input.life_contexts.length === 0 || input.product_words.length === 0) {\n                    console.warn('[SERP] WARNING: life_contexts or product_words is empty!', {\n                      life_contexts: input.life_contexts,\n                      product_words: input.product_words\n                    })\n                  }\n\n                  jobConfig = {\n                    life_contexts: input.life_contexts,\n                    product_words: input.product_words,\n                    indicators: input.indicators || [],\n                    sources: input.sources || { reddit: true, thematic_forums: false, general_forums: [] },\n                    serp_pages: input.serp_pages || 5,\n                  }\n                } else {\n                  console.log('[SERP] No valid input, falling back to completed steps...')\n                  // Fall back to building from completed steps (legacy flow)\n                  const lifeContextsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'life_contexts')\n                  const needWordsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'need_words')\n                  const indicatorsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'indicators')\n                  const sourcesStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'sources')\n\n                  const selectedContexts = lifeContextsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedNeedWords = needWordsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedIndicators = indicatorsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n\n                  // Parse sources output (can be JSON string from LLM or already parsed object)\n                  let sourcesConfig: { reddit: { enabled: boolean; subreddits: string[] }; thematic_forums: { enabled: boolean; forums: string[] }; general_forums: { enabled: boolean; forums: string[] } } = { reddit: { enabled: true, subreddits: [] }, thematic_forums: { enabled: false, forums: [] }, general_forums: { enabled: false, forums: [] } }\n                  try {\n                    if (sourcesStep?.output) {\n                      // Check if output is already an object (parsed)\n                      if (typeof sourcesStep.output === 'object' && sourcesStep.output !== null) {\n                        sourcesConfig = sourcesStep.output as typeof sourcesConfig\n                      } else if (typeof sourcesStep.output === 'string') {\n                        // Try to extract JSON from string\n                        const jsonMatch = sourcesStep.output.match(/\\{[\\s\\S]*\\}/)\n                        if (jsonMatch) {\n                          sourcesConfig = JSON.parse(jsonMatch[0])\n                        }\n                      }\n                    }\n                  } catch (e) {\n                    console.error('Error parsing sources config:', e)\n                  }\n\n                  // Get campaign variables with proper typing\n                  const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                  jobConfig = {\n                    campaign_id: selectedCampaignId, // CRITICAL: Pass campaign_id so extract uses correct variables\n                    life_contexts: selectedContexts,\n                    product_words: selectedNeedWords,\n                    indicators: selectedIndicators,\n                    sources: sourcesConfig,\n                    serp_pages: (campaignVars?.serp_pages as number) || 5,\n                    // Also pass campaign variables directly in config for reliability\n                    ecp_name: (campaignVars?.company_name as string) || selectedCampaign?.name,\n                    ecp_product: campaignVars?.product as string | undefined,\n                    ecp_target: campaignVars?.target as string | undefined,\n                    ecp_industry: campaignVars?.industry as string | undefined,\n                    ecp_category: campaignVars?.category as string | undefined,\n                    ecp_country: campaignVars?.country as string | undefined,\n                  }\n                }\n\n                console.log('[SERP] Starting job with config:', JSON.stringify(jobConfig, null, 2))\n\n                // 1. Create job\n                const createResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: jobConfig,\n                  }),\n                })\n                const createData = await createResponse.json()\n                console.log('[SERP] Create job response:', createData)\n\n                if (!createData.success) {\n                  throw new Error(createData.error || 'Error creando job')\n                }\n\n                jobId = createData.job_id\n                console.log('[SERP] Job created with ID:', jobId)\n                updateStepState(stepId, { output: { jobId }, progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' } })\n              }\n\n              // 2. Execute SERP job (this will resume from where it left off if job was interrupted)\n              console.log('[SERP] Executing SERP search...')\n              const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout HTML pages)\n              const contentType = serpResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                const text = await serpResponse.text()\n                console.error('[SERP] Non-JSON response:', text.slice(0, 500))\n                // If we got a non-JSON response, the job might still be running in the background\n                // Continue to polling to check status\n                console.log('[SERP] Continuing to poll for job status despite non-JSON response...')\n              } else {\n                const serpData = await serpResponse.json()\n                console.log('[SERP] SERP response:', serpData)\n\n                if (serpData.error) {\n                  // Check if it's a missing API key error\n                  if (serpData.code === 'MISSING_API_KEY') {\n                    throw new Error(`API Key faltante: ${serpData.service}. Configura tu API key en Ajustes > APIs.`)\n                  }\n                  throw new Error(serpData.error)\n                }\n              }\n\n              // 3. Poll for status and auto-resume if needed\n              let isResuming = false\n              let lastCompletedCount = -1 // Track previous poll value\n              let stallCount = 0 // Count consecutive stalls\n              let initialCompleted = -1 // Track initial value when polling started\n\n              // Clear any existing poll interval\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n              }\n\n              pollIntervalRef.current = setInterval(async () => {\n                try {\n                  const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const statusData = await statusResponse.json()\n\n                  const completed = statusData.progress?.serp?.completed || 0\n                  const total = statusData.progress?.serp?.total || 0\n                  const remaining = total - completed\n                  const label = total > 0\n                    ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n                    : 'Iniciando búsqueda SERP...'\n                  updateStepState(stepId, {\n                    progress: {\n                      current: completed,\n                      total: total,\n                      label,\n                    },\n                  })\n\n                  // Track initial value on first poll\n                  if (initialCompleted === -1) {\n                    initialCompleted = completed\n                  }\n\n                  // Auto-resume if job was interrupted (still serp_running but not progressing)\n                  // This handles Vercel timeout scenarios\n                  if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n                    // Check if progress has stalled (same value as PREVIOUS poll)\n                    if (lastCompletedCount === completed && remaining > 0) {\n                      stallCount++\n                      // After 2 consecutive stalls (4+ seconds), OR if no progress since we started polling\n                      const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                      if (stallCount >= 2 || noProgressSinceStart) {\n                        console.log(`[SERP] Job stalled at ${completed}/${total} (stallCount=${stallCount}, initialCompleted=${initialCompleted}), auto-resuming...`)\n                        isResuming = true\n                        stallCount = 0\n                        // Resume the job by calling SERP endpoint again\n                        fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                          .then(res => res.json())\n                          .then(data => {\n                            console.log('[SERP] Resume response:', data)\n                            isResuming = false\n                          })\n                          .catch(err => {\n                            console.error('[SERP] Resume error:', err)\n                            isResuming = false\n                          })\n                      }\n                    } else {\n                      stallCount = 0 // Reset stall count if progress is being made\n                    }\n                  }\n\n                  // Update last completed for next poll comparison\n                  lastCompletedCount = completed\n\n                  // Check if SERP phase is done (includes later states that imply SERP finished)\n                  const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n                  if (serpDone) {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    updateStepState(stepId, {\n                      status: 'completed',\n                      completedAt: new Date(),\n                      output: {\n                        jobId,\n                        urlsFound: statusData.job?.urls_found || 0,\n                        costs: statusData.costs,\n                      },\n                      progress: undefined, // Clear progress to stop spinner\n                    })\n                    setTimeout(goToNextStep, 500)\n                  } else if (statusData.status === 'failed' || statusData.status === 'error') {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    throw new Error(statusData.job?.error_message || 'Job failed')\n                  }\n                } catch (pollError) {\n                  if (pollIntervalRef.current) {\n                    clearInterval(pollIntervalRef.current)\n                    pollIntervalRef.current = null\n                  }\n                  updateStepState(stepId, {\n                    status: 'error',\n                    error: pollError instanceof Error ? pollError.message : 'Error checking job status',\n                  })\n                }\n              }, 2000) // Poll every 2 seconds\n\n              // Don't fall through to the completion logic below\n              return\n            }\n\n            // SCRAPE JOB: Scrape URLs from the SERP results\n            if (step.jobType === 'niche_finder_scrape') {\n              // Get the jobId from the previous step (search_and_preview)\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n              console.log('[SCRAPE] Looking for search_and_preview step:', searchStep)\n              console.log('[SCRAPE] search_and_preview output:', searchStep?.output)\n\n              // Also check for serp_search (legacy step name)\n              const serpStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'serp_search')\n              console.log('[SCRAPE] Looking for serp_search step:', serpStep)\n              console.log('[SCRAPE] serp_search output:', serpStep?.output)\n\n              // Try to get jobId from either step\n              let jobId = (searchStep?.output as { jobId?: string })?.jobId ||\n                          (serpStep?.output as { jobId?: string })?.jobId\n\n              // If still no jobId, try from input (might be passed from ReviewAndScrapePanel)\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n                console.log('[SCRAPE] Got jobId from input:', jobId)\n              }\n\n              if (!jobId) {\n                console.error('[SCRAPE] No jobId found. All steps:', state.phases.flatMap(p => p.steps).map(s => ({ id: s.id, output: s.output })))\n                throw new Error('No se encontró el Job ID del paso de búsqueda')\n              }\n\n              console.log('[SCRAPE] Starting scrape for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando scraping...' }\n              })\n\n              // Get total URLs to scrape\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.urls_found || 0\n\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Scrapeando 0/${totalUrls} URLs...` }\n              })\n\n              // Start scraping - this will scrape in batches\n              let scrapedCount = 0\n              let failedCount = 0\n              let hasMore = true\n\n              while (hasMore) {\n                try {\n                  const scrapeResponse = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = scrapeResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[SCRAPE] Non-JSON response, continuing...')\n                    // Wait a bit and continue polling\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'scrape_done') {\n                      hasMore = false\n                      scrapedCount = checkData.job?.scrape_success_count || 0\n                      failedCount = checkData.job?.scrape_failed_count || 0\n                    }\n                    continue\n                  }\n\n                  const scrapeData = await scrapeResponse.json()\n                  console.log('[SCRAPE] Batch response:', scrapeData)\n\n                  if (scrapeData.error) {\n                    throw new Error(scrapeData.error)\n                  }\n\n                  scrapedCount += scrapeData.scraped || 0\n                  failedCount += scrapeData.failed || 0\n                  hasMore = scrapeData.has_more || false\n\n                  // Update progress with real-time feedback\n                  updateStepState(stepId, {\n                    progress: {\n                      current: scrapedCount + failedCount,\n                      total: totalUrls,\n                      label: `Scrapeando ${scrapedCount + failedCount}/${totalUrls} URLs...`,\n                    },\n                    partialResults: {\n                      successCount: scrapedCount,\n                      failedCount: failedCount,\n                      lastUrl: scrapeData.last_scraped_url,\n                      lastSnippet: scrapeData.last_scraped_snippet,\n                    },\n                  })\n\n                } catch (scrapeError) {\n                  console.error('[SCRAPE] Batch error:', scrapeError)\n                  // Don't throw - try to continue with next batch\n                  // The endpoint will mark failed URLs and continue\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'scrape_done' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Scraping failed')\n                    }\n                  }\n                }\n              }\n\n              // Mark as completed\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  scrapedCount,\n                  failedCount,\n                },\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            if (step.jobType === 'niche_finder_extract') {\n              // Get jobId from previous steps (review_and_scrape or scrape_results)\n              const scrapeResultsStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'scrape_results')\n              const reviewAndScrapeStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'review_and_scrape')\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n\n              console.log('[EXTRACT] Looking for jobId from steps:', {\n                scrape_results: scrapeResultsStep?.output,\n                review_and_scrape: reviewAndScrapeStep?.output,\n                search_and_preview: searchStep?.output,\n              })\n\n              let jobId = (scrapeResultsStep?.output as { jobId?: string })?.jobId ||\n                          (reviewAndScrapeStep?.output as { jobId?: string })?.jobId ||\n                          (searchStep?.output as { jobId?: string })?.jobId\n\n              // Also try from input\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n              }\n\n              if (!jobId) {\n                console.error('[EXTRACT] No jobId found')\n                throw new Error('No se encontró el Job ID. Por favor ejecuta los pasos anteriores primero.')\n              }\n\n              console.log('[EXTRACT] Starting extraction for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' }\n              })\n\n              // Get total URLs to extract from job status\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.scrape_success_count || 0\n\n              console.log('[EXTRACT] Total URLs to process:', totalUrls)\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` }\n              })\n\n              // Call extract endpoint in batches until has_more=false\n              let hasMore = true\n              let extractedTotal = 0\n              let filteredTotal = 0\n              let processedTotal = 0\n\n              while (hasMore) {\n                try {\n                  const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = extractResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[EXTRACT] Non-JSON response, polling status...')\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'completed') {\n                      hasMore = false\n                      extractedTotal = checkData.job?.niches_extracted || 0\n                    }\n                    continue\n                  }\n\n                  const extractData = await extractResponse.json()\n                  console.log('[EXTRACT] Batch response:', extractData)\n\n                  if (extractData.error) {\n                    throw new Error(extractData.error)\n                  }\n\n                  extractedTotal += extractData.extracted || 0\n                  filteredTotal += extractData.filtered || 0\n                  processedTotal = extractedTotal + filteredTotal\n                  hasMore = extractData.has_more || false\n\n                  updateStepState(stepId, {\n                    progress: {\n                      current: processedTotal,\n                      total: totalUrls,\n                      label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                    },\n                    partialResults: {\n                      successCount: extractedTotal,\n                      failedCount: filteredTotal,\n                    },\n                  })\n                } catch (extractError) {\n                  console.error('[EXTRACT] Batch error:', extractError)\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'completed' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Extraction failed')\n                    }\n                  }\n                }\n              }\n\n              // Get extracted problems and format as CSV\n              console.log('[EXTRACT] Getting results from /api/niche-finder/results/', jobId)\n              const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n\n              if (!resultsResponse.ok) {\n                console.error('[EXTRACT] Failed to get results:', resultsResponse.status, resultsResponse.statusText)\n                throw new Error(`Error obteniendo resultados: ${resultsResponse.status}`)\n              }\n\n              const resultsData = await resultsResponse.json()\n              console.log('[EXTRACT] Results data:', {\n                hasNiches: !!resultsData.niches,\n                nichesCount: resultsData.niches?.length || 0,\n                status: resultsData.status,\n                urls: resultsData.urls,\n              })\n\n              // Format niches as CSV string with all relevant columns\n              const niches = resultsData.niches || []\n              let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n              for (const niche of niches) {\n                const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                const url = niche.source_url || ''\n                csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n              }\n\n              console.log('[EXTRACT] Completed. Total problems:', niches.length, 'CSV preview:', csvOutput.substring(0, 200))\n\n              // Mark as completed with CSV output\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: csvOutput,\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            // UNIFIED SEARCH + EXTRACT: Handles both SERP and analysis in one step\n            if (step.jobType === 'niche_finder_unified') {\n              const action = (input as { action?: string })?.action\n\n              // ============ ACTION: SERP ============\n              if (action === 'serp') {\n                const config = (input as { config?: { life_contexts: string[]; product_words: string[]; indicators: string[]; sources: { reddit: boolean; thematic_forums: boolean; general_forums: string[] }; serp_pages: number } }).config\n                if (!config) {\n                  throw new Error('No se recibió configuración para la búsqueda')\n                }\n\n                console.log('[UNIFIED] Starting SERP with config:', config)\n\n                // Get campaign variables\n                const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                // Create the SERP job\n                const jobResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: {\n                      ...config,\n                      campaign_id: selectedCampaignId,\n                      ecp_name: campaignVars?.['ECP Name'] || campaignVars?.ecp_name,\n                      ecp_product: campaignVars?.['ECP Product'] || campaignVars?.ecp_product,\n                      ecp_target: campaignVars?.['ECP Target'] || campaignVars?.ecp_target,\n                      ecp_industry: campaignVars?.['ECP Industry'] || campaignVars?.ecp_industry,\n                      ecp_category: campaignVars?.['ECP Category'] || campaignVars?.ecp_category,\n                      ecp_country: campaignVars?.['ECP Country'] || campaignVars?.ecp_country,\n                    }\n                  }),\n                })\n\n                if (!jobResponse.ok) {\n                  const errorText = await jobResponse.text()\n                  throw new Error(`Error al crear job: ${jobResponse.status} - ${errorText || 'Sin respuesta'}`)\n                }\n\n                const jobText = await jobResponse.text()\n                if (!jobText || jobText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al crear el job')\n                }\n\n                const jobData = JSON.parse(jobText)\n                const jobId = jobData.job_id\n\n                if (!jobId) {\n                  throw new Error('No se pudo crear el job de búsqueda')\n                }\n\n                console.log('[UNIFIED] SERP Job created:', jobId)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'serp_executing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' },\n                })\n\n                // Start SERP execution\n                const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n\n                if (!serpResponse.ok) {\n                  const serpErrorText = await serpResponse.text()\n                  let errorMessage = `Error al iniciar búsqueda SERP: ${serpResponse.status}`\n                  try {\n                    const serpError = JSON.parse(serpErrorText)\n                    if (serpError.code === 'MISSING_API_KEY') {\n                      errorMessage = `${serpError.error}`\n                    } else if (serpError.error) {\n                      errorMessage = serpError.error\n                    }\n                  } catch {\n                    if (serpErrorText) errorMessage += ` - ${serpErrorText}`\n                  }\n                  throw new Error(errorMessage)\n                }\n\n                console.log('[UNIFIED] SERP execution started successfully')\n\n                // Poll for SERP completion\n                let serpComplete = false\n                let pollRetries = 0\n                const MAX_POLL_RETRIES = 3\n                while (!serpComplete) {\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n                  try {\n                    const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n\n                    if (!statusRes.ok) {\n                      console.warn(`[UNIFIED] Status poll failed with ${statusRes.status}`)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error(`Error al consultar estado del job: ${statusRes.status}`)\n                      }\n                      continue\n                    }\n\n                    const text = await statusRes.text()\n                    if (!text || text.trim() === '') {\n                      console.warn('[UNIFIED] Empty response from status endpoint, retrying...')\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('El servidor no está respondiendo correctamente')\n                      }\n                      continue\n                    }\n\n                    const statusData = JSON.parse(text)\n                    pollRetries = 0 // Reset retries on success\n\n                    const urlsFound = statusData.job?.urls_found || 0\n                    // Status API returns serp_total and serp_completed (not total_queries/completed_queries)\n                    const totalSearches = statusData.job?.serp_total || statusData.progress?.serp?.total || 0\n                    const completedSearches = statusData.job?.serp_completed || statusData.progress?.serp?.completed || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: completedSearches,\n                        total: totalSearches,\n                        label: `Buscando... ${urlsFound} URLs encontradas`,\n                      },\n                    })\n\n                    if (['serp_done', 'serp_completed', 'scrape_done', 'completed'].includes(statusData.status)) {\n                      serpComplete = true\n                      console.log('[UNIFIED] SERP completed. URLs found:', urlsFound)\n                      updateStepState(stepId, {\n                        output: { jobId, phase: 'serp_complete', urlsFound },\n                        progress: undefined,\n                      })\n                    } else if (statusData.status === 'failed') {\n                      throw new Error(statusData.job?.error_message || 'SERP falló')\n                    }\n                  } catch (pollError) {\n                    if (pollError instanceof SyntaxError) {\n                      console.warn('[UNIFIED] JSON parse error in poll, retrying...', pollError)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('Error al procesar respuesta del servidor')\n                      }\n                    } else {\n                      throw pollError\n                    }\n                  }\n                }\n                return // Don't mark as completed - wait for analyze action\n              }\n\n              // ============ ACTION: ANALYZE (Scrape + Extract) ============\n              if (action === 'analyze') {\n                const jobId = (input as { jobId?: string }).jobId\n                const selectedSources = (input as { selectedSources?: string[] }).selectedSources || []\n                const extractionPrompt = (input as { extractionPrompt?: string }).extractionPrompt\n\n                if (!jobId) {\n                  throw new Error('No se encontró el Job ID')\n                }\n\n                console.log('[UNIFIED] Starting analysis for job:', jobId, 'sources:', selectedSources, 'custom prompt:', !!extractionPrompt)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'analyzing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando análisis...' },\n                })\n\n                // If a custom extraction prompt was provided, update the job config\n                if (extractionPrompt) {\n                  console.log('[UNIFIED] Updating job with custom extraction prompt')\n                  const updateRes = await fetch(`/api/niche-finder/jobs/${jobId}`, {\n                    method: 'PATCH',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ extraction_prompt: extractionPrompt }),\n                  })\n                  if (!updateRes.ok) {\n                    console.warn('[UNIFIED] Failed to update job with custom prompt:', updateRes.status)\n                  }\n                }\n\n                // Get total URLs to process\n                const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                if (!statusRes.ok) {\n                  throw new Error(`Error al obtener estado del job: ${statusRes.status}`)\n                }\n                const statusText = await statusRes.text()\n                if (!statusText || statusText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al consultar estado')\n                }\n                const statusData = JSON.parse(statusText)\n                const totalUrls = statusData.job?.urls_found || 0\n\n                // Start scraping - call API repeatedly until all URLs are processed\n                console.log('[UNIFIED] Starting scrape for', totalUrls, 'URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: totalUrls, label: 'Descargando contenido...' },\n                })\n\n                let scrapeComplete = false\n                let scrapeRetries = 0\n                let totalScraped = 0\n                let totalFailed = 0\n                const MAX_SCRAPE_RETRIES = 5 // More retries for transient failures\n\n                while (!scrapeComplete) {\n                  try {\n                    console.log(`[UNIFIED] Scrape batch starting, totalScraped=${totalScraped}, retries=${scrapeRetries}`)\n\n                    // Call scrape API with timeout (120s to allow for slow scrapes)\n                    const controller = new AbortController()\n                    const timeout = setTimeout(() => controller.abort(), 120000)\n\n                    const scrapeRes = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                      method: 'POST',\n                      headers: { 'Content-Type': 'application/json' },\n                      body: JSON.stringify({ sources: selectedSources }),\n                      signal: controller.signal,\n                    })\n                    clearTimeout(timeout)\n\n                    if (!scrapeRes.ok) {\n                      const errorText = await scrapeRes.text().catch(() => '')\n                      console.error(`[UNIFIED] Scrape response not ok: ${scrapeRes.status}`, errorText)\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(`Error en scraping: ${scrapeRes.status} - ${errorText || 'Unknown error'}`)\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeText = await scrapeRes.text()\n                    if (!scrapeText) {\n                      console.warn('[UNIFIED] Empty scrape response, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Respuesta vacía del servidor después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeData = JSON.parse(scrapeText)\n                    scrapeRetries = 0 // Reset on successful response\n\n                    if (scrapeData.error) {\n                      // Check if it's a retryable error\n                      if (scrapeData.error.includes('Rate limit') || scrapeData.error.includes('timeout')) {\n                        console.warn(`[UNIFIED] Retryable scrape error: ${scrapeData.error}`)\n                        scrapeRetries++\n                        if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(scrapeData.error)\n                        await new Promise(r => setTimeout(r, 5000))\n                        continue\n                      }\n                      throw new Error(scrapeData.error)\n                    }\n\n                    // Update progress with scraped count from this batch\n                    totalScraped += scrapeData.scraped || 0\n                    totalFailed += scrapeData.failed || 0\n                    const remaining = scrapeData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: totalScraped,\n                        total: totalUrls,\n                        label: `Descargando... ${totalScraped}/${totalUrls} URLs${totalFailed > 0 ? ` (${totalFailed} fallidas)` : ''}`,\n                      },\n                      partialResults: {\n                        successCount: totalScraped,\n                        failedCount: totalFailed,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Scrape batch complete: +${scrapeData.scraped} scraped, ${remaining} remaining, has_more: ${scrapeData.has_more}`)\n\n                    // Check if scraping is complete\n                    if (!scrapeData.has_more || remaining === 0) {\n                      scrapeComplete = true\n                    }\n                  } catch (e) {\n                    console.error('[UNIFIED] Scrape error:', e)\n                    if (e instanceof SyntaxError) {\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 3000))\n                    } else if (e instanceof Error && e.name === 'AbortError') {\n                      // Timeout - retry with longer wait\n                      console.warn('[UNIFIED] Scrape request timed out, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Timeout en scraping después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 5000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Scraping complete, total scraped:', totalScraped)\n\n                // Start extraction - use totalScraped as the base since only scraped URLs can be extracted\n                const extractionTotal = totalScraped || totalUrls // Fallback to totalUrls if scraping tracked differently\n                console.log('[UNIFIED] Starting extraction for', extractionTotal, 'scraped URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: extractionTotal, label: 'Extrayendo problemas...' },\n                })\n\n                let extractComplete = false\n                let extractedTotal = 0\n                let filteredTotal = 0\n                let extractRetries = 0\n\n                while (!extractComplete) {\n                  try {\n                    const extractRes = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, { method: 'POST' })\n                    if (!extractRes.ok) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error(`Error en extracción: ${extractRes.status}`)\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const text = await extractRes.text()\n                    if (!text) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Respuesta vacía del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const extractData = JSON.parse(text)\n                    extractRetries = 0\n\n                    if (extractData.error) {\n                      throw new Error(extractData.error)\n                    }\n\n                    extractedTotal += extractData.extracted || 0\n                    filteredTotal += extractData.filtered || 0\n                    const processed = extractedTotal + filteredTotal\n                    const remaining = extractData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: processed,\n                        total: extractionTotal,\n                        label: `Extrayendo... ${extractedTotal} problemas de ${processed}/${extractionTotal} URLs${filteredTotal > 0 ? ` (${filteredTotal} filtradas)` : ''}`,\n                      },\n                      partialResults: {\n                        extracted: extractedTotal,\n                        filtered: filteredTotal,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Extract batch: ${extractData.extracted} extracted, ${extractData.filtered} filtered, ${remaining} remaining, has_more: ${extractData.has_more}`)\n\n                    if (!extractData.has_more || remaining === 0) {\n                      extractComplete = true\n                    }\n                  } catch (e) {\n                    if (e instanceof SyntaxError) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Extraction complete. Problems:', extractedTotal, 'Filtered:', filteredTotal)\n\n                // Get results and format as CSV\n                console.log('[UNIFIED] Getting results')\n                const resultsRes = await fetch(`/api/niche-finder/results/${jobId}`)\n                if (!resultsRes.ok) {\n                  throw new Error(`Error al obtener resultados: ${resultsRes.status}`)\n                }\n                const resultsText = await resultsRes.text()\n                const resultsData = resultsText ? JSON.parse(resultsText) : { niches: [] }\n                const niches = resultsData.niches || []\n\n                let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n                for (const niche of niches) {\n                  const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                  const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                  const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                  const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                  const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                  const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                  const url = niche.source_url || ''\n                  csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n                }\n\n                console.log('[UNIFIED] Complete. Problems:', niches.length)\n                updateStepState(stepId, {\n                  status: 'completed',\n                  completedAt: new Date(),\n                  output: { jobId, extractedCount: niches.length, csv: csvOutput },\n                })\n                setTimeout(goToNextStep, 500)\n                return\n              }\n\n              // Unknown action\n              console.warn('[UNIFIED] Unknown action:', action)\n            }\n\n            // For other job types, just mark as pending\n            result = input\n            break\n\n          case 'none':\n          default:\n            // No execution needed, just proceed\n            result = input\n            break\n        }\n\n        // Mark as completed\n        updateStepState(stepId, {\n          status: 'completed',\n          completedAt: new Date(),\n          output: result,\n        })\n\n        // Auto-advance for auto steps\n        if (['auto', 'auto_with_review'].includes(step.type)) {\n          setTimeout(goToNextStep, 500)\n        }\n      } catch (error) {\n        updateStepState(stepId, {\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Error desconocido',\n        })\n      }\n    },\n    [projectId, playbookConfig.type, playbookConfig.phases, updateStepState, goToNextStep, selectedCampaign, state.phases]\n  )\n\n  // Handle continue from current step\n  const handleContinue = useCallback(() => {\n    console.log('[handleContinue] Called for step:', currentStep?.id, 'current status:', currentStepState?.status)\n    // Note: Don't update step state here if the caller (WorkArea) already updated it.\n    // The caller is responsible for setting status and output correctly before calling onContinue.\n    // We only set completedAt if not already completed, and we do it in a way that preserves output.\n    if (currentStepState?.status !== 'completed') {\n      console.log('[handleContinue] Status is not completed, updating step state (without output)')\n      // Mark as completed, but preserve any existing output that might have been set\n      // by the caller in the same tick (before React re-renders)\n      updateStepState(currentStep.id, {\n        status: 'completed',\n        completedAt: new Date(),\n        // Don't set output - it should already be set by the caller\n      })\n    } else {\n      console.log('[handleContinue] Status is already completed, not updating')\n    }\n    // Enable auto-execution for the next step (if it's an auto step)\n    setShouldAutoExecute(true)\n    goToNextStep()\n  }, [currentStep?.id, currentStepState?.status, updateStepState, goToNextStep])\n\n  // Handle edit - volver a editar un paso completado\n  const handleEdit = useCallback(() => {\n    if (!currentStep) return\n    // Cambiar status a pending sin perder los datos (suggestions, output, etc.)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      completedAt: undefined,\n      error: undefined,\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle cancel - cancelar ejecución en curso\n  // IMPORTANTE: Mantiene el output (jobId) para poder retomar el job\n  const handleCancel = useCallback(() => {\n    if (!currentStep) return\n\n    // Clear polling interval if running\n    if (pollIntervalRef.current) {\n      clearInterval(pollIntervalRef.current)\n      pollIntervalRef.current = null\n      console.log('[Cancel] Cleared polling interval')\n    }\n\n    // Volver a pending y limpiar progreso, pero MANTENER output (contiene jobId)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      progress: undefined,\n      error: undefined,\n      // NO limpiamos output para mantener el jobId y poder retomar\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle quick retry - retry with same configuration\n  const handleQuickRetry = useCallback(async () => {\n    if (!currentStep || !currentStepState) return\n\n    console.log('[Retry] Quick retry for step:', currentStep.id)\n\n    // Start a new retry attempt\n    try {\n      await stepRetryActions.startRetry(currentStep.id)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Reset step state and re-execute\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input\n    executeStep(currentStep.id, currentStepState.input)\n  }, [currentStep, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle retry with config modification - opens dialog\n  const handleRetryWithConfig = useCallback(() => {\n    if (!currentStep) return\n    setRetryDialogStepId(currentStep.id)\n    setRetryDialogOpen(true)\n  }, [currentStep])\n\n  // Handle retry from dialog with config overrides\n  const handleRetryFromDialog = useCallback(async (configOverrides?: StepAttemptConfig) => {\n    if (!retryDialogStepId || !currentStepState) return\n\n    console.log('[Retry] Retry from dialog for step:', retryDialogStepId, 'with config:', configOverrides)\n\n    // Start a new retry attempt with config\n    try {\n      await stepRetryActions.startRetry(retryDialogStepId, configOverrides)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Close dialog\n    setRetryDialogOpen(false)\n    setRetryDialogStepId(null)\n\n    // Reset step state\n    updateStepState(retryDialogStepId, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input (config overrides are tracked in the attempt)\n    executeStep(retryDialogStepId, currentStepState.input)\n  }, [retryDialogStepId, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle skip step - mark as skipped and continue\n  const handleSkipStep = useCallback(() => {\n    if (!currentStep) return\n\n    console.log('[Skip] Skipping step:', currentStep.id)\n\n    updateStepState(currentStep.id, {\n      status: 'skipped',\n      completedAt: new Date(),\n      error: undefined,\n    })\n\n    // Move to next step\n    handleContinue()\n  }, [currentStep, updateStepState, handleContinue])\n\n  // Get retry info for current step\n  const currentStepRetryInfo = currentStep\n    ? stepRetryActions.getRetryInfo(currentStep.id)\n    : null\n\n  // Check if max retries reached\n  const maxRetriesReached = currentStepRetryInfo\n    ? currentStepRetryInfo.attemptNumber >= currentStepRetryInfo.maxAttempts\n    : false\n\n  // Auto-start current step if it's an auto step, pending, AND user clicked Continue\n  useEffect(() => {\n    console.log('[AutoExecute] Check:', {\n      shouldAutoExecute,\n      currentStepId: currentStep?.id,\n      currentStepType: currentStep?.type,\n      currentStepStatus: currentStepState?.status,\n    })\n    if (\n      shouldAutoExecute &&\n      currentStep &&\n      currentStepState?.status === 'pending' &&\n      ['auto'].includes(currentStep.type)\n    ) {\n      console.log('[AutoExecute] Starting auto execution for:', currentStep.id)\n      // Reset the flag\n      setShouldAutoExecute(false)\n      // Small delay to allow UI to render first\n      const timer = setTimeout(() => {\n        executeStep(currentStep.id)\n      }, 300)\n      return () => clearTimeout(timer)\n    }\n  }, [shouldAutoExecute, currentStep, currentStepState?.status, executeStep])\n\n  // Resume polling for in_progress steps on page reload\n  // This handles the case where user refreshes the page while a SERP job is running\n  useEffect(() => {\n    // Only for search_with_preview steps that are in_progress with a jobId\n    if (\n      currentStep?.type === 'search_with_preview' &&\n      (currentStepState?.status === 'in_progress' || currentStepState?.status === 'pending') &&\n      currentStepState?.output &&\n      !pollIntervalRef.current\n    ) {\n      const output = currentStepState.output as { jobId?: string }\n      const jobId = output.jobId\n\n      if (jobId) {\n        console.log('[Resume] Resuming polling for job:', jobId)\n\n        // First, check if job is already done (immediate check, not polling)\n        fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          .then(res => res.json())\n          .then(statusData => {\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDone) {\n              console.log('[Resume] Job already completed, marking step as done')\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n              return // Don't start polling\n            }\n            // If not done, continue with normal polling setup below\n            startPolling()\n          })\n          .catch(err => {\n            console.error('[Resume] Error checking initial status:', err)\n            startPolling() // Start polling anyway\n          })\n\n        function startPolling() {\n          if (pollIntervalRef.current) return // Already polling\n\n          // Set up polling - same logic as in executeStep\n          let isResuming = false\n          let lastCompletedCount = -1\n          let stallCount = 0\n          let initialCompleted = -1\n\n          pollIntervalRef.current = setInterval(async () => {\n          try {\n            const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n            const statusData = await statusResponse.json()\n\n            const completed = statusData.progress?.serp?.completed || 0\n            const total = statusData.progress?.serp?.total || 0\n            const remaining = total - completed\n            const label = total > 0\n              ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n              : 'Reconectando...'\n\n            updateStepState(currentStep.id, {\n              progress: {\n                current: completed,\n                total: total,\n                label,\n              },\n            })\n\n            // Track initial value on first poll\n            if (initialCompleted === -1) {\n              initialCompleted = completed\n              console.log('[Resume] Initial completed:', initialCompleted)\n            }\n\n            // Auto-resume if job was interrupted\n            if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n              if (lastCompletedCount === completed && remaining > 0) {\n                stallCount++\n                const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                if (stallCount >= 2 || noProgressSinceStart) {\n                  console.log(`[Resume] Job stalled at ${completed}/${total}, auto-resuming...`)\n                  isResuming = true\n                  stallCount = 0\n                  fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                    .then(res => res.json())\n                    .then(data => {\n                      console.log('[Resume] Resume response:', data)\n                      isResuming = false\n                    })\n                    .catch(err => {\n                      console.error('[Resume] Resume error:', err)\n                      isResuming = false\n                    })\n                }\n              } else {\n                stallCount = 0\n              }\n            }\n            lastCompletedCount = completed\n\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDoneInPoll = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDoneInPoll) {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n            } else if (statusData.status === 'failed' || statusData.status === 'error') {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'error',\n                error: statusData.job?.error_message || 'Job failed',\n              })\n            }\n          } catch (pollError) {\n            console.error('[Resume] Poll error:', pollError)\n            // Don't stop polling on transient errors\n          }\n        }, 2000)\n        } // End startPolling function\n\n        // Cleanup on unmount\n        return () => {\n          if (pollIntervalRef.current) {\n            clearInterval(pollIntervalRef.current)\n            pollIntervalRef.current = null\n          }\n        }\n      }\n    }\n  }, [currentStep?.id, currentStep?.type, currentStepState?.status, currentStepState?.output, updateStepState, goToNextStep])\n\n  if (!currentPhase || !currentStep || !currentStepState) {\n    return (\n      <div className=\"flex items-center justify-center h-64 text-gray-500\">\n        Error: Configuración de playbook inválida\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n      {/* Header with mode selector */}\n      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3\">\n          <span className=\"text-xl\">{playbookConfig.icon}</span>\n          <h2 className=\"text-lg font-semibold text-gray-900\">{playbookConfig.name}</h2>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {/* Session Data button */}\n          {selectedCampaignId && mode === 'campaign' && (\n            <button\n              onClick={() => setShowArtifactBrowser(!showArtifactBrowser)}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                showArtifactBrowser\n                  ? 'bg-indigo-100 text-indigo-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n              title=\"Browse all session artifacts\"\n            >\n              <Database size={16} />\n              Session Data\n            </button>\n          )}\n\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}\n          <div className=\"relative flex items-center gap-1\">\n            <button\n              onClick={() => {\n                setMode('campaign')\n                setShowCampaignDropdown(!showCampaignDropdown)\n              }}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                mode === 'campaign'\n                  ? 'bg-blue-100 text-blue-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Folder size={16} />\n              {selectedCampaign ? selectedCampaign.name : 'Seleccionar Campaña'}\n              <ChevronDown size={16} />\n            </button>\n\n            {/* Edit campaign settings button */}\n            {selectedCampaignId && (\n              <button\n                onClick={() => setShowCampaignSettings(true)}\n                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg\"\n                title=\"Editar configuración de campaña\"\n              >\n                <Pencil size={14} />\n              </button>\n            )}\n\n            {/* Dropdown */}\n            {showCampaignDropdown && (\n              <div className=\"absolute right-0 top-full mt-1 w-64 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50\">\n                {campaigns.length === 0 ? (\n                  <div className=\"px-3 py-2 text-sm text-gray-500\">No hay campañas</div>\n                ) : (\n                  campaigns.map(campaign => (\n                    <div\n                      key={campaign.id}\n                      className={`flex items-center justify-between px-3 py-2 text-sm hover:bg-gray-50 ${\n                        selectedCampaignId === campaign.id ? 'bg-blue-50' : ''\n                      }`}\n                    >\n                      <button\n                        onClick={() => {\n                          setSelectedCampaignId(campaign.id)\n                          setShowCampaignDropdown(false)\n                        }}\n                        className=\"flex-1 flex items-center justify-between text-left\"\n                      >\n                        <span className=\"font-medium text-gray-900\">{campaign.name}</span>\n                        <span className=\"text-gray-500 mr-2\">\n                          {campaign.completedSteps}/{campaign.totalSteps}\n                        </span>\n                      </button>\n                      <button\n                        onClick={(e) => {\n                          e.stopPropagation()\n                          deleteCampaign(campaign.id)\n                        }}\n                        className=\"p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded\"\n                        title=\"Eliminar campaña\"\n                      >\n                        <Trash2 size={14} />\n                      </button>\n                    </div>\n                  ))\n                )}\n                <div className=\"border-t border-gray-100 mt-1 pt-1\">\n                  <button\n                    onClick={() => {\n                      setShowWizard(true)\n                      setShowCampaignDropdown(false)\n                    }}\n                    className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-blue-600 hover:bg-blue-50\"\n                  >\n                    <Plus size={16} />\n                    Nueva Campaña\n                  </button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Main content */}\n      {mode === 'config' ? (\n        /* Configuration Mode - Full width */\n        <div className=\"flex-1 overflow-hidden\">\n          <ConfigurationMode\n            projectId={projectId}\n            playbookConfig={playbookConfig}\n            onSave={() => {\n              // Optionally refresh something after save\n            }}\n          />\n        </div>\n      ) : (\n        /* Campaign Mode - Dual panel */\n        <div className=\"flex flex-1 overflow-hidden\">\n          {/* Navigation Panel - Left side */}\n          <div className=\"w-80 flex-shrink-0\">\n            <NavigationPanel\n              phases={playbookConfig.phases}\n              phaseStates={state.phases}\n              currentPhaseIndex={state.currentPhaseIndex}\n              currentStepIndex={state.currentStepIndex}\n              onStepClick={goToStep}\n            />\n          </div>\n\n          {/* Work Area - Right side */}\n          <div className=\"flex-1 overflow-y-auto\">\n            {!selectedCampaignId ? (\n              /* No campaign selected - prompt to select or create */\n              <div className=\"flex flex-col items-center justify-center h-full bg-white p-8 text-center\">\n                <Folder className=\"text-gray-300 mb-4\" size={64} />\n                <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                  Selecciona o crea una campaña\n                </h3>\n                <p className=\"text-gray-500 mb-6 max-w-md\">\n                  Para ejecutar el playbook, primero debes seleccionar una campaña existente o crear una nueva.\n                </p>\n                <button\n                  onClick={() => setShowWizard(true)}\n                  className=\"flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n                >\n                  <Plus size={16} />\n                  Nueva Campaña\n                </button>\n              </div>\n            ) : (\n              <>\n                <WorkArea\n                  step={currentStep}\n                  stepState={currentStepState}\n                  onContinue={handleContinue}\n                  onBack={goToPreviousStep}\n                  onExecute={(input) => executeStep(currentStep.id, input)}\n                  onUpdateState={(update) => updateStepState(currentStep.id, update)}\n                  onEdit={handleEdit}\n                  onCancel={handleCancel}\n                  onRerunPrevious={rerunPreviousStep}\n                  onRetry={handleQuickRetry}\n                  onRetryWithConfig={handleRetryWithConfig}\n                  onSkipStep={handleSkipStep}\n                  isFirst={isFirstStep}\n                  isLast={isLastStep}\n                  previousStepOutput={getPreviousStepOutput()}\n                  projectId={projectId}\n                  playbookContext={buildPlaybookContext()}\n                  allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                    phase.steps.map((stepDef, stepIdx) => ({\n                      definition: stepDef,\n                      state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                    }))\n                  )}\n                  saveState={sessionId ? stepPersistenceState : undefined}\n                  retryInfo={currentStepRetryInfo || undefined}\n                  maxRetriesReached={maxRetriesReached}\n                  sessionId={sessionId}\n                />\n\n                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n\n          {/* Artifact Browser Panel - Right side */}\n          {showArtifactBrowser && selectedCampaignId && (\n            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">\n              <ArtifactBrowser\n                sessionId={sessionId}\n                projectId={projectId}\n                clientId=\"\"\n                userId=\"system\"\n                campaignId={selectedCampaignId}\n                campaignName={selectedCampaign?.name || ''}\n                playbookId={playbookConfig.id}\n                playbookName={playbookConfig.name}\n                playbookType={playbookConfig.type}\n                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                  phase.steps.map((stepDef, stepIdx) => ({\n                    definition: stepDef,\n                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                  }))\n                )}\n                isVisible={showArtifactBrowser}\n                onClose={() => setShowArtifactBrowser(false)}\n              />\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Campaign Wizard Modal */}\n      {showWizard && (\n        <CampaignWizard\n          projectId={projectId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowWizard(false)}\n          onCreated={(campaignId) => {\n            setSelectedCampaignId(campaignId)\n            setShowWizard(false)\n            // Reload campaigns\n            loadCampaigns()\n          }}\n        />\n      )}\n\n      {/* Campaign Settings Modal */}\n      {showCampaignSettings && selectedCampaignId && (\n        <CampaignSettings\n          campaignId={selectedCampaignId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowCampaignSettings(false)}\n          onSaved={() => {\n            loadCampaigns()\n          }}\n        />\n      )}\n    </div>\n  )\n}\n","structuredPatch":[{"oldStart":206,"oldLines":6,"newStart":206,"newLines":25,"lines":["     loadCampaigns()","   }, [loadCampaigns])"," ","+  // Load project data (for clientId)","+  useEffect(() => {","+    async function loadProjectData() {","+      try {","+        const response = await fetch(`/api/projects/${projectId}`)","+        if (response.ok) {","+          const data = await response.json()","+          setProjectData({","+            clientId: data.client_id || '',","+            userId: 'system', // TODO: Get from auth context","+          })","+        }","+      } catch (error) {","+        console.error('Error loading project data:', error)","+      }","+    }","+    loadProjectData()","+  }, [projectId])","+","   const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)"," ","   // Ref to track if we should save (avoid saving on initial load)"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CduddGNfSdi45Aym9GBP8a","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the ArtifactBrowser to use the fetched projectData:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":724,"cache_read_input_tokens":132846,"cache_creation":{"ephemeral_5m_input_tokens":724,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"10ec3940-5fc4-4fef-ad8f-26a1b6ad516b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CduddGNfSdi45Aym9GBP8a","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MiXdK25rAzNpN8QvSTDqFD","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","offset":2848,"limit":40}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":724,"cache_read_input_tokens":132846,"cache_creation":{"ephemeral_5m_input_tokens":724,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"4abaf36e-21cd-4b89-a0a7-65948a33ac90"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MiXdK25rAzNpN8QvSTDqFD","type":"tool_result","content":"  2848→                      setRetryDialogStepId(null)\n  2849→                    }}\n  2850→                    isRetrying={stepRetryState.isRetrying}\n  2851→                  />\n  2852→                )}\n  2853→              </>\n  2854→            )}\n  2855→          </div>\n  2856→\n  2857→          {/* Artifact Browser Panel - Right side */}\n  2858→          {showArtifactBrowser && selectedCampaignId && (\n  2859→            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">\n  2860→              <ArtifactBrowser\n  2861→                sessionId={sessionId}\n  2862→                projectId={projectId}\n  2863→                clientId=\"\"\n  2864→                userId=\"system\"\n  2865→                campaignId={selectedCampaignId}\n  2866→                campaignName={selectedCampaign?.name || ''}\n  2867→                playbookId={playbookConfig.id}\n  2868→                playbookName={playbookConfig.name}\n  2869→                playbookType={playbookConfig.type}\n  2870→                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n  2871→                  phase.steps.map((stepDef, stepIdx) => ({\n  2872→                    definition: stepDef,\n  2873→                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n  2874→                  }))\n  2875→                )}\n  2876→                isVisible={showArtifactBrowser}\n  2877→                onClose={() => setShowArtifactBrowser(false)}\n  2878→              />\n  2879→            </div>\n  2880→          )}\n  2881→        </div>\n  2882→      )}\n  2883→\n  2884→      {/* Campaign Wizard Modal */}\n  2885→      {showWizard && (\n  2886→        <CampaignWizard\n  2887→          projectId={projectId}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"db827d2d-6fa5-413d-a52c-12a3403892ca","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","content":"                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n\n          {/* Artifact Browser Panel - Right side */}\n          {showArtifactBrowser && selectedCampaignId && (\n            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">\n              <ArtifactBrowser\n                sessionId={sessionId}\n                projectId={projectId}\n                clientId=\"\"\n                userId=\"system\"\n                campaignId={selectedCampaignId}\n                campaignName={selectedCampaign?.name || ''}\n                playbookId={playbookConfig.id}\n                playbookName={playbookConfig.name}\n                playbookType={playbookConfig.type}\n                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                  phase.steps.map((stepDef, stepIdx) => ({\n                    definition: stepDef,\n                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                  }))\n                )}\n                isVisible={showArtifactBrowser}\n                onClose={() => setShowArtifactBrowser(false)}\n              />\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Campaign Wizard Modal */}\n      {showWizard && (\n        <CampaignWizard\n          projectId={projectId}","numLines":40,"startLine":2848,"totalLines":2913}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LDhY2xKtYqGbjhEyEAb68F","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y7e6grtKoSSt9xbE1cQgk6","name":"Edit","input":{"replace_all":false,"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","old_string":"          {/* Artifact Browser Panel - Right side */}\n          {showArtifactBrowser && selectedCampaignId && (\n            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">\n              <ArtifactBrowser\n                sessionId={sessionId}\n                projectId={projectId}\n                clientId=\"\"\n                userId=\"system\"\n                campaignId={selectedCampaignId}\n                campaignName={selectedCampaign?.name || ''}\n                playbookId={playbookConfig.id}\n                playbookName={playbookConfig.name}\n                playbookType={playbookConfig.type}\n                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                  phase.steps.map((stepDef, stepIdx) => ({\n                    definition: stepDef,\n                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                  }))\n                )}\n                isVisible={showArtifactBrowser}\n                onClose={() => setShowArtifactBrowser(false)}\n              />\n            </div>\n          )}","new_string":"          {/* Artifact Browser Panel - Right side */}\n          {showArtifactBrowser && selectedCampaignId && (\n            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">\n              <ArtifactBrowser\n                sessionId={sessionId}\n                projectId={projectId}\n                clientId={projectData?.clientId || ''}\n                userId={projectData?.userId || 'system'}\n                campaignId={selectedCampaignId}\n                campaignName={selectedCampaign?.name || ''}\n                playbookId={playbookConfig.id}\n                playbookName={playbookConfig.name}\n                playbookType={playbookConfig.type}\n                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                  phase.steps.map((stepDef, stepIdx) => ({\n                    definition: stepDef,\n                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                  }))\n                )}\n                isVisible={showArtifactBrowser}\n                onClose={() => setShowArtifactBrowser(false)}\n              />\n            </div>\n          )}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":792,"cache_read_input_tokens":133570,"cache_creation":{"ephemeral_5m_input_tokens":792,"ephemeral_1h_input_tokens":0},"output_tokens":756,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"697be471-8f13-4776-b924-a58cd330e7ef"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y7e6grtKoSSt9xbE1cQgk6","type":"tool_result","content":"The file /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"9ae27866-4aca-4950-8a06-f2005b18aab9","tool_use_result":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/PlaybookShell.tsx","oldString":"          {/* Artifact Browser Panel - Right side */}\n          {showArtifactBrowser && selectedCampaignId && (\n            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">\n              <ArtifactBrowser\n                sessionId={sessionId}\n                projectId={projectId}\n                clientId=\"\"\n                userId=\"system\"\n                campaignId={selectedCampaignId}\n                campaignName={selectedCampaign?.name || ''}\n                playbookId={playbookConfig.id}\n                playbookName={playbookConfig.name}\n                playbookType={playbookConfig.type}\n                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                  phase.steps.map((stepDef, stepIdx) => ({\n                    definition: stepDef,\n                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                  }))\n                )}\n                isVisible={showArtifactBrowser}\n                onClose={() => setShowArtifactBrowser(false)}\n              />\n            </div>\n          )}","newString":"          {/* Artifact Browser Panel - Right side */}\n          {showArtifactBrowser && selectedCampaignId && (\n            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">\n              <ArtifactBrowser\n                sessionId={sessionId}\n                projectId={projectId}\n                clientId={projectData?.clientId || ''}\n                userId={projectData?.userId || 'system'}\n                campaignId={selectedCampaignId}\n                campaignName={selectedCampaign?.name || ''}\n                playbookId={playbookConfig.id}\n                playbookName={playbookConfig.name}\n                playbookType={playbookConfig.type}\n                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                  phase.steps.map((stepDef, stepIdx) => ({\n                    definition: stepDef,\n                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                  }))\n                )}\n                isVisible={showArtifactBrowser}\n                onClose={() => setShowArtifactBrowser(false)}\n              />\n            </div>\n          )}","originalFile":"'use client'\n\nimport { useState, useCallback, useEffect, useRef } from 'react'\nimport {\n  PlaybookShellProps,\n  PlaybookState,\n  PhaseState,\n  StepState,\n  StepDefinition,\n  PhaseDefinition,\n} from './types'\nimport NavigationPanel from './NavigationPanel'\nimport { WorkArea } from './WorkArea'\nimport ConfigurationMode from './ConfigurationMode'\nimport CampaignWizard from './CampaignWizard'\nimport CampaignSettings from './CampaignSettings'\nimport { Settings, ChevronDown, Plus, Folder, Pencil, Trash2, Database } from 'lucide-react'\nimport { ArtifactBrowser } from './ArtifactBrowser'\nimport { useStepPersistence } from '@/hooks/useStepPersistence'\nimport { useStepRetry } from '@/hooks/useStepRetry'\nimport { StepAttemptConfig, StepRetryInfo } from './types'\nimport StepRetryDialog from './StepRetryDialog'\nimport FailedStepActions from './FailedStepActions'\n\n// Mode types for the unified view\ntype PlaybookMode = 'config' | 'campaign'\n\ninterface Campaign {\n  id: string\n  name: string\n  status: 'draft' | 'in_progress' | 'completed'\n  completedSteps: number\n  totalSteps: number\n  customVariables?: Record<string, unknown> // Includes context_type, product, target, etc.\n  playbookState?: PlaybookState // Saved playbook state for persistence\n}\n\nfunction initializeState(\n  projectId: string,\n  playbookConfig: PlaybookShellProps['playbookConfig'],\n  initialState?: Partial<PlaybookState>\n): PlaybookState {\n  const phases: PhaseState[] = playbookConfig.phases.map(phase => ({\n    id: phase.id,\n    status: 'pending',\n    steps: phase.steps.map(step => ({\n      id: step.id,\n      status: 'pending',\n    })),\n  }))\n\n  // Apply initial state if provided - match by ID for robustness when config changes\n  if (initialState?.phases) {\n    initialState.phases.forEach((savedPhaseState) => {\n      // Find phase by ID instead of index\n      const phaseIndex = phases.findIndex(p => p.id === savedPhaseState.id)\n      if (phaseIndex === -1) return\n\n      phases[phaseIndex].status = savedPhaseState.status\n      savedPhaseState.steps.forEach((savedStepState) => {\n        // Find step by ID instead of index\n        const stepIndex = phases[phaseIndex].steps.findIndex(s => s.id === savedStepState.id)\n        if (stepIndex === -1) return\n\n        phases[phaseIndex].steps[stepIndex] = {\n          ...phases[phaseIndex].steps[stepIndex],\n          ...savedStepState,\n        }\n      })\n    })\n  }\n\n  const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n  const completedSteps = phases.reduce(\n    (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n    0\n  )\n\n  // Validate currentPhaseIndex and currentStepIndex are within bounds\n  let currentPhaseIndex = initialState?.currentPhaseIndex ?? 0\n  let currentStepIndex = initialState?.currentStepIndex ?? 0\n\n  // Ensure phase index is valid\n  if (currentPhaseIndex >= playbookConfig.phases.length) {\n    currentPhaseIndex = Math.max(0, playbookConfig.phases.length - 1)\n  }\n\n  // Ensure step index is valid for the current phase\n  const currentPhaseSteps = playbookConfig.phases[currentPhaseIndex]?.steps.length ?? 0\n  if (currentStepIndex >= currentPhaseSteps) {\n    currentStepIndex = Math.max(0, currentPhaseSteps - 1)\n  }\n\n  // If the current step doesn't exist, find the first non-completed step\n  if (currentPhaseSteps === 0 || currentStepIndex < 0) {\n    // Find first pending step\n    for (let pi = 0; pi < phases.length; pi++) {\n      for (let si = 0; si < phases[pi].steps.length; si++) {\n        if (phases[pi].steps[si].status !== 'completed') {\n          currentPhaseIndex = pi\n          currentStepIndex = si\n          break\n        }\n      }\n      if (currentStepIndex >= 0) break\n    }\n    // Default to first step if all completed\n    if (currentStepIndex < 0) {\n      currentPhaseIndex = 0\n      currentStepIndex = 0\n    }\n  }\n\n  console.log('[initializeState] Validated indices:', {\n    originalPhase: initialState?.currentPhaseIndex,\n    originalStep: initialState?.currentStepIndex,\n    validatedPhase: currentPhaseIndex,\n    validatedStep: currentStepIndex,\n    maxPhases: playbookConfig.phases.length,\n    maxSteps: currentPhaseSteps,\n  })\n\n  return {\n    projectId,\n    playbookType: playbookConfig.type,\n    phases,\n    currentPhaseIndex,\n    currentStepIndex,\n    config: initialState?.config ?? {},\n    completedSteps,\n    totalSteps,\n    startedAt: initialState?.startedAt,\n    completedAt: initialState?.completedAt,\n  }\n}\n\nexport default function PlaybookShell({\n  projectId,\n  playbookConfig,\n  initialState,\n  sessionId,\n}: PlaybookShellProps) {\n  const [state, setState] = useState<PlaybookState>(() =>\n    initializeState(projectId, playbookConfig, initialState)\n  )\n\n  // Step persistence hook for auto-saving step data to database\n  const [stepPersistenceState, stepPersistenceActions] = useStepPersistence({\n    sessionId: sessionId || null,\n    autoSaveInterval: 30000, // Auto-save every 30 seconds\n    enabled: !!sessionId, // Only enable if sessionId is provided\n  })\n\n  // Step retry hook for managing retry attempts\n  const [stepRetryState, stepRetryActions] = useStepRetry(sessionId || null, {\n    enabled: !!sessionId,\n  })\n\n  // State for retry dialog\n  const [retryDialogOpen, setRetryDialogOpen] = useState(false)\n  const [retryDialogStepId, setRetryDialogStepId] = useState<string | null>(null)\n\n  // Flag to distinguish between intentional navigation (Continue button)\n  // vs manual navigation (clicking on a step)\n  const [shouldAutoExecute, setShouldAutoExecute] = useState(false)\n\n  // Mode: 'config' for editing base prompts, 'campaign' for execution\n  const [mode, setMode] = useState<PlaybookMode>('campaign')\n  const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null)\n  const [campaigns, setCampaigns] = useState<Campaign[]>([])\n  const [showCampaignDropdown, setShowCampaignDropdown] = useState(false)\n  const [showWizard, setShowWizard] = useState(false)\n  const [showCampaignSettings, setShowCampaignSettings] = useState(false)\n  const [showArtifactBrowser, setShowArtifactBrowser] = useState(false)\n  const [projectData, setProjectData] = useState<{ clientId: string; userId: string } | null>(null)\n\n  // Load campaigns from database\n  const loadCampaigns = useCallback(async () => {\n    try {\n      const response = await fetch(`/api/campaign/create?projectId=${projectId}`)\n      if (!response.ok) {\n        console.error('Failed to load campaigns')\n        return\n      }\n      const data = await response.json()\n      if (data.campaigns) {\n        const totalSteps = playbookConfig.phases.reduce((sum, phase) => sum + phase.steps.length, 0)\n        const mappedCampaigns: Campaign[] = data.campaigns.map((c: any) => ({\n          id: c.id,\n          name: c.ecp_name,\n          status: c.status || 'draft',\n          // Calculate completed steps from playbook_state if available\n          completedSteps: c.playbook_state?.completedSteps ?? 0,\n          totalSteps,\n          customVariables: c.custom_variables || {}, // Load campaign variables including context_type\n          playbookState: c.playbook_state || null, // Load saved playbook state\n        }))\n        setCampaigns(mappedCampaigns)\n      }\n    } catch (error) {\n      console.error('Error loading campaigns:', error)\n    }\n  }, [projectId, playbookConfig.phases])\n\n  useEffect(() => {\n    loadCampaigns()\n  }, [loadCampaigns])\n\n  // Load project data (for clientId)\n  useEffect(() => {\n    async function loadProjectData() {\n      try {\n        const response = await fetch(`/api/projects/${projectId}`)\n        if (response.ok) {\n          const data = await response.json()\n          setProjectData({\n            clientId: data.client_id || '',\n            userId: 'system', // TODO: Get from auth context\n          })\n        }\n      } catch (error) {\n        console.error('Error loading project data:', error)\n      }\n    }\n    loadProjectData()\n  }, [projectId])\n\n  const selectedCampaign = campaigns.find(c => c.id === selectedCampaignId)\n\n  // Ref to track if we should save (avoid saving on initial load)\n  const shouldSaveRef = useRef(false)\n  // Ref to prevent duplicate saves\n  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  // Ref to store polling interval for cancellation\n  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Save playbook state to database (debounced)\n  const savePlaybookState = useCallback(async (stateToSave: PlaybookState) => {\n    if (!selectedCampaignId) return\n\n    try {\n      await fetch(`/api/campaign/${selectedCampaignId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ playbook_state: stateToSave }),\n      })\n    } catch (error) {\n      console.error('Error saving playbook state:', error)\n    }\n  }, [selectedCampaignId])\n\n  // Auto-save state when it changes (debounced)\n  useEffect(() => {\n    if (!shouldSaveRef.current || !selectedCampaignId) return\n\n    // Clear any pending save\n    if (saveTimeoutRef.current) {\n      clearTimeout(saveTimeoutRef.current)\n    }\n\n    // Debounce saves by 500ms to avoid too many API calls\n    saveTimeoutRef.current = setTimeout(() => {\n      savePlaybookState(state)\n    }, 500)\n\n    return () => {\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n      }\n    }\n  }, [state, selectedCampaignId, savePlaybookState])\n\n  // Load saved state when selecting a campaign\n  useEffect(() => {\n    if (!selectedCampaignId) {\n      shouldSaveRef.current = false\n      return\n    }\n\n    const campaign = campaigns.find(c => c.id === selectedCampaignId)\n    if (campaign?.playbookState) {\n      // Load saved state\n      shouldSaveRef.current = false // Don't save while loading\n      setState(initializeState(projectId, playbookConfig, campaign.playbookState))\n      // Enable saving after a short delay\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    } else {\n      // Fresh state for new campaign\n      shouldSaveRef.current = false\n      setState(initializeState(projectId, playbookConfig))\n      setTimeout(() => {\n        shouldSaveRef.current = true\n      }, 100)\n    }\n  }, [selectedCampaignId, campaigns, projectId, playbookConfig])\n\n  // Load step data from database on session resume (if sessionId is provided)\n  useEffect(() => {\n    if (!sessionId) return\n\n    const loadStepData = async () => {\n      try {\n        const savedSteps = await stepPersistenceActions.loadAllSteps()\n        if (Object.keys(savedSteps).length === 0) return\n\n        console.log('[PlaybookShell] Loaded step data from session:', Object.keys(savedSteps))\n\n        // Merge saved step data into current state\n        setState(prev => {\n          const newPhases = prev.phases.map(phase => ({\n            ...phase,\n            steps: phase.steps.map(step => {\n              const savedStep = savedSteps[step.id]\n              if (savedStep) {\n                return {\n                  ...step,\n                  ...savedStep,\n                }\n              }\n              return step\n            }),\n          }))\n\n          // Recalculate phase status\n          newPhases.forEach(phase => {\n            const hasError = phase.steps.some(s => s.status === 'error')\n            const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n            const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n            if (hasError) {\n              phase.status = 'error'\n            } else if (allCompleted) {\n              phase.status = 'completed'\n            } else if (hasInProgress) {\n              phase.status = 'in_progress'\n            } else {\n              phase.status = 'pending'\n            }\n          })\n\n          // Recalculate completed steps\n          const completedSteps = newPhases.reduce(\n            (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n            0\n          )\n\n          // Find the first non-completed step to set as current\n          let currentPhaseIndex = 0\n          let currentStepIndex = 0\n          outer: for (let pi = 0; pi < newPhases.length; pi++) {\n            for (let si = 0; si < newPhases[pi].steps.length; si++) {\n              if (newPhases[pi].steps[si].status !== 'completed') {\n                currentPhaseIndex = pi\n                currentStepIndex = si\n                break outer\n              }\n            }\n          }\n\n          return {\n            ...prev,\n            phases: newPhases,\n            completedSteps,\n            currentPhaseIndex,\n            currentStepIndex,\n          }\n        })\n      } catch (error) {\n        console.error('[PlaybookShell] Error loading step data:', error)\n      }\n    }\n\n    loadStepData()\n  }, [sessionId, stepPersistenceActions])\n\n  // Delete a campaign\n  const deleteCampaign = useCallback(async (campaignId: string) => {\n    if (!confirm('¿Estás seguro de que quieres eliminar esta campaña? Esta acción no se puede deshacer.')) {\n      return\n    }\n\n    try {\n      const response = await fetch(`/api/campaign/${campaignId}`, {\n        method: 'DELETE',\n      })\n\n      if (!response.ok) {\n        throw new Error('Error al eliminar campaña')\n      }\n\n      // If we deleted the selected campaign, clear selection\n      if (selectedCampaignId === campaignId) {\n        setSelectedCampaignId(null)\n      }\n\n      // Reload campaigns\n      loadCampaigns()\n    } catch (error) {\n      console.error('Error deleting campaign:', error)\n      alert('Error al eliminar la campaña')\n    }\n  }, [selectedCampaignId, loadCampaigns])\n\n  // Helper function to get the output from the previous step\n  const getPreviousStepOutput = (): string | undefined => {\n    // Find the current step's dependencies\n    if (!currentStep?.dependsOn?.length) return undefined\n\n    // Get the first dependency's output\n    const dependencyId = currentStep.dependsOn[0]\n\n    // Search for this step across all phases\n    for (const phase of state.phases) {\n      const stepState = phase.steps.find(s => s.id === dependencyId)\n      if (stepState?.output) {\n        return typeof stepState.output === 'string'\n          ? stepState.output\n          : JSON.stringify(stepState.output, null, 2)\n      }\n    }\n\n    return undefined\n  }\n\n  // Build context for LLM-based suggestion generation\n  const buildPlaybookContext = (): Record<string, unknown> => {\n    // Start with campaign's custom_variables (includes context_type, product, target, etc.)\n    const campaignVars = selectedCampaign?.customVariables || {}\n\n    const context: Record<string, unknown> = {\n      ...campaignVars, // Include all campaign variables\n      product: campaignVars.product || state.config?.product || '',\n      target: campaignVars.target || state.config?.target || '',\n      context_type: campaignVars.context_type || 'both', // Explicitly include context_type\n    }\n\n    // DEBUG: Log all steps to see their state\n    console.log('[buildPlaybookContext] All steps:', state.phases.flatMap(p =>\n      p.steps.map(s => ({ id: s.id, status: s.status, hasOutput: !!s.output }))\n    ))\n\n    // Collect values from completed steps\n    for (const phase of state.phases) {\n      for (const stepState of phase.steps) {\n        // DEBUG: Log keyword_config step specifically\n        if (stepState.id === 'keyword_config') {\n          console.log('[buildPlaybookContext] keyword_config step:', {\n            status: stepState.status,\n            hasOutput: !!stepState.output,\n            outputKeys: stepState.output ? Object.keys(stepState.output as object) : [],\n            output: stepState.output,\n          })\n        }\n\n        if (stepState.status === 'completed' || stepState.decision || stepState.suggestions) {\n          // Get decision value\n          if (stepState.decision) {\n            context[stepState.id] = stepState.decision\n          }\n\n          // Get selected suggestions as array of labels\n          if (stepState.suggestions?.length) {\n            const selectedLabels = stepState.suggestions\n              .filter(s => s.selected)\n              .map(s => s.label)\n            if (selectedLabels.length > 0) {\n              context[stepState.id] = selectedLabels\n            }\n          }\n\n          // Get output if available\n          if (stepState.output) {\n            context[`${stepState.id}_output`] = stepState.output\n          }\n\n          // Special case: Extract serpJobId from serp_search or search_and_preview step output\n          // This is needed for review_urls/review_and_scrape step to display SERP results\n          // Note: We check this inside the completed block, but also outside below\n          if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Also extract serpJobId from review_and_scrape step (the scrape step)\n          // This ensures scrape_results step can find the jobId after scraping completes\n          if (stepState.id === 'review_and_scrape' && stepState.output) {\n            const output = stepState.output as { jobId?: string }\n            if (output.jobId && !context.serpJobId) {\n              context.serpJobId = output.jobId\n            }\n          }\n\n          // Special case: Parse sources step output for QueryPreviewPanel\n          // The LLM returns a JSON string that needs to be parsed\n          if (stepState.id === 'sources' && stepState.output) {\n            try {\n              let parsedSources = stepState.output\n              if (typeof stepState.output === 'string') {\n                // Try to extract JSON from the LLM response\n                const jsonMatch = stepState.output.match(/\\{[\\s\\S]*\\}/)\n                if (jsonMatch) {\n                  parsedSources = JSON.parse(jsonMatch[0])\n                }\n              }\n              // Only set if it's a valid sources config object\n              if (parsedSources && typeof parsedSources === 'object' &&\n                  ('reddit' in parsedSources || 'thematic_forums' in parsedSources || 'general_forums' in parsedSources)) {\n                context.sources = parsedSources\n              }\n            } catch (e) {\n              console.error('[buildPlaybookContext] Error parsing sources output:', e)\n              // Don't set context.sources - let it use default values\n            }\n          }\n\n          // Special case: Extract keyword_config unified output for SearchWithPreviewStep\n          // The unified panel saves data in two formats:\n          // 1. lifeContexts, needWords, indicators as arrays of objects (for UI)\n          // 2. life_contexts, product_words, indicators as arrays of strings (for SERP job)\n          if (stepState.id === 'keyword_config' && stepState.output) {\n            const output = stepState.output as {\n              // Object arrays (for UI state)\n              lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n              needWords?: Array<{ id: string; label: string; selected: boolean }>\n              indicators?: Array<{ id: string; label: string; selected: boolean }>\n              // String arrays (pre-extracted for SERP job)\n              life_contexts?: string[]\n              product_words?: string[]\n              sources?: {\n                reddit_general?: { enabled: boolean }\n                reddit?: { enabled: boolean; subreddits?: string[] }\n                thematic_forums?: { enabled: boolean; forums?: string[] }\n                general_forums?: { enabled: boolean; forums?: string[] }\n              }\n            }\n\n            // First try to use pre-extracted string arrays (set on completion)\n            if (output.life_contexts && Array.isArray(output.life_contexts)) {\n              context.life_contexts = output.life_contexts\n            } else if (output.lifeContexts) {\n              // Fall back to extracting from object array\n              context.life_contexts = output.lifeContexts\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            // Check multiple possible keys for need words\n            if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n              context.need_words = output.product_words\n              console.log('[buildPlaybookContext] Got need_words from product_words:', output.product_words)\n            } else if ((output as any).need_words && Array.isArray((output as any).need_words) && (output as any).need_words.length > 0) {\n              // Also check for 'need_words' key (alternative naming)\n              context.need_words = (output as any).need_words\n              console.log('[buildPlaybookContext] Got need_words from need_words key:', (output as any).need_words)\n            } else if (output.needWords && Array.isArray(output.needWords)) {\n              const extracted = output.needWords\n                .filter(item => item.selected)\n                .map(item => item.label)\n              if (extracted.length > 0) {\n                context.need_words = extracted\n                console.log('[buildPlaybookContext] Got need_words from needWords (selected):', extracted)\n              } else {\n                console.warn('[buildPlaybookContext] needWords array exists but no items selected:', output.needWords)\n              }\n            } else {\n              console.warn('[buildPlaybookContext] Could not find need_words in output:', {\n                hasProductWords: !!output.product_words,\n                productWordsLength: output.product_words?.length,\n                hasNeedWords: !!(output as any).need_words,\n                hasNeedWordsArray: !!output.needWords,\n                outputKeys: Object.keys(output),\n              })\n            }\n\n            if (output.indicators && Array.isArray(output.indicators) && typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else if (output.indicators && Array.isArray(output.indicators)) {\n              context.indicators = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected)\n                .map(item => item.label)\n            }\n\n            if (output.sources) {\n              context.sources = output.sources\n            }\n\n            // DEBUG: Log what we extracted from keyword_config\n            console.log('[buildPlaybookContext] Extracted from keyword_config:', {\n              life_contexts: context.life_contexts,\n              need_words: context.need_words,\n              indicators: context.indicators,\n              sources: context.sources,\n            })\n          }\n        }\n\n        // IMPORTANT: Extract serpJobId even from non-completed steps (e.g., after cancel)\n        // This allows review_and_scrape to show URLs from a cancelled SERP job\n        if ((stepState.id === 'serp_search' || stepState.id === 'search_and_preview') && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also check review_and_scrape for non-completed steps (e.g., in progress or cancelled)\n        if (stepState.id === 'review_and_scrape' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // Also extract serpJobId from scrape_results step (for extraction step)\n        if (stepState.id === 'scrape_results' && stepState.output && !context.serpJobId) {\n          const output = stepState.output as { jobId?: string }\n          if (output.jobId) {\n            context.serpJobId = output.jobId\n          }\n        }\n\n        // IMPORTANT: Also extract keyword_config data even if step is not 'completed'\n        // This ensures retry/navigation doesn't lose the config\n        if (stepState.id === 'keyword_config' && stepState.output && !context.life_contexts) {\n          console.log('[buildPlaybookContext] Extracting keyword_config from non-completed step')\n          const output = stepState.output as {\n            lifeContexts?: Array<{ id: string; label: string; selected: boolean }>\n            needWords?: Array<{ id: string; label: string; selected: boolean }>\n            indicators?: Array<{ id: string; label: string; selected: boolean }>\n            life_contexts?: string[]\n            product_words?: string[]\n            sources?: Record<string, unknown>\n          }\n\n          if (output.life_contexts && Array.isArray(output.life_contexts) && output.life_contexts.length > 0) {\n            context.life_contexts = output.life_contexts\n          } else if (output.lifeContexts) {\n            const extracted = output.lifeContexts.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.life_contexts = extracted\n            }\n          }\n\n          if (output.product_words && Array.isArray(output.product_words) && output.product_words.length > 0) {\n            context.need_words = output.product_words\n          } else if (output.needWords) {\n            const extracted = output.needWords.filter(item => item.selected).map(item => item.label)\n            if (extracted.length > 0) {\n              context.need_words = extracted\n            }\n          }\n\n          if (output.indicators && Array.isArray(output.indicators) && output.indicators.length > 0) {\n            if (typeof output.indicators[0] === 'string') {\n              context.indicators = output.indicators\n            } else {\n              const extracted = (output.indicators as Array<{ id: string; label: string; selected: boolean }>)\n                .filter(item => item.selected).map(item => item.label)\n              if (extracted.length > 0) {\n                context.indicators = extracted\n              }\n            }\n          }\n\n          if (output.sources && !context.sources) {\n            context.sources = output.sources\n          }\n\n          console.log('[buildPlaybookContext] Extracted from non-completed keyword_config:', {\n            life_contexts: context.life_contexts,\n            need_words: context.need_words,\n          })\n        }\n      }\n    }\n\n    // DEBUG: Log final context\n    console.log('[buildPlaybookContext] Final context:', {\n      life_contexts: context.life_contexts,\n      need_words: context.need_words,\n      indicators: context.indicators,\n      sources: context.sources,\n      serpJobId: context.serpJobId,\n    })\n\n    return context\n  }\n\n  // Get current phase and step definitions\n  const currentPhase = playbookConfig.phases[state.currentPhaseIndex]\n  const currentStep = currentPhase?.steps[state.currentStepIndex]\n  const currentStepState = state.phases[state.currentPhaseIndex]?.steps[state.currentStepIndex]\n\n  // Calculate navigation bounds\n  const isFirstStep = state.currentPhaseIndex === 0 && state.currentStepIndex === 0\n  const isLastStep =\n    state.currentPhaseIndex === playbookConfig.phases.length - 1 &&\n    state.currentStepIndex === currentPhase.steps.length - 1\n\n  // Navigate to a specific step\n  const goToStep = useCallback((phaseIndex: number, stepIndex: number) => {\n    // Save current state immediately before navigating (don't wait for debounce)\n    if (shouldSaveRef.current && selectedCampaignId) {\n      // Clear pending debounced save\n      if (saveTimeoutRef.current) {\n        clearTimeout(saveTimeoutRef.current)\n        saveTimeoutRef.current = null\n      }\n      // Save current state synchronously\n      savePlaybookState(state)\n    }\n\n    setState(prev => ({\n      ...prev,\n      currentPhaseIndex: phaseIndex,\n      currentStepIndex: stepIndex,\n    }))\n  }, [selectedCampaignId, state, savePlaybookState])\n\n  // Go to next step\n  const goToNextStep = useCallback(() => {\n    setState(prev => {\n      const currentPhase = playbookConfig.phases[prev.currentPhaseIndex]\n\n      // Check if there's a next step in current phase\n      if (prev.currentStepIndex < currentPhase.steps.length - 1) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex + 1,\n        }\n      }\n\n      // Check if there's a next phase\n      if (prev.currentPhaseIndex < playbookConfig.phases.length - 1) {\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex + 1,\n          currentStepIndex: 0,\n        }\n      }\n\n      // Already at the end\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Go to previous step\n  const goToPreviousStep = useCallback(() => {\n    setState(prev => {\n      // Check if there's a previous step in current phase\n      if (prev.currentStepIndex > 0) {\n        return {\n          ...prev,\n          currentStepIndex: prev.currentStepIndex - 1,\n        }\n      }\n\n      // Check if there's a previous phase\n      if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        return {\n          ...prev,\n          currentPhaseIndex: prev.currentPhaseIndex - 1,\n          currentStepIndex: prevPhase.steps.length - 1,\n        }\n      }\n\n      // Already at the beginning\n      return prev\n    })\n  }, [playbookConfig.phases])\n\n  // Re-run the previous step (go back and reset its state to pending)\n  const rerunPreviousStep = useCallback(() => {\n    setState(prev => {\n      let newPhaseIndex = prev.currentPhaseIndex\n      let newStepIndex = prev.currentStepIndex\n\n      // Find previous step\n      if (prev.currentStepIndex > 0) {\n        newStepIndex = prev.currentStepIndex - 1\n      } else if (prev.currentPhaseIndex > 0) {\n        const prevPhase = playbookConfig.phases[prev.currentPhaseIndex - 1]\n        newPhaseIndex = prev.currentPhaseIndex - 1\n        newStepIndex = prevPhase.steps.length - 1\n      } else {\n        // Already at the beginning, nothing to rerun\n        return prev\n      }\n\n      // Get the previous step ID\n      const prevStepId = playbookConfig.phases[newPhaseIndex].steps[newStepIndex].id\n\n      // Reset the previous step state to pending and navigate to it\n      const newPhases = prev.phases.map((phase, pi) => ({\n        ...phase,\n        steps: phase.steps.map((step, si) => {\n          if (pi === newPhaseIndex && si === newStepIndex) {\n            return {\n              ...step,\n              status: 'pending' as const,\n              output: undefined,\n              error: undefined,\n            }\n          }\n          return step\n        }),\n      }))\n\n      return {\n        ...prev,\n        phases: newPhases,\n        currentPhaseIndex: newPhaseIndex,\n        currentStepIndex: newStepIndex,\n      }\n    })\n    // Trigger auto-execute after navigating\n    setShouldAutoExecute(true)\n  }, [playbookConfig.phases])\n\n  // Update step state\n  const updateStepState = useCallback(\n    (stepId: string, update: Partial<StepState>) => {\n      console.log('[updateStepState] Updating step:', stepId, 'with:', {\n        ...update,\n        output: update.output ? `[output with keys: ${Object.keys(update.output as object).join(', ')}]` : undefined,\n      })\n\n      // Persist step changes to database (if sessionId is provided)\n      if (sessionId) {\n        // Handle status-specific persistence\n        if (update.status === 'in_progress') {\n          stepPersistenceActions.markStepRunning(stepId, update.input)\n        } else if (update.status === 'completed') {\n          stepPersistenceActions.markStepCompleted(stepId, update.output)\n        } else if (update.status === 'error') {\n          stepPersistenceActions.markStepFailed(stepId, update.error || 'Unknown error')\n        } else if (update.output !== undefined) {\n          // For output-only updates (during execution), schedule auto-save\n          stepPersistenceActions.scheduleAutoSave(stepId, update.output)\n        }\n      }\n\n      setState(prev => {\n        // Find the current step to log what we're merging\n        const currentStep = prev.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n        if (stepId === 'keyword_config') {\n          console.log('[updateStepState] keyword_config before merge:', {\n            status: currentStep?.status,\n            hasOutput: !!currentStep?.output,\n            outputKeys: currentStep?.output ? Object.keys(currentStep.output as object) : [],\n          })\n        }\n\n        const newPhases = prev.phases.map(phase => ({\n          ...phase,\n          steps: phase.steps.map(step =>\n            step.id === stepId ? { ...step, ...update } : step\n          ),\n        }))\n\n        // Log the merged result for keyword_config\n        if (stepId === 'keyword_config') {\n          const mergedStep = newPhases.flatMap(p => p.steps).find(s => s.id === stepId)\n          console.log('[updateStepState] keyword_config after merge:', {\n            status: mergedStep?.status,\n            hasOutput: !!mergedStep?.output,\n            outputKeys: mergedStep?.output ? Object.keys(mergedStep.output as object) : [],\n          })\n        }\n\n        // Recalculate phase status\n        newPhases.forEach(phase => {\n          const hasError = phase.steps.some(s => s.status === 'error')\n          const allCompleted = phase.steps.every(s => s.status === 'completed' || s.status === 'skipped')\n          const hasInProgress = phase.steps.some(s => s.status === 'in_progress')\n\n          if (hasError) {\n            phase.status = 'error'\n          } else if (allCompleted) {\n            phase.status = 'completed'\n          } else if (hasInProgress) {\n            phase.status = 'in_progress'\n          } else {\n            phase.status = 'pending'\n          }\n        })\n\n        // Recalculate completed steps\n        const completedSteps = newPhases.reduce(\n          (sum, phase) => sum + phase.steps.filter(s => s.status === 'completed').length,\n          0\n        )\n\n        return {\n          ...prev,\n          phases: newPhases,\n          completedSteps,\n        }\n      })\n    },\n    [sessionId, stepPersistenceActions]\n  )\n\n  // Execute a step\n  const executeStep = useCallback(\n    async (stepId: string, input?: any) => {\n      console.log('[executeStep] Starting execution for step:', stepId, 'with input:', input)\n\n      const step = playbookConfig.phases\n        .flatMap(p => p.steps)\n        .find(s => s.id === stepId)\n\n      if (!step) {\n        console.error('[executeStep] Step not found:', stepId)\n        return\n      }\n\n      console.log('[executeStep] Found step:', step.id, 'type:', step.type, 'executor:', step.executor, 'jobType:', step.jobType)\n\n      // Mark as in progress\n      updateStepState(stepId, {\n        status: 'in_progress',\n        startedAt: new Date(),\n        input,\n      })\n\n      try {\n        let result: any\n\n        // Special case: Execute extraction from scrape_results step\n        if (step.id === 'scrape_results' && input?.action === 'extract' && input?.jobId) {\n          console.log('[EXTRACT from scrape_results] Starting extraction for job:', input.jobId)\n          const jobId = input.jobId\n\n          updateStepState(stepId, {\n            output: { jobId },\n            progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' },\n            partialResults: { extracted: 0, filtered: 0 },\n          })\n\n          // Get total URLs to extract from job status\n          const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          const statusData = await statusResponse.json()\n          const scrapedUrlCount = statusData.url_counts?.scraped || 0\n          const totalUrls = scrapedUrlCount || statusData.job?.urls_scraped || 0\n          const existingExtractedCount = statusData.job?.niches_extracted || 0\n          const existingFilteredCount = statusData.url_counts?.filtered || 0\n\n          console.log('[EXTRACT] Status check:', {\n            scrapedUrlCount,\n            totalUrls,\n            existingExtractedCount,\n            existingFilteredCount,\n            jobStatus: statusData.job?.status,\n            urlsFailed: statusData.url_counts?.failed || 0,\n          })\n\n          // Check if there's nothing to extract (all URLs failed or filtered)\n          if (scrapedUrlCount === 0 && existingExtractedCount === 0) {\n            const failedCount = statusData.url_counts?.failed || 0\n            console.log('[EXTRACT] No URLs to extract and no existing results. Failed:', failedCount, 'Filtered:', existingFilteredCount)\n\n            // Show error state - nothing to extract\n            updateStepState(stepId, {\n              status: 'error',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: 0,\n                filteredCount: existingFilteredCount,\n                error: failedCount > 0\n                  ? `El scraping falló para ${failedCount} URLs (posible bloqueo de Reddit API). No hay contenido disponible para extraer.`\n                  : 'No hay URLs disponibles para extraer. Verifica que el scraping se completó correctamente.',\n              },\n              progress: undefined,\n            })\n\n            return // Stop - nothing to do\n          }\n\n          // Check if extraction was already done (no URLs to process but results exist)\n          if (scrapedUrlCount === 0 && existingExtractedCount > 0) {\n            console.log('[EXTRACT] Extraction already completed, using existing results')\n            updateStepState(stepId, {\n              progress: { current: 100, total: 100, label: `Usando resultados existentes: ${existingExtractedCount} problemas encontrados` },\n            })\n\n            // Skip extraction loop and jump to results fetching\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // Mark scrape_results as completed\n            updateStepState(stepId, {\n              status: 'completed',\n              completedAt: new Date(),\n              output: {\n                jobId,\n                extractedCount: existingExtractedCount,\n                filteredCount: existingFilteredCount,\n              },\n              progress: undefined,\n            })\n\n            // Also update extract_problems step for clean_filter to use\n            console.log('[EXTRACT] Updating extract_problems step with existing CSV results')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,\n              partialResults: {\n                extracted: existingExtractedCount,\n                filtered: existingFilteredCount,\n                successCount: niches.length,\n              }\n            })\n\n            console.log('[EXTRACT] Using existing results:', niches.length, 'problems')\n            return // Don't proceed with new extraction\n          }\n\n          updateStepState(stepId, {\n            progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` },\n          })\n\n          // Call extract endpoint in batches until has_more=false\n          let hasMore = true\n          let extractedTotal = 0\n          let filteredTotal = 0\n          let processedTotal = 0\n\n          while (hasMore) {\n            try {\n              const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout)\n              const contentType = extractResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                console.error('[EXTRACT] Non-JSON response, polling status...')\n                await new Promise(resolve => setTimeout(resolve, 2000))\n\n                // Check current status\n                const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                const checkData = await checkResponse.json()\n\n                if (checkData.status === 'completed') {\n                  hasMore = false\n                  extractedTotal = checkData.job?.niches_extracted || 0\n                }\n                continue\n              }\n\n              const extractData = await extractResponse.json()\n              console.log('[EXTRACT] Batch response:', extractData)\n\n              if (extractData.error) {\n                throw new Error(extractData.error)\n              }\n\n              extractedTotal += extractData.extracted || 0\n              filteredTotal += extractData.filtered || 0\n              processedTotal = extractedTotal + filteredTotal\n              hasMore = extractData.has_more || false\n\n              updateStepState(stepId, {\n                progress: {\n                  current: processedTotal,\n                  total: totalUrls,\n                  label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                },\n                partialResults: {\n                  extracted: extractedTotal,\n                  filtered: filteredTotal,\n                },\n              })\n            } catch (extractError) {\n              console.error('[EXTRACT] Batch error:', extractError)\n              await new Promise(resolve => setTimeout(resolve, 2000))\n\n              // Check if we should stop\n              const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const checkData = await checkResponse.json()\n              if (checkData.status === 'completed' || checkData.status === 'failed') {\n                hasMore = false\n                if (checkData.status === 'failed') {\n                  throw new Error(checkData.job?.error_message || 'Extraction failed')\n                }\n              }\n            }\n          }\n\n          // Mark as completed\n          updateStepState(stepId, {\n            status: 'completed',\n            completedAt: new Date(),\n            output: {\n              jobId,\n              extractedCount: extractedTotal,\n              filteredCount: filteredTotal,\n            },\n            progress: undefined, // Clear progress\n          })\n\n          console.log('[EXTRACT] Completed! Extracted:', extractedTotal, 'Filtered:', filteredTotal)\n\n          // Save results to Context Lake automatically\n          try {\n            // Get project data (includes client_id)\n            const projectResponse = await fetch(`/api/projects/${projectId}`)\n            const projectData = await projectResponse.json()\n\n            // Get extracted niches for CSV content\n            const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n            const resultsData = await resultsResponse.json()\n            const niches = resultsData.niches || []\n\n            // Build CSV content\n            let csvContent = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n            for (const niche of niches) {\n              const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n              const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n              const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n              const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n              const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n              const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n              const url = niche.source_url || ''\n              csvContent += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n            }\n\n            // IMPORTANT: Also update extract_problems step so clean_filter can use the results\n            // clean_filter depends on extract_problems, not scrape_results\n            console.log('[EXTRACT] Updating extract_problems step with CSV results for clean_filter')\n            updateStepState('extract_problems', {\n              status: 'completed',\n              completedAt: new Date(),\n              output: csvContent,  // CSV string that clean_filter will use\n              partialResults: {\n                extracted: extractedTotal,\n                filtered: filteredTotal,\n                successCount: niches.length,\n              }\n            })\n\n            const dateStr = new Date().toISOString().split('T')[0]\n            const campaignSlug = selectedCampaign?.name?.toLowerCase().replace(/\\s+/g, '-') || 'sin-nombre'\n            const projectSlug = projectData.name?.toLowerCase().replace(/\\s+/g, '-') || 'proyecto'\n\n            const documentData = {\n              projectId: projectId,\n              clientId: projectData.client_id,\n              filename: `Niche Finder - ${selectedCampaign?.name || 'Sin nombre'} - ${dateStr}`,\n              category: 'research',\n              content: csvContent,\n              description: `${extractedTotal} problemas extraídos del Niche Finder. ${filteredTotal} URLs filtradas de ${totalUrls} procesadas.`,\n              tags: [\n                `fecha:${dateStr}`,\n                `proyecto:${projectSlug}`,\n                `campaña:${campaignSlug}`,\n                `job:${jobId}`,\n                'niche-finder',\n                'problemas-extraidos'\n              ],\n              folder: `niche-finder/${campaignSlug}`,\n              userId: 'system', // TODO: Get actual user ID from session\n              sourceMetadata: {\n                origin_type: 'flow_step_output',\n                playbook_id: playbookConfig.type || 'niche-finder',\n                playbook_name: playbookConfig.name,\n                campaign_id: selectedCampaignId || '',\n                campaign_name: selectedCampaign?.name || '',\n                campaign_variables: selectedCampaign?.customVariables || {},\n                step_id: 'scrape_results',\n                step_name: 'Extracción de Problemas',\n                step_order: 3,\n                executed_at: new Date().toISOString(),\n                model_used: 'openai/gpt-4o-mini',\n                model_provider: 'openrouter',\n                input_tokens: 0,\n                output_tokens: 0,\n                input_document_ids: [],\n                input_previous_step_ids: ['search_and_preview', 'review_and_scrape'],\n                converted_at: new Date().toISOString(),\n                converted_by: 'system',\n                was_edited_before_conversion: false\n              },\n              sourceCampaignId: selectedCampaignId || '',\n              sourceStepId: 'scrape_results',\n              sourceStepName: 'Extracción de Problemas',\n              sourcePlaybookId: playbookConfig.type\n            }\n\n            const saveResponse = await fetch('/api/documents/from-step-output', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify(documentData)\n            })\n\n            if (saveResponse.ok) {\n              const savedDoc = await saveResponse.json()\n              console.log('[EXTRACT] Results saved to Context Lake:', savedDoc.document?.id)\n            } else {\n              console.error('[EXTRACT] Failed to save to Context Lake:', await saveResponse.text())\n            }\n          } catch (saveError) {\n            console.error('[EXTRACT] Error saving to Context Lake:', saveError)\n            // Don't fail the extraction if saving to Context Lake fails\n          }\n\n          return // Don't fall through to the switch\n        }\n\n        switch (step.executor) {\n          case 'llm':\n            // Build variables including campaign custom_variables (product, target, industry, etc.)\n            const campaignVars = selectedCampaign?.customVariables || {}\n            const stepVariables = {\n              ...Object.fromEntries(\n                Object.entries(campaignVars).map(([k, v]) => [k, String(v ?? '')])\n              ),\n              ...(input || {}),\n            }\n            // Call LLM API\n            const response = await fetch('/api/playbook/execute-step', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({\n                projectId,\n                stepId,\n                playbookType: playbookConfig.type,\n                promptKey: step.promptKey,\n                variables: stepVariables,\n              }),\n            })\n            const data = await response.json()\n            if (!data.success) throw new Error(data.error || 'Error ejecutando paso')\n            result = data.output\n            break\n\n          case 'api':\n            // Call custom API endpoint\n            if (step.apiEndpoint) {\n              // Build payload with previous step outputs and campaign variables\n              const campaignVarsForApi = selectedCampaign?.customVariables || {}\n\n              // Get outputs from previous steps (dependsOn)\n              const previousOutputs: Record<string, unknown> = {}\n              if (step.dependsOn?.length) {\n                for (const depId of step.dependsOn) {\n                  for (const phase of state.phases) {\n                    const depStep = phase.steps.find(s => s.id === depId)\n                    if (depStep?.output) {\n                      previousOutputs[depId] = depStep.output\n                    }\n                  }\n                }\n              }\n\n              // Build scenes array from generate_scenes output (for video-viral generate-clips)\n              let scenes: string[] | undefined\n              if (previousOutputs.generate_scenes) {\n                let scenesOutput = previousOutputs.generate_scenes\n\n                // Parse JSON if output is a string (LLM outputs often come as strings)\n                if (typeof scenesOutput === 'string') {\n                  try {\n                    // Try to extract JSON from the string (might be wrapped in markdown code blocks)\n                    const jsonMatch = scenesOutput.match(/```(?:json)?\\s*(\\{[\\s\\S]*?\\})\\s*```/) ||\n                                     scenesOutput.match(/(\\{[\\s\\S]*\\})/)\n                    if (jsonMatch) {\n                      scenesOutput = JSON.parse(jsonMatch[1])\n                    }\n                  } catch (e) {\n                    console.error('[executeStep] Failed to parse generate_scenes output:', e)\n                  }\n                }\n\n                // Extract scene_1, scene_2, scene_3, etc. from the output\n                if (typeof scenesOutput === 'object' && scenesOutput !== null) {\n                  const scenesRecord = scenesOutput as Record<string, string>\n                  scenes = Object.entries(scenesRecord)\n                    .filter(([key]) => key.startsWith('scene_'))\n                    .sort(([a], [b]) => a.localeCompare(b))\n                    .map(([, value]) => value)\n                  console.log('[executeStep] Extracted scenes:', scenes)\n                }\n              }\n\n              const apiResponse = await fetch(step.apiEndpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                  projectId,\n                  stepId,\n                  input,\n                  ...campaignVarsForApi,\n                  previousOutputs,\n                  scenes, // For generate-clips endpoint\n                }),\n              })\n              const apiData = await apiResponse.json()\n              if (!apiData.success && apiData.error) throw new Error(apiData.error)\n              result = apiData\n            }\n            break\n\n          case 'job':\n            // Job-based execution: create job, execute, poll for status\n            console.log('[executeStep] Executor is JOB, jobType:', step.jobType)\n\n            if (step.jobType === 'niche_finder_serp') {\n              // Check if we have an existing job to resume (from cancelled execution)\n              const currentStepForJob = state.phases.flatMap(p => p.steps).find(s => s.id === stepId)\n              const existingJobId = (currentStepForJob?.output as { jobId?: string })?.jobId\n\n              let jobId: string\n\n              if (existingJobId) {\n                // Resume existing job\n                console.log('[SERP] Resuming existing job:', existingJobId)\n                jobId = existingJobId\n                updateStepState(stepId, { progress: { current: 0, total: 0, label: 'Retomando búsqueda SERP...' } })\n              } else {\n                // Build job config from completed steps OR from input (for search_with_preview)\n                let jobConfig: {\n                  life_contexts: string[]\n                  product_words: string[]\n                  indicators: string[]\n                  sources: { reddit: boolean | { enabled?: boolean; subreddits?: string[] }; thematic_forums: boolean | { enabled?: boolean; forums?: string[] }; general_forums: string[] | { enabled?: boolean; forums?: string[] } }\n                  serp_pages: number\n                  // Campaign metadata for extraction to use correct variables\n                  campaign_id?: string | null\n                  ecp_name?: string\n                  ecp_product?: string\n                  ecp_target?: string\n                  ecp_industry?: string\n                  ecp_category?: string\n                  ecp_country?: string\n                }\n\n                // If input is provided (from SearchWithPreviewPanel), use it directly\n                console.log('[SERP] Input received:', JSON.stringify(input, null, 2))\n\n                if (input && input.life_contexts && input.product_words) {\n                  // Warn if arrays are empty\n                  if (input.life_contexts.length === 0 || input.product_words.length === 0) {\n                    console.warn('[SERP] WARNING: life_contexts or product_words is empty!', {\n                      life_contexts: input.life_contexts,\n                      product_words: input.product_words\n                    })\n                  }\n\n                  jobConfig = {\n                    life_contexts: input.life_contexts,\n                    product_words: input.product_words,\n                    indicators: input.indicators || [],\n                    sources: input.sources || { reddit: true, thematic_forums: false, general_forums: [] },\n                    serp_pages: input.serp_pages || 5,\n                  }\n                } else {\n                  console.log('[SERP] No valid input, falling back to completed steps...')\n                  // Fall back to building from completed steps (legacy flow)\n                  const lifeContextsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'life_contexts')\n                  const needWordsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'need_words')\n                  const indicatorsStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'indicators')\n                  const sourcesStep = state.phases\n                    .flatMap(p => p.steps)\n                    .find(s => s.id === 'sources')\n\n                  const selectedContexts = lifeContextsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedNeedWords = needWordsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n                  const selectedIndicators = indicatorsStep?.suggestions?.filter(s => s.selected).map(s => s.label) || []\n\n                  // Parse sources output (can be JSON string from LLM or already parsed object)\n                  let sourcesConfig: { reddit: { enabled: boolean; subreddits: string[] }; thematic_forums: { enabled: boolean; forums: string[] }; general_forums: { enabled: boolean; forums: string[] } } = { reddit: { enabled: true, subreddits: [] }, thematic_forums: { enabled: false, forums: [] }, general_forums: { enabled: false, forums: [] } }\n                  try {\n                    if (sourcesStep?.output) {\n                      // Check if output is already an object (parsed)\n                      if (typeof sourcesStep.output === 'object' && sourcesStep.output !== null) {\n                        sourcesConfig = sourcesStep.output as typeof sourcesConfig\n                      } else if (typeof sourcesStep.output === 'string') {\n                        // Try to extract JSON from string\n                        const jsonMatch = sourcesStep.output.match(/\\{[\\s\\S]*\\}/)\n                        if (jsonMatch) {\n                          sourcesConfig = JSON.parse(jsonMatch[0])\n                        }\n                      }\n                    }\n                  } catch (e) {\n                    console.error('Error parsing sources config:', e)\n                  }\n\n                  // Get campaign variables with proper typing\n                  const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                  jobConfig = {\n                    campaign_id: selectedCampaignId, // CRITICAL: Pass campaign_id so extract uses correct variables\n                    life_contexts: selectedContexts,\n                    product_words: selectedNeedWords,\n                    indicators: selectedIndicators,\n                    sources: sourcesConfig,\n                    serp_pages: (campaignVars?.serp_pages as number) || 5,\n                    // Also pass campaign variables directly in config for reliability\n                    ecp_name: (campaignVars?.company_name as string) || selectedCampaign?.name,\n                    ecp_product: campaignVars?.product as string | undefined,\n                    ecp_target: campaignVars?.target as string | undefined,\n                    ecp_industry: campaignVars?.industry as string | undefined,\n                    ecp_category: campaignVars?.category as string | undefined,\n                    ecp_country: campaignVars?.country as string | undefined,\n                  }\n                }\n\n                console.log('[SERP] Starting job with config:', JSON.stringify(jobConfig, null, 2))\n\n                // 1. Create job\n                const createResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: jobConfig,\n                  }),\n                })\n                const createData = await createResponse.json()\n                console.log('[SERP] Create job response:', createData)\n\n                if (!createData.success) {\n                  throw new Error(createData.error || 'Error creando job')\n                }\n\n                jobId = createData.job_id\n                console.log('[SERP] Job created with ID:', jobId)\n                updateStepState(stepId, { output: { jobId }, progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' } })\n              }\n\n              // 2. Execute SERP job (this will resume from where it left off if job was interrupted)\n              console.log('[SERP] Executing SERP search...')\n              const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, {\n                method: 'POST',\n              })\n\n              // Handle non-JSON responses (e.g., Vercel timeout HTML pages)\n              const contentType = serpResponse.headers.get('content-type')\n              if (!contentType || !contentType.includes('application/json')) {\n                const text = await serpResponse.text()\n                console.error('[SERP] Non-JSON response:', text.slice(0, 500))\n                // If we got a non-JSON response, the job might still be running in the background\n                // Continue to polling to check status\n                console.log('[SERP] Continuing to poll for job status despite non-JSON response...')\n              } else {\n                const serpData = await serpResponse.json()\n                console.log('[SERP] SERP response:', serpData)\n\n                if (serpData.error) {\n                  // Check if it's a missing API key error\n                  if (serpData.code === 'MISSING_API_KEY') {\n                    throw new Error(`API Key faltante: ${serpData.service}. Configura tu API key en Ajustes > APIs.`)\n                  }\n                  throw new Error(serpData.error)\n                }\n              }\n\n              // 3. Poll for status and auto-resume if needed\n              let isResuming = false\n              let lastCompletedCount = -1 // Track previous poll value\n              let stallCount = 0 // Count consecutive stalls\n              let initialCompleted = -1 // Track initial value when polling started\n\n              // Clear any existing poll interval\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n              }\n\n              pollIntervalRef.current = setInterval(async () => {\n                try {\n                  const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const statusData = await statusResponse.json()\n\n                  const completed = statusData.progress?.serp?.completed || 0\n                  const total = statusData.progress?.serp?.total || 0\n                  const remaining = total - completed\n                  const label = total > 0\n                    ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n                    : 'Iniciando búsqueda SERP...'\n                  updateStepState(stepId, {\n                    progress: {\n                      current: completed,\n                      total: total,\n                      label,\n                    },\n                  })\n\n                  // Track initial value on first poll\n                  if (initialCompleted === -1) {\n                    initialCompleted = completed\n                  }\n\n                  // Auto-resume if job was interrupted (still serp_running but not progressing)\n                  // This handles Vercel timeout scenarios\n                  if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n                    // Check if progress has stalled (same value as PREVIOUS poll)\n                    if (lastCompletedCount === completed && remaining > 0) {\n                      stallCount++\n                      // After 2 consecutive stalls (4+ seconds), OR if no progress since we started polling\n                      const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                      if (stallCount >= 2 || noProgressSinceStart) {\n                        console.log(`[SERP] Job stalled at ${completed}/${total} (stallCount=${stallCount}, initialCompleted=${initialCompleted}), auto-resuming...`)\n                        isResuming = true\n                        stallCount = 0\n                        // Resume the job by calling SERP endpoint again\n                        fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                          .then(res => res.json())\n                          .then(data => {\n                            console.log('[SERP] Resume response:', data)\n                            isResuming = false\n                          })\n                          .catch(err => {\n                            console.error('[SERP] Resume error:', err)\n                            isResuming = false\n                          })\n                      }\n                    } else {\n                      stallCount = 0 // Reset stall count if progress is being made\n                    }\n                  }\n\n                  // Update last completed for next poll comparison\n                  lastCompletedCount = completed\n\n                  // Check if SERP phase is done (includes later states that imply SERP finished)\n                  const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n                  if (serpDone) {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    updateStepState(stepId, {\n                      status: 'completed',\n                      completedAt: new Date(),\n                      output: {\n                        jobId,\n                        urlsFound: statusData.job?.urls_found || 0,\n                        costs: statusData.costs,\n                      },\n                      progress: undefined, // Clear progress to stop spinner\n                    })\n                    setTimeout(goToNextStep, 500)\n                  } else if (statusData.status === 'failed' || statusData.status === 'error') {\n                    if (pollIntervalRef.current) {\n                      clearInterval(pollIntervalRef.current)\n                      pollIntervalRef.current = null\n                    }\n                    throw new Error(statusData.job?.error_message || 'Job failed')\n                  }\n                } catch (pollError) {\n                  if (pollIntervalRef.current) {\n                    clearInterval(pollIntervalRef.current)\n                    pollIntervalRef.current = null\n                  }\n                  updateStepState(stepId, {\n                    status: 'error',\n                    error: pollError instanceof Error ? pollError.message : 'Error checking job status',\n                  })\n                }\n              }, 2000) // Poll every 2 seconds\n\n              // Don't fall through to the completion logic below\n              return\n            }\n\n            // SCRAPE JOB: Scrape URLs from the SERP results\n            if (step.jobType === 'niche_finder_scrape') {\n              // Get the jobId from the previous step (search_and_preview)\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n              console.log('[SCRAPE] Looking for search_and_preview step:', searchStep)\n              console.log('[SCRAPE] search_and_preview output:', searchStep?.output)\n\n              // Also check for serp_search (legacy step name)\n              const serpStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'serp_search')\n              console.log('[SCRAPE] Looking for serp_search step:', serpStep)\n              console.log('[SCRAPE] serp_search output:', serpStep?.output)\n\n              // Try to get jobId from either step\n              let jobId = (searchStep?.output as { jobId?: string })?.jobId ||\n                          (serpStep?.output as { jobId?: string })?.jobId\n\n              // If still no jobId, try from input (might be passed from ReviewAndScrapePanel)\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n                console.log('[SCRAPE] Got jobId from input:', jobId)\n              }\n\n              if (!jobId) {\n                console.error('[SCRAPE] No jobId found. All steps:', state.phases.flatMap(p => p.steps).map(s => ({ id: s.id, output: s.output })))\n                throw new Error('No se encontró el Job ID del paso de búsqueda')\n              }\n\n              console.log('[SCRAPE] Starting scrape for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando scraping...' }\n              })\n\n              // Get total URLs to scrape\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.urls_found || 0\n\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Scrapeando 0/${totalUrls} URLs...` }\n              })\n\n              // Start scraping - this will scrape in batches\n              let scrapedCount = 0\n              let failedCount = 0\n              let hasMore = true\n\n              while (hasMore) {\n                try {\n                  const scrapeResponse = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = scrapeResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[SCRAPE] Non-JSON response, continuing...')\n                    // Wait a bit and continue polling\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'scrape_done') {\n                      hasMore = false\n                      scrapedCount = checkData.job?.scrape_success_count || 0\n                      failedCount = checkData.job?.scrape_failed_count || 0\n                    }\n                    continue\n                  }\n\n                  const scrapeData = await scrapeResponse.json()\n                  console.log('[SCRAPE] Batch response:', scrapeData)\n\n                  if (scrapeData.error) {\n                    throw new Error(scrapeData.error)\n                  }\n\n                  scrapedCount += scrapeData.scraped || 0\n                  failedCount += scrapeData.failed || 0\n                  hasMore = scrapeData.has_more || false\n\n                  // Update progress with real-time feedback\n                  updateStepState(stepId, {\n                    progress: {\n                      current: scrapedCount + failedCount,\n                      total: totalUrls,\n                      label: `Scrapeando ${scrapedCount + failedCount}/${totalUrls} URLs...`,\n                    },\n                    partialResults: {\n                      successCount: scrapedCount,\n                      failedCount: failedCount,\n                      lastUrl: scrapeData.last_scraped_url,\n                      lastSnippet: scrapeData.last_scraped_snippet,\n                    },\n                  })\n\n                } catch (scrapeError) {\n                  console.error('[SCRAPE] Batch error:', scrapeError)\n                  // Don't throw - try to continue with next batch\n                  // The endpoint will mark failed URLs and continue\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'scrape_done' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Scraping failed')\n                    }\n                  }\n                }\n              }\n\n              // Mark as completed\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  scrapedCount,\n                  failedCount,\n                },\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            if (step.jobType === 'niche_finder_extract') {\n              // Get jobId from previous steps (review_and_scrape or scrape_results)\n              const scrapeResultsStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'scrape_results')\n              const reviewAndScrapeStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'review_and_scrape')\n              const searchStep = state.phases.flatMap(p => p.steps).find(s => s.id === 'search_and_preview')\n\n              console.log('[EXTRACT] Looking for jobId from steps:', {\n                scrape_results: scrapeResultsStep?.output,\n                review_and_scrape: reviewAndScrapeStep?.output,\n                search_and_preview: searchStep?.output,\n              })\n\n              let jobId = (scrapeResultsStep?.output as { jobId?: string })?.jobId ||\n                          (reviewAndScrapeStep?.output as { jobId?: string })?.jobId ||\n                          (searchStep?.output as { jobId?: string })?.jobId\n\n              // Also try from input\n              if (!jobId && input?.jobId) {\n                jobId = input.jobId\n              }\n\n              if (!jobId) {\n                console.error('[EXTRACT] No jobId found')\n                throw new Error('No se encontró el Job ID. Por favor ejecuta los pasos anteriores primero.')\n              }\n\n              console.log('[EXTRACT] Starting extraction for job:', jobId)\n              updateStepState(stepId, {\n                output: { jobId },\n                progress: { current: 0, total: 0, label: 'Iniciando extracción de problemas...' }\n              })\n\n              // Get total URLs to extract from job status\n              const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n              const statusData = await statusResponse.json()\n              const totalUrls = statusData.job?.scrape_success_count || 0\n\n              console.log('[EXTRACT] Total URLs to process:', totalUrls)\n              updateStepState(stepId, {\n                progress: { current: 0, total: totalUrls, label: `Extrayendo problemas de 0/${totalUrls} URLs...` }\n              })\n\n              // Call extract endpoint in batches until has_more=false\n              let hasMore = true\n              let extractedTotal = 0\n              let filteredTotal = 0\n              let processedTotal = 0\n\n              while (hasMore) {\n                try {\n                  const extractResponse = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, {\n                    method: 'POST',\n                  })\n\n                  // Handle non-JSON responses (e.g., Vercel timeout)\n                  const contentType = extractResponse.headers.get('content-type')\n                  if (!contentType || !contentType.includes('application/json')) {\n                    console.error('[EXTRACT] Non-JSON response, polling status...')\n                    await new Promise(resolve => setTimeout(resolve, 2000))\n\n                    // Check current status\n                    const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                    const checkData = await checkResponse.json()\n\n                    if (checkData.status === 'completed') {\n                      hasMore = false\n                      extractedTotal = checkData.job?.niches_extracted || 0\n                    }\n                    continue\n                  }\n\n                  const extractData = await extractResponse.json()\n                  console.log('[EXTRACT] Batch response:', extractData)\n\n                  if (extractData.error) {\n                    throw new Error(extractData.error)\n                  }\n\n                  extractedTotal += extractData.extracted || 0\n                  filteredTotal += extractData.filtered || 0\n                  processedTotal = extractedTotal + filteredTotal\n                  hasMore = extractData.has_more || false\n\n                  updateStepState(stepId, {\n                    progress: {\n                      current: processedTotal,\n                      total: totalUrls,\n                      label: `Extrayendo problemas... ${extractedTotal} encontrados de ${processedTotal}/${totalUrls} URLs`,\n                    },\n                    partialResults: {\n                      successCount: extractedTotal,\n                      failedCount: filteredTotal,\n                    },\n                  })\n                } catch (extractError) {\n                  console.error('[EXTRACT] Batch error:', extractError)\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n\n                  // Check if we should stop\n                  const checkResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                  const checkData = await checkResponse.json()\n                  if (checkData.status === 'completed' || checkData.status === 'failed') {\n                    hasMore = false\n                    if (checkData.status === 'failed') {\n                      throw new Error(checkData.job?.error_message || 'Extraction failed')\n                    }\n                  }\n                }\n              }\n\n              // Get extracted problems and format as CSV\n              console.log('[EXTRACT] Getting results from /api/niche-finder/results/', jobId)\n              const resultsResponse = await fetch(`/api/niche-finder/results/${jobId}`)\n\n              if (!resultsResponse.ok) {\n                console.error('[EXTRACT] Failed to get results:', resultsResponse.status, resultsResponse.statusText)\n                throw new Error(`Error obteniendo resultados: ${resultsResponse.status}`)\n              }\n\n              const resultsData = await resultsResponse.json()\n              console.log('[EXTRACT] Results data:', {\n                hasNiches: !!resultsData.niches,\n                nichesCount: resultsData.niches?.length || 0,\n                status: resultsData.status,\n                urls: resultsData.urls,\n              })\n\n              // Format niches as CSV string with all relevant columns\n              const niches = resultsData.niches || []\n              let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n              for (const niche of niches) {\n                const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                const url = niche.source_url || ''\n                csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n              }\n\n              console.log('[EXTRACT] Completed. Total problems:', niches.length, 'CSV preview:', csvOutput.substring(0, 200))\n\n              // Mark as completed with CSV output\n              updateStepState(stepId, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: csvOutput,\n              })\n              setTimeout(goToNextStep, 500)\n              return\n            }\n\n            // UNIFIED SEARCH + EXTRACT: Handles both SERP and analysis in one step\n            if (step.jobType === 'niche_finder_unified') {\n              const action = (input as { action?: string })?.action\n\n              // ============ ACTION: SERP ============\n              if (action === 'serp') {\n                const config = (input as { config?: { life_contexts: string[]; product_words: string[]; indicators: string[]; sources: { reddit: boolean; thematic_forums: boolean; general_forums: string[] }; serp_pages: number } }).config\n                if (!config) {\n                  throw new Error('No se recibió configuración para la búsqueda')\n                }\n\n                console.log('[UNIFIED] Starting SERP with config:', config)\n\n                // Get campaign variables\n                const campaignVars = selectedCampaign?.customVariables as Record<string, string | number | undefined> | undefined\n\n                // Create the SERP job\n                const jobResponse = await fetch('/api/niche-finder/jobs/start', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({\n                    project_id: projectId,\n                    config: {\n                      ...config,\n                      campaign_id: selectedCampaignId,\n                      ecp_name: campaignVars?.['ECP Name'] || campaignVars?.ecp_name,\n                      ecp_product: campaignVars?.['ECP Product'] || campaignVars?.ecp_product,\n                      ecp_target: campaignVars?.['ECP Target'] || campaignVars?.ecp_target,\n                      ecp_industry: campaignVars?.['ECP Industry'] || campaignVars?.ecp_industry,\n                      ecp_category: campaignVars?.['ECP Category'] || campaignVars?.ecp_category,\n                      ecp_country: campaignVars?.['ECP Country'] || campaignVars?.ecp_country,\n                    }\n                  }),\n                })\n\n                if (!jobResponse.ok) {\n                  const errorText = await jobResponse.text()\n                  throw new Error(`Error al crear job: ${jobResponse.status} - ${errorText || 'Sin respuesta'}`)\n                }\n\n                const jobText = await jobResponse.text()\n                if (!jobText || jobText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al crear el job')\n                }\n\n                const jobData = JSON.parse(jobText)\n                const jobId = jobData.job_id\n\n                if (!jobId) {\n                  throw new Error('No se pudo crear el job de búsqueda')\n                }\n\n                console.log('[UNIFIED] SERP Job created:', jobId)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'serp_executing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando búsqueda SERP...' },\n                })\n\n                // Start SERP execution\n                const serpResponse = await fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n\n                if (!serpResponse.ok) {\n                  const serpErrorText = await serpResponse.text()\n                  let errorMessage = `Error al iniciar búsqueda SERP: ${serpResponse.status}`\n                  try {\n                    const serpError = JSON.parse(serpErrorText)\n                    if (serpError.code === 'MISSING_API_KEY') {\n                      errorMessage = `${serpError.error}`\n                    } else if (serpError.error) {\n                      errorMessage = serpError.error\n                    }\n                  } catch {\n                    if (serpErrorText) errorMessage += ` - ${serpErrorText}`\n                  }\n                  throw new Error(errorMessage)\n                }\n\n                console.log('[UNIFIED] SERP execution started successfully')\n\n                // Poll for SERP completion\n                let serpComplete = false\n                let pollRetries = 0\n                const MAX_POLL_RETRIES = 3\n                while (!serpComplete) {\n                  await new Promise(resolve => setTimeout(resolve, 2000))\n                  try {\n                    const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n\n                    if (!statusRes.ok) {\n                      console.warn(`[UNIFIED] Status poll failed with ${statusRes.status}`)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error(`Error al consultar estado del job: ${statusRes.status}`)\n                      }\n                      continue\n                    }\n\n                    const text = await statusRes.text()\n                    if (!text || text.trim() === '') {\n                      console.warn('[UNIFIED] Empty response from status endpoint, retrying...')\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('El servidor no está respondiendo correctamente')\n                      }\n                      continue\n                    }\n\n                    const statusData = JSON.parse(text)\n                    pollRetries = 0 // Reset retries on success\n\n                    const urlsFound = statusData.job?.urls_found || 0\n                    // Status API returns serp_total and serp_completed (not total_queries/completed_queries)\n                    const totalSearches = statusData.job?.serp_total || statusData.progress?.serp?.total || 0\n                    const completedSearches = statusData.job?.serp_completed || statusData.progress?.serp?.completed || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: completedSearches,\n                        total: totalSearches,\n                        label: `Buscando... ${urlsFound} URLs encontradas`,\n                      },\n                    })\n\n                    if (['serp_done', 'serp_completed', 'scrape_done', 'completed'].includes(statusData.status)) {\n                      serpComplete = true\n                      console.log('[UNIFIED] SERP completed. URLs found:', urlsFound)\n                      updateStepState(stepId, {\n                        output: { jobId, phase: 'serp_complete', urlsFound },\n                        progress: undefined,\n                      })\n                    } else if (statusData.status === 'failed') {\n                      throw new Error(statusData.job?.error_message || 'SERP falló')\n                    }\n                  } catch (pollError) {\n                    if (pollError instanceof SyntaxError) {\n                      console.warn('[UNIFIED] JSON parse error in poll, retrying...', pollError)\n                      pollRetries++\n                      if (pollRetries >= MAX_POLL_RETRIES) {\n                        throw new Error('Error al procesar respuesta del servidor')\n                      }\n                    } else {\n                      throw pollError\n                    }\n                  }\n                }\n                return // Don't mark as completed - wait for analyze action\n              }\n\n              // ============ ACTION: ANALYZE (Scrape + Extract) ============\n              if (action === 'analyze') {\n                const jobId = (input as { jobId?: string }).jobId\n                const selectedSources = (input as { selectedSources?: string[] }).selectedSources || []\n                const extractionPrompt = (input as { extractionPrompt?: string }).extractionPrompt\n\n                if (!jobId) {\n                  throw new Error('No se encontró el Job ID')\n                }\n\n                console.log('[UNIFIED] Starting analysis for job:', jobId, 'sources:', selectedSources, 'custom prompt:', !!extractionPrompt)\n                updateStepState(stepId, {\n                  output: { jobId, phase: 'analyzing' },\n                  progress: { current: 0, total: 0, label: 'Iniciando análisis...' },\n                })\n\n                // If a custom extraction prompt was provided, update the job config\n                if (extractionPrompt) {\n                  console.log('[UNIFIED] Updating job with custom extraction prompt')\n                  const updateRes = await fetch(`/api/niche-finder/jobs/${jobId}`, {\n                    method: 'PATCH',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ extraction_prompt: extractionPrompt }),\n                  })\n                  if (!updateRes.ok) {\n                    console.warn('[UNIFIED] Failed to update job with custom prompt:', updateRes.status)\n                  }\n                }\n\n                // Get total URLs to process\n                const statusRes = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n                if (!statusRes.ok) {\n                  throw new Error(`Error al obtener estado del job: ${statusRes.status}`)\n                }\n                const statusText = await statusRes.text()\n                if (!statusText || statusText.trim() === '') {\n                  throw new Error('El servidor devolvió una respuesta vacía al consultar estado')\n                }\n                const statusData = JSON.parse(statusText)\n                const totalUrls = statusData.job?.urls_found || 0\n\n                // Start scraping - call API repeatedly until all URLs are processed\n                console.log('[UNIFIED] Starting scrape for', totalUrls, 'URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: totalUrls, label: 'Descargando contenido...' },\n                })\n\n                let scrapeComplete = false\n                let scrapeRetries = 0\n                let totalScraped = 0\n                let totalFailed = 0\n                const MAX_SCRAPE_RETRIES = 5 // More retries for transient failures\n\n                while (!scrapeComplete) {\n                  try {\n                    console.log(`[UNIFIED] Scrape batch starting, totalScraped=${totalScraped}, retries=${scrapeRetries}`)\n\n                    // Call scrape API with timeout (120s to allow for slow scrapes)\n                    const controller = new AbortController()\n                    const timeout = setTimeout(() => controller.abort(), 120000)\n\n                    const scrapeRes = await fetch(`/api/niche-finder/jobs/${jobId}/scrape`, {\n                      method: 'POST',\n                      headers: { 'Content-Type': 'application/json' },\n                      body: JSON.stringify({ sources: selectedSources }),\n                      signal: controller.signal,\n                    })\n                    clearTimeout(timeout)\n\n                    if (!scrapeRes.ok) {\n                      const errorText = await scrapeRes.text().catch(() => '')\n                      console.error(`[UNIFIED] Scrape response not ok: ${scrapeRes.status}`, errorText)\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(`Error en scraping: ${scrapeRes.status} - ${errorText || 'Unknown error'}`)\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeText = await scrapeRes.text()\n                    if (!scrapeText) {\n                      console.warn('[UNIFIED] Empty scrape response, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Respuesta vacía del servidor después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 3000))\n                      continue\n                    }\n\n                    const scrapeData = JSON.parse(scrapeText)\n                    scrapeRetries = 0 // Reset on successful response\n\n                    if (scrapeData.error) {\n                      // Check if it's a retryable error\n                      if (scrapeData.error.includes('Rate limit') || scrapeData.error.includes('timeout')) {\n                        console.warn(`[UNIFIED] Retryable scrape error: ${scrapeData.error}`)\n                        scrapeRetries++\n                        if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error(scrapeData.error)\n                        await new Promise(r => setTimeout(r, 5000))\n                        continue\n                      }\n                      throw new Error(scrapeData.error)\n                    }\n\n                    // Update progress with scraped count from this batch\n                    totalScraped += scrapeData.scraped || 0\n                    totalFailed += scrapeData.failed || 0\n                    const remaining = scrapeData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: totalScraped,\n                        total: totalUrls,\n                        label: `Descargando... ${totalScraped}/${totalUrls} URLs${totalFailed > 0 ? ` (${totalFailed} fallidas)` : ''}`,\n                      },\n                      partialResults: {\n                        successCount: totalScraped,\n                        failedCount: totalFailed,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Scrape batch complete: +${scrapeData.scraped} scraped, ${remaining} remaining, has_more: ${scrapeData.has_more}`)\n\n                    // Check if scraping is complete\n                    if (!scrapeData.has_more || remaining === 0) {\n                      scrapeComplete = true\n                    }\n                  } catch (e) {\n                    console.error('[UNIFIED] Scrape error:', e)\n                    if (e instanceof SyntaxError) {\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 3000))\n                    } else if (e instanceof Error && e.name === 'AbortError') {\n                      // Timeout - retry with longer wait\n                      console.warn('[UNIFIED] Scrape request timed out, retrying...')\n                      scrapeRetries++\n                      if (scrapeRetries >= MAX_SCRAPE_RETRIES) throw new Error('Timeout en scraping después de múltiples reintentos')\n                      await new Promise(r => setTimeout(r, 5000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Scraping complete, total scraped:', totalScraped)\n\n                // Start extraction - use totalScraped as the base since only scraped URLs can be extracted\n                const extractionTotal = totalScraped || totalUrls // Fallback to totalUrls if scraping tracked differently\n                console.log('[UNIFIED] Starting extraction for', extractionTotal, 'scraped URLs')\n                updateStepState(stepId, {\n                  progress: { current: 0, total: extractionTotal, label: 'Extrayendo problemas...' },\n                })\n\n                let extractComplete = false\n                let extractedTotal = 0\n                let filteredTotal = 0\n                let extractRetries = 0\n\n                while (!extractComplete) {\n                  try {\n                    const extractRes = await fetch(`/api/niche-finder/jobs/${jobId}/extract`, { method: 'POST' })\n                    if (!extractRes.ok) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error(`Error en extracción: ${extractRes.status}`)\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const text = await extractRes.text()\n                    if (!text) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Respuesta vacía del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                      continue\n                    }\n                    const extractData = JSON.parse(text)\n                    extractRetries = 0\n\n                    if (extractData.error) {\n                      throw new Error(extractData.error)\n                    }\n\n                    extractedTotal += extractData.extracted || 0\n                    filteredTotal += extractData.filtered || 0\n                    const processed = extractedTotal + filteredTotal\n                    const remaining = extractData.remaining || 0\n\n                    updateStepState(stepId, {\n                      progress: {\n                        current: processed,\n                        total: extractionTotal,\n                        label: `Extrayendo... ${extractedTotal} problemas de ${processed}/${extractionTotal} URLs${filteredTotal > 0 ? ` (${filteredTotal} filtradas)` : ''}`,\n                      },\n                      partialResults: {\n                        extracted: extractedTotal,\n                        filtered: filteredTotal,\n                      },\n                    })\n\n                    console.log(`[UNIFIED] Extract batch: ${extractData.extracted} extracted, ${extractData.filtered} filtered, ${remaining} remaining, has_more: ${extractData.has_more}`)\n\n                    if (!extractData.has_more || remaining === 0) {\n                      extractComplete = true\n                    }\n                  } catch (e) {\n                    if (e instanceof SyntaxError) {\n                      extractRetries++\n                      if (extractRetries >= 3) throw new Error('Error al procesar respuesta del servidor')\n                      await new Promise(r => setTimeout(r, 2000))\n                    } else {\n                      throw e\n                    }\n                  }\n                }\n\n                console.log('[UNIFIED] Extraction complete. Problems:', extractedTotal, 'Filtered:', filteredTotal)\n\n                // Get results and format as CSV\n                console.log('[UNIFIED] Getting results')\n                const resultsRes = await fetch(`/api/niche-finder/results/${jobId}`)\n                if (!resultsRes.ok) {\n                  throw new Error(`Error al obtener resultados: ${resultsRes.status}`)\n                }\n                const resultsText = await resultsRes.text()\n                const resultsData = resultsText ? JSON.parse(resultsText) : { niches: [] }\n                const niches = resultsData.niches || []\n\n                let csvOutput = 'problema,persona,causa_funcional,carga_emocional,evidencia,alternativas,url_fuente\\n'\n                for (const niche of niches) {\n                  const problem = (niche.problem || '').replace(/\"/g, '\"\"')\n                  const persona = (niche.persona || '').replace(/\"/g, '\"\"')\n                  const functionalCause = (niche.functional_cause || '').replace(/\"/g, '\"\"')\n                  const emotionalLoad = (niche.emotional_load || '').replace(/\"/g, '\"\"')\n                  const evidence = (niche.evidence || '').replace(/\"/g, '\"\"')\n                  const alternatives = (niche.alternatives || '').replace(/\"/g, '\"\"')\n                  const url = niche.source_url || ''\n                  csvOutput += `\"${problem}\",\"${persona}\",\"${functionalCause}\",\"${emotionalLoad}\",\"${evidence}\",\"${alternatives}\",\"${url}\"\\n`\n                }\n\n                console.log('[UNIFIED] Complete. Problems:', niches.length)\n                updateStepState(stepId, {\n                  status: 'completed',\n                  completedAt: new Date(),\n                  output: { jobId, extractedCount: niches.length, csv: csvOutput },\n                })\n                setTimeout(goToNextStep, 500)\n                return\n              }\n\n              // Unknown action\n              console.warn('[UNIFIED] Unknown action:', action)\n            }\n\n            // For other job types, just mark as pending\n            result = input\n            break\n\n          case 'none':\n          default:\n            // No execution needed, just proceed\n            result = input\n            break\n        }\n\n        // Mark as completed\n        updateStepState(stepId, {\n          status: 'completed',\n          completedAt: new Date(),\n          output: result,\n        })\n\n        // Auto-advance for auto steps\n        if (['auto', 'auto_with_review'].includes(step.type)) {\n          setTimeout(goToNextStep, 500)\n        }\n      } catch (error) {\n        updateStepState(stepId, {\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Error desconocido',\n        })\n      }\n    },\n    [projectId, playbookConfig.type, playbookConfig.phases, updateStepState, goToNextStep, selectedCampaign, state.phases]\n  )\n\n  // Handle continue from current step\n  const handleContinue = useCallback(() => {\n    console.log('[handleContinue] Called for step:', currentStep?.id, 'current status:', currentStepState?.status)\n    // Note: Don't update step state here if the caller (WorkArea) already updated it.\n    // The caller is responsible for setting status and output correctly before calling onContinue.\n    // We only set completedAt if not already completed, and we do it in a way that preserves output.\n    if (currentStepState?.status !== 'completed') {\n      console.log('[handleContinue] Status is not completed, updating step state (without output)')\n      // Mark as completed, but preserve any existing output that might have been set\n      // by the caller in the same tick (before React re-renders)\n      updateStepState(currentStep.id, {\n        status: 'completed',\n        completedAt: new Date(),\n        // Don't set output - it should already be set by the caller\n      })\n    } else {\n      console.log('[handleContinue] Status is already completed, not updating')\n    }\n    // Enable auto-execution for the next step (if it's an auto step)\n    setShouldAutoExecute(true)\n    goToNextStep()\n  }, [currentStep?.id, currentStepState?.status, updateStepState, goToNextStep])\n\n  // Handle edit - volver a editar un paso completado\n  const handleEdit = useCallback(() => {\n    if (!currentStep) return\n    // Cambiar status a pending sin perder los datos (suggestions, output, etc.)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      completedAt: undefined,\n      error: undefined,\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle cancel - cancelar ejecución en curso\n  // IMPORTANTE: Mantiene el output (jobId) para poder retomar el job\n  const handleCancel = useCallback(() => {\n    if (!currentStep) return\n\n    // Clear polling interval if running\n    if (pollIntervalRef.current) {\n      clearInterval(pollIntervalRef.current)\n      pollIntervalRef.current = null\n      console.log('[Cancel] Cleared polling interval')\n    }\n\n    // Volver a pending y limpiar progreso, pero MANTENER output (contiene jobId)\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      progress: undefined,\n      error: undefined,\n      // NO limpiamos output para mantener el jobId y poder retomar\n    })\n  }, [currentStep?.id, updateStepState])\n\n  // Handle quick retry - retry with same configuration\n  const handleQuickRetry = useCallback(async () => {\n    if (!currentStep || !currentStepState) return\n\n    console.log('[Retry] Quick retry for step:', currentStep.id)\n\n    // Start a new retry attempt\n    try {\n      await stepRetryActions.startRetry(currentStep.id)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Reset step state and re-execute\n    updateStepState(currentStep.id, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input\n    executeStep(currentStep.id, currentStepState.input)\n  }, [currentStep, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle retry with config modification - opens dialog\n  const handleRetryWithConfig = useCallback(() => {\n    if (!currentStep) return\n    setRetryDialogStepId(currentStep.id)\n    setRetryDialogOpen(true)\n  }, [currentStep])\n\n  // Handle retry from dialog with config overrides\n  const handleRetryFromDialog = useCallback(async (configOverrides?: StepAttemptConfig) => {\n    if (!retryDialogStepId || !currentStepState) return\n\n    console.log('[Retry] Retry from dialog for step:', retryDialogStepId, 'with config:', configOverrides)\n\n    // Start a new retry attempt with config\n    try {\n      await stepRetryActions.startRetry(retryDialogStepId, configOverrides)\n    } catch (error) {\n      console.error('[Retry] Failed to start retry:', error)\n    }\n\n    // Close dialog\n    setRetryDialogOpen(false)\n    setRetryDialogStepId(null)\n\n    // Reset step state\n    updateStepState(retryDialogStepId, {\n      status: 'pending',\n      error: undefined,\n      progress: undefined,\n    })\n\n    // Re-execute with the same input (config overrides are tracked in the attempt)\n    executeStep(retryDialogStepId, currentStepState.input)\n  }, [retryDialogStepId, currentStepState, stepRetryActions, updateStepState, executeStep])\n\n  // Handle skip step - mark as skipped and continue\n  const handleSkipStep = useCallback(() => {\n    if (!currentStep) return\n\n    console.log('[Skip] Skipping step:', currentStep.id)\n\n    updateStepState(currentStep.id, {\n      status: 'skipped',\n      completedAt: new Date(),\n      error: undefined,\n    })\n\n    // Move to next step\n    handleContinue()\n  }, [currentStep, updateStepState, handleContinue])\n\n  // Get retry info for current step\n  const currentStepRetryInfo = currentStep\n    ? stepRetryActions.getRetryInfo(currentStep.id)\n    : null\n\n  // Check if max retries reached\n  const maxRetriesReached = currentStepRetryInfo\n    ? currentStepRetryInfo.attemptNumber >= currentStepRetryInfo.maxAttempts\n    : false\n\n  // Auto-start current step if it's an auto step, pending, AND user clicked Continue\n  useEffect(() => {\n    console.log('[AutoExecute] Check:', {\n      shouldAutoExecute,\n      currentStepId: currentStep?.id,\n      currentStepType: currentStep?.type,\n      currentStepStatus: currentStepState?.status,\n    })\n    if (\n      shouldAutoExecute &&\n      currentStep &&\n      currentStepState?.status === 'pending' &&\n      ['auto'].includes(currentStep.type)\n    ) {\n      console.log('[AutoExecute] Starting auto execution for:', currentStep.id)\n      // Reset the flag\n      setShouldAutoExecute(false)\n      // Small delay to allow UI to render first\n      const timer = setTimeout(() => {\n        executeStep(currentStep.id)\n      }, 300)\n      return () => clearTimeout(timer)\n    }\n  }, [shouldAutoExecute, currentStep, currentStepState?.status, executeStep])\n\n  // Resume polling for in_progress steps on page reload\n  // This handles the case where user refreshes the page while a SERP job is running\n  useEffect(() => {\n    // Only for search_with_preview steps that are in_progress with a jobId\n    if (\n      currentStep?.type === 'search_with_preview' &&\n      (currentStepState?.status === 'in_progress' || currentStepState?.status === 'pending') &&\n      currentStepState?.output &&\n      !pollIntervalRef.current\n    ) {\n      const output = currentStepState.output as { jobId?: string }\n      const jobId = output.jobId\n\n      if (jobId) {\n        console.log('[Resume] Resuming polling for job:', jobId)\n\n        // First, check if job is already done (immediate check, not polling)\n        fetch(`/api/niche-finder/jobs/${jobId}/status`)\n          .then(res => res.json())\n          .then(statusData => {\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDone = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDone) {\n              console.log('[Resume] Job already completed, marking step as done')\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n              return // Don't start polling\n            }\n            // If not done, continue with normal polling setup below\n            startPolling()\n          })\n          .catch(err => {\n            console.error('[Resume] Error checking initial status:', err)\n            startPolling() // Start polling anyway\n          })\n\n        function startPolling() {\n          if (pollIntervalRef.current) return // Already polling\n\n          // Set up polling - same logic as in executeStep\n          let isResuming = false\n          let lastCompletedCount = -1\n          let stallCount = 0\n          let initialCompleted = -1\n\n          pollIntervalRef.current = setInterval(async () => {\n          try {\n            const statusResponse = await fetch(`/api/niche-finder/jobs/${jobId}/status`)\n            const statusData = await statusResponse.json()\n\n            const completed = statusData.progress?.serp?.completed || 0\n            const total = statusData.progress?.serp?.total || 0\n            const remaining = total - completed\n            const label = total > 0\n              ? `Búsquedas: ${completed}/${total} (faltan ${remaining})`\n              : 'Reconectando...'\n\n            updateStepState(currentStep.id, {\n              progress: {\n                current: completed,\n                total: total,\n                label,\n              },\n            })\n\n            // Track initial value on first poll\n            if (initialCompleted === -1) {\n              initialCompleted = completed\n              console.log('[Resume] Initial completed:', initialCompleted)\n            }\n\n            // Auto-resume if job was interrupted\n            if (statusData.status === 'serp_running' && completed < total && !isResuming) {\n              if (lastCompletedCount === completed && remaining > 0) {\n                stallCount++\n                const noProgressSinceStart = completed === initialCompleted && stallCount >= 1\n                if (stallCount >= 2 || noProgressSinceStart) {\n                  console.log(`[Resume] Job stalled at ${completed}/${total}, auto-resuming...`)\n                  isResuming = true\n                  stallCount = 0\n                  fetch(`/api/niche-finder/jobs/${jobId}/serp`, { method: 'POST' })\n                    .then(res => res.json())\n                    .then(data => {\n                      console.log('[Resume] Resume response:', data)\n                      isResuming = false\n                    })\n                    .catch(err => {\n                      console.error('[Resume] Resume error:', err)\n                      isResuming = false\n                    })\n                }\n              } else {\n                stallCount = 0\n              }\n            }\n            lastCompletedCount = completed\n\n            // Check if SERP phase is done (includes later states that imply SERP finished)\n            const serpDoneInPoll = ['serp_done', 'serp_completed', 'scrape_done', 'extracting', 'completed'].includes(statusData.status)\n            if (serpDoneInPoll) {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'completed',\n                completedAt: new Date(),\n                output: {\n                  jobId,\n                  urlsFound: statusData.job?.urls_found || 0,\n                  costs: statusData.costs,\n                },\n                progress: undefined, // Clear progress to stop spinner\n              })\n              setTimeout(goToNextStep, 500)\n            } else if (statusData.status === 'failed' || statusData.status === 'error') {\n              if (pollIntervalRef.current) {\n                clearInterval(pollIntervalRef.current)\n                pollIntervalRef.current = null\n              }\n              updateStepState(currentStep.id, {\n                status: 'error',\n                error: statusData.job?.error_message || 'Job failed',\n              })\n            }\n          } catch (pollError) {\n            console.error('[Resume] Poll error:', pollError)\n            // Don't stop polling on transient errors\n          }\n        }, 2000)\n        } // End startPolling function\n\n        // Cleanup on unmount\n        return () => {\n          if (pollIntervalRef.current) {\n            clearInterval(pollIntervalRef.current)\n            pollIntervalRef.current = null\n          }\n        }\n      }\n    }\n  }, [currentStep?.id, currentStep?.type, currentStepState?.status, currentStepState?.output, updateStepState, goToNextStep])\n\n  if (!currentPhase || !currentStep || !currentStepState) {\n    return (\n      <div className=\"flex items-center justify-center h-64 text-gray-500\">\n        Error: Configuración de playbook inválida\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"flex flex-col h-[calc(100vh-180px)] min-h-[600px] bg-gray-50 rounded-xl overflow-hidden border border-gray-200\">\n      {/* Header with mode selector */}\n      <div className=\"flex items-center justify-between px-4 py-3 bg-white border-b border-gray-200\">\n        <div className=\"flex items-center gap-3\">\n          <span className=\"text-xl\">{playbookConfig.icon}</span>\n          <h2 className=\"text-lg font-semibold text-gray-900\">{playbookConfig.name}</h2>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {/* Session Data button */}\n          {selectedCampaignId && mode === 'campaign' && (\n            <button\n              onClick={() => setShowArtifactBrowser(!showArtifactBrowser)}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                showArtifactBrowser\n                  ? 'bg-indigo-100 text-indigo-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n              title=\"Browse all session artifacts\"\n            >\n              <Database size={16} />\n              Session Data\n            </button>\n          )}\n\n          {/* Config Base button */}\n          <button\n            onClick={() => setMode('config')}\n            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n              mode === 'config'\n                ? 'bg-blue-100 text-blue-700'\n                : 'text-gray-600 hover:bg-gray-100'\n            }`}\n          >\n            <Settings size={16} />\n            Configuración Base\n          </button>\n\n          {/* Campaign selector */}\n          <div className=\"relative flex items-center gap-1\">\n            <button\n              onClick={() => {\n                setMode('campaign')\n                setShowCampaignDropdown(!showCampaignDropdown)\n              }}\n              className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${\n                mode === 'campaign'\n                  ? 'bg-blue-100 text-blue-700'\n                  : 'text-gray-600 hover:bg-gray-100'\n              }`}\n            >\n              <Folder size={16} />\n              {selectedCampaign ? selectedCampaign.name : 'Seleccionar Campaña'}\n              <ChevronDown size={16} />\n            </button>\n\n            {/* Edit campaign settings button */}\n            {selectedCampaignId && (\n              <button\n                onClick={() => setShowCampaignSettings(true)}\n                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg\"\n                title=\"Editar configuración de campaña\"\n              >\n                <Pencil size={14} />\n              </button>\n            )}\n\n            {/* Dropdown */}\n            {showCampaignDropdown && (\n              <div className=\"absolute right-0 top-full mt-1 w-64 bg-white rounded-lg shadow-lg border border-gray-200 py-1 z-50\">\n                {campaigns.length === 0 ? (\n                  <div className=\"px-3 py-2 text-sm text-gray-500\">No hay campañas</div>\n                ) : (\n                  campaigns.map(campaign => (\n                    <div\n                      key={campaign.id}\n                      className={`flex items-center justify-between px-3 py-2 text-sm hover:bg-gray-50 ${\n                        selectedCampaignId === campaign.id ? 'bg-blue-50' : ''\n                      }`}\n                    >\n                      <button\n                        onClick={() => {\n                          setSelectedCampaignId(campaign.id)\n                          setShowCampaignDropdown(false)\n                        }}\n                        className=\"flex-1 flex items-center justify-between text-left\"\n                      >\n                        <span className=\"font-medium text-gray-900\">{campaign.name}</span>\n                        <span className=\"text-gray-500 mr-2\">\n                          {campaign.completedSteps}/{campaign.totalSteps}\n                        </span>\n                      </button>\n                      <button\n                        onClick={(e) => {\n                          e.stopPropagation()\n                          deleteCampaign(campaign.id)\n                        }}\n                        className=\"p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded\"\n                        title=\"Eliminar campaña\"\n                      >\n                        <Trash2 size={14} />\n                      </button>\n                    </div>\n                  ))\n                )}\n                <div className=\"border-t border-gray-100 mt-1 pt-1\">\n                  <button\n                    onClick={() => {\n                      setShowWizard(true)\n                      setShowCampaignDropdown(false)\n                    }}\n                    className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-blue-600 hover:bg-blue-50\"\n                  >\n                    <Plus size={16} />\n                    Nueva Campaña\n                  </button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Main content */}\n      {mode === 'config' ? (\n        /* Configuration Mode - Full width */\n        <div className=\"flex-1 overflow-hidden\">\n          <ConfigurationMode\n            projectId={projectId}\n            playbookConfig={playbookConfig}\n            onSave={() => {\n              // Optionally refresh something after save\n            }}\n          />\n        </div>\n      ) : (\n        /* Campaign Mode - Dual panel */\n        <div className=\"flex flex-1 overflow-hidden\">\n          {/* Navigation Panel - Left side */}\n          <div className=\"w-80 flex-shrink-0\">\n            <NavigationPanel\n              phases={playbookConfig.phases}\n              phaseStates={state.phases}\n              currentPhaseIndex={state.currentPhaseIndex}\n              currentStepIndex={state.currentStepIndex}\n              onStepClick={goToStep}\n            />\n          </div>\n\n          {/* Work Area - Right side */}\n          <div className=\"flex-1 overflow-y-auto\">\n            {!selectedCampaignId ? (\n              /* No campaign selected - prompt to select or create */\n              <div className=\"flex flex-col items-center justify-center h-full bg-white p-8 text-center\">\n                <Folder className=\"text-gray-300 mb-4\" size={64} />\n                <h3 className=\"text-lg font-medium text-gray-900 mb-2\">\n                  Selecciona o crea una campaña\n                </h3>\n                <p className=\"text-gray-500 mb-6 max-w-md\">\n                  Para ejecutar el playbook, primero debes seleccionar una campaña existente o crear una nueva.\n                </p>\n                <button\n                  onClick={() => setShowWizard(true)}\n                  className=\"flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n                >\n                  <Plus size={16} />\n                  Nueva Campaña\n                </button>\n              </div>\n            ) : (\n              <>\n                <WorkArea\n                  step={currentStep}\n                  stepState={currentStepState}\n                  onContinue={handleContinue}\n                  onBack={goToPreviousStep}\n                  onExecute={(input) => executeStep(currentStep.id, input)}\n                  onUpdateState={(update) => updateStepState(currentStep.id, update)}\n                  onEdit={handleEdit}\n                  onCancel={handleCancel}\n                  onRerunPrevious={rerunPreviousStep}\n                  onRetry={handleQuickRetry}\n                  onRetryWithConfig={handleRetryWithConfig}\n                  onSkipStep={handleSkipStep}\n                  isFirst={isFirstStep}\n                  isLast={isLastStep}\n                  previousStepOutput={getPreviousStepOutput()}\n                  projectId={projectId}\n                  playbookContext={buildPlaybookContext()}\n                  allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                    phase.steps.map((stepDef, stepIdx) => ({\n                      definition: stepDef,\n                      state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                    }))\n                  )}\n                  saveState={sessionId ? stepPersistenceState : undefined}\n                  retryInfo={currentStepRetryInfo || undefined}\n                  maxRetriesReached={maxRetriesReached}\n                  sessionId={sessionId}\n                />\n\n                {/* Retry Dialog */}\n                {retryDialogOpen && retryDialogStepId && currentStepRetryInfo && (\n                  <StepRetryDialog\n                    isOpen={retryDialogOpen}\n                    stepName={currentStep.name}\n                    errorMessage={currentStepState.error || 'Unknown error'}\n                    retryInfo={currentStepRetryInfo}\n                    onRetry={handleRetryFromDialog}\n                    onClose={() => {\n                      setRetryDialogOpen(false)\n                      setRetryDialogStepId(null)\n                    }}\n                    isRetrying={stepRetryState.isRetrying}\n                  />\n                )}\n              </>\n            )}\n          </div>\n\n          {/* Artifact Browser Panel - Right side */}\n          {showArtifactBrowser && selectedCampaignId && (\n            <div className=\"w-96 flex-shrink-0 border-l border-gray-200\">\n              <ArtifactBrowser\n                sessionId={sessionId}\n                projectId={projectId}\n                clientId=\"\"\n                userId=\"system\"\n                campaignId={selectedCampaignId}\n                campaignName={selectedCampaign?.name || ''}\n                playbookId={playbookConfig.id}\n                playbookName={playbookConfig.name}\n                playbookType={playbookConfig.type}\n                allSteps={playbookConfig.phases.flatMap((phase, phaseIdx) =>\n                  phase.steps.map((stepDef, stepIdx) => ({\n                    definition: stepDef,\n                    state: state.phases[phaseIdx]?.steps[stepIdx] || { id: stepDef.id, status: 'pending' },\n                  }))\n                )}\n                isVisible={showArtifactBrowser}\n                onClose={() => setShowArtifactBrowser(false)}\n              />\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Campaign Wizard Modal */}\n      {showWizard && (\n        <CampaignWizard\n          projectId={projectId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowWizard(false)}\n          onCreated={(campaignId) => {\n            setSelectedCampaignId(campaignId)\n            setShowWizard(false)\n            // Reload campaigns\n            loadCampaigns()\n          }}\n        />\n      )}\n\n      {/* Campaign Settings Modal */}\n      {showCampaignSettings && selectedCampaignId && (\n        <CampaignSettings\n          campaignId={selectedCampaignId}\n          playbookConfig={playbookConfig}\n          onClose={() => setShowCampaignSettings(false)}\n          onSaved={() => {\n            loadCampaigns()\n          }}\n        />\n      )}\n    </div>\n  )\n}\n","structuredPatch":[{"oldStart":2860,"oldLines":8,"newStart":2860,"newLines":8,"lines":["               <ArtifactBrowser","                 sessionId={sessionId}","                 projectId={projectId}","-                clientId=\"\"","-                userId=\"system\"","+                clientId={projectData?.clientId || ''}","+                userId={projectData?.userId || 'system'}","                 campaignId={selectedCampaignId}","                 campaignName={selectedCampaign?.name || ''}","                 playbookId={playbookConfig.id}"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RutZgLDJhXXrx1oyW1J6aX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014a8nRjmqPvLwMmRS2UmWs7","name":"TodoWrite","input":{"todos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"completed","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"completed","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"completed","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"completed","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"completed","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"completed","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"completed","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Integrate ArtifactBrowser into PlaybookShell","status":"completed","activeForm":"Integrating ArtifactBrowser into PlaybookShell"},{"content":"Run quality checks","status":"in_progress","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":810,"cache_read_input_tokens":134362,"cache_creation":{"ephemeral_5m_input_tokens":810,"ephemeral_1h_input_tokens":0},"output_tokens":398,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"1cc03524-1079-4d90-832d-3e11f8505e5c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014a8nRjmqPvLwMmRS2UmWs7","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"e70837e7-d385-44e6-9751-102b3fb08acf","tool_use_result":{"oldTodos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"completed","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"completed","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"completed","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"completed","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"completed","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"completed","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"completed","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Integrate ArtifactBrowser into PlaybookShell","status":"in_progress","activeForm":"Integrating ArtifactBrowser into PlaybookShell"},{"content":"Run quality checks","status":"pending","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"completed","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"completed","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"completed","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"completed","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"completed","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"completed","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"completed","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Integrate ArtifactBrowser into PlaybookShell","status":"completed","activeForm":"Integrating ArtifactBrowser into PlaybookShell"},{"content":"Run quality checks","status":"in_progress","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015HntSaux7tNVagqc7pQrT8","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's run the quality checks - TypeScript compilation and lint:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":440,"cache_read_input_tokens":135172,"cache_creation":{"ephemeral_5m_input_tokens":440,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"4c4bfc12-6b3e-4357-a010-3654de448a5e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015HntSaux7tNVagqc7pQrT8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013yXjExFUCyHQqoDyy1Wfok","name":"Bash","input":{"command":"npx tsc --noEmit 2>&1 | head -100","description":"Run TypeScript type checking","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":440,"cache_read_input_tokens":135172,"cache_creation":{"ephemeral_5m_input_tokens":440,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"44943db6-6a83-4d21-8c71-77979ad92000"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013yXjExFUCyHQqoDyy1Wfok","type":"tool_result","content":"src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(32,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(33,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(34,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(35,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(36,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(37,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(38,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(39,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(40,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.","is_error":false}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"9ef3d8c4-1d26-41f9-ae43-294d988d38eb","tool_use_result":{"stdout":"src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(32,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(33,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(34,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(35,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(36,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(37,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(38,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(39,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.\nsrc/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx(40,3): error TS2322: Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'ComponentType<{ size?: number | undefined; className?: string | undefined; }>'.\n  Type 'ForwardRefExoticComponent<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'FunctionComponent<{ size?: number | undefined; className?: string | undefined; }>'.\n    Types of property 'propTypes' are incompatible.\n      Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>> | undefined' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }> | undefined'.\n        Type 'WeakValidationMap<Omit<LucideProps, \"ref\"> & RefAttributes<SVGSVGElement>>' is not assignable to type 'WeakValidationMap<{ size?: number | undefined; className?: string | undefined; }>'.\n          Types of property 'size' are incompatible.\n            Type 'Validator<string | number | null | undefined> | undefined' is not assignable to type 'Validator<number | null | undefined> | undefined'.\n              Type 'Validator<string | number | null | undefined>' is not assignable to type 'Validator<number | null | undefined>'.\n                Type 'string | number | null | undefined' is not assignable to type 'number | null | undefined'.\n                  Type 'string' is not assignable to type 'number'.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NeWBmqiAgsR7PTdo8hZ3oi","type":"message","role":"assistant","content":[{"type":"text","text":"There's a type issue with the icon map. Let me fix this:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4111,"cache_read_input_tokens":135612,"cache_creation":{"ephemeral_5m_input_tokens":4111,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"707bebe2-b33a-41dc-ab56-bbcbc913e27d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NeWBmqiAgsR7PTdo8hZ3oi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Sio5tqesp34Sjh8DZjZ91o","name":"Read","input":{"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx","limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4111,"cache_read_input_tokens":135612,"cache_creation":{"ephemeral_5m_input_tokens":4111,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"d0adbf02-be36-4dce-8936-1b71a415c545"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Sio5tqesp34Sjh8DZjZ91o","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useCallback, useMemo } from 'react'\n     4→import {\n     5→  Search,\n     6→  ChevronDown,\n     7→  ChevronRight,\n     8→  Database,\n     9→  FileText,\n    10→  Download,\n    11→  Save,\n    12→  Filter,\n    13→  X,\n    14→  ExternalLink,\n    15→  Loader2,\n    16→  Package,\n    17→  RefreshCw,\n    18→  BarChart3,\n    19→  Sparkles,\n    20→  Lightbulb,\n    21→  GitBranch,\n    22→  Wand2,\n    23→} from 'lucide-react'\n    24→import { Artifact, ArtifactGroup, ArtifactType, ARTIFACT_TYPE_LABELS } from './types'\n    25→import { useArtifacts } from './useArtifacts'\n    26→import ArtifactViewerModal from './ArtifactViewerModal'\n    27→import SaveToContextLakeModal, { StepOutputContext } from '@/components/documents/SaveToContextLakeModal'\n    28→import { useToast } from '@/components/ui/Toast/ToastContext'\n    29→\n    30→// Icon mapping for artifact types\n    31→const ICON_MAP: Record<string, React.ComponentType<{ size?: number; className?: string }>> = {\n    32→  Search: Search,\n    33→  FileText: FileText,\n    34→  Database: Database,\n    35→  Sparkles: Sparkles,\n    36→  Wand2: Wand2,\n    37→  BarChart3: BarChart3,\n    38→  Lightbulb: Lightbulb,\n    39→  GitBranch: GitBranch,\n    40→  Package: Package,\n    41→}\n    42→\n    43→interface ArtifactBrowserProps {\n    44→  sessionId?: string\n    45→  projectId: string\n    46→  clientId: string\n    47→  userId: string\n    48→  campaignId?: string\n    49→  campaignName?: string\n    50→  playbookId: string\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"7a197788-a04f-45f1-b535-c55aba177b02","tool_use_result":{"type":"text","file":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx","content":"'use client'\n\nimport { useState, useCallback, useMemo } from 'react'\nimport {\n  Search,\n  ChevronDown,\n  ChevronRight,\n  Database,\n  FileText,\n  Download,\n  Save,\n  Filter,\n  X,\n  ExternalLink,\n  Loader2,\n  Package,\n  RefreshCw,\n  BarChart3,\n  Sparkles,\n  Lightbulb,\n  GitBranch,\n  Wand2,\n} from 'lucide-react'\nimport { Artifact, ArtifactGroup, ArtifactType, ARTIFACT_TYPE_LABELS } from './types'\nimport { useArtifacts } from './useArtifacts'\nimport ArtifactViewerModal from './ArtifactViewerModal'\nimport SaveToContextLakeModal, { StepOutputContext } from '@/components/documents/SaveToContextLakeModal'\nimport { useToast } from '@/components/ui/Toast/ToastContext'\n\n// Icon mapping for artifact types\nconst ICON_MAP: Record<string, React.ComponentType<{ size?: number; className?: string }>> = {\n  Search: Search,\n  FileText: FileText,\n  Database: Database,\n  Sparkles: Sparkles,\n  Wand2: Wand2,\n  BarChart3: BarChart3,\n  Lightbulb: Lightbulb,\n  GitBranch: GitBranch,\n  Package: Package,\n}\n\ninterface ArtifactBrowserProps {\n  sessionId?: string\n  projectId: string\n  clientId: string\n  userId: string\n  campaignId?: string\n  campaignName?: string\n  playbookId: string","numLines":50,"startLine":1,"totalLines":619}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017wDnGqU7xqfmJo9k1oesJi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RB2AAKm82pB9LDVuU7MD6X","name":"Edit","input":{"replace_all":false,"file_path":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx","old_string":"import { useToast } from '@/components/ui/Toast/ToastContext'\n\n// Icon mapping for artifact types\nconst ICON_MAP: Record<string, React.ComponentType<{ size?: number; className?: string }>> = {\n  Search: Search,\n  FileText: FileText,\n  Database: Database,\n  Sparkles: Sparkles,\n  Wand2: Wand2,\n  BarChart3: BarChart3,\n  Lightbulb: Lightbulb,\n  GitBranch: GitBranch,\n  Package: Package,\n}","new_string":"import { useToast } from '@/components/ui/Toast/ToastContext'\nimport type { LucideIcon } from 'lucide-react'\n\n// Icon mapping for artifact types\nconst ICON_MAP: Record<string, LucideIcon> = {\n  Search: Search,\n  FileText: FileText,\n  Database: Database,\n  Sparkles: Sparkles,\n  Wand2: Wand2,\n  BarChart3: BarChart3,\n  Lightbulb: Lightbulb,\n  GitBranch: GitBranch,\n  Package: Package,\n}"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":802,"cache_read_input_tokens":139723,"cache_creation":{"ephemeral_5m_input_tokens":802,"ephemeral_1h_input_tokens":0},"output_tokens":440,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"64558a60-8c20-4a62-b947-74936383b678"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RB2AAKm82pB9LDVuU7MD6X","type":"tool_result","content":"The file /Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"7b759ada-af2b-4362-acee-2b7d8da6b197","tool_use_result":{"filePath":"/Users/martin/Gattaca-Secuenciador-de-Prompts/src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx","oldString":"import { useToast } from '@/components/ui/Toast/ToastContext'\n\n// Icon mapping for artifact types\nconst ICON_MAP: Record<string, React.ComponentType<{ size?: number; className?: string }>> = {\n  Search: Search,\n  FileText: FileText,\n  Database: Database,\n  Sparkles: Sparkles,\n  Wand2: Wand2,\n  BarChart3: BarChart3,\n  Lightbulb: Lightbulb,\n  GitBranch: GitBranch,\n  Package: Package,\n}","newString":"import { useToast } from '@/components/ui/Toast/ToastContext'\nimport type { LucideIcon } from 'lucide-react'\n\n// Icon mapping for artifact types\nconst ICON_MAP: Record<string, LucideIcon> = {\n  Search: Search,\n  FileText: FileText,\n  Database: Database,\n  Sparkles: Sparkles,\n  Wand2: Wand2,\n  BarChart3: BarChart3,\n  Lightbulb: Lightbulb,\n  GitBranch: GitBranch,\n  Package: Package,\n}","originalFile":"'use client'\n\nimport { useState, useCallback, useMemo } from 'react'\nimport {\n  Search,\n  ChevronDown,\n  ChevronRight,\n  Database,\n  FileText,\n  Download,\n  Save,\n  Filter,\n  X,\n  ExternalLink,\n  Loader2,\n  Package,\n  RefreshCw,\n  BarChart3,\n  Sparkles,\n  Lightbulb,\n  GitBranch,\n  Wand2,\n} from 'lucide-react'\nimport { Artifact, ArtifactGroup, ArtifactType, ARTIFACT_TYPE_LABELS } from './types'\nimport { useArtifacts } from './useArtifacts'\nimport ArtifactViewerModal from './ArtifactViewerModal'\nimport SaveToContextLakeModal, { StepOutputContext } from '@/components/documents/SaveToContextLakeModal'\nimport { useToast } from '@/components/ui/Toast/ToastContext'\n\n// Icon mapping for artifact types\nconst ICON_MAP: Record<string, React.ComponentType<{ size?: number; className?: string }>> = {\n  Search: Search,\n  FileText: FileText,\n  Database: Database,\n  Sparkles: Sparkles,\n  Wand2: Wand2,\n  BarChart3: BarChart3,\n  Lightbulb: Lightbulb,\n  GitBranch: GitBranch,\n  Package: Package,\n}\n\ninterface ArtifactBrowserProps {\n  sessionId?: string\n  projectId: string\n  clientId: string\n  userId: string\n  campaignId?: string\n  campaignName?: string\n  playbookId: string\n  playbookName: string\n  playbookType: string\n  allSteps?: Array<{\n    definition: { id: string; name: string }\n    state: { id: string; status: string; output?: unknown; input?: unknown }\n  }>\n  isVisible?: boolean\n  onClose?: () => void\n}\n\nexport default function ArtifactBrowser({\n  sessionId,\n  projectId,\n  clientId,\n  userId,\n  campaignId,\n  campaignName,\n  playbookId,\n  playbookName,\n  playbookType,\n  allSteps = [],\n  isVisible = true,\n  onClose,\n}: ArtifactBrowserProps) {\n  const toast = useToast()\n\n  const {\n    artifacts,\n    loading,\n    error,\n    filter,\n    setFilter,\n    filteredGroups,\n    refreshArtifacts,\n    getArtifactById,\n  } = useArtifacts({\n    sessionId,\n    projectId,\n    campaignId,\n    playbookType,\n    allSteps,\n  })\n\n  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set())\n  const [expandedArtifacts, setExpandedArtifacts] = useState<Set<string>>(new Set())\n  const [viewerOpen, setViewerOpen] = useState(false)\n  const [selectedArtifact, setSelectedArtifact] = useState<Artifact | null>(null)\n  const [saveModalOpen, setSaveModalOpen] = useState(false)\n  const [saveArtifact, setSaveArtifact] = useState<Artifact | null>(null)\n  const [showFilters, setShowFilters] = useState(false)\n\n  // Toggle group expansion\n  const toggleGroup = useCallback((groupType: string) => {\n    setExpandedGroups(prev => {\n      const next = new Set(prev)\n      if (next.has(groupType)) {\n        next.delete(groupType)\n      } else {\n        next.add(groupType)\n      }\n      return next\n    })\n  }, [])\n\n  // Toggle artifact expansion\n  const toggleArtifact = useCallback((artifactId: string) => {\n    setExpandedArtifacts(prev => {\n      const next = new Set(prev)\n      if (next.has(artifactId)) {\n        next.delete(artifactId)\n      } else {\n        next.add(artifactId)\n      }\n      return next\n    })\n  }, [])\n\n  // Open viewer modal\n  const handleViewArtifact = useCallback((artifact: Artifact) => {\n    setSelectedArtifact(artifact)\n    setViewerOpen(true)\n  }, [])\n\n  // Open save modal\n  const handleSaveToContextLake = useCallback((artifact: Artifact) => {\n    setSaveArtifact(artifact)\n    setSaveModalOpen(true)\n    setViewerOpen(false)\n  }, [])\n\n  // Handle save completion\n  const handleSaveComplete = useCallback((docId: string) => {\n    toast.success('Artifact saved to Context Lake')\n    setSaveModalOpen(false)\n    setSaveArtifact(null)\n\n    // Mark artifact as saved (in future, could update state)\n  }, [toast])\n\n  // Export artifact\n  const handleExport = useCallback((artifact: Artifact, format: 'csv' | 'json') => {\n    const content = artifact.content\n\n    let data: string\n    let filename: string\n    let mimeType: string\n\n    if (format === 'json') {\n      data = JSON.stringify(content, null, 2)\n      filename = `${artifact.name.replace(/\\s+/g, '_')}.json`\n      mimeType = 'application/json'\n    } else {\n      // CSV export\n      if (Array.isArray(content) && content.length > 0 && typeof content[0] === 'object') {\n        const headers = Object.keys(content[0] as Record<string, unknown>)\n        const rows = [\n          headers.join(','),\n          ...content.map(row => {\n            const r = row as Record<string, unknown>\n            return headers.map(h => {\n              const val = r[h]\n              if (val === null || val === undefined) return ''\n              if (typeof val === 'string') return `\"${val.replace(/\"/g, '\"\"')}\"`\n              return String(val)\n            }).join(',')\n          })\n        ]\n        data = rows.join('\\n')\n      } else {\n        data = typeof content === 'string' ? content : JSON.stringify(content)\n      }\n      filename = `${artifact.name.replace(/\\s+/g, '_')}.csv`\n      mimeType = 'text/csv'\n    }\n\n    const blob = new Blob([data], { type: mimeType })\n    const url = URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = filename\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    URL.revokeObjectURL(url)\n\n    toast.success(`Exported as ${format.toUpperCase()}`)\n  }, [toast])\n\n  // Get available step names for filter\n  const availableSteps = useMemo(() => {\n    const steps = new Map<string, string>()\n    filteredGroups.forEach(group => {\n      group.artifacts.forEach(artifact => {\n        steps.set(artifact.stepId, artifact.stepName)\n      })\n    })\n    return Array.from(steps.entries()).map(([id, name]) => ({ id, name }))\n  }, [filteredGroups])\n\n  // Get total count\n  const totalArtifacts = useMemo(() => {\n    return filteredGroups.reduce((sum, group) => sum + group.count, 0)\n  }, [filteredGroups])\n\n  if (!isVisible) return null\n\n  return (\n    <div className=\"flex flex-col h-full bg-white border-l border-gray-200\">\n      {/* Header */}\n      <div className=\"px-4 py-3 border-b border-gray-200 bg-gradient-to-r from-indigo-50 to-purple-50\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"p-2 bg-white rounded-lg shadow-sm\">\n              <Database size={18} className=\"text-indigo-600\" />\n            </div>\n            <div>\n              <h3 className=\"font-semibold text-gray-900\">Session Data</h3>\n              <p className=\"text-xs text-gray-500 mt-0.5\">\n                {totalArtifacts} artifacts from {artifacts?.totalSteps || 0} steps\n              </p>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <button\n              onClick={refreshArtifacts}\n              disabled={loading}\n              className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-white/50 rounded transition-colors\"\n              title=\"Refresh\"\n            >\n              <RefreshCw size={14} className={loading ? 'animate-spin' : ''} />\n            </button>\n            {onClose && (\n              <button\n                onClick={onClose}\n                className=\"p-1.5 text-gray-400 hover:text-gray-600 hover:bg-white/50 rounded transition-colors\"\n              >\n                <X size={16} />\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Search and Filters */}\n      <div className=\"p-3 border-b border-gray-100 space-y-3\">\n        {/* Search */}\n        <div className=\"relative\">\n          <Search size={16} className=\"absolute left-3 top-1/2 -translate-y-1/2 text-gray-400\" />\n          <input\n            type=\"text\"\n            value={filter.searchQuery}\n            onChange={(e) => setFilter({ searchQuery: e.target.value })}\n            placeholder=\"Search artifacts...\"\n            className=\"w-full pl-9 pr-4 py-2 text-sm border border-gray-200 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500\"\n          />\n          {filter.searchQuery && (\n            <button\n              onClick={() => setFilter({ searchQuery: '' })}\n              className=\"absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600\"\n            >\n              <X size={14} />\n            </button>\n          )}\n        </div>\n\n        {/* Filter toggle */}\n        <button\n          onClick={() => setShowFilters(!showFilters)}\n          className={`flex items-center gap-2 text-sm ${\n            showFilters || filter.types.length > 0 || filter.stepIds.length > 0\n              ? 'text-indigo-600'\n              : 'text-gray-500'\n          } hover:text-indigo-700`}\n        >\n          <Filter size={14} />\n          Filters\n          {(filter.types.length > 0 || filter.stepIds.length > 0) && (\n            <span className=\"px-1.5 py-0.5 text-xs bg-indigo-100 text-indigo-700 rounded\">\n              {filter.types.length + filter.stepIds.length}\n            </span>\n          )}\n          {showFilters ? <ChevronDown size={14} /> : <ChevronRight size={14} />}\n        </button>\n\n        {/* Expanded filters */}\n        {showFilters && (\n          <div className=\"space-y-3 pt-2\">\n            {/* Type filter */}\n            <div>\n              <p className=\"text-xs font-medium text-gray-500 mb-2\">Artifact Type</p>\n              <div className=\"flex flex-wrap gap-1\">\n                {Object.entries(ARTIFACT_TYPE_LABELS).map(([type, info]) => (\n                  <button\n                    key={type}\n                    onClick={() => {\n                      const types = filter.types.includes(type as ArtifactType)\n                        ? filter.types.filter(t => t !== type)\n                        : [...filter.types, type as ArtifactType]\n                      setFilter({ types })\n                    }}\n                    className={`px-2 py-1 text-xs rounded transition-colors ${\n                      filter.types.includes(type as ArtifactType)\n                        ? 'bg-indigo-100 text-indigo-700'\n                        : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n                    }`}\n                  >\n                    {info.label}\n                  </button>\n                ))}\n              </div>\n            </div>\n\n            {/* Step filter */}\n            {availableSteps.length > 1 && (\n              <div>\n                <p className=\"text-xs font-medium text-gray-500 mb-2\">Step</p>\n                <div className=\"flex flex-wrap gap-1\">\n                  {availableSteps.map(step => (\n                    <button\n                      key={step.id}\n                      onClick={() => {\n                        const stepIds = filter.stepIds.includes(step.id)\n                          ? filter.stepIds.filter(id => id !== step.id)\n                          : [...filter.stepIds, step.id]\n                        setFilter({ stepIds })\n                      }}\n                      className={`px-2 py-1 text-xs rounded transition-colors ${\n                        filter.stepIds.includes(step.id)\n                          ? 'bg-indigo-100 text-indigo-700'\n                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n                      }`}\n                    >\n                      {step.name}\n                    </button>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {/* Clear filters */}\n            {(filter.types.length > 0 || filter.stepIds.length > 0) && (\n              <button\n                onClick={() => setFilter({ types: [], stepIds: [] })}\n                className=\"text-xs text-red-600 hover:text-red-700\"\n              >\n                Clear filters\n              </button>\n            )}\n          </div>\n        )}\n      </div>\n\n      {/* Content */}\n      <div className=\"flex-1 overflow-y-auto\">\n        {loading ? (\n          <div className=\"flex items-center justify-center py-12\">\n            <Loader2 className=\"w-6 h-6 text-indigo-500 animate-spin\" />\n          </div>\n        ) : error ? (\n          <div className=\"p-4 text-red-600 text-sm\">\n            <p>{error}</p>\n            <button\n              onClick={refreshArtifacts}\n              className=\"mt-2 text-indigo-600 hover:underline\"\n            >\n              Retry\n            </button>\n          </div>\n        ) : filteredGroups.length === 0 ? (\n          <div className=\"flex flex-col items-center justify-center py-12 text-gray-500\">\n            <Package size={40} className=\"text-gray-300 mb-3\" />\n            <p className=\"text-sm font-medium\">No artifacts found</p>\n            <p className=\"text-xs mt-1\">\n              {filter.searchQuery || filter.types.length > 0 || filter.stepIds.length > 0\n                ? 'Try adjusting your filters'\n                : 'Execute steps to generate data'}\n            </p>\n          </div>\n        ) : (\n          <div className=\"divide-y divide-gray-100\">\n            {filteredGroups.map(group => (\n              <ArtifactGroupComponent\n                key={group.type}\n                group={group}\n                isExpanded={expandedGroups.has(group.type)}\n                expandedArtifacts={expandedArtifacts}\n                onToggle={() => toggleGroup(group.type)}\n                onToggleArtifact={toggleArtifact}\n                onView={handleViewArtifact}\n                onSave={handleSaveToContextLake}\n                onExport={handleExport}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Artifact Viewer Modal */}\n      <ArtifactViewerModal\n        isOpen={viewerOpen}\n        artifact={selectedArtifact}\n        onClose={() => setViewerOpen(false)}\n        onSaveToContextLake={handleSaveToContextLake}\n        onExport={handleExport}\n      />\n\n      {/* Save to Context Lake Modal */}\n      {saveArtifact && (\n        <SaveToContextLakeModal\n          isOpen={saveModalOpen}\n          content={typeof saveArtifact.content === 'string'\n            ? saveArtifact.content\n            : JSON.stringify(saveArtifact.content, null, 2)}\n          projectId={projectId}\n          clientId={clientId}\n          userId={userId}\n          stepContext={{\n            stepId: saveArtifact.stepId,\n            stepName: saveArtifact.stepName,\n            stepOrder: saveArtifact.stepOrder,\n            campaignId: campaignId || '',\n            campaignName: campaignName || '',\n            playbookId,\n            playbookName,\n            wasEditedBeforeConversion: false,\n          }}\n          onSave={handleSaveComplete}\n          onClose={() => {\n            setSaveModalOpen(false)\n            setSaveArtifact(null)\n          }}\n        />\n      )}\n    </div>\n  )\n}\n\n// Artifact Group Component\ninterface ArtifactGroupComponentProps {\n  group: ArtifactGroup\n  isExpanded: boolean\n  expandedArtifacts: Set<string>\n  onToggle: () => void\n  onToggleArtifact: (id: string) => void\n  onView: (artifact: Artifact) => void\n  onSave: (artifact: Artifact) => void\n  onExport: (artifact: Artifact, format: 'csv' | 'json') => void\n}\n\nfunction ArtifactGroupComponent({\n  group,\n  isExpanded,\n  expandedArtifacts,\n  onToggle,\n  onToggleArtifact,\n  onView,\n  onSave,\n  onExport,\n}: ArtifactGroupComponentProps) {\n  const typeInfo = ARTIFACT_TYPE_LABELS[group.type]\n  const IconComponent = ICON_MAP[typeInfo.icon] || Package\n\n  return (\n    <div>\n      {/* Group Header */}\n      <button\n        onClick={onToggle}\n        className=\"w-full flex items-center gap-3 px-4 py-3 hover:bg-gray-50 transition-colors\"\n      >\n        {isExpanded ? (\n          <ChevronDown size={16} className=\"text-gray-400\" />\n        ) : (\n          <ChevronRight size={16} className=\"text-gray-400\" />\n        )}\n        <span className={`p-1.5 rounded ${typeInfo.color}`}>\n          <IconComponent size={14} />\n        </span>\n        <span className=\"font-medium text-gray-900 flex-1 text-left\">\n          {group.label}\n        </span>\n        <span className=\"text-sm text-gray-500\">{group.count}</span>\n      </button>\n\n      {/* Expanded Artifacts */}\n      {isExpanded && (\n        <div className=\"bg-gray-50 border-y border-gray-100\">\n          {group.artifacts.map(artifact => (\n            <ArtifactItem\n              key={artifact.id}\n              artifact={artifact}\n              isExpanded={expandedArtifacts.has(artifact.id)}\n              onToggle={() => onToggleArtifact(artifact.id)}\n              onView={() => onView(artifact)}\n              onSave={() => onSave(artifact)}\n              onExport={(format) => onExport(artifact, format)}\n            />\n          ))}\n        </div>\n      )}\n    </div>\n  )\n}\n\n// Individual Artifact Item\ninterface ArtifactItemProps {\n  artifact: Artifact\n  isExpanded: boolean\n  onToggle: () => void\n  onView: () => void\n  onSave: () => void\n  onExport: (format: 'csv' | 'json') => void\n}\n\nfunction ArtifactItem({\n  artifact,\n  isExpanded,\n  onToggle,\n  onView,\n  onSave,\n  onExport,\n}: ArtifactItemProps) {\n  const preview = useMemo(() => {\n    if (typeof artifact.content === 'string') {\n      return artifact.content.slice(0, 150) + (artifact.content.length > 150 ? '...' : '')\n    }\n    if (Array.isArray(artifact.content)) {\n      return `${artifact.content.length} items`\n    }\n    return 'Object data'\n  }, [artifact.content])\n\n  const canExportCsv = Array.isArray(artifact.content) && artifact.content.length > 0\n\n  return (\n    <div className=\"border-b border-gray-100 last:border-0\">\n      {/* Item Header */}\n      <div className=\"flex items-center gap-2 px-4 py-2.5 hover:bg-white/50\">\n        <button\n          onClick={onToggle}\n          className=\"p-1 text-gray-400 hover:text-gray-600\"\n        >\n          {isExpanded ? (\n            <ChevronDown size={14} />\n          ) : (\n            <ChevronRight size={14} />\n          )}\n        </button>\n        <div className=\"flex-1 min-w-0\">\n          <p className=\"text-sm font-medium text-gray-800 truncate\">\n            {artifact.name}\n          </p>\n          <p className=\"text-xs text-gray-500 truncate\">\n            {artifact.stepName}\n            {artifact.itemCount && ` · ${artifact.itemCount} items`}\n            {artifact.wordCount && ` · ${artifact.wordCount} words`}\n          </p>\n        </div>\n        <div className=\"flex items-center gap-1\">\n          <button\n            onClick={onView}\n            className=\"p-1.5 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 rounded transition-colors\"\n            title=\"View\"\n          >\n            <ExternalLink size={14} />\n          </button>\n          <button\n            onClick={onSave}\n            className=\"p-1.5 text-gray-400 hover:text-purple-600 hover:bg-purple-50 rounded transition-colors\"\n            title=\"Save to Context Lake\"\n          >\n            <Save size={14} />\n          </button>\n          <button\n            onClick={() => onExport(canExportCsv ? 'csv' : 'json')}\n            className=\"p-1.5 text-gray-400 hover:text-green-600 hover:bg-green-50 rounded transition-colors\"\n            title={`Export as ${canExportCsv ? 'CSV' : 'JSON'}`}\n          >\n            <Download size={14} />\n          </button>\n        </div>\n      </div>\n\n      {/* Expanded Preview */}\n      {isExpanded && (\n        <div className=\"px-4 py-3 bg-white border-t border-gray-100\">\n          <div className=\"text-xs text-gray-600 font-mono bg-gray-50 p-3 rounded max-h-32 overflow-auto\">\n            {typeof artifact.content === 'string' ? (\n              artifact.content.slice(0, 500)\n            ) : (\n              <pre>{JSON.stringify(artifact.content, null, 2).slice(0, 500)}</pre>\n            )}\n            {(typeof artifact.content === 'string' ? artifact.content.length : JSON.stringify(artifact.content).length) > 500 && (\n              <span className=\"text-gray-400\">... [more]</span>\n            )}\n          </div>\n          <div className=\"flex justify-end mt-2\">\n            <button\n              onClick={onView}\n              className=\"text-xs text-indigo-600 hover:text-indigo-700 hover:underline\"\n            >\n              View full content\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n","structuredPatch":[{"oldStart":26,"oldLines":9,"newStart":26,"newLines":10,"lines":[" import ArtifactViewerModal from './ArtifactViewerModal'"," import SaveToContextLakeModal, { StepOutputContext } from '@/components/documents/SaveToContextLakeModal'"," import { useToast } from '@/components/ui/Toast/ToastContext'","+import type { LucideIcon } from 'lucide-react'"," "," // Icon mapping for artifact types","-const ICON_MAP: Record<string, React.ComponentType<{ size?: number; className?: string }>> = {","+const ICON_MAP: Record<string, LucideIcon> = {","   Search: Search,","   FileText: FileText,","   Database: Database,"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GH5ve6YVpbEhtvkTCXNXBr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VSyBpjxoTXNguscpGR3qEJ","name":"Bash","input":{"command":"npx tsc --noEmit 2>&1 | head -50","description":"Run TypeScript type checking again","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":502,"cache_read_input_tokens":140525,"cache_creation":{"ephemeral_5m_input_tokens":502,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"d0aa2b87-de44-46d1-9b0e-afd30840ec0f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VSyBpjxoTXNguscpGR3qEJ","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"0c4ac21f-7ebd-40e1-8056-eb78065134d6","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MuHbQs68Qho1QFTsGyDyEY","type":"message","role":"assistant","content":[{"type":"text","text":"TypeScript passes. Now let's run ESLint:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":134,"cache_read_input_tokens":141027,"cache_creation":{"ephemeral_5m_input_tokens":134,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"2a2b9713-dfab-4808-8a4f-1b336bbac10a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MuHbQs68Qho1QFTsGyDyEY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016Y9ptUKDxYMuJyRjzkQztv","name":"Bash","input":{"command":"npx eslint src/components/playbook/ArtifactBrowser --max-warnings=0 2>&1 | head -50","description":"Run ESLint on new files","timeout":60000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":134,"cache_read_input_tokens":141027,"cache_creation":{"ephemeral_5m_input_tokens":134,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"9dc7936e-3035-4f51-8088-326efceb87f6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016Y9ptUKDxYMuJyRjzkQztv","type":"tool_result","content":"Oops! Something went wrong! :(\n\nESLint: 9.39.2\n\nESLint couldn't find an eslint.config.(js|mjs|cjs) file.\n\nFrom ESLint v9.0.0, the default configuration file is now eslint.config.js.\nIf you are using a .eslintrc.* file, please follow the migration guide\nto update your configuration file to the new format:\n\nhttps://eslint.org/docs/latest/use/configure/migration-guide\n\nIf you still have problems after following the migration guide, please stop by\nhttps://eslint.org/chat/help to chat with the team.","is_error":false}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"c6178201-b44c-4321-897b-f2611b7be57c","tool_use_result":{"stdout":"Oops! Something went wrong! :(\n\nESLint: 9.39.2\n\nESLint couldn't find an eslint.config.(js|mjs|cjs) file.\n\nFrom ESLint v9.0.0, the default configuration file is now eslint.config.js.\nIf you are using a .eslintrc.* file, please follow the migration guide\nto update your configuration file to the new format:\n\nhttps://eslint.org/docs/latest/use/configure/migration-guide\n\nIf you still have problems after following the migration guide, please stop by\nhttps://eslint.org/chat/help to chat with the team.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MnrbgxdQX3Reb8cwCocCtz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011Ts5y1VKExnhXYs5X3BRra","name":"Bash","input":{"command":"npx next lint --dir src/components/playbook/ArtifactBrowser 2>&1 | head -50","description":"Run Next.js lint on new files","timeout":60000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":298,"cache_read_input_tokens":141161,"cache_creation":{"ephemeral_5m_input_tokens":298,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"94c37615-a956-42c1-958c-c830fe028265"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011Ts5y1VKExnhXYs5X3BRra","type":"tool_result","content":"? How would you like to configure ESLint? https://nextjs.org/docs/basic-features/eslint\n\u001b[?25l❯  Strict (recommended)\n   Base\n   Cancel ⚠ If you set up ESLint yourself, we recommend adding the Next.js ESLint plugin. See https://nextjs.org/docs/basic-features/eslint#migrating-existing-config","is_error":false}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"369df4f5-ac5c-4070-8a49-a9b139a89ff4","tool_use_result":{"stdout":"? How would you like to configure ESLint? https://nextjs.org/docs/basic-features/eslint\n\u001b[?25l❯  Strict (recommended)\n   Base\n   Cancel ⚠ If you set up ESLint yourself, we recommend adding the Next.js ESLint plugin. See https://nextjs.org/docs/basic-features/eslint#migrating-existing-config","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01U8yL83r1Sr9h18pWXdbSJb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GNB89rB1j2K5FKc4zspFs8","name":"Bash","input":{"command":"npm run build 2>&1 | tail -50","description":"Run Next.js build to verify","timeout":180000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":227,"cache_read_input_tokens":141459,"cache_creation":{"ephemeral_5m_input_tokens":227,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"7817d286-afdb-4eb9-8173-c1fff1f724ec"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GNB89rB1j2K5FKc4zspFs8","type":"tool_result","content":"├ ƒ /api/playbook/video-viral/publish                 0 B                0 B\n├ ƒ /api/projects/[projectId]                         0 B                0 B\n├ ƒ /api/projects/[projectId]/export-csv              0 B                0 B\n├ ƒ /api/projects/[projectId]/export-data             0 B                0 B\n├ ƒ /api/projects/[projectId]/invitations             0 B                0 B\n├ ƒ /api/projects/[projectId]/members                 0 B                0 B\n├ ƒ /api/projects/[projectId]/share-links             0 B                0 B\n├ ƒ /api/projects/[projectId]/sync-export             0 B                0 B\n├ ƒ /api/projects/[projectId]/transfer-ownership      0 B                0 B\n├ ƒ /api/reports/analyze                              0 B                0 B\n├ ƒ /api/reports/export                               0 B                0 B\n├ ƒ /api/scraper/poll                                 0 B                0 B\n├ ƒ /api/scraper/preview                              0 B                0 B\n├ ƒ /api/scraper/start                                0 B                0 B\n├ ƒ /api/scraper/status                               0 B                0 B\n├ ƒ /api/scraper/webhook                              0 B                0 B\n├ ƒ /api/share-links/join                             0 B                0 B\n├ ƒ /api/test-upload                                  0 B                0 B\n├ ƒ /api/user/api-keys                                0 B                0 B\n├ ƒ /api/user/api-keys/check                          0 B                0 B\n├ ƒ /api/v2/clients                                   0 B                0 B\n├ ○ /api/v2/playbooks                                 0 B                0 B\n├ ƒ /api/webhooks/polar                               0 B                0 B\n├ ƒ /api/webhooks/polar/test                          0 B                0 B\n├ ○ /apple-icon                                       0 B                0 B\n├ ƒ /auth/callback                                    0 B                0 B\n├ ○ /auth/login                                       27.7 kB         174 kB\n├ ƒ /auth/logout                                      0 B                0 B\n├ ○ /clients                                          6.83 kB         161 kB\n├ ƒ /clients/[clientId]                               5.55 kB         193 kB\n├ ○ /guide                                            9.88 kB         104 kB\n├ ○ /icon                                             0 B                0 B\n├ ƒ /invitations/[token]                              2.47 kB        89.4 kB\n├ ○ /playbooks                                        1.48 kB         103 kB\n├ ƒ /playbooks/[slug]                                 2.92 kB         104 kB\n├ ƒ /projects/[projectId]                             223 kB          416 kB\n├ ƒ /projects/join/[token]                            2.21 kB        89.2 kB\n├ ○ /projects/new                                     7.18 kB         168 kB\n└ ○ /trash                                            4.04 kB         165 kB\n+ First Load JS shared by all                         87 kB\n  ├ chunks/23-e10e9acb1772602f.js                     31.3 kB\n  ├ chunks/fd9d1056-389d572092a35222.js               53.6 kB\n  └ other shared chunks (total)                       1.99 kB\n\n\nƒ Middleware                                          78.2 kB\n\n○  (Static)   prerendered as static content\nƒ  (Dynamic)  server-rendered on demand","is_error":false}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"e175c5e8-ee3a-4b80-ba97-fed8346810b7","tool_use_result":{"stdout":"├ ƒ /api/playbook/video-viral/publish                 0 B                0 B\n├ ƒ /api/projects/[projectId]                         0 B                0 B\n├ ƒ /api/projects/[projectId]/export-csv              0 B                0 B\n├ ƒ /api/projects/[projectId]/export-data             0 B                0 B\n├ ƒ /api/projects/[projectId]/invitations             0 B                0 B\n├ ƒ /api/projects/[projectId]/members                 0 B                0 B\n├ ƒ /api/projects/[projectId]/share-links             0 B                0 B\n├ ƒ /api/projects/[projectId]/sync-export             0 B                0 B\n├ ƒ /api/projects/[projectId]/transfer-ownership      0 B                0 B\n├ ƒ /api/reports/analyze                              0 B                0 B\n├ ƒ /api/reports/export                               0 B                0 B\n├ ƒ /api/scraper/poll                                 0 B                0 B\n├ ƒ /api/scraper/preview                              0 B                0 B\n├ ƒ /api/scraper/start                                0 B                0 B\n├ ƒ /api/scraper/status                               0 B                0 B\n├ ƒ /api/scraper/webhook                              0 B                0 B\n├ ƒ /api/share-links/join                             0 B                0 B\n├ ƒ /api/test-upload                                  0 B                0 B\n├ ƒ /api/user/api-keys                                0 B                0 B\n├ ƒ /api/user/api-keys/check                          0 B                0 B\n├ ƒ /api/v2/clients                                   0 B                0 B\n├ ○ /api/v2/playbooks                                 0 B                0 B\n├ ƒ /api/webhooks/polar                               0 B                0 B\n├ ƒ /api/webhooks/polar/test                          0 B                0 B\n├ ○ /apple-icon                                       0 B                0 B\n├ ƒ /auth/callback                                    0 B                0 B\n├ ○ /auth/login                                       27.7 kB         174 kB\n├ ƒ /auth/logout                                      0 B                0 B\n├ ○ /clients                                          6.83 kB         161 kB\n├ ƒ /clients/[clientId]                               5.55 kB         193 kB\n├ ○ /guide                                            9.88 kB         104 kB\n├ ○ /icon                                             0 B                0 B\n├ ƒ /invitations/[token]                              2.47 kB        89.4 kB\n├ ○ /playbooks                                        1.48 kB         103 kB\n├ ƒ /playbooks/[slug]                                 2.92 kB         104 kB\n├ ƒ /projects/[projectId]                             223 kB          416 kB\n├ ƒ /projects/join/[token]                            2.21 kB        89.2 kB\n├ ○ /projects/new                                     7.18 kB         168 kB\n└ ○ /trash                                            4.04 kB         165 kB\n+ First Load JS shared by all                         87 kB\n  ├ chunks/23-e10e9acb1772602f.js                     31.3 kB\n  ├ chunks/fd9d1056-389d572092a35222.js               53.6 kB\n  └ other shared chunks (total)                       1.99 kB\n\n\nƒ Middleware                                          78.2 kB\n\n○  (Static)   prerendered as static content\nƒ  (Dynamic)  server-rendered on demand","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VcrnrgGwt9pCN9FKkKLri5","type":"message","role":"assistant","content":[{"type":"text","text":"The build passes successfully. Now let's commit the changes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1468,"cache_read_input_tokens":141686,"cache_creation":{"ephemeral_5m_input_tokens":1468,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"0bdd0325-710c-4845-8205-28f7ce80b896"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VcrnrgGwt9pCN9FKkKLri5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EXT8MK1nZd6ifwxtJS3Xgf","name":"TodoWrite","input":{"todos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"completed","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"completed","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"completed","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"completed","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"completed","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"completed","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"completed","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Integrate ArtifactBrowser into PlaybookShell","status":"completed","activeForm":"Integrating ArtifactBrowser into PlaybookShell"},{"content":"Run quality checks","status":"completed","activeForm":"Running quality checks"},{"content":"Commit changes","status":"in_progress","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1468,"cache_read_input_tokens":141686,"cache_creation":{"ephemeral_5m_input_tokens":1468,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"6039e3e2-afab-4c8e-acc3-844b9eb88c3b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EXT8MK1nZd6ifwxtJS3Xgf","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"12efce4b-3144-4af4-a29a-b5cfb125e3af","tool_use_result":{"oldTodos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"completed","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"completed","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"completed","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"completed","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"completed","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"completed","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"completed","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Integrate ArtifactBrowser into PlaybookShell","status":"completed","activeForm":"Integrating ArtifactBrowser into PlaybookShell"},{"content":"Run quality checks","status":"in_progress","activeForm":"Running quality checks"},{"content":"Commit changes","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"completed","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"completed","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"completed","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"completed","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"completed","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"completed","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"completed","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Integrate ArtifactBrowser into PlaybookShell","status":"completed","activeForm":"Integrating ArtifactBrowser into PlaybookShell"},{"content":"Run quality checks","status":"completed","activeForm":"Running quality checks"},{"content":"Commit changes","status":"in_progress","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Rnahr5oMzDqNUaY2DxKrXh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013TFp8hEW6vpwhQLZNdJrJK","name":"Bash","input":{"command":"git status","description":"Check git status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":453,"cache_read_input_tokens":143154,"cache_creation":{"ephemeral_5m_input_tokens":453,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"5a506046-52f7-43ea-9d41-7e0909e1ae89"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Rnahr5oMzDqNUaY2DxKrXh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AGjs4Ng7z4mZcMxqJswseF","name":"Bash","input":{"command":"git diff --stat","description":"Show diff stats"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":453,"cache_read_input_tokens":143154,"cache_creation":{"ephemeral_5m_input_tokens":453,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"e73a8f32-6b9a-41bf-9c68-849cc689b4d6"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Rnahr5oMzDqNUaY2DxKrXh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LA9Ep7ZEDwN2L2JcwPvqv9","name":"Bash","input":{"command":"git log --oneline -5","description":"Show recent commits"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":453,"cache_read_input_tokens":143154,"cache_creation":{"ephemeral_5m_input_tokens":453,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"d8d4cf9c-4dd4-4090-af41-594dea017362"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LA9Ep7ZEDwN2L2JcwPvqv9","type":"tool_result","content":"ed8bdae feat: US-010 - Implement Step Retry Functionality\nded3d4b feat: US-010 - Implement Step Retry Functionality\n1fe6009 feat: US-009 - Build Live Execution Progress Component\nb8c0942 feat: US-009 - Build Live Execution Progress Component\nc4f5aaa feat: US-008 - Create Universal \"Save to Context Lake\" Button","is_error":false}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"fff19584-cf73-4b55-bb8b-7e56d32fc767","tool_use_result":{"stdout":"ed8bdae feat: US-010 - Implement Step Retry Functionality\nded3d4b feat: US-010 - Implement Step Retry Functionality\n1fe6009 feat: US-009 - Build Live Execution Progress Component\nb8c0942 feat: US-009 - Build Live Execution Progress Component\nc4f5aaa feat: US-008 - Create Universal \"Save to Context Lake\" Button","stderr":"","interrupted":false,"isImage":false}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AGjs4Ng7z4mZcMxqJswseF","type":"tool_result","content":" .ralph-tui/progress.md                    |  9 +++++\n .ralph-tui/session-meta.json              |  6 +--\n .ralph-tui/session.json                   | 24 +++++++++---\n src/components/playbook/PlaybookShell.tsx | 65 ++++++++++++++++++++++++++++++-\n tasks/prd-playbook-orchestration-ux.json  |  2 +-\n 5 files changed, 95 insertions(+), 11 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"df134191-6534-4da7-86e2-76b60f9f5f52","tool_use_result":{"stdout":" .ralph-tui/progress.md                    |  9 +++++\n .ralph-tui/session-meta.json              |  6 +--\n .ralph-tui/session.json                   | 24 +++++++++---\n src/components/playbook/PlaybookShell.tsx | 65 ++++++++++++++++++++++++++++++-\n tasks/prd-playbook-orchestration-ux.json  |  2 +-\n 5 files changed, 95 insertions(+), 11 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013TFp8hEW6vpwhQLZNdJrJK","type":"tool_result","content":"On branch main\nYour branch is ahead of 'origin/main' by 21 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .ralph-tui/progress.md\n\tmodified:   .ralph-tui/session-meta.json\n\tmodified:   .ralph-tui/session.json\n\tmodified:   src/components/playbook/PlaybookShell.tsx\n\tmodified:   tasks/prd-playbook-orchestration-ux.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.agents/skills/create-pr/\n\t.agents/skills/n8n-workflow-patterns/\n\t.claude/skills/create-pr\n\t.claude/skills/n8n-workflow-patterns\n\t.codex/skills/create-pr\n\t.codex/skills/n8n-workflow-patterns\n\t.cursor/skills/create-pr\n\t.cursor/skills/n8n-workflow-patterns\n\t.github/skills/create-pr\n\t.github/skills/n8n-workflow-patterns\n\t.opencode/skills/create-pr\n\t.opencode/skills/n8n-workflow-patterns\n\t.ralph-tui/iterations/a2c55120_2026-01-25_20-27-38_US-010.log\n\tskills/create-pr\n\tskills/n8n-workflow-patterns\n\tsrc/components/playbook/ArtifactBrowser/\n\ttasks/prd-n8n-to-gattaca-converter-v2.json\n\ttasks/prd-n8n-to-gattaca-converter-v2.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"6d19c774-53d0-4f9a-997e-f6b50915ff25","tool_use_result":{"stdout":"On branch main\nYour branch is ahead of 'origin/main' by 21 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .ralph-tui/progress.md\n\tmodified:   .ralph-tui/session-meta.json\n\tmodified:   .ralph-tui/session.json\n\tmodified:   src/components/playbook/PlaybookShell.tsx\n\tmodified:   tasks/prd-playbook-orchestration-ux.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.agents/skills/create-pr/\n\t.agents/skills/n8n-workflow-patterns/\n\t.claude/skills/create-pr\n\t.claude/skills/n8n-workflow-patterns\n\t.codex/skills/create-pr\n\t.codex/skills/n8n-workflow-patterns\n\t.cursor/skills/create-pr\n\t.cursor/skills/n8n-workflow-patterns\n\t.github/skills/create-pr\n\t.github/skills/n8n-workflow-patterns\n\t.opencode/skills/create-pr\n\t.opencode/skills/n8n-workflow-patterns\n\t.ralph-tui/iterations/a2c55120_2026-01-25_20-27-38_US-010.log\n\tskills/create-pr\n\tskills/n8n-workflow-patterns\n\tsrc/components/playbook/ArtifactBrowser/\n\ttasks/prd-n8n-to-gattaca-converter-v2.json\n\ttasks/prd-n8n-to-gattaca-converter-v2.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WYrYYo7PJmPBM6kdzNXgPc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KuYniLXwW3oe7gMwBmHHtt","name":"Bash","input":{"command":"git add src/components/playbook/ArtifactBrowser/ src/components/playbook/PlaybookShell.tsx && git commit -m \"$(cat <<'EOF'\nfeat: US-011 - Create Artifact Browser for Session Data\n\nImplements a comprehensive artifact browser that allows users to explore\nall data generated during a playbook session:\n\n- Add \"Session Data\" tab accessible from PlaybookShell header\n- Create ArtifactBrowser component with collapsible right panel\n- Group artifacts by type: SERP Results, Scraped Content, Extracted Data, etc.\n- Each group expandable to show individual items with previews\n- Search and filter functionality across all artifacts\n- ArtifactViewerModal for viewing artifacts in detail (preview/table/raw modes)\n- \"Save to Context Lake\" integration via SaveToContextLakeModal\n- Export as CSV/JSON option for structured data\n- Automatic artifact detection from step outputs and session data\n\nComponents:\n- ArtifactBrowser/ArtifactBrowser.tsx - Main browser panel\n- ArtifactBrowser/ArtifactViewerModal.tsx - Modal for viewing artifacts\n- ArtifactBrowser/useArtifacts.ts - Hook for artifact state management\n- ArtifactBrowser/types.ts - Type definitions\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Commit the changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":291,"cache_creation_input_tokens":693,"cache_read_input_tokens":143607,"cache_creation":{"ephemeral_5m_input_tokens":693,"ephemeral_1h_input_tokens":0},"output_tokens":402,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"17363d08-c6a3-41bb-bbe4-4f47fbc1cfad"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KuYniLXwW3oe7gMwBmHHtt","type":"tool_result","content":"[main 55b91e2] feat: US-011 - Create Artifact Browser for Session Data\n 6 files changed, 1665 insertions(+), 1 deletion(-)\n create mode 100644 src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx\n create mode 100644 src/components/playbook/ArtifactBrowser/ArtifactViewerModal.tsx\n create mode 100644 src/components/playbook/ArtifactBrowser/index.ts\n create mode 100644 src/components/playbook/ArtifactBrowser/types.ts\n create mode 100644 src/components/playbook/ArtifactBrowser/useArtifacts.ts","is_error":false}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"35e78247-4f74-45f2-869e-969315fba4c8","tool_use_result":{"stdout":"[main 55b91e2] feat: US-011 - Create Artifact Browser for Session Data\n 6 files changed, 1665 insertions(+), 1 deletion(-)\n create mode 100644 src/components/playbook/ArtifactBrowser/ArtifactBrowser.tsx\n create mode 100644 src/components/playbook/ArtifactBrowser/ArtifactViewerModal.tsx\n create mode 100644 src/components/playbook/ArtifactBrowser/index.ts\n create mode 100644 src/components/playbook/ArtifactBrowser/types.ts\n create mode 100644 src/components/playbook/ArtifactBrowser/useArtifacts.ts","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018KUPuRFC3x2cE9pCSLurKY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DLZkvxBK3ugqvjqDwbmRAs","name":"TodoWrite","input":{"todos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"completed","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"completed","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"completed","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"completed","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"completed","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"completed","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"completed","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Integrate ArtifactBrowser into PlaybookShell","status":"completed","activeForm":"Integrating ArtifactBrowser into PlaybookShell"},{"content":"Run quality checks","status":"completed","activeForm":"Running quality checks"},{"content":"Commit changes","status":"completed","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":888,"cache_read_input_tokens":144300,"cache_creation":{"ephemeral_5m_input_tokens":888,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"992ec448-aa75-4019-91e9-8cefc1a7d89d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DLZkvxBK3ugqvjqDwbmRAs","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"9a62e03d-8680-43f5-8999-c3cec11c18fa","tool_use_result":{"oldTodos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"completed","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"completed","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"completed","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"completed","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"completed","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"completed","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"completed","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Integrate ArtifactBrowser into PlaybookShell","status":"completed","activeForm":"Integrating ArtifactBrowser into PlaybookShell"},{"content":"Run quality checks","status":"completed","activeForm":"Running quality checks"},{"content":"Commit changes","status":"in_progress","activeForm":"Committing changes"}],"newTodos":[{"content":"Create ArtifactBrowser component with tab/panel structure","status":"completed","activeForm":"Creating ArtifactBrowser component"},{"content":"Implement artifact grouping by step (SERP Results, Scraped Content, etc.)","status":"completed","activeForm":"Implementing artifact grouping by step"},{"content":"Add expandable artifact groups with individual items","status":"completed","activeForm":"Adding expandable artifact groups"},{"content":"Implement search/filter within artifacts","status":"completed","activeForm":"Implementing search/filter within artifacts"},{"content":"Create ArtifactViewerModal for viewing artifacts","status":"completed","activeForm":"Creating ArtifactViewerModal"},{"content":"Integrate Save to Context Lake functionality","status":"completed","activeForm":"Integrating Save to Context Lake"},{"content":"Add Export as CSV/JSON functionality","status":"completed","activeForm":"Adding Export as CSV/JSON functionality"},{"content":"Integrate ArtifactBrowser into PlaybookShell","status":"completed","activeForm":"Integrating ArtifactBrowser into PlaybookShell"},{"content":"Run quality checks","status":"completed","activeForm":"Running quality checks"},{"content":"Commit changes","status":"completed","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LFE65HJCbCfyFuCt9oEJTJ","type":"message","role":"assistant","content":[{"type":"text","text":"<promise>COMPLETE</promise>\n\n## Summary\n\nI've successfully implemented **US-011 - Create Artifact Browser for Session Data** with all acceptance criteria met:\n\n### Components Created\n\n1. **`ArtifactBrowser/types.ts`** - Type definitions for:\n   - Artifact types (serp_results, scraped_content, extracted_data, step_output, etc.)\n   - Artifact, ArtifactGroup, SessionArtifacts interfaces\n   - Filter and export options\n   - Type labels with icons and colors\n\n2. **`ArtifactBrowser/useArtifacts.ts`** - Custom hook for:\n   - Building artifacts from step outputs and session data\n   - Automatic artifact type detection\n   - Filtering by type, step, and search query\n   - Session API integration\n\n3. **`ArtifactBrowser/ArtifactViewerModal.tsx`** - Modal viewer with:\n   - Three view modes: Preview, Table, Raw\n   - Copy to clipboard\n   - Fullscreen toggle\n   - Integration with Save to Context Lake and Export\n\n4. **`ArtifactBrowser/ArtifactBrowser.tsx`** - Main panel with:\n   - Collapsible right-side panel (384px width)\n   - Grouped artifacts by type with expandable sections\n   - Individual artifact items with quick preview\n   - Search bar and advanced filters\n   - View, Save, Export action buttons per artifact\n\n### Integration\n\n- Added \"Session Data\" button in PlaybookShell header (visible when campaign is selected)\n- Panel toggles on button click\n- Fetches project data for clientId/userId needed by Context Lake\n- Passes all step data to ArtifactBrowser for real-time updates\n\n### Features\n\n- **Grouping by type**: SERP Results (150 URLs), Scraped Content (120 pages), etc.\n- **Expandable groups**: Click to expand and see individual items\n- **Search/filter**: Search across all artifacts, filter by type or step\n- **View button**: Opens artifact in modal with table/markdown/raw views\n- **Save to Context Lake**: Integration with existing SaveToContextLakeModal\n- **Export as CSV/JSON**: Download structured data in desired format"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":438,"cache_read_input_tokens":145188,"cache_creation":{"ephemeral_5m_input_tokens":438,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","uuid":"b9fc2a09-5965-473b-847e-3ad30ff123d6"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":500196,"duration_api_ms":499064,"num_turns":60,"result":"<promise>COMPLETE</promise>\n\n## Summary\n\nI've successfully implemented **US-011 - Create Artifact Browser for Session Data** with all acceptance criteria met:\n\n### Components Created\n\n1. **`ArtifactBrowser/types.ts`** - Type definitions for:\n   - Artifact types (serp_results, scraped_content, extracted_data, step_output, etc.)\n   - Artifact, ArtifactGroup, SessionArtifacts interfaces\n   - Filter and export options\n   - Type labels with icons and colors\n\n2. **`ArtifactBrowser/useArtifacts.ts`** - Custom hook for:\n   - Building artifacts from step outputs and session data\n   - Automatic artifact type detection\n   - Filtering by type, step, and search query\n   - Session API integration\n\n3. **`ArtifactBrowser/ArtifactViewerModal.tsx`** - Modal viewer with:\n   - Three view modes: Preview, Table, Raw\n   - Copy to clipboard\n   - Fullscreen toggle\n   - Integration with Save to Context Lake and Export\n\n4. **`ArtifactBrowser/ArtifactBrowser.tsx`** - Main panel with:\n   - Collapsible right-side panel (384px width)\n   - Grouped artifacts by type with expandable sections\n   - Individual artifact items with quick preview\n   - Search bar and advanced filters\n   - View, Save, Export action buttons per artifact\n\n### Integration\n\n- Added \"Session Data\" button in PlaybookShell header (visible when campaign is selected)\n- Panel toggles on button click\n- Fetches project data for clientId/userId needed by Context Lake\n- Passes all step data to ArtifactBrowser for real-time updates\n\n### Features\n\n- **Grouping by type**: SERP Results (150 URLs), Scraped Content (120 pages), etc.\n- **Expandable groups**: Click to expand and see individual items\n- **Search/filter**: Search across all artifacts, filter by type or step\n- **View button**: Opens artifact in modal with table/markdown/raw views\n- **Save to Context Lake**: Integration with existing SaveToContextLakeModal\n- **Export as CSV/JSON**: Download structured data in desired format","session_id":"988adfdd-0c07-41b3-908e-b3815cd23c5b","total_cost_usd":4.842316849999998,"usage":{"input_tokens":1143,"cache_creation_input_tokens":132318,"cache_read_input_tokens":5815752,"output_tokens":28251,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":132318}},"modelUsage":{"claude-haiku-4-5-20251001":{"inputTokens":26122,"outputTokens":5707,"cacheReadInputTokens":655076,"cacheCreationInputTokens":130300,"webSearchRequests":0,"costUSD":0.28303960000000006,"contextWindow":200000,"maxOutputTokens":64000},"claude-opus-4-5-20251101":{"inputTokens":1149,"outputTokens":28567,"cacheReadInputTokens":5815752,"cacheCreationInputTokens":149037,"webSearchRequests":0,"costUSD":4.559277249999999,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"5ec8d88d-964f-45fa-b792-30ec46c42438"}

--- SUBAGENT TRACE ---
{
  "events": [
    {
      "id": "subagent_1769369881753_txsek7r",
      "type": "spawn",
      "timestamp": "2026-01-25T19:38:01.753Z",
      "agentType": "Explore",
      "description": "Explore codebase structure",
      "prompt": "Explore the codebase to understand:\n1. The structure of the src/components directory, especially any existing session-related components\n2. How artifacts/data are stored and managed in the session (look for session state, context, or stores)\n3. The existing modal patterns used in the app\n4. How the \"Save to Context Lake\" functionality is implemented\n5. Any existing export functionality (CSV/JSON)\n6. The UI patterns used for tabs/panels and expandable sections\n\nFocus on finding patterns I should follow for the Artifact Browser implementation."
    },
    {
      "id": "subagent_1769369881753_txsek7r",
      "type": "complete",
      "timestamp": "2026-01-25T19:46:15.543Z",
      "agentType": "Explore",
      "description": "Explore codebase structure",
      "exitStatus": "success",
      "durationMs": 493790
    }
  ],
  "hierarchy": [
    {
      "state": {
        "id": "subagent_1769369881753_txsek7r",
        "agentType": "Explore",
        "description": "Explore codebase structure",
        "status": "completed",
        "childIds": [],
        "spawnedAt": "2026-01-25T19:38:01.753Z",
        "prompt": "Explore the codebase to understand:\n1. The structure of the src/components directory, especially any existing session-related components\n2. How artifacts/data are stored and managed in the session (look for session state, context, or stores)\n3. The existing modal patterns used in the app\n4. How the \"Save to Context Lake\" functionality is implemented\n5. Any existing export functionality (CSV/JSON)\n6. The UI patterns used for tabs/panels and expandable sections\n\nFocus on finding patterns I should follow for the Artifact Browser implementation.",
        "endedAt": "2026-01-25T19:46:15.543Z",
        "durationMs": 493790
      },
      "children": []
    }
  ],
  "stats": {
    "totalSubagents": 1,
    "byType": {
      "Explore": 1
    },
    "totalDurationMs": 493790,
    "failureCount": 0,
    "maxDepth": 1
  }
}